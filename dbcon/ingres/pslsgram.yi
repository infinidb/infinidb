/* Copyright (c) 1986, 2005 Ingres Corporation
**
**
*/

%{
#include    <compat.h>
#ifdef i64_aix
#define MAX 403
#define MIN 405
#endif
#include    <gl.h>
#include    <cs.h>
#include    <me.h>
#include    <bt.h>
#include    <ci.h>
#include    <cv.h>
#include    <mh.h>
#include    <qu.h>
#include    <st.h>
#include    <tr.h>
#include    <tm.h>
#include    <tmtz.h>
#include    <cm.h>
#include    <er.h>
#include    <pc.h>
#include    <iicommon.h>
#include    <dbdbms.h>
#include    <gca.h>
#include    <ddb.h>
#include    <dmf.h>
#include    <dmacb.h>
#include    <dmccb.h>
#include    <dmtcb.h>
#include    <dmrcb.h>
#include    <dmucb.h>
#include    <adf.h>
#include    <ade.h>
#include    <adfops.h>
#include    <adudate.h>
#include    <ulf.h>
#include    <ulm.h>
#include    <qsf.h>
#include    <qefrcb.h>
#include    <rdf.h>
#include    <sxf.h>
#include    <copy.h>
#include    <qefmain.h>
#include    <qefqeu.h>
#include    <qeuqcb.h>
#include    <qefcopy.h>
#include    <qefcb.h>
#include    <qefnode.h>
#include    <psfparse.h>
#include    <qefact.h>
#include    <qefqp.h>
#include    <opfcb.h>
#include    <scf.h>
#include    <ex.h>
#include    <psfindep.h>
#include    <pshparse.h>
#include    "pslsgram.h"
#include    "pslscan.h"
#include    <yacc.h>
#include    <usererror.h>
#include    <dudbms.h>
#include    <psftrmwh.h>
#include    <psqcvtdw.h>
#include    <psqmonth.h>
#include    <psttprpnd.h>
#include    <psyaudit.h>
#include    <uld.h>
#include    <cui.h>

/* Mark that we want the static array in this function */
#define GM_WANT_ARRAY
#include    <gwf.h>

/*
** NO_OPTIM = rs4_us5 dgi_us5 int_lnx int_rpl ibm_lnx usl_us5 i64_aix
*/

#define YYDEBUG 1
#define YACC_VARS 1
#define	MAX_GW_REG_CHARS 2
#define DROP_BASETABLE	1
#define DROP_VIEW	2
#define DROP_INDEX	3
#define DROP_LINK	9
#define REMOVE_OBJ	10
#define REMOVE_TBL	11
#define REMOVE_VIEW	12
#define REMOVE_INDEX	13
#define REMOVE_PROCEDURE	14

/*
** used to distinguish AVG, MIN, MAX, SUM when they are reduced to
** avg_min_max_sum
*/
#define	    AGGR_AVG	0
#define	    AGGR_MIN	1
#define	    AGGR_MAX	2
#define	    AGGR_SUM	3

static char	*aggr_func_names[] = {"avg", "min", "max", "sum"};

/* define the component fields of a year to month or day to second interval */
#define INT_YEAR	1
#define	INT_MONTH	2
#define INT_DAY		3
#define	INT_HOUR	4
#define	INT_MINUTE	5
#define	INT_SECOND	6

static char	interval_filler[] = {'0', '-', '0', '0', ' ', '0',
				':', '0', ':', '0'};  /* 0-00 0:0:0 */

static char	*extract_fields[] = {"year", "month", "day", "hour", 
		"minute", "second", "microsecond", "nanosecond",
		"timezone_hour", "timezone_minute"};
#define	EXTRACT_FIELDS_COUNT 10

/*
** Array to reverse comparison ops for backwards subsel compare.
** Note that this is straight reversal, not inversion (NOT compop)!
*/
static ADI_OP_ID revops[] = {ADI_NE_OP, -1, -1, -1, -1, -1, ADI_GT_OP, 
		ADI_GE_OP, ADI_EQ_OP, ADI_LT_OP, ADI_LE_OP};

/*
** List of valid collation names (and count thereof).
** NOTE: this list must be consistent with the set of #define's of
** collation codes in iicommon.h.
*/
#define	VALID_COLLATION_COUNT	6
static char	*collname_array[] = {"unicode", "unicode_case_insensitive", 
	"sql_character", "multi", "spanish", "unicode_french"};
static char	*type_array[] = {"NCHAR, NVARCHAR", "CHAR, VARCHAR, C, TXT"};

/*
** the following constants are used to distinguish between ANY, ALL, and SOME
** in predicates involving comparisons with subselect
*/
#define	    ANY_SUBSEL		1
#define	    ALL_SUBSEL		2
#define     SOME_SUBSEL		3

/*
** values that can be returned by drop_behaviour production
*/
#define	    CASCADING_DESTRUCTION	1
#define	    RESTRICTED_DESTRUCTION	2

/*
** the following macro is an optimization for the check for
** reserved identifiers;  by using this macro, we only call the
** psl_reserved_ident function if the identifier actually begins
** with a '$'
*/
#define	    PSL_IS_RESERVED_IDENT(name, sess_cb, psq_cb, force_check)	\
		((CMcmpcase(name, ERx("$")) == 0) 			\
		 && psl_reserved_ident(name, sess_cb, psq_cb, force_check))

/* There are a few places (ok, at least 1) where a keyword is treated
** like an identifier, by simply returning the appropriate string.
** If the ID is an object name, like a column name, it has to obey the
** case rules in effect.  It's tedious to write the necessary if or ?:
** expression over and over, define a macro:
*/
#define	    REG_ID_CASE_STRING(sess_cb,lcstring,ucstring) \
		((*sess_cb->pss_dbxlate & CUI_ID_REG_U) ? lcstring : ucstring)

%}

/**
**
**  Name: PSLSGRAM.YI - The grammar for SQL.
**
**  Description:
**      This file contains the grammar for SQL in the server. 
[@comment_line@]...
**
**          psl_sparse - Parses an SQL statement, checks for syntax errors
**			and some limited semantic errors, and generates data
**			structures for the next phase in query processing.
**
**
**  History:
**	30-jan-87 (stec)
**
**	21-may-87 (puree)
**	    add productions and semantic routines for dynamic SQL.
**	03-jun-87  (puree)
**	    fix copy bug 146 (data type and msg 5830)
**	26-aug-87 (puree)
**	    use cp_cvlen for ADF result length, cp_length for user specified
**	    length.
**	22-feb-88 (puree)
**	    fix copy bug 1984.  set ADE_LEN_UNKNOWN in variable length dummy
**	    field.
**	    fix DSQL bug.  By design, DSQL parameters are not allowed in 
**	    QRYMOD statements: GRANT, CREATE PERMIT, CREATE INTEGRITY, and 
**	    CREATE VIEW.
**	26-may-88 (thurston)
**	    Added code to the SET DATE_FORMAT production to allow "german" as
**	    a legal format.
**	03-jun-88 (jrb)
**	    Added ESCAPE option of LIKE predicate to grammar.  Added code to
**	    all functions using PST_OP_NODEs to set pst_isescape to proper
**	    value.
**	26-jul-88 (andre)
**	    Modified restrictions on when a DB object may be created/deleted,
**	    i.e. an object can't be created/deleted if 1) it is a core catalog
**	    or 2) it is a catalog and the user has no update privilege or
**	    3) it is not a catalog (i.e. it is a table), and the user doesn't
**	    own it.    
**	17-aug-88 (stec)
**	    Removed register directive from the definition of decvar in
**	    create_dbproc and cdbp_declare productions.
**	01-sep-88 (stec)
**	    Fixed C compiler warnings for Mikem.
**	06-sep-88 (stec)
**	    Cursor_open production (also for dyn SQL) must not create a resdom
**	    and var nodes representing TID if `for read only' has been
**	    specified.
**	07-sep-88 (stec)
**	    Defer execution of psy_qrymod routine for prepare SELECT stmt until
**	    OPEN CURSOR time.
**	08-sep-88 (stec)
**	    Fix initialization of cb->pss_resrng in `query:' rule for
**	    OPEN CURSOR and PREPARE statements.
**	09-sep-88 (stec)
**	    manual merge; write protect built-ins.
**	09-sep-88 (stec)
**	    UNION subselects in a DB proc should have same local var nos. 
**	13-sep-88 (stec)
**	    Fix the problem of resetting of pss_rsdmno for every subselect
**	    (related to bug 2563).
**	20-sep-88 (stec)
**	    Change args passed to psf_error for code 5116.
**	21-sep-88 (stec)
**	    Call psl0_rngent to identify drop statement objects.
**	21-sep-88 (stec)
**	    Fix error message handling for the case when nonexistent column
**	    specified in for update clause of prepared SELECT.
**	21-sep-88 (stec)
**	    Set money_format statement.
**	22-sep-88 (stec)
**	    Store nonupdt on pst_prepare request and restore it on pst_execute.
**	26-sep-88 (stec)
**	    Correct args in the call to psf_error for 5524.
**	    Fix initialization of cb->pss_resrng in `query:' rule for OPEN CURSOR
**	    and PREPARE statements.
**	27-sep-88 (stec)
**	    Fix IBM compiler error.
**	07-oct-88 (stec)
**	    Fix create view bug (see comment in crname production).
**	10-oct-88 (stec)
**	    Fix a DB proc bug where numbering of parms collided with
**	    numbering of built-ins. Built-ins will be initialized
**	    before parms are processed.
**	10-oct-88 (stec)
**	    Fix allocate 0 memory in DB code bug.
**	13-oct-88 (stec)
**	    Fix `set money precision' to accept <0..2>.
**	13-oct-88 (stec)
**	    Disallow SET[NO]JOURNALING on catalogs (LRC decision).
**	14-oct-88 (andre)
**	    Fix the bug in grant: that allowed one to GRANT EXECUTE on table.
**	19-oct-88 (stec)
**	    Change criteria for shareable QPs (include catalogs).
**	19-oct-88 (stec)
**	    DROP will now get info from RDF, invalidate the entry and get
**	    a fresh one from DMF (see comment in the drop_name: rule).
**	20-oct-88 (stec)
**	    Added hints for UNIX (change 1033).
**	20-oct-88 (stec)
**	    Check cursor updatability, change open cursor related code.
**	21-oct-88 (stec)
**	    Removed hints for UNIX (change 1033), requested by Roger.
**	24-oct-88 (puree)
**	    Fix copy bug 2684.  For a dummy copy column in copy into, if the 
**	    cp_length is ADE_LEN_UNKNOWN, set cp_cvlen to 0 so that iicopy
**	    computes the correct row length.
**	01-nov-88 (stec)
**	    Changed with_dups initialization.
**	    Implement code changes allowing DBA to grant privileges on
**	    extended catalogs.
**	04-nov-88 (stec)
**	    Replaced MEcopy with STRUCT_ASSIGN_MACRO (cursor action).
**	07-nov-88 (stec)
**	    Changed some error codes (create better messages).
**	08-nov-88 (stec)
**	    Catalog update priv is sufficient to grant privs on catalogs.
**	    Issue warnings when CREATE PERMIT is not GRANT compatible.
**	    Fix update btree index check.
**	09-nov-88 (stec)
**	    Fix cursor problem - should not be readonly if FOR UPDATE
**	    not specified.
**	10-nov-88 (stec)
**	    Fix SET DATE FORMAT bug.
**	    Append unique database id to identifier of a shared QP.
**	11-nov-88 (stec)
**	    Change timezone defn from i2 to nat.
**	    Change proc id to include database id.
**	14-nov-88 (stec)
**	    Initialize properly ADF_CB on the stack.
**	15-nov-88 (stec)
**	    Change cursor code to open without READONLY clause
**	    specified when non-deleteable.
**	15-nov-88 (puree)
**	    Change "covalue" production for hex and string constants for
**	    copy.
**	23-nov-88 (stec)
**	    Use usererror.h include file rather than erusf.h.
**	    Use E_US1265_QEP_INVALID define instead of E_US1265_4709.
**	28-nov-88 (stec)
**	    Add support for nonconforming user names in CREATE PERMIT/GRANT.
**	    Allow DROP PERMIT on catalogs by non-dba users if catalog update 
**	    privilege has been specified.
**	29-nov-88 (stec)
**	    Initialize pst_ntargno correctly for INSERTs with subselects.
**	02-dec-88 (stec)
**	    Change aggregate test in psl_up.
**	07-dec-88 (stec)
**	    Test updateability of a cursor before checking result relation
**	    name.
**	29-dec-88 (andre)
**	    Do away with target_expr, since by introducing func_arg, we no
**	    longer need "func LPAREN NULLWORD RPAREN" rule, and the target_expr
**	    would only have select_expr on the RHS with no semantic rules.
**	    In the RHS's for the scalar_function, we use func_arg instead of
**	    select_expr to allow for NULL as an argument to a scalar function.
**	29-dec-88 (andre)
**	    Made changes to allow for [owner.]table construct in COPY.
**	10-jan-89 (puree)
**	    Fix copy bug 4367 and 4370, handling of null-substitution values.
**	    Also need changes in the front end part IICOPY.
**	18-jan-89 (stec)
**	    Make sure that table designators used in a target list refer to
**	    tables in the current scope.
**	20-jan-89 (puree)
**	    Fix error handling in COPY production. Also fix bug 4537, allow
**	    dummy column to skip the rest of processing once the length and
**	    type is set.
**	24-jan-89 (stec)
**	    Straightened out comments related to when indices and non-
**	    extended catalogs can be modified (catalog update privilege
**	    is required).
**	7-feb-89 (lan)
**	    Fix bug #4394 where a non-DBA user can issue GRANT statement.
**	    Changed so that this is not allowed.
**	15-feb-89 (stec)
**	    Correct error processing for cursor columns in the UPDATE
**	    statement. Error code 2207 should be returned instead of 2206.
**	    Fix error handling for psl_curval routine.
**	28-feb-89 (paul)
**	    Add initialization for rule statement list field in PST_STATEMENT
**	    structures created in the grammar.
**	05-mar-89 (ralph)
**	    GRANT Enhancements, Phase 1:
**	    Restructured GRANT for application/group identifiers.
**	    Added CREATE/ALTER/DROP GROUP/APPLICATION_ID
**	13-mar-89 (neil)
**	   Added parsing of CREATE and DROP RULE statements.  Completed
**	   all changes related to rules.
**	03-apr-89 (ralph)
**	    GRANT Enhancements, Phase 2:
**	    Restructured GRANT for database privileges;
**	    Added REVOKE for revoking database privileges.
**	18-apr-89 (jrb)
**	    Made many changes for decimal project:
**	       o Set db_prec field of db_data_value to proper value everywhere
**	       o Changed interface of adc_lenchk
**	       o Changed interface of pst_node
**	19-apr-89 (mikem)
**	   Logical key development.  Added parsing of new with clauses added
**	   to allow specification of "with system_maintained".  Also some
**	   support for error checking on logical_key column creation parsing.
**	10-may-89 (ralph)
**	    GRANT Enhancements, Phase 2b:
**	    Restructured GRANT for database privileges;
**	    Added REVOKE for revoking database privileges;
**	    Removed reserved words APLID, RULE;
**	    Changed ``application_id'' to ``role'';
**	    Introduced double keywords: ALTGROUP, ALTROLE, ALTUSER,
**		CRTGROUP, CRTROLE, CRTRULE, CRTUSER, DROPGROUP,
**		DROPROLE, DROPRULE, DROPUSER, SETPRTRULES,
**		FROMGROUP, FROMROLE, FROMUSER, TOGROUP, TOROLE, TOUSER.
**	    Allow multiple groups/roles to me specified
**	11-may-89 (neil)
**	    Added rule tracing SET PRINTRULES.
**	    Added Dynamic SQL cursor updates.
**	    Fixed bug that didn't allow null to be assigned to a DBP variable.
**	23-may-89 (jrb)
**	    Renumbered US0983 to US0985 because of conflict with Titan number.
**	30-may-89 (ralph)
**	    GRANT Enhancements, Phase 2c:
**	    Check CREATE_TABLE, CREATE_PROCEDURE, and LOCKMODE privileges
**	13-jun-89 (fred)
**	    Added ADI_DT_MAP_MACRO() to BTtest() calls for coercability of
**	    datatypes.  Necessary for extensible datatyping system.
**	23-jun-89 (ralph)
**	    GRANT Enhancements, Phase 2e:
**	    Added support for SET [NO]MAX{QUERY,IO,ROW,CPU,PAGE,COST}
**	24-jul-89 (jrb)
**	    Fixed typo where I was setting db_length to 0 instead of db_prec to
**	    0 for an integer type.
**	28-jul-89 (ralph)
**	    Don't check CREATE_PROCEDURE if only recreating a procedure
**      30-jul-89 (jennifer)
**          Added DAC audit calls.
**	04-aug-89 (andre)
**	    IMPORTANT:  if everything works, it will be just another comment, if
**	    something doesn't work, the key may be found here.  We are getting
**	    rid of the klugy (spellchecker, anyone) way we have been dealing
**	    with target_list of a SELECT statement.
**	    In short, we'll be building subtrees representing target list before
**	    we get to see the from_list.  As a result information about the
**	    table attributes will not be available.  We will have to obtain this
**	    information after the from_list is processed, so for the time being,
**	    the tree willl look normal, but it will not contain some very
**	    relevant information.  We will have to employ place holders for *
**	    and var.* constructs, since we have no idea as to the number and the
**	    names of table attributes.  After the from list is processed, we'll
**	    go over the target list, filling in newly available information and
**	    performing type resolution for the opnodes.  VAR nodes may
**	    temporarily have to contain information which we will later discard.
**	    I am referring to var names which may have to be saved when the
**	    terget element contains attribute names prefixed by the range
**	    variable name.
**	15-aug-89 (andre)
**	    Started adding code to handle outer joins.
**	17-aug-89 (andre)
**	    added join_from_item and all the related [non-]terminals and rules.
**	22-aug-89 (neil)
**	    Added EXECUTE PROCEDURE functionality.
**	18-sep-89 (jrb)
**	    Major changes for DECIMAL datatype.  Fields for precision were set
**	    properly, new code for DECIMAL conversion function, literals,
**	    column specifications, and COPY support.
**	08-sep-89 (neil)
**	    Alerters: Added parsing of all EVENT statements.
**	26-sep-89 (neil)
**	    Support for SET [NO]RULES.
**	08-oct-89 (ralph)
**	    Removed RAISE keyword.
**	    Added B1 keywords:
**		CALLPROC, WHEN.
**	    Added B1 double keywords:
**		ALTLOC, CRTLOC, CRTSECALM, DROPLOC, DROPSECALM,
**		ENSECAUDIT, DISECAUDIT, ALLDBS, BYUSER.
**	    Added support for B1 statements:
**		CREATE/ALTER/DROP USER/LOCATION
**		CREATE/DROP SECURITY_ALARM
**		ENABLE/DISABLE SECURITY_AUDIT
**	    Enhanced existing statements for B1:
**		Added ON ALL DATABASES to GRANT/REVOKE objects
**		Added [NO]ACCESS and [NO]UPDATE_SYSCAT privs to GRANT/REVOKE
**	20-oct-89 (neil)
**	    Rules: Allow unary operators on constants.
**	24-oct-89 (ralph)
**	    Call qeu_audit() for ENABLE/DISABLE SECURITY_AUDIT
**	30-oct-89 (fred)
**	    Added support for unsortable and/or unkeyable datatypes for large
**	    object support.  Also, changed interface to pst_*sort() to
**	    accept/require, as the last parameter, the entire psq_cb instead of
**	    just the psq_error field('s address).  This is necessitated by the
**	    use in pst_*sort() of psf_adf_error() to report an errors from
**	    adi_dtinfo() in finding whether a datatype is sortable.
**	01-nov-89 (ralph)
**	    For CREATE/ALTER LOCATION WITH USAGE = (ALL), turn on DU_ALL_LOCS.
**	    Allow CREATE/ALTER LOCATION WITH NOUSAGE.
**	    Make DU_ALL_LOCS the default usage for CREATE/ALTER LOCATION.
**	    Make the IF clause in CREATE SECURITY_ALARM optional.
**	25-nov-89 (neil)
**	    Alerters: Extended functionality for CREATE & DROP EVENT and
**	    event related permissions.
**	16-jan-90 (andre)
**	    Added rules for CREATE/DROP SYNONYM.
**	16-jan-90 (ralph)
**	    Correct call to psf_error for ENABLE/DISABLE SECURITY_AUDIT.
**          Set psy_grant to PSY_SDROP when dropping security alarms.
**	    Remove NONE from valid USAGE list on CREATE/ALTER LOCATION.
**	    Make the BY clause optional on CREATE SECURITY_ALARM.
**          Corrected ENABLE/DISABLE SECURITY_AUDIT PROCEDURE.
**          Added [NO]PASSWORD option to CREATE/ALTER USER.
**	    Recognize "GRANT [NO]UPDATE_SYSCAT nn" as an error.
**	1-feb-90 (andre)
**	    Changed interface to psl0_rngent();
**	    use psy_permit_ok() to determine if a permit may be
**	    granted/created/dropped;
**	    use psy_dbp_grant_check() to determine if the user may grant a
**	    permit on a dbproc();
**	    use psy_view_grant_check() to determine if the user may grant a
**	    permit on a view;
**	    when creating view and dbprocs, determine if the user should be
**	    allowed to grant a permit on them (using psy_dbp_grant_check() (for
**	    dbprocs only) and psy_view_grant_check());
**	    lots of other stuff
**	12-feb-90 (neil)
**	    Add EVENT and RULE to ENABLE/DISABLE SECURITY_AUDIT.
**	20-feb-90 (andre)
**	    Add support for comments.
**	9-mar-90 (andre)
**	    1) LEFT, INNER, FULL, RIGHT will no longer be recognized as keywords
**	    2) support SET [NO]OPTIMIZEONLY: act as if user entered
**	       "SET TRACE POINT op160"
**	    3) rather than setting VGRANT_OK in PST_HEADER, set PSS_VGRANT_OK in
**	       cb->pss_flag
**	    4) if (cb->pss_flag & PSS_0DBPGRANT_CHECK)
**	       {
**	           do not perform the semantic action associated with
**		   CREATE_DBPROC;
**		   as soon as it is determined that the dbproc is not grantable,
**		   return(E_DB_ERROR);
**	       }
**	    5) prevent user from dropping access permits which would be created
**	       for DBA-owned QUEL views.
**		   
**	    The following entries were copied from the 6.3 code on 3/12/90.
**
**	17-sep-89 (ralph)
**	    Initialize PSY_CB queues for CREATE/ALTER/DROP GROUP/ROLE
**	20-sep-89 (neil)
**	    Unreserved RAISE, AFTER & BEFORE.
**	29-sep-89 (neil)
**	    Support for SET [NO]RULES.
**	10-oct-89 (mikem)
**	    2 bug fixes.  First make sure that we only allow 'system_maintained' on
**	    logical key datatypes.  Second add argument number to 5 psf_errors() in
**	    the error reporting code of the 'null_default' production (error messages
**	    here were missing the only parameter).
**	12-oct-89 (stec)
**	    Fixed bug 8269. Problem was that "i = :i" in the target list of a
**	    subselect in an insert stmt was not processed correctly. The first
**	    "i" must not be treated as a local var. The same applies to the delete
**	    and update statements (ie., cdpb_dmlstmt); query statement did not
**	    require any change since the issue has been handled correctly. 
**	    Solution used was to set pss_1sub_seen to TRUE when parsing of the
**	    stmt commences, this determines how the first "name" in the
**	    "NAME EQUAL select_expr" production is to be interpreted. If the
**	    said flag is set, the first "name" will never be interpreted as a
**	    local var, i.e., it will be interpreted as a column. The flag needs
**	    to be reset when parsing of the dml statement
**	    (cdbp_dmlstmt production) ends.
**	    Explanation above applies also to "NAME EQUAL NULLWORD" production.
**	20-oct-89 (neil)
**	    Rules: Allow unary operators on constants.
**	03-jan-90 (ralph)
**	    Change calls to QSO_LOCK to QSO_GETHANDLE for dbprocs
**	    Change interface to QSO_TRANS_OR_DEFINE
**	19-jan-90 (anton)
**	    Integrate alignment changes and CL_ERR_DESC changes from NS&E
**	    Their history follows:
+ **	03-aug-89 (kimman)
+ **	    Added ming hint for su4_u42.
+ **	    Error code passed to TRset_file should be a CL_ERR_DESC.
+ **	17-aug-89 (fredp)
+ **	    Turn on Sun4 compiler optimization now that /tmp on the porting
+ **	    machine is large enough (10MB free space). This reduces the code
+ **	    size by over 60K bytes.
+ **	30-Aug-89 (bryanp)
+ **	    Added MING hint to disable optimization for MPE/XL. There are TWO
+ **	    NO_OPTIM's in this file...why?
+ **	14-sep-89 (fredp)
+ **	    Integrate my changes from b3ug, change 1939.
+ **	28-Nov-1989 (fredv)
+ **	    The following C code is wrong:
+ **		{
+ **		PTR *oldpieceptr;
+ **		oldpieceptr = (PTR *) ((char *) str);
+ **		}
+ **	     This statement doesn't assign (char *) str to *oldpieceptr;
+ **	     instead, oldpieceptr gets (char *) str. Thus, when we use 
+ **	     *oldpieceptr as an address later on, the address may be invalid 
+ **	     depends on what are the first 4 bytes of str (if they are 
+ **	     translated into an invalid address, a bus error will be raised.).
+ **	     Since the declaration of the variable oldpieceptr as (PTR *) is 
+ **	     unnecessary and causes problem, changed it to PTR and made 
+ **	     adjustment to the places have reference to it.
+ **	01-Dec-1989 (fredv)
+ **	     Backed out my last changed and fixed the real problem: alignment.
+ **	     Since *oldpieceptr may not be aligned, we must copy *oldpieceptr
+ **	     to a temporary variable and pass this variable (not *oldpieceptr)
+ **	     to psq_tb1add() for byte aligned machine.
**	    End of included history
**	09-apr-90 (andre)
**	    changed interface for psl_rngent(), psl0_rngent(), psl_orngent(),
**	    and psl0_orngent().  All of these functions will pass info back to
**	    the caller.
**	26-apr-90 (andre)
**	    "boolean" productions will now return (PSS_TREEINFO *) instead of
**	    (PST_QNODE *).  This is necessary, s.t. we can determine if a given
**	    tree contains a SUBSEL which is a descenedent of OR.
**	21-may-90 (linda)
**	    Add syntax for "register table", "register [unique] index",
**	    "remove table", "remove index" in support of Gateways (RMS
**	    Gateway project).
**	24-may-90 (linda)
**	    Always set dmu_gw_id = DMGW_NONE when creating tables, views or
**	    indexes.
**	29-may-90 (linda)
**	    Remove "register" as a single-word token, other minor cleanup.
**	29-may-90 (andre)
**	    Made changes to support use of corelated aggregates inside HAVING
**	    clause.
**	30-may-90 (andre)
**	    psy_dbp_grant_check() will no longer be called from the grammar
**	    (having grammar call itself recursively resulted in stack overflow.)
**	    In pslsgram.yi we will make sure that the user is DBA or $INGRES
**	    (this restriction is likely to be eventually removed) and is the
**	    owner of the dbproc.  Having successfully parsed the GRANT
**	    statement, we will invoke a slightly modified psy_dbp_grant_check()
**	    on every dbproc in the list to make sure that it is grantable.
**	    For EXECUTE/CALLPROC proc_name, we will just check if the user owns
**	    the dbproc: psy_dbp_grant_check() will not be invoked while
**	    recreating dbprocs.
**	07-jun-90 (andre)
**	    Changed execute_dbproc production so that if the dbproc is owned by
**	    the current user, we will store private alias object id (hence the
**	    dbproc doesn't have to be grantable in order to be executed by this
**	    user); otherwise store the public alias object id (hence the dbproc
**	    has to be grantable in order to be executed by this user.)
**	    Changed create_dbproc production so that it always defines a private
**	    alias object (for the owner of the dbproc) using
**	    qso_trans_or_define() and, if the dbproc was determined to be
**	    grantable, a public alias object using qso_crtalias().
**	    Added code so that if we are parsing a dbproc and
**	    (cb->pss_flag & PSS_1DBP_MUSTBE_GRANTABLE) and we have determined
**	    that the dbproc being parsed is not grantable, err_code will be set
**	    to E_PS042C and E_DB_ERROR will be returned.
**	22-jun-90 (linda)
**	    Remove GWUPDATE token.  Several corrections to "register table"
**	    code, for example to enforce 1000-row default, noupdate default,
**	    etc.
**      08-aug-90 (ralph)
**          Added [NO]DB_ADMIN database privilege.
**          Set statement mode to PSQ_[GR]OKPRIV if unrestricted dbprivs.
**          Don't allow ENABLE/DISABLE SECURITY_AUDIT ROW/LEVEL if non-B1.
**	    Change GRANT ... ON ALL DATABASES to GRANT ... ON INSTALLATION.
**	    Initialize psy_cb.psy_opctl for GRANT extension positioning.
**	    Enhance ALTER USER to allow normal users to change passwords.
**	    Issue E_PS0426 instead of E_PS0427 when fail create security alarm
**	23-aug-90 (ralph)
**          Call psy_cpyperm to check permission to issue COPY INTO/FROM.
**	    Changed interface to pst_dbpshow.
**	12-sep-90 (teresa)
**	    Changed several booleans to become bitmaps in pss_flag or in
**	    pss_ses_flag: pss_agintree, pss_subintree, pss_catupd, pss_warnings,
**	    pss_journaling, pss_dba_drop_all, pss_fips_mode, pss_txtemit.
**	    also changed psq_alldelupd to bitflag in PSQ_CB.psq_flag
**	06-nov-90 (andre)
**	    replaced pss_flag with pss_dbp_flags and pss_stmt_flags
**	27-nov-90 (andre)
**	    a predicate NOT IN subselect will be translated into the same tree
**	    as a predicate !=ALL subselect.  This fixes bug 34433.
**	15-jan-91 (andre)
**	    Notify OPF if the query contained correlated aggregates.
**      07-feb-1991 (jennifer)
**          Fix bug 31865 by checking minpages and maxpages for a maximum
**          value of 8388607.
**      07-feb-1991 (jennifer)
**          Fix bug 34079 by checking if update,delete or insert directly to 
**          a secondary index.  This was never supposed to be supported
**          for 6.0.
**	04-feb-91 (neil)
**	    1. Allow EXEC IMMED of set logevents & set printevents
**	    2. Fixed error message on invalid EXECUTE PROCEDURE name.
**	    3. Fixed unowned names or correlated names in EXECUTE PROCEDURE
**	       target lists.
**	04-feb-91 (andre)
**	    The following changes were made as a part of the project to support
**	    shareable QUEL repeat queries:
**	     - changed define_query: production to use newly defined function,
**	       psl_repeat_qry_id(), to determine BE id of a query plan for this
**	       query;
**	     - added support for a new tracepoint, ps132, which will report
**	       whether the query was shareable, and if not, provide a reason;
**	     - defined a new function, psl_repeat_qry_id(), which will be used
**	       for both QUEL and SQL repeat queries:
**	        - for SQL repeat queries, it will simply try to find an exsiting
**		  shareable QEP, and if that fails, will define a BE id for the
**	 	  QEP object;
**		 - for QUEL, if a shareable QEP is found, it will use
**		   information about this query found in DB_SHR_RPTQRY_INFO and
**		   information about the query for which shareable QEP was built
**		   to establish if a given query can use the existing QEP
**	06-feb-91 (andre)
**	    The following changes were made in the course of fixing bug 35659:
**	     - put code responsible for allocation and initialization of dbproc
**	       statement blocks into a new function, psl_init_dbp_stmt() which
**	       will do as much common iniitalization as possible, with
**	       non-trivial statement-specific initialization to be performed by
**	       the caller;  among other things, psl_init_dbp_stmt() may create a
**	       new ENDLOOP statement block if dbpinfo->pss_patch is set to NULL;
**	       this new function will be called from all productions which need
**	       to allocate a new satetment node;
**	     - having successfully parsed of IF...ENDIF (cdbp_ifstmt), reset
**	       $Ydbpinfo->pss_patch to NULL to force psl_init_dbp_stmt() to
**	       create a statement block if ENDLOOP was encountered immediately
**	       following IF...ENDIF;
**	     - having successfully parsed WHILE...ENDWHILE set
**	       $Ydbpinfo.pss_patch to address of pst_false instead of the
**	       address of pst_next, since if ENDLOOP is encountered immediately
**	       following ENDWHILE, pst_false and not pst_next must be reset;
**	     - detect unreachable statements and do not append them to the list
**	       of dbp statements, thus saving OPF the cost of optimizing
**	       and allocating space for QEPs for unreachable statements
**	19-feb-91 (andre)
**	    $Ynonupdt is a boolean and should be treated as such, i.e. it can be
**	    set only to TRUE or FALSE ($Ynonupdt |= TRUE is NOT encouraged); to
**	    test its value, use ([!]$Ynonupdt) (seems pointless to compare it to
**	    TRUE or FALSE)  all this was done to fix bug #35872
**	20-feb-91 (andre)
**	    group and role permits must be disregarded when parsing definitions
**	    of views, rules, and database procedures -
**	    OR PSS_DISREGARD_GROUP_ROLE_PERMS into cb->pss_flag upon parsing
**	    CREATE VIEW, CREATE RULE, or [CREATE] PROCEDURE 
**	    (this was done as a part of fix for bug #32457)
**	28-feb-91 (andre)
**	    fixed bug 32431: instead of relying on resetting psq_mode to
**	    PSQ_RELOCATE upon encountering "modify to RELOCATE", we use the fact
**	    that qeu_cb->qeu_d_op already gets reset to DMU_RELOCATE_TABLE.
**	    Also, as an experiment in reducing the size of the garmmar files,
**	    all semantic actions used to parse MODIFY statement (both for QUEL
**	    and SQL) have been copied (with minor changes into a separate file,
**	    PSLMDFY.C)
**	08-mar-91 (andre)
**	    several productions (e.g. cdbp_message, cdbp_raise_error) assumed
**	    (incorrectly) that $Ydbpinfo->pss_link ALWAYS points at the last
**	    statement which was allocated; if the statement being processed in
**	    unreachable, it will not be added to the statement list, hence the
**	    assumption should be qualified with
**	    "if ($Ydbpinfo->pss_unreachable_stmt_lvl == 0)" or, better yet,
**	    should never be made.
**	    Instead, I have added a new field to PSS_DBPINFO, pss_last_stmt,
**	    which is guaranteed to ALWAYS point at the last allocated statement
**	    block.
**	19-mar-91 (andre)
**	    moved semantic actions responsible for parsing SET LOCKMODE into
**	    PSLLKMD.C
**	22-apr-91 (andre)
**	    modify copyoption: production to disregard WITH-clause of form
**	    "copyhandler = <string>"
**	29-apr-1991 (Derek)
**	    Added EMPTYTABLE to COPY, ALLOCATION and EXTEND to CREATE and INDEX.
**	29-apr-91 (andre)
**	    fix bug 35924:
**	     - ONINSTALLATION has been replaced with ON CURRENT NAME where NAME
**	       must be "installation".  "ON INSTALLATION" will no longer be
**	       treated as a double keyword;
**	     - in dropperm:, ONEVENT has been replaced with ON NAME where NAME
**	       must be "event".
**	17-may-91 (andre)
**	    Add support for SET USER AUTHORIZATION, SET [NO]ROLE, and SET
**	    [NO]GROUP.
**	06-jun-91 (andre)
**	    (belatedly) add support for EXECUTE IMMEDIATE CREATE SYNONYM,
**	    dynamically prepared COMMENT ON and CREATE SYNONYM
**	12-jun-91 (andre)
**	    Added support for GRANT WITH GRANT OPTION and REVOKE [CASCADE] on
**	    tables, views amd database procedures
**	13-jun-91 (andre)
**	    made ON CURRENT a double keyword since otherwise YACC gets 2 red/red
**	    conflicts upon seeing ALL [PRIVILEGES] ON (conflicts are between
**	    reducing to tbl_priv_spec and db_priv_spec)
**	14-jun-91 (andre)
**	    clean up text that gets stored for GRANT ON TABLE/PROCEDURE/EVENT:
**	    we will get rid of extra blanks following the object, grantyee, and
**	    column names.  There is no reason to biold up a template for column
**	    names since they are invariant.  There is no reason to store object
**	    and grantee name offsets for every name since they are the same for
**	    every grantee and object.
**	21-jun-91 (andre)
**	    change the code generating IIQRYTEXT text for CREATE PERMIT and
**	    GRANT ON [TABLE] to facilitate splitting permit tuples so that each
**	    tuple represents exactly one privilege.
**	05-aug-91 (andre)
**	    psy_view_grant_check() has been effectively discarded and all calls
**	    to it has been eliminated;
**	    
**	    a new function, psy_tbl_grant_check() will be used to determine if
**	    the user may grant/create a permit on a table or a view; the actual
**	    call will be made in psy_dperm() and psy_dgrant().
**	    
**	    grantability and updateability of views will be determined at
**	    creation time inside psy_view().
**
**	    psy_permit_ok() will continue to be trusted in CREATE PERMIT, but
**	    with GRANT we will no longer insist that the user be the same as the
**	    object owner;
**	    until our FEs are changed to not rely on CATUPD to grant permits on
**	    catalogs and (user=dba) to create/grant permits on extended
**	    catalogs, we will avoid calling psy_tbl_grant_check() when
**	    psy_permit_ok() returned TRUE even though object owner is different
**	    from the current user
**	17-sep-91 (andre)
**	    currently we insist that in order for a dbproc to be grantable, all
**	    base tables (after qrymod) used in it must be owned by the owner of
**	    the dbproc.  This is both incomplete (U1.DBP could be referencing
**	    U2.V which is defined on top of U1.T) and overly restrictive (even
**	    if the dbproc owner does not own some object used in the database
**	    procedure, he may have been granted the required privilege WGO in
**	    which case he should be allowed to GRANT EXECUTE on this dbproc)
**
**	    Under the new algorithm, we will assume that a dbproc is grantable
**	    and will let psy_check_permits() (in PSYPERMIT.C) disprove it.
**	03-oct-91 (andre)
**	    if we are reparsing a dbproc in order to determine if it is
**	    grantable, and it turns out to be non-grantable, functions
**	    responsble for enforcing the permits (dopro(), psy_dbpperm(), and
**	    psy_evperm()) will print an error message advising the user that he
**	    lacks some required privileges WGO and return E_DB_ERROR.  Thus, the
**	    we will no longer have to check if (pss_dbp_flags & PSS_DBPGRANT_OK)
**	    if (pss_dbp_flags & PSS_0DBPGRANT_CHECK)
**	20-nov-1991 (andre)
**	    merge 4-feb-91 (rogerk) change:
**		Added SET [NO]LOGGING statement.  Causes PSQ_SLOGGING statement
**		to enable/disable logging.
**	    merge 4-mar-91 (andre) change:
**		PST_QTREE changed so that the range table is represented as a
**		variable-size array of range entry pointers + when restoring PSF
**		range table from the one contained in PST_QTREE, copy
**		correlation name.  These changes were made in the course of
**		imrpoving diagnostics for bug #35862
**	    merge 27-feb-91 (ralph) change:
**		Added the DESTINATION clause to MESSAGE and RAISE ERROR.
**	    merge 06-mar-91 (ralph) change:
**		Change LOG to ERROR_LOG in DESTINATION clause of the MESSAGE
**		and RAISE ERROR statements.
**	    merge 25-feb-91 (rogerk) change:
**		Added SET SESSION statement.  Returns PSQ_SON_ERROR query mode.
**		Changed ERUSF error numbers added for Set Nologging to be ERPSF
**		error numbers: E_US1275 -> E_PS0F81_SETLG_PRIV_ERR.
**	    merge 29-apr-91 (andre) change:
**		fix bug 35924: in dropperm:, ONEVENT has been replaced with ON
**			       NAME;
**			       ONINSTALLATION has been replaced with ON CURRENT
**			       NAME where NAME must be "installation".
**			       "ON INSTALLATION" will no longer be treated as a
**			       double keyword.
**	    merge 03-jun-91 (stevet) change:
**		fix bug 37777.  Preserve NULLability when datatype is being
**		mapped to DB_CHA_TYPE because of the AD_NOEXPORT
**		AD_CONDEXPORT condition.
**	    merge 17-jul-91 (ralph) change:
**		Change "event" to "dbevent" in the DROP PERMIT ON EVENT
**		statement.  Generate correct query text (dbevent) for
**		CREATE DBEVENT and GRANT ... ON DBEVENT statements.
**	    merge 07-aug-91 (andre) change:
**		fix bug 38876: allow comparison of any select_expr with NULL
**	    merge 10-sep-91 (andre) change:
**		If the WITH-clause of COPY statement encounters WITH LOG = ~V,
**		call qdata_cvt() to ensure that we are dealing with a
**		DB_TEXT_STRING before trying to copy it.
**	09-dec-91 (andre)
**	    fix bug 41330.
**	    In COPY, both NUL and NULL are valid delimiters.  The trouble is
**	    that NULL also happens to be a keyword.  We will add a new
**	    production with NULL as a delimiter and factor out the code used in
**	    coent: into a separate function calls to which will replace
**	    semantic actions in coent: productions.
**	07-jan-92 (andre)
**	    upon seeing UPDATE or DELETE, increment cb->pss_qualdepth.  This
**	    will facilitate processing of subselects in qualification of
**	    UPDATE/DELETE in a manner similar to subselects found in
**	    qualification of SELECT.  We use pss_qualdepth to determine whether
**	    we are in a subselect of the qualification, and not having it
**	    incremented in DELETE and UPDATE caused confusion
**
**	    Make sure that aggregates are disallowed in updatelist but are
**	    allowed in the qualification of UPDATE
**
**	    Call pst_rsdm_dt_resolve() when processing a prototype tree 
**	    target list element involving [<corr_name>.]<col_name>.  This
**	    provides correct handling for the case when the attribute involved
**	    is of UDT
**	14-jan-92 (barbara)
**	    Included ddb.h for Star.
**	05-feb-92 (rblumer)
**	    (merge fix for 6.4 bug 39014)
**	    In create_dbproc, added a check to see if we are REcreating the
**	    procedure before deleting an existing query plan.  Otherwise
**	    if several session simultaneously execute an uncached query,
**	    each and every session will end up re-optimizing the query.
**	12-feb-92 (rog)
**	    In the cdbp_begin and cdbp_stmtlst productions, set psq_mode
**	    to 0 instead of PSQ_CREDBP so that a better syntax error message
**	    gets printed for syntax errors on statements inside dbproc
**	    begin/end blocks.  (39333)
**	26-feb-92 (andre)
**	    if PSS_REPAIR_SYSCAT and PSS_CATUPD are set in
**	    sess_cb->pss_ses_flags, allow UPDATE/DELETE/INSERT on indexes marked
**	    as non-extended catalogs 
**	30-mar-1992 (bryanp)
**	    Temporary table enhancements: new tokens, new DECLARE GLOBAL
**	    TEMPORARY TABLE statement.
**	    Various changes in support of SESSION as a keyword.
**	07-may-92 (andre)
**	    fix for bug 20499 introduced a bug of its own:
**		as a part of processing EXPR1 BETWEEN EXPR2 AND EXPR3 and
**		EXPR1 IN (EXPR2, ..., EXPRn) we would copy EXPR1 tree and insert
**		PST_AGHEAD nodes into "appropriate" lists (PST_AGHEAD is
**		inserted into a list based on the scope of the column-reference
**		found in its subtree, e.g. sum(a.i) would be inserted into a
**		list corresponding to the scope of a).
**
**		Unfortunately, in the FOR loop scanning through the list of
**		YYAGG_LIST_NODEs (which are used to build PST_AGHEAD node
**		lists), we would compute the next element to be processed by
**		following agg_next pointer from the element just processed - the
**		trouble is that as a part of "processing" a node, we insert it
**		in the front of "appropriate" list, thus reseting agg_next from
**		pointing to the next element of the list to be processed to
**		pointing at the next element, if any, of the "appropriate" list.
**		
**		If the list into which the just-processed element has been
**		inserted had no other elements, the effect would be that if the
**		list of PST_AGHEADs to be processed contained more than one
**		element, all elements but the first will never be inserted into
**		their "appropriate" lists.  On the other hand, if the list into
**		which the first PST_AGHEAD was inserted contained at least one
**		other element (as would ALWAYS happen with EXPR1 BETWEEN EXPR2
**		AND EXPR3 and EXPR1 IN (EXPR2, ..., EXPRn)), we would enter an
**		infinite loop since the new elements are inserted in the front
**		of the loop.
**	19-may-92 (andre)
**	    1) if reparsing dbproc text to determine whether it is active
**	       (pss_dbp_flags & PSS_CHECK_IF_ACTIVE), skip the body of
**	       create_dbproc (we already do it when reparsing dbprocs to
**	       determine if they are grantable
**	       (pss_dbp_flags & PSS_0DBPGRANT_CHECK));
**	    2) when [re]creating a dbproc (as opposed to reparsing its text to
**	       determine whether it is grantable/active), open a memory stream
**	       to record objects/privileges on which the dbproc depends.
**      15-jun-92 (schang)
**          GW merge
**	22-jun-92 (schang)
**	    1.  pass parameter for error code 8004L,
**	    2.  document routines psl_reg_struct().
**	30-jun-92 (barbara)
**	    Merge of Star grammar into rplus for Sybil.  Merged Star comments:
**	    17-aug-88 (andre)
**		Added dircon non-terminal.
**	    08-sep-88 (andre)
**		Added dir_exec_immed non-terminal.
**	    05-oct-88 (andre)
**		Uppercase DBMS name when it is supplied by the user in the WITH
**		clause.
**	    06-dec-88 (andre)
**		Added regstmnt nonterminal.
**	    15-Feb-89 (andre)
**		Changed the semantic action for QUESTIONMARK so that 
**		pst_origtxt is set to NULL and the query is marked multi-site.
**		QUESTIONMARK is found only in PREPARE, and when we process
**		execute, PST_CONST nodes corresponding to ? will be modified
**		to appear like those corresponding to ~V's, so we are not doing
**		anything unkosher.  Hopefully, we will eventually stop treating
**		parameterized queries as multi-site.)
**	    13-oct-89 (stec)
**		Changed initialization of the pst_sent mask for DROP in the
**		distributed case. If the command is DROP LINK or REMOVE the show
**		type mask is to specify PST_REMOVE, so that RDF does not check
**		existence of the object.
**	    25-feb-91 (fpang)
**		For 'create table as select...', if user did not specify the
**		site for the result table and the query is single-site, the
**		new table will be created in the CDB.
**		Fixes B31918.
**	    21-mar-91 (fpang)
**		For 'like ~V', mark it as multi-site, so opf/opc can figure out
**		what to do with the parameters.
**		Fixes B34562 and B35847.
**	    29-mar-91 (dchan)
**		Added NO_OPTIM for ds3_ulx as the compiler complains about
**		"mismatched offsets between vreg and reference."
**	    07-may-91 (andre)
**		fix bug 37414 - in drop_name: production store LDB object 
**		type in PSS_LTBL_INFO if the LDB object will be dropped 
**		along with STAR object
**	    04-jun-91 (andre)
**		support SET [NO]OPTIMIZEONLY: act as if user entered
**		"SET [NO]TRACE POINT op160"
**	    17-jun-91 (fpang)
**		Initialized qef_rcb->qef_modifier, causes qef to get confused
**		about the tranxasction state if it is not initialized.
**		Fixes B37913.
**	    07-aug-91 (andre)
**		fix for bug 38876: allow any select_expr to be compared with
**		NULL
**	    19-aug-91 (seng)
**		This module requires a fix for compiler reasons on the RS/6000
**		and HP 9000/800.  For some reason, you cannot autoincrement
**		something that is being caste to another type.  Create a
**		temporary variable for the caste and then CMnext() the
**		temporary variable.
**	    21-aug-91 (seng)
**		Change braces in above change to be on their own line, per
**		coding standards.
**	    27-oct-91 (barbara)
**		Star was ignoring statistics directly after optimizedb because
**		it had outdated cache info (bug 39414).  Fix is to flush RDF
**		cache during a SET STATISTICS statement.  Set statistics is
**		issued by optimizedb after stats and histograms tables have
**		been updated.
**	    12-mar-92 (barbara)
**		Fixed bug 42625: Star was reusing/sharing a repeat query plan
**		even though a table used in the plan had been reregistered
**		making the plan out of date.  Imported fix from local for QUEL
**		repeat queries.  1)  Save query ids of shareable repeat queries
**		for OPC to include in query plan (call psl_rptqry_tblids();
**		2) when checking if current definition of repeat query matches
**		a saved query plan, compare table ids as well as unique query
**		ids (see psl_repeat_qry_id()).
**	    (End of Star merged comments)
**	    Sybil merge included following changes: extracted COPY semantic
**	    actions into separate module; abolished most of Star's buffering
**	    for single-site query optimization; extracted REGISTER semantic
**	    actions into separate module; incorporated Star-specific actions
**	    for CREATE, SET, const functions; changed interface to psl0_rngent,
**	    pst_header, pst_rgent, pst_clrrng, psl_do_insert, psl_shareable,
**	    psl_nm_eq_no, psl_ct6_cr_single_kwd, psl_lst_prefix,
**	    psl_ct8_cr_lst_elem, psl_ct9_new_loc_name, psl_lm2_setlockkey
**	    and psl_lm3_setlockparm_name.
**	26-jun-92 (schang)
**	    "set lockmode session" command is broken by you know who, fixed it.
**	14-jul-92 (andre)
**	    when processing GRANT statement, remember whether the user specified
**	    ALL [PRIVILEGES]
**	19-jul-92 (andre)
**	    added a new keyword - EXCLUDING;
**
**	    added EXCLUDING clause to GRANT and CREATE PERMIT
**
**	02-aug-92 (andre)
**	    added support for REVOKE on tables, dbprocs and dbevents
**	03-aug-92 (pholman)
**	    Rename SYSTEM_ADMIN privilege to be more appropriate to be more
**	    appropriate MAINTAIN_LOCATIONS.
**	03-aug-92 (barbara)
**	    Completed Star support for Sybil.  Added CREATE LINK, DIRECT
**	    [DIS]CONNECT and DIRECT EXECUTE IMMEDIATE.  In support of RDF
**	    rewrite, invalidate base table info on relocate statement and
**	    set statistics.  Fixed several bugs.
**	11-aug-92 (pholman)
**	    C2: change qeu_audit statements to sxf_calls.
**      14-aug-92 (teresa)
**          changed "set statistics on <tablename>" production to invalidate
**          Changed setstats: logic to invalidate RDF's cache in local case as
**          the RDF cache entry for <tablename> in local's case as well as in
**          distributed.
**	17-aug-92 (andre)
**	    made changes to allow mixing of UNION and UNION ALL in query
**	    expressions.
**	14-sep-92 (robf)
**	    Changes for C2-Audit gateway, allow REGISTER TABLE, REMOVE
**	    commands in regular DBMS.
**	    Allow reg_gateway_tab in EXECUTE IMMEDIATE
**	    Commented out spurious TRdisplays in REGISTER TABLE command
**	    Added trace point 20 (148) to handle register statements
**	    Allow SCONSTS for gateway DBMS and STRUCTURE clauses of
**	    REGISTER TABLE (e.g DBMS='sxa').
**	    Ensure REGISTER [VIEW] is only legal in distributed.
**	    Validate non-distributed REMOVE to make sure only gateway
**          objects get removed.
**	16-sep-92 (andre)
**	    privilege map gets populated using bitwise operators - care should
**	    be exercised when accessing it using BTnext(), BTset(), BTclear(),
**	    and the like.  In particular, one should not count on BTnext()
**	    returning DB_RETP even if you know for a fact that the map contains
**	    DB_RETRIEVE
**	20-sep-92 (andre)
**	    when processing IF or ELSEIF inside a dbproc we allocate a statement
**	    block and push it on stack to keep track of scope of the statements.
**	    When we are done processing an IF statement, the statement block is
**	    popped off the stack.  If an IF statement involved ELSEIF, we would
**	    pop the statement description of ELSEIF off the stack at the end of
**	    processing the statement list associated with ELSEIF, but this was
**	    incorrect, here's why:
**
**	    We translate
**		IF cond1 THEN			IF cond1 THEN
**		    act1			    act1
**		ELSIF cond2 THEN		ELSE
**		    act2		into	    IF cond2 THEN
**		ELSE[IF cond3 THEN]			act2
**		    act3			    ELSE
**		ENDIF					[IF cond3 THEN]
**							    act3
**							[ENDIF]
**						    ENDIF
**						ENDIF
**	    So, strictly speaking, the end of IF statement produced by
**	    translation of ELSEIF is not reached until we reach the ENDIF
**	    terminating the entire IF statement.  This becomes very relevant if
**	    the IF statement involving ELSEIFs is inside a WHILE statement, and
**	    a statement list associated with N-th (N>1) ELSEIF begins with
**	    ENDLOOP, since by popping descriptions of previous ELSEIF(s) we
**	    ensure that pst_false of the enclosing IF statement will be "fixed"
**	    (i.e. made to point outside of the WHILE statement) instead of
**	    pst_false of the (N-1)-st ELSEIF.  This also results in the query
**	    tree being built in a way which makes (N-1)-st ELSEIF unreachable.
**	    
**	    To correct this problem, we will remove the code to pop a statement
**	    description off the stack at the end of processing the statement
**	    list of ELSEIF and will modify the code popping off the description
**	    of IF statement, to pop off descriptions until that of the IF
**	    statement is reached.
**	22-sep-92 (andre)
**	    having called psy_gevent() in the semantic action of event_name:,
**	    we must copy database name into ev->pst_event.dba_dbname
**  	24-sep-92 (stevet)
**  	    Implemented the new timezone adjustment method by
**  	    replacing TMzone() with TMtz_search() routine.
**	28-sep-92 (andre)
**	    when processing definitions of dbprocs, we will always insist on
**	    up-to-date RDF cache entries and, consequently, will not delay
**	    reporting of errors
**	29-sep-1992 (fred)
**	    Added support for BIT & BIT VARYING datatypes.  Changed create table
**	    typedesc production to allow "bit varying (length)" type name.  Also
**	    added support for b'010101010' type construct.
**	1-oct-92 (andre)
**	    add support for <column reference>s of form
**	    <schema>.<table>.<column>.  Define col_ref and all_col_ref
**	    non-terminals and use them wherever [[<schema>.]<table>.]<column>
**	    and [<schema>.]<table>.*, respectively, is allowed (e.g. cname,
**	    comment_col)
**	06-oct-92 (bonobo)
**	    Removed stray control characters which were inadvertantly included
**	    in the last integration.
**      07-oct-92 (robf)
**          REGISTER ROWS= clause broke due to DGTT keyword "ROWS", changed
**          grammer to use keyword instead.
**          Updated CREATE SECURITY_ALARM handling, mark as DB_ALARM and
**          generate appropriate query text.
**          Allow WORK as a target of CREATE/ALTER LOCATION.
**	08-oct-92 (ralph)
**	    Add support for delimited identifiers
**	26-oct-92 (jhahn)
**	    Added byref support
**	09-oct-92 (barbara)
**	    Added with clause to DIRECT EXECUTE IMMEDIATE; fixed bug re
**	    REGISTER WITH REFRESH; set Ycorrelation_mask for OPF to reflect
**	    all levels of subquery in nested SELECTS; fix SET LOCKMODE to
**	    correctly generate text for QEF; set pst_numparm to 0 on
**	    dynamic cursors after user parameters have been substituted.
**	28-oct-92 (andre)
**	    set PSS_DSQL_QUERY when parsing DSQL queries
**	30-oct-92 (rblumer)
**	     FIPS CONSTRAINTS
**	    30-jul-92 (rickh)
**	        change DBR_T_TABLE to DBR_T_ROW.
**	    30-jul-92 (rblumer)
**	        changed uses of dbr_column to dbr_columns; 
**              it is now a bitmap instead of an i2.
**	    12-aug-92 (rblumer)
**		added new syntax productions for multi-column rules
**		and corrected some compiler warnings.
**	    15-oct-92 (rblumer)
**		added new productions for constraints & user-defined defaults;
**		replaced specs and  null_default productions with
**		tbl_elem_list and type_qual_list productions;
**		added separate KEY rules for productions that allow the
**		word "key" as now KEY is a keyword.
**	03-nov-92 (jrb)
**	    Added "set work locations..." command for multi-location sorts
**	    project.
**	07-nov-92 (andre)
**	    removed code to check whether PSS_1DBP_MUSTBE_GRANTABLE is set in
**	    pss_dbp_flags (this mask will no longer be used since now existence
**	    of a permit on a dbproc implies that the dbproc is grantable and
**	    that mask was defined to deal with the case when a permit was
**	    defined on a non-grantable dbproc) +
**	    removed code to create public and private aliases on dbproc QPs
**	10-nov-92 (ralph)
**	    Grandfather SCONSTs in production "user_ident" by producing
**	    "internal_ident" rather than "generic_ident".  
**	    This is being done to allow backward compatibility for
**	    UPGRADEFE until the FE group revises their code to eliminate
**	    single-quoted identifiers.  This should be reversed prior to
**	    product shipment.
**	10-Nov-92 (jhahn)
**	    Fixed integration editing.
**	16-nov-92 (andre)
**	    when calling psl_valid_session_schema_use() from obj_spec:
**	    production, we must pass a NULL-terminated table name instead of
**	    address of a normalized table name
**      18-nov-92 (teresa)
**          Added support to the register logic for procedures.
**	20-nov-92 (ralph)
**	    DROP PERMIT ON DBEVENT was broken from integration.  Fixed.
**	21-nov-92 (barbara)
**	    Many minor bug fixes for Sybil in the area of DROP/REMOVE
**	    [owner.]table.  Changed the interface to psl0_orngent to pass
**	    in distributed flags that then get mapped into RDF flags (same
**	    now as interface to psl0_rngent).
**	01-dec-92 (andre)
**	    Removed support for SET GROUP/ROLE; replaced SET USER AUTHORIZATION
**	    with SQL92-compliant SET SESSION AUTHORIZATION (with INITIAL_USER
**	    added to enable one to reset session <auth id> to the value which
**	    was in effect as session startup);
**	    added support for new constant functions: CURRENT_USER,
**	    INITIAL_USER, SESSION_USER, and SYSTEM_USER
**	05-dec-92 (andre)
**	    added support for GRANT/REVOKE REFERENCES
**	08-dec-92 (barbara)
**	    Instead of overloading qeu_qso to handle query text on gateway
**	    REGISTER TABLE/INDEX, use qeu_qtext.
**	12-dec-92 (andre)
**	    A number of PSY_CB fields were renamed to improve code readability
**	23-nov-92 (andre)
**	    The following changes will be made to support enforcement of CHECK
**	    OPTION in a SQL92-compliant fashion by using statement-level rules
**	    and set-input database procedures:
**
**	    - if the view definition involved WITH CHECK OPTION
**		- if it was found non-updateable, an error will be issued;
**		  before applying qrymod, we can conclude that a view is not
**		  updateable if at least one of the following holds:
**		    - outermost <subselect> of the <query expression> involves
**		      DISTINCT;
**		    - the target list of the outermost <subselect> of the
**		      <query expression> involves an expression involving a
**		      <set function>;
**		    - <from clause> of the outermost <subselect> of the
**		      <query expression> specifies more than one
**		      <table reference> (note that a "complete" definition would
**		      require that the <table reference> refer either to a base
**		      table or an updateable view, but in the context of the
**		      grammar we will not be determining whether the underlying
**		      view is updateable);
**		    - the outermost <subselect> of the <query expression> 
**		      involves a <group by clause> or a <having clause>;
**		    - the <query expression> involves a set operator (i.e.
**		      UNION [ALL], EXCEPT [ALL], or INTERSECT [ALL]) outside of
**		      a subquery
**	
**	    - CREATE VIEW processing will follow the same path as CREATE TABLE,
**	      i.e. we will no longer expect sequencer to call psy_dview().  This
**	      will trigger several changes throughout the PSF:
**		- we will no longer build PSY_CB when processing CREATE VIEW -
**		  instead we will allocate a PST_STATEMENT node which now 
**		  includes PST_CREATE_VIEW which will contain all the 
**		  information required to create a new view
**		- a somewhat modified code from psy_dview() will be combined 
**		  with semantic action for create_view: production into 
**		  psl_cview() which will be called directly by the grammar
**	23-nov-92 (ralph)
**	    Add support for CREATE SCHEMA:
**		<psfparse.h> should be included before <qefact.h>.
**		Add grammar productions for CREATE SCHEMA.
**		Identify actions to be driven for CREATE SCHEMA with %nobypass
**		Modify actions to handle 1st pass of CREATE SCHEMA.
**		Modify CREATE TABLE constraints actions for 2nd pass.
**		Add dummy support for ALTER TABLE ADD [CONSTRAINT].
**	01-dec-92 (andre)
**	    Removed support for SET GROUP/ROLE; replaced SET USER AUTHORIZATION
**	    with SQL92-compliant SET SESSION AUTHORIZATION (with INITIAL_USER
**	    added to enable one to reset session <auth id> to the value which
**	    was in effect as session startup);
**	    added support for new constant functions: CURRENT_USER,
**	    INITIAL_USER, SESSION_USER, and SYSTEM_USER
**      04-dec-92 (schang)
**          change PSQ_REMOVE to PSQ_REG_REMOVE so that remove table can be
**          done in dsql.
**	04-dec-1992 (pholman)
**	    Change sxf_calls to new wrapper psy_secaudit, change EVENT to
**	    DBEVENT in "SECURITY_AUDIT" Syntax (as per C2 prod. spec), make
**	    LEVEL xORANGE (future to be decided in next release).
**	05-dec-92 (rblumer)
**	    emit text for check constraint and user_default productions; 
**	    added ALTER TABLE statement with ADD/DROP constraint clauses; 
**          made sure view definition either copies or defines a default ID;
**	    added psl_reserved_ident function to test new-object identifiers;
**	    added (internal) syntax for stmt-level rules and set-input dbprocs.
**	05-dec-92 (andre)
**	    added support for GRANT/REVOKE REFERENCES
**	08-dec-92 (barbara)
**	    Instead of overloading qeu_qso to handle query text on gateway
**	    REGISTER TABLE/INDEX, use qeu_qtext.
**      10-dec-92 (schang)
**          Since PSS_TYPE_NOT_NULL and PSS_TYPE_DEFAULT are separate bit
**          flag, we can OR them together to form the default data restriction
**          for RMS GW
**	12-dec-92 (andre)
**	    A number of PSY_CB fields were renamed to improve code readability
**	14-dec-92 (jhahn)
**	    Added more support for byrefs and nested procedure calls.
**	14-dec-92 (jrb)
**	    Fix check for distributed on SET WORK LOCATIONS command; I was
**	    using an obsolete method of checking which no longer works.
**	14-dec-92 (tam)
**	    Changed execute_dbproc to handle dynamic SQL registered proc
**	    execution in star.
**	    Instead of building a query tree, we buffer up the query
**	    text to give to SCF.  Many productions inside execute_dbproc 
**	    were bypassed with "break;" statements.  Modelled after the 
**	    copytable productions.  Introduce new query mode PSQ_DDEXECPROC.
**	    Changed drop_prefix: and drop_obj: to handle REMOVE PROCEDURE.
**	    Added REMOVE_PROCEDURE definition for $Yupobjtype.
**	18-dec-92 (robf)
**	    Improve REGISTER IMPORT DBMS error handling:
**	    - If a bad DBMS clause is issued error 9310 wasn't found due
**	      to wrong parameters. Corrected call to psf_error.
**	    - If a legal DBMS clause was used, but the current server doesn't
**	      support that gateway then user got a nasty generic error.
**            Call GWF to verify the server can handle the gateway requested
**	      then issue an appropriate message.
**	22-dec-92 (andre)
**	    CREATE VIEW will be represented by a PST_CREATE_VIEW statement node
**	    replaced semantic action of create_view production with a call to
**	    psl_cv1_create_view()
**	    replaced semantic action of viewstmnt production with a call to
**	    psl_cv2_viewstmnt()
**
**	    Added support for creating rules on views
**	23-dec-92 (ralph)
**	    Added various bug fixes for CREATE SCHEMA
**	29-dec-1992 (robf)
**	    ifdef xORANGE the call to SLintenal since auditing by level
**	    is not part of C2.
**	    REGISTER...IMPORT should be same as REGISTER TABLE...IMPORT
**	    (i.e. the default object type is a table), this now is allowed.
**	5-feb-1993 (markg)
**	    Fixed bug in permit handling for dbevents.
**	07-jan-93 (tam)
**	    Changed drop_obj: at REMOVE_PROCEDURE, set psy_cb->psy_tabname[i] to 
**	    the procedure name.  psy_kregproc needs it to construct the QP alias 
**	    to destroy the query plan.  Changed error reporting in drop_obj:
**	12-jan-93 (tam)
**	    remapped register/remove syntax errors (2036, 2763) to take care of 
**	    REGISTER PROECDURE.
**	13-jan-93 (andre)
**	    permit destruction of IIDEVICES when running UPGRADEDB with catalog
**	    update privilege
**      13-jan-1993 (stevet)
**          Add check to make sure second argument of string
**          functions: ascii(), text(), char(), varchar(), is a
**          constant integer.
**	11-feb-93 (andre)
**	    add support for referencing TID attribute of the underlying base
**	    table of updatable views through that view as long as it is
**	    referenced using [<schema>.]<table>.<column> construct
**	12-feb-93 (andre)
**	    select * from t1, t2,..., tn should return columns of t1 followed by
**	    columns of t2, ..., followed by columns of tn.  Unfortunately, we do
**	    not always end up doing it that way.  The problem is caused by the
**	    fact that range entries are entered in LRU order, but when we look
**	    for elements of the FROM-list, we scan the range entries in the
**	    order thay are in the array.
**	    To correct that, we must scan the first N entries (where N is the
**	    number of elements in the FROM list) in the LRU list backwards,
**	    which will ensure that we process columns of tables involved in the
**	    FROM-list in correct order (actually, we will use the map of
**	    relations involved in the current FROM-list along with $Yrng_vars
**	    structure and the fact that given two range entries R1 and R2 with
**	    range numbers N and N+i (i>0), respectively, we can guarantee that
**	    R1 was encountered before R2.)
**
**	    This will get more complicated as we try to deal with FROM-lists
**	    involving outer joins, but this will be dealt with for the next
**	    integration (along with adding SQL92-compliant support for NATURAL
**	    joins.)
**	25-jan-93 (rblumer)
**	    clear default text and node before parsing each column default;
**	    use pss_tchain2 for the default text, not pss_tchain;
**	    use UNKNOWN default id for calculated columns in views;
**	    change psl_do_insert to generate nodes for default columns, instead
**	    of postponing this to compile time(OPF);
**	    set up proc params that PSY will pass to RDF.
**	5-feb-1993 (markg)
**	    Fixed bug in permit handling for dbevents.
**	19-feb-93 (andre)
**	    added support for DROP SCHEMA;
**	    things are simplified by the fact that in 6.5 each user has exactly
**	    one schema and that schema has the same name as the user name (so in
**	    order to drop a schema, user name must be the same as the schema
**	    name.)
**  	22-Feb-1993 (fred)
**  	    Large object support for copy.  Changed the copy
**  	    production for "coent" from 
**  	    	name_or_sconst | NAME LPAREN... | NAME LPAREN...
**  	    to
**  	    	name_or_sconst | tname LPAREN... | tname LPAREN...
**  	    This allows for multi-word names (like "long varchar(0)").
**  	    Which now occur.
**	04-mar-93 (rblumer)
**	    change parameter to psf_adf_error to be psq_error, not psq_cb.
**	05-mar-93 (ralph)
**	    CREATE SCHEMA:
**	    Change interface to psl_ct22s_cons_allowed()
**	    DELIM_IDENT:
**	    Changed psl_idxlate() call to cui_idxlate()
**	    Translate nonkeyword output to lower case.
**	08-mar-93 (andre)
**	    if at server startup we were told to not flatten queries involving
**	    singleton subselects and a query involved a singleton subselect
**	    (either in the query itself or in a view used in the query), then we
**	    will tell OPF to not flatten the query
**
**	    if a user declared a cursor FOR UPDATE was specified (i.e. neither
**	    DIRECT nor DEFERRED was specified), then the cursor will be opened
**	    for DEFERRED UPDATE unless at server startup we were told that the
**	    default mode of updatable cursor is DIRECT.
**	09-mar-93 (andre)
**	    things are getting more interesting:
**		- we will allow a cursor to be declared
**		  FOR [DEFERRED|DIRECT] UPDATE without specifying the column
**		  list which will be identical to specifying a <column list>
**		  consisting of names of every column of the underlying table of
**		  the <query expression> contained in the <cursor specification>
**		- if a user declares a cursor which specifies none of ORDER BY,
**		  FOR READONLY, or for [DIRECT|DEFERRED] UPDATE, we will allow
**		  update of columns of the underlying table of the <query
**		  expression> contained in the <cursor declaration> providing
**		  that the <query expression> is updatable
**		- whe a user declares a cursor FOR ... UPDATE OF <column list>,
**		  we verify that he possesses UPDATE on column in the
**		  <column list> and report an error if he does not.  My
**		  undersdtanding of SQL92 suggests that this is not quite
**		  correct.  SQL92 requires that we verify that the user
**		  possesses UPDATE when trying to UPDATE a specific column, and
**		  not when declaring the cursor (this is especially relevant
**		  when the <cursor declaration> does not include a <column list>
**		  of columns which may be updated through the cursor.
**		  Accordingly, I will change the existing algorithm as follows:
**		    - at cursor declaration time, we will build a list of column
**		      for which the user possesses UPDATE privilege; even if a
**		      <cursor declaration> contains a <column list> of columns
**		      which may be updated through the cursor and the user does
**		      not possess UPDATE privilege on some column in that list,
**		      we will NOT flag it as an error.
**		    - at the time when we process UPDATE WHERE CURRENT OF ~Q,
**		      if the column being updated is not on the list of column
**		      for which the user possessed UPDATE privilege at the time
**		      the cursor declaration has been processed, we will attempt
**		      to recompute the map of attributes of the underlying table
**		      of the <query expression> on which the user possesses
**		      UPDATE privilege.  If, after the recomputation, we
**		      determine that the user still lacks UPDATE privilege on
**		      some column which he/she is trying to UPDATE, only then
**		      will we report an error.
**	11-mar-93 (andre)
**	    changed col_ref production to NOT use schema_spec non-terminal.
**	    Use of schema_spec production here resulted in 2 shift-reduce
**	    conflicts which made the grammar reject <column reference>s of form
**	    <schema>.<table>.<column>.  The reson is that upon seeing a
**	    generic_ident followed by a PERIOD, yacc has a choice between
**	    assuming that the generic_ident is a schema_spec (and reduce by
**	    schema_spec ::= generic_ident production) or a <table name> (and
**	    shift using col_ref ::= generic_ident PERIOD generic_ident
**	    production)  Unfortunately, in a 1-look ahead parser, this cannot be
**	    resolved.  The solution then, is to expand schema_spec non-terminal
**	    in-line and spare grammar the agony of deciding: to shift or not to
**	    shift
**	13-mar-93 (andre)
**	    added support for ALTER TABLE DROP CONSTRAINT
**	17-mar-93 (rblumer)
**	    change syntax error number 2004 (6.4) to 4113 (6.5). Since we use
**	    the same error message files for 6.4 and 6.5, we cannot change the
**	    6.4 error message text; so I have added a similar message for 4113.
**	    (this error message is for NOT NULL/NOT DEFAULT syntax).
**	25-mar-93 (andre)
**	    we will no longer restrict LHS of a LIKE predicate to be a simple
**	    <column reference> - any character-valued expression will be
**	    allowed; mercifully, this simply requires that we replace cname with
**	    element on the LHS of the LIKE-predicate productions
**	29-mar-93 (andre)
**	    CHECK constraint inside CREATE TABLE or ALTER TABLE may not contain
**	    a <dynamic parameter specification> (i.e. ?).  I will simply add
**	    PSQ_CREATE and PSQ_ALTERTABLE to the list of query modes in
**	    constant: QUESTIONMARK production
**	30-mar-93 (rblumer)
**	    change all create statements to NOT allow names beginning with '$',
**	    by setting PSS_NEW_OBJ_NAME bit in create productions and adding
**	    checks to several name/identifier productions;
**	    needed to split up productions for create view, synonym, and link;
**	    added PSL_IS_RESERVED_IDENT macro, and changed psl_reserved_ident
**	    to use PSS_NEW_OBJ_NAME to tell when to disallow '$'.
**	    In create_procedure, set PSS_SYSTEM_GENERATED during RECREATE, too.
**	    Handle schema.table.column correctly inside of CHECK constraint.
**	    Also got rid of a few compiler warnings about ST/MEmove calls.
**	05-mar-93 (anitap)
**	    Check if we are in CREATE SCHEMA for GRANT statement. If we are,
**	    set psy_cb->psy_flags to PSY_SCHEMA_MODE.
**	02-apr-93 (andre)
**	    remove call to psq_ccol() from cname: production.  It does not
**	    belong there for two reasons:
**		- by the time we know that psq_mode==PSQ_REPCURS, no columns 
**		  will be referenced since that happens after we see
**		  WHERE CURRENT OF
**		- columns referenced on the RHS of UPDATE do not necessarily
**		  have to be specified in the FOR UPDATE LIST (of course, given
**		  the first reason, the second reason is quite irrelevant)
**
**	    (fix for bugs 50823 & 50825)
**	    in UPDATE production, delay calling psl_curval() until AFTER we are
**	    done with psy_qrymod().  This way psy_view() will not have to deal
**	    with PST_CURVAL nodes.
**	04-apr-93 (rblumer)
**	    prevent NOT_DROPPABLE procedures and indexes from being dropped;
**	    prevent GRANT and REVOKE on system-generated procedures.
**	    added with_clauses parameter to psl_md3_modstorage and
**	    added cr_nm_eq_nm clause to MODIFY command;
**	    deleted 'default CASCADE' production for DROP CONSTRAINT.
**	12-apr-93 (rblumer)
**	    allow system-generated rules to be created on tables that the
**	    current user does not own.  This is necessary for REF constraints.
**	    Fixed problem with $-names in CREATE PROC (get error during SELECT)
**	    by resetting PSS_NEW_OBJ_NAME in cdbpdeclare, not cdbp_declare1;
**	    this only showed up during a RECREATE of the procedure.
**	    Fixed problem where CREATEDB couldn't create $ingres user--changed
**	    psl_reserved_ident to use new pss_cat_owner field.
**	    Fixed rule_scope error message-was truncating parameter to 3 chars.
**	    Moved checks for $-names from low-level obj_spec production to
**	    specific high-level create productions.
**	13-apr-93 (andre)
**	    a check in exdbp_name: production preventing execution of
**	    system-generated dbprocs was excessively restrictive.
**	    System-generated rules must be able to fire system-generated
**	    dbprocs and, even though there are no plans to do it now, I will
**	    make it possible for system-generated dbprocs to do it as well
**	10-mar-93 (barbara)
**	    Star support of delimited ids.  Interface changes (see list
**	    in pshparse.h)
**	23-apr-93 (rblumer)
**	    in psl_reserved_ident, change CREATE USER check to compare against
**	    pss_cat_owner, instead of DB_INGRES_NAME, in order to use correct
**	    upper or lower-case.
**	26-apr-93 (vijay)
**	    undef align_ptr before redefing it. Fussy AIX compiler. 
**	01-apr-93 (ralph)
**	    DELIM_IDENT: Various bug fixes, including:
**		Correct EXECUTE INTERNAL handling
**		Use pss_cat_owner instead of "$ingres" where appropriate
**		Change reference to pss_cb->pss_dbxlate to be ptr to u_i4
**		Ignore case when detecting object names that start with "ii"
**		Translate database and location names to lower case.
**		Introduce nonkey_or_sconst production.
**		Translate dbms type parameter on reg_dbms_or_struct_parm to
**		lower case.
**	12-apr-93 (tam)
**	    In exdbp_name: when parsing EXECUTE PROCEDURE in STAR, readjust 
**	    $Yscanbuf_ptr to take care of owner.procedure.
**	29-apr-93 (tam)
**	    In drop_obj: On DROP, DROP TABLE, DROP VIEW for STAR, disallow
**	    operation if the object being dropped is not created through STAR.
**	29-apr-93 (peterk)
**	    fix compile problem in psl_reserved_ident() per Barbara's
**	    suggestion. change . to -> (pss_cat_owner is a ptr)
**	02-may-93 (andre)
**	    when processing a CHECK constraint, we will postpone looking up
**	    attribute definitions and performing type resolution ONLY if CHECK
**	    constrasint was specified as a part of CREATE TABLE statement.
**	    If processing ALTER TABLE ADD ... CHECK (<condition>), all column
**	    names are known, so there is nothing to be gained from postponing it
**	    and then calling a recursive function to traverse the tree to look
**	    up column definitions and perform type resolution.
**
**	    When processing scalar functions found in CHECK constraints, delay
**	    type resolution if the constraint was specified as a part of CREATE
**	    TABLE statement, since in that case we wouldn't have looked up
**	    definitions of attributes and type resolution is very unlikely to
**	    succeed.
**	03-may-93 (andre)
**	    we must delay type resolution for OP nodes whenever we delay looking
**	    up description of attributes, i.e. when processing target list AND
**	    when processing CHECK constraint specified as a part of CREATE TABLE
**	    statement
**	03-may-93 (andre)
**	    in cname: production, if a column reference of form
**	    [schema.]table.column was specified, we need to remove elements of
**	    the chain containing <schema name> and "." (if schema name was
**	    specified) and overwrite table name with NEW.  Number of chain
**	    elements over which we need to backtrack to find one containing
**	    <table name> depends on whether <schema name> was specified.
**	04-may-93 (andre)
**	    combine code for dealing with PST_BOP and PST_UOP nodes in
**	    psl_p_telem() with semantic actions for scalar_function: production
**	06-may-93 (andre)
**	    if processing a CHECK constraint defined using ALTER TABLE
**	    statement, we will resolve references to columns immediately.  A map
**	    of referenced attributes will be maintained in $Ycheck_cons_cols.
**	    Once we finish processing a constraint definition and allocate a
**	    PSS_CONS structure describing the constraint, we will copy the
**	    map into memory pointed to by PSS_CONS.pss_check_cons_cols
**      06-may-93 (anitap)
**          Added support for "SET UPDATE_ROWCOUNT" statement.
**	18-may-93 (andre)
**	    if a user fails to supply correlation names for before and after
**	    image in CREATE RULE statement, we supply default names: "new" and
**	    "old".  This causes a problem is the database to which we are
**	    connected supports UPPER CASE regular identifiers (new.col1 gets
**	    translated to NEW.COL1 and NEW does not match "new".)  To correct
**	    this problem, default correlation names will be generated using
**	    a regular identifier case.
**	05-may-93 (barbara)
**	    For Star, fixed up setting of distr_sflags to record whether
**	    object name is single- or double-quoted.
**	21-may-1993 (rog)
**	    For union queries with parameters, if we have seen any parameters,
**	    don't try to resolve the union until after we substituted them in.
**	    (bug 47966)
**	26-may-93 (andre)
**	    strconst and strconst_e should be used only when we are 
**	    interested in the value of the string constant - and it had better
**	    be a string constant (which needs to be verified if the value was
**	    supplied inside a language variable (QDATA)).  
**
**	    References to str_hex_const_node_e will be replaced with references
**	    to constant.  Type resolution code will ensure that value of correct
**	    type is being supplied
**
**	    When calling qdata_cvt(), ensure that the output datatype agrees
**	    with input datatype as regards nullability
**
**	    FIX_ME: SQL92 allows <escape char> to be expressed as a <dynamic
**	    param>, but our current representation of LIKE predicate effectively
**	    precludes us from supporting it.  To fix this we can iether change
**	    representation of LIKE predicate (which sounds like a major
**	    headache) or build some structure describing <dynamic parameters>
**	    (i.e. what they are (e.g. ESCAPE_CHAR or MATCH_VALUE), etc.)
**	27-may-93 (rblumer)
**	    add check to psl_set_function to return an error if parsing a CHECK
**	    constraint, as aggregates are not allowed in a CHECK constraint.
**	    Modify psl_set_function to handle rest of aggregates, too.
**	    Also optimize ANY aggregate by ignoring value of distinct.
**	    In psl_p_telem, added a case for AND, OR, and NOT nodes, 
**	    now that this function is used for CHECK constraints, too.
**	27-may-93 (rblumer)
**	    Got rid of a bunch of UNIX compiler warnings (both acc & gcc).
**	28-may-93 (rblumer)
**	    Can now handle negative numbers as defaults (added subproduction to
**	    the def_value production to handle them).
**	04-jun-93 (barbara)
**	    Star DROP: Record for QEF whether or not name should be delimited
**	    on DROP statement to be sent to LDB.
**	17-jun-93 (andre)
**	    changed interface of psy_secaudit() to accept PSS_SESBLK
**	26-jun-93 (andre)
**	    if processing EXECUTE IMMEDIATE CREATE RULE and the statement has
**	    been sent to us by QEF, check whether PST_CASCADED_CHECK_OPTION_RULE
**	    was set in PST_INFO.pst_execflags and, if so, set
**	    DBR_F_CASCADED_CHECK_OPTION_RULE in DB_IIRULE.dbr_flags to indicate
**	    that this rule was created to enforce CASCADED CHECK OPTION.
**	28-jun-93 (tam)
**	    In set_sess_auth_id: enable SET SESSION AUTHORIZATION statement 
**	    for star.  Star will only change the user authorization id of the 
**	    star level control blocks (inside SCF).  This is deemed sufficient 
**	    to handle the need for unloaddb/reloaddb, which is the requirement 
**	    for this change. The user id for the local connections for this 
**	    star session is not changed.  To reset those local authorizations, 
**	    the user has to do it through DIRECT CONNECT or DIRECT EXECUTE 
**	    IMMEDIATE. The general issue of star/local access control will be 
**	    addressed subsequent to 6.5.
**	30-jun-93 (shailaja)
**	    Fixed compiler warnings.
**	02-jul-93 (rblumer)
**	    Added sess_cb & dbpinfo parameters to psl_ct18s_type_qual function.
**	06-jul-93 (anitap)
**	    CHANGED was a keyword for SET UPDATE_ROWCOUNT statement. Removed
**	    the keyword. Added error message for syntax error.
**	    Changed SET UPDATE_ROWCOUNT TO CHANGED/QUALIFIED to SET UPDATE_
**	    ROWCOUNT CHANGED/QUALIFIED according to LRC recommendation.
**	07-Jul-93 (daveb)
**	    Removed FUNC_EXTERN of EXsetup.  It is (and should be) in <ex.h>
**	    Removed FUNC_EXTERN of scf_call.  It is (and should be) in <scf.h>
**	07-jul-93 (rickh)
**	    Prototyped qef_call invocations.
**	10-jul-93 (andre)
**	    a wrong parameter was passed to pst_union_resolve() in
**	    cursor_open_dsql production.  Address of the cursor block was being
**	    passed instead of the root node of the query tree.  Guess our tests
**	    do not include dynamic cursors for UNION-selects
**      12-Jul-1993 (fred)
**          Changed lots of places so that users cannot directly muck
**          with extension tables.  These are now treated basically
**          the same as core system catalogs for permission purposes.
**	14-jul-93 (ed)
**	    replacing <dbms.h> by <gl.h> <sl.h> <iicommon.h> <dbdbms.h>
**	16-jul-93 (rblumer)
**	    Cleaned up code for objects beginning with "ii":
**	      --made synonyms only allow "ii" names if the user is $ingres,
**	      just like rules and procedures (change actually in pslctbl.c);
**	      [dbevents still allow 'ii' names, for backward compatibility]
**	      --removed Star-only code (from viewclause production) that changed
**	      owner-name to $ingres for "ii" views; that is now done for both
**	      local and star objects in the crname production.
**	26-jul-1993 (rmuth)
**	    Support more WITH options for the COPY command. Add the
**	    "with_clauses" parameter to psl_cp1_copy, psl_cp2_copstmnt and 
**	    psl_cp11_nm_eq_no.
**	27-jul-93 (ralph)
**	    DELIM_IDENT:
**	    Call cui_idxlate() to normalize/translate the cursor name on
**	    OPEN statements under the curop_ini_1 and curop_ini_2 productions.
**	    Lower case nonkeywords specified in the cr_lst_elem production.
**	10-aug-93 (rblumer)
**	    change col_constraint2 production to have allow a referential
**	    constraint with no column specified, per ANSI syntax.
**	    Also cast args to rdf_call and removed some unused variables.
**	10-aug-93 (andre)
**	    fixed causes of compiler warnings
**	12-aug-93 (andre)
**	    replace TABLES_TO_CHECK() with PSS_USRTBL|PSS_DBATBL|PSS_INGTBL,
**	    DBPROCS_TO_CHECK() with PSS_USRDBP|PSS_DBADBP|PSS_INGDBP and
**	    DBEVENTS_TO_CHECK() with PSS_USREVENT|PSS_DBAEVENT|PSS_INGEVENT
**	    These macros were being used because long time ago we made an
**	    assumption that 3-tier name space will not be used when processing 
**	    SQL queries while running in FIPS mode.  That assumption proved to 
**	    be incorrect and there is no longer a need to use these macros
**	16-aug-93 (andre)
**	    in a number of cases name_or_sconst was used where nonkey_or_sconst
**	    was really more appropriate.  
**	17-aug-93 (andre)
**	    made changes to ensure that names of schemas, objects, users, and
**	    columns specified in GRANT statement are represented by the same 
** 	    type of identifier (regular or delimited) in IIQRYTEXT as was 
**	    specified by the user
**
**	    PSS_OBJ_NAME.pss_qualified has been replaced with 
**	    PSS_OBJSPEC_EXPL_SCHEMA defined over PSS_OBJ_NAME.pss_objspec_flags
**	    PSS_OBJ_NAME.pss_sess_table has been replaced with
**	    PSS_OBJSPEC_SESS_SCHEMA defined over PSS_OBJ_NAME.pss_objspec_flags
**	18-aug-93 (stephenb)
**	    added accessmask |= SXF_A_INDEX in call to psy_secaudit() when 
**	    auditing drop index.
**	23-aug-1993 (rmuth)
**	    READONLY table : Disallow a user dropping this object.
**	1-sep-93 (stephenb)
**	    added calls to psy_secaudit() on failure to add comment to a table
**	    this action must be written to the security audit log.
**	01-sep-93 (andre)
**	    if parsing a new dbproc or reparsing a dbproc which is neither 
**	    marked as active nor as having an independent object/privilege list
**	    associated with it, we need to try to determine id of some base 
**	    table (other than a core catalog) used in the dbproc (either 
**	    directly or through a view).  In order to tell psy_view() to look
**	    for underlying base table id, we will intialize cb->pss_dbp_ubt_id 
**	    in cdbp_procname: production
**	02-sep-1993 (barbara)
**	    1. Star bug 54468: Copy owner and table name into DMT_CB on
**	       SET STATS.  Needed for QEF to issue SQL update of table_stats
**	       column.
**	    2. Star delimited ids: To decide whether or not to delimit, Star now
**	       relies on the presence of the LDB's DB_DELIMITED_CASE capability
**	       instead of its OPEN/SQL_LEVEL.
**	15-sep-93 (swm)
**	    Moved cs.h include above other header files which need its
**	    definition of CS_SID.
**	15-sep-93 (rblumer)
**	    return error for CREATE LINK and distribute REGISTER INDEX if not
**	    in a Star session.  Otherwise get a segv in later Star processing.
**	13-sep-1993 (dianeh)
**	    Removed NO_OPTIM setting for obsolete ports (sun_u42, hp9_mpe, and)
**	    ds3_ulx).
**	20-sep-1993 (rog)
**	    The fix for 47966 introduced a bug: we stopped calling
**	    pst_union_resolve() if cb->pss_highparm != -1 in all cases when
**	    we really only wanted to do this if we were processing dynamic SQL.
**	    (bug 54164)
**	24-sep-93 (andre)
**	    (fix for bug 54500)
**	    pass to psl_ct2s_crt_tbl_as_select() $Yqry_mask so that it may 
**	    decide whether to set PST_NO_FLATTEN and/or PST_CORR_AGGR bits in 
**	    pst_mask1 field of the query tree header
**	30-sep-93 (stephenb)
**	    CREATE/DROP INTEGRITY is an auditable event, added calls to
**	    psy_secaudit() to audit failed attempt to do so.
**	1-oct-93 (stephenb)
**	    CREATE PROCEDURE is audited as a table event, changed it to
**	    a procedure event.
**	01-sep-93 (jhahn)
**	    Added support for multiple query plans for set input procedures.
**	23-sep-1993 (rblumer)
**	    B51992: split up production for create synonym, so that we can
**	    reset PSS_NEW_OBJ_NAME before we process the table name;
**	    otherwise don't get error if use session.<table> for table name.
**	24-sep-93 (rblumer)
**	    we were only catching $ column names in CREATE TABLE for the first
**	    column name.  Due to moving around of productions for Star,
**	    PSS_NEW_OBJ_NAME was getting cleared at the wrong time
**	    (in tbl_elem), so I removed that line, and just to be sure,
**	    added a reserved_ident call with force_check = TRUE.
**	    Also added create_schema as a valid execute-immediate statement.
**	    Also added code to the cons_col production to record whether column
**	    was specified as a regular identifier.
**      05-oct-93 (anitap)
**	    Added support for STAR for "SET UPDATE_ROWCOUNT" statement. Also
**	    added execute immediate support for the above statement.
**	    Fixed compiler errors.
**	07-oct-1993 (barbara)
**	    For Star, support SET LOCKMODE SESSION ... for flavors in addition
**	    to the already-supported TIMEOUT flavor (bug 53492).
**	07-oct-93 (swm)
**	    Bug #56437
**	    Added PTR cast in assignments to dmc_cb->dmc_id. Removed PTR
**	    casts of CS_SIDs.
**	08-oct-93 (rblumer)
**	    add trace point PS251, to return an error when single-quoted
**	    identifiers are used as usernames in the user_ident production.
**	    Also return error when have delimited ID in cr_lst_elem production
**	    & are in a COMPRESSION or LOCATION clause (i.e. not a KEY clause).
**	09-oct-93 (swm)
**	    Bug #56437
**	    Put pss_sessid into new dmc_session_id rather than dmc_id.
**	10-oct-93 (tam)
**	    (b54417) In cr_tb_eq_id, if the table name is PSS_ID_SCONST,
**	    set quoted_value flag so that the table name will be quoted in
**	    the query to the local server.
**	11-oct-1993 (tad)
**	    Bug #56449
**	    Changed %x to %p for pointer values.
**	11-oct-93 (swm)
**	    Bug #56448
**	    Made psf_display() portable. The old psf_display() took a variable
**	    number of variable-sized arguments. It could not be re-written as
**	    a varargs function as this practice is outlawed in main line code.
**	    The problem was solved by invoking a varargs function, TRformat,
**	    directly.
**	    The psf_display() function has now been deleted, but for flexibilty
**	    psf_display has been #defined to TRformat to accomodate future
**	    change.
**	    All calls to psf_display() changed to pass additional arguments
**	    required by TRformat:
**	        psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1, ...)
**	    this emulates the behaviour of the old psf_display() except that
**	    the trbuf must be supplied.
**	13-oct-93 (andre)
**	    fix for bugs 50083 and 54384
**
**	    These bugs were caused by the fact that in the course of processing
**	    SELECT, CREATE TABLE/VIEW AS SELECT, DGTT AS SELECT, no attempt was
**	    made to verify that the width of the tuple represented by the 
**	    target list of the outermost <SUBSELECT> did not exceed the current
**	    maximum of 2008.  Furthermore, for CREATE TABLE/VIEW AS SELECT and
**	    DGTT AS SELECT we were not verifying that the number of columns of
**	    the table/view being created did not exceed 300 (if the number were
**	    greater than 301, they would get caught by an obscure check in 
**	    pst_adresdom(), but one can specify a view/table with 301 columns 
**	    which would get by that check only to blow up with unfriendly 
**	    messages in QEF and OPF, respectively.
**
** 	    These bugs will be corrected as follows:
**	      - in newcolspec production, we will check whether the number of 
**		columns exceeds DB_MAX_COLS, and if so, issue an error message
**	      - in subselect production, if the subselect is the outermost one
**		and we are processing one of SELECT, CREATE TABLE/VIEW AS 
**		SELECT, or DGTT AS SELECT, we will compute number of attributes
**		and the width of the tuple represented by the target list and if
**		they fall outside of existing limits, appropriate error message 
**		will be issued
**	15-oct-93 (andre)
**	    AS is optional in <expr> [AS] <column spec> (in target_spec).  
**	    Replaced AS with optional_as non-terminal
**	03-nov-93 (andre)
**	    if in the course of parsing a GRANT or REVOKE statement, we 
**	    encounter a reference to a non-existant object owned by another 
**	    user, rather than telling the user that the object does not exist 
**	    (and thus disclosing information to which he should not be privy), 
**	    we will issue a more generic message saying that the object does 
**	    not exist OR the user lacks required privileges on it - this way 
**	    the message issued for a non-existent object will be the same as 
**	    that issued for an object on which the user possesses not a single 
**	    privilege which appears to be the intent of SQL92
**
**	    If in the course of parsing a GRANT statement which was issued 
**	    inside CREATE SCHEMA statement we come across a non-existent object,
**	    we will return E_DB_ERROR which will result in rollback of CREATE 
**	    SCHEMA statement.  Again, this is in line with SQL92.
**	15-nov-93 (andre)
**	    added code to init pss_flattening_flags to 0 in cdbp_stmt production
**
**	    moved PSS_SINGLETON_SUBSELECT from cb->pss_stmt_flags to 
**	    cb->pss_flattening_flags
**
**	    moved PSS_SUBSEL_IN_OR_TREE, PSS_ALL_IN_TREE, PSS_MULT_CORR_ATTRS,
**	    and PSS_CORR_AGGR from PSS_YYVARS.qry_mask to 
**	    cb->pss_flattening_flags
**	17-nov-93 (andre)
**	    PST_CORR_AGGR already gets set if a query involves correlated 
**	    aggregates.  Now we will add queries containing 
**		correlated NOT EXISTS, NOT IN, != ALL, and
**	    	<expr> != ALL (select ...) with  <expr> containing an attribute 
**	    	reference
**	    to the list of queries for which PST_CORR_AGGR will be set
**	18-nov-93 (andre)
**	    moved code responsible for setting (if appropriate) PST_NO_FLATTEN
**	    and PST_CORR_AGGR bits in header->pst_mask1 to pst_header().
**	22-oct-93 (rblumer)
**	    added psl_fill_proc_param call in create_procedure production, in
**	    order to store procedure parameters in the catalogs for normal
**	    procedures (not just set-input procedures); changed existing call
**	    to add new parameters.  Set new procparmno variable appropriately.
**	    Also, the setparm* variables are now in DBPINFO, not in session cb.
**	27-oct-93 (rblumer)
**	    changed new 6.5 commands to return errors for single-quoted user
**	    names (includes COMMENT, CREATE/ALTER/DROP USER, CREATE SYNONYM,
**	    and REF constraints).
**	    Also changed single-quoted user names for 6.4 commands to be
**	    replaced by delimited names in stored query text;
**	    added psl_remove_single_quotes function for this purpose, and
**	    changed user_ident production to call it when PSS_TXTEMIT is on.
**	29-oct-93 (rblumer)
**	    B56231: usernames added to PROCEDURE text were not delimited even
**	    when they were delimited identifiers.  This would cause syntax
**	    errors whenever the procedure needed to be REcreated.
**	    Changed the code adding the username to convert it to a delimited
**	    identifier before adding it to the text chain.  This is done for
**	    ALL usernames, not just ones that need to be delimited.  Since the
**	    username is already case-translated when we get it, and
**	    DELIM_ID_CASE has to be either be mixed (untranslated) or the same
**	    as REG_ID_CASE, this will never cause case-translation problems
**	    when recreating the procedure.
**	    Also fixes the same problem for views (occurs in UNLOADDB scripts).
**	    Moved code for adding the above username into a new function,
**	    psl_prepend_schemaname, and changed grammar to call it.
**	05-nov-93 (barbara)
**	    For Star DROP, when comparing table-name prefix to "ii", do it in
**	    a case insensitive way (bug 56567).
**	12-nov-93 (stephenb)
**	    add calls to psysecadit() to audit failure to perform the following
**	    SAVE <table>, DROP PERMIT ON DBEVENT, DROP PERMIT ON PROCEDURE,
**	    DROP DBEVENT, DROP PROCEDURE, DROP RULE.
**	18-nov-93 (stephenb)
**	    Include psyaudit.h for prototyping, and then eliminate prototyping
**	    errors. Alter auditing for table type objects so that we only
**	    audit when the user has fully specified the objectname.
**	24-nov-93 (robf)
**          Security alarm enhancments for Secure 2.0:
**	    - May be created on Group and Role as well as User & Public
**	    - May be named
**	    - May be created on DATABASE and CURRENT INSTALLATION
**	    - May have an optional DBEVENT associated with them.
**	29-nov-93 (robf)
**          QUERY_SYSCAT database privilege changed to SELECT_SYSCAT per
**	    LRC decision.
**	29-nov-93 (rblumer)
**	    Added comment pointing out use of tstream in psl_fill_proc_params.
**	16-dec-93 (rblumer)
**	    Changed permtelm production to allow delimited identifiers [b58022]
**	    (by changing it to use generic_ident token instead of NAME token).
**	    Changed cr_tbl_with_clause to return syntax error after parsing 
**	    WITH instead of after parsing whole WITH clause.
**	31-dec-93 (andre)
**	    fix for bug 57384:
**	    if the cursor is being opened without specifying FOR READONLY, 
**	    ORDER BY, or FOR UPDATE, we may still allow user to perform updated
**	    through it - however, it is wrong for PSF to tell OPC that the 
**	    cursor will be used for DEFERRED update since this will break lots 
**	    of existing applications + if the user intended to do DEFERRED 
**	    update, it is not unreasonable to expect him to say 
**	    FOR [DEFERRED] UPDATE
**	03-jan-94 (rblumer)
**	    Changed cr_lst_elem production to print out error 2022 correctly
**	    (by calling psf_error directly instead of psl_sx_error).
**	    Changed modopt_lst_elem production to use nonkeyword prod
**	    instead of NAME, so that the names get lower-cased correctly.
**	    Changed index_lst_elem production to use generic_ident instead of
**	    nonkeyword because the KEY option should allow delimited ids;
**	    then had to add code to disallow delimited ids for LOCATION option,
**	    and to lower-case nonkeywords (as in cr_lst_elem production).
**	04-jan-94 (rblumer)
**	    B58442: Disabled generation of dummy NOT NULL constraints in the
**	    null_constraint production; added trace point PS176, which enables
**	    generation if desired.
**	08-jan-94 (andre)
**	    added support for WITH NOJOURNAL_CHECK clause in ALTER TABLE ADD 
**	    statement
**	09-jan-94 (andre)
**	    make changes to prevent a user from altering journaling status of
**	    a table involved in a REFERENCES constraint
**
**	    if a rule definition involved name of a synonym, replace the name 
**	    of a synonym with the real object name in the text stored for rules
**
**	    restrict dbproc parameter/variable type/default declarations to 
**	    those allowed in 6.4 minus SYSTEM_MAINTAINED
**	10-jan-94 (andre)
**	    (fix for bug 58020)
**	    if provided, nullability/defaultability specification for a dbproc
**	    parameter or variable must be one of:
**		WITH NULL
**		NOT NULL
**		NOT NULL WITH DEFAULT
**		NOT NULL NOT DEFAULT
**	10-jan-94 (rblumer)
**	    B56551: compressed structure names were not allowed in 'set
**	    result_structure' command because string compares were being done
**	    against the wrong variable ($2).  Changed it to the right one (ch).
**	10-jan-94 (rblumer)
**	    --B58747: changed CREATE DBEVENT to delimit event name in query
**	    text if the user delimited it.
**	    --B58749: will now add procedure owner to query text that contains
**	    an unqualified procedure name in an execute procedure statement,
**	    by calling psl_prepend_schemaname in exdbp_name production
**	    (should only affect query text for CREATE PROCEDURE & CREATE RULE).
**	    --B58794: will now add dbevent owner to query text that contains
**	    an unqualified dbevent name in an execute procedure statement.
**	    (added in event_name production, for RAISE,REGISTER,REMOVE DBEVENT).
**	12-jan-94 (rickh)
**	    De-supported NATURAL joins until we implement ANSI semantics.
**	13-jan-94 (andre)
**	    as a part of fix for bug 58048, if recreating a dbproc, the QP 
**	    object lookup will occur in psq_recreate() which will prevent 
**	    multiple sesssions from recreating the same dbproc at the same 
**	    time, which means that we need not (and must not) perform that 
**	    lookup in create_dbproc: production.  psq_recreate() will ensure 
**	    that psq_cb->psq_cursid contains the QP object's BE id
**	25-jan-94 (andre)
**	    (fix for bug 54990)
**	    PSS_MULT_CORR_ATTRS may also be set if a tree rooted in NOT IN or 
**	    != ALL involved multiple correlated references.  Furthermore, if
**	    looking for multiple correlated references while processing a NOT IN
**	    or != ALL predicate, we will consider variables referenced in the 
**	    predicate's left subtree when deciding whether a query involves 
** 	    multiple correlated references.  
**	02-feb-94 (vijay)
**	    Cast ID to PTR for qsf_owner.
**	14-feb-94  (robf)
**          Removed check which disallowed SET SESSION in STAR. Some clauses
**	    are now allowed, so we check directly each part of the statement.
**	22-feb-94 (robf)
**          Added SET ROLE per ANSI/ISO SQL-3
**	28-feb-94 (robf)
**          Initialize pst_dmuflags in all cases.
**	09-mar-94 (andre)
**	    fix for bug 60413:
**	    if after processing the list of objects specified in GRANT/REVOKE 
**	    statement we conclude that the speciifed privileges will not be 
**	    granted/revoked on ANY of the named objects (e.g. because none of 
**	    them exist), we will return an error status rather than continuing 
**	    on to psy_dgrant() or psy_revoke().
**      14-mar-94 (andre)
**          after calling pst_union_resolve() when processing a UNION SELECT w/o
**          dynamic parameters, we go through an extra step to propagate type
**          information from the RESDOM nodes of the first element of UNION to
**          the subsequent ones.  This is necessary because after resolving
**          RESDOM in the 1-st element with corresponding RESDOM in the (N-k)-th
**          element, we may discover that type of RESDOM in the 1-st element
**          needs to be changed as an effect of type of the corresponding RESDOM
**          node in the N-th element.  Obviously, this means that type info
**          contained in RESDOM nodes in elements #2-#(N-1) will be incorrect.
**          Unfortunately, when processing opening of a dynamic cursor with
**          parameters whose <query expression> involved UNION, we were
**          neglecting to perform that last step (i.e. copying type info from
**          RESDOMs of the first element to RESDOMs of subsequent elements.)
**          It seems like a sensible solution to move code performing that last
**          step from query_expr: production into pst_union_resolve().
**	15-mar-94 (andre)
**	    removed code setting PSS_DSQL_QUERY when processing DSQL queries
**      17-mar-1994 (pearl)
**          Bug 58955.  'set trace [terminal | output | input]' does not notify
**          user if it cannot open the file or tty specified by the user.
**          To correct this situation, check the return from TRset_file() if
**          a tty or file is being opened.  If an error is encountered,
**          write error E_US1764_5988 to the session, but don't log it in
**          the errlog.
**	17-mar-94 (andre)
**	    made changes to support shareable repeat cursors:
**	      -	reordered curop_ini_2 production (moved QUERYID to the 4-th
**	        position to match code produced by ESQLC (this may need to be
**	        undone)
**	      - if processing DEFINE CURSOR FOR REPEATED SELECT and a cursor
**	        block describing this cursor already exists, we should complain
**		only if it is marked as opened; otherwise, we will call
**		psq_crcreate() which will attempt to reuse existing block;
**		such sutuation may arise if it should become necessary to
**		reparse definition of a repeat cursor if its QP got flushed out
**		of QSF
**	      - added code to cursor_open: production so that if processing a
**	        definition of shareable repeated cursor, we invoke
**		psl_repeat_qry_id() to determine whether there is already a QP
**		for this cursor + we must insist that the cursor be opened
**		FOR READONLY
**	17-mar-94 (andre)
**	    A bit of unfinished business:  we need to check for illegal use of
**	    VLUPs in the <query expression> of repeat cursors
**	17-mar-94 (andre)
**	    repeat cursors will be allowed only if the user set trace point
**	    ps151
**	21-mar-94 (robf)
**          Blank pad full password in SET ROLE to ensure comparison is
**	    consistent.
**	31-mar-94 (rblumer)
**	    B61181 - ALTER TABLE allows single-quoted schema name, but it
**	      shouldn't (added it to list of non-allowed stmts in user_ident).
**	    B57856 - PREPARE doesn't allow delimited statement name, but it
**	      should (changed NAME to generic_ident in prepare production).
**	19-apr-94 (robf)
**          in USER/ROLE/PROFILE WITH-clause processing handle WITH GROUP
**	    consistently with other WITH xxx=clauses (pass to psl_us2_with...)
**	    Also allow delimited identifiers for group and profile names 
**	    in the same clauses.
**	25-apr-94 (robf)
**          Tighten up error handling for GRANT/REVOKE dbpriv/role,
**	    catch combos like GRANT QUERY_IO_LIMIT 30 TO PUBLIC and
**	    issue better message.
**	28-apr-94 (andre)
**	    fix for bug 61048
**	    When we process a dynamic SELECT, we record number of joins in the 
**	    query in pst_numjoins inside the query tree header.  Having called 
**	    pst_execute() to get a copy of a query tree for a prepared SELECT 
**	    (as a part of declaring a dynamic cursor), we need to copy 
**	    tree->pst_numjoins into $Yjoin_id to avoid having psl_crsopen() 
**	    overwrite tree->pst_numjoins with 0 which would be otherwise found 
**	    in $Yjoin_id
**	9-may-94 (robf)
**          Remove extra close comment above, caused compile errors.
**	23-may-94 (robf)
**          Add checks for security catalogs when determining updatability,
**	    this catches early direct attempts to change security catalogs
**	    which may only be updated by security sessions.
**	    Also security audit failed updates due to lack of update_syscat
**	    or security privilege and fire appropriate security alarms.
**	27-jun-94 (robf)
**          Bug 64493: Bad GRANT/REVOKE which mixed dbpriv and table syntax
**	    could issue error E_US100D/E_US100E twice. 
**      1-july-94 (abowler)
**			Cross Integration from 6.4 to 1.1 (ramra01)
**          Fix for bug 64341
**          Where we have a prepare for statements of the form 'insert into
**          ... select ? from x where col1 != ?' we allow the datatype of the
**          placemarker to be taken from the known column type. Otherwise we
**          end up trying to coerce against datatype 0 (unknown).
**      19-dec-94 (sarjo01) from 15-Sep-94 (johna)
**          initialize dmt_mustlock (added by markm while fixing bug (58681)
**      20-nov-1994 (andyw)
**          Added NO_OPTIM due to Solaris 2.4/Compiler 3.00 errors
**	23-nov-94 (rudtr01)
**	    modified keywd and copyfile productions to translate the 
**	    query text properly (STAR) when the filename is passed
**	    as QDATA (~V).
**       1-dec-1994 (inkdo01)
**          Propagated Fred's Feb 22-1993 change to the declaration of 
**          procedure parameters, so that multi-word data types can 
**          include specific length declarations.
**      20-dec-94 (canor01)
**          Add NO_OPTIM for rs4_us5.
**	29-dec-94 (wilri01)
**	    Changed text of E_PS03A2_MISSING_JQUAL:SS42000_SYN_OR_ACCESS_ERR to
**	    remove reference to NATURAL JOIN, which was not implemented.
**      05-jan-95 (newca01)
**          Allow use of SET SESSION AUTHORIZATION in STAR.  This reinstates
**          change 403151, which was removed when change 414242 was 
**          integrated.  The Unloaddb/reloaddb functions will not work for
**          STAR without change 403151.
**      05-feb-95 (carly01)
**		Fixed parse bug in ALTER USER WITH PRIVILEGES=(,),NODEFAULT_
**		PRIVILEGES (b66257).
**      18-Jan-95 (liibi01)
**          Fix bug 66217 and various inconsistency for the grammer of 
**          'ALTER USER' statement. Commands like 'ALTER USER [username]\g'
**          now will be rejected due to syntax error, which previously can 
**          be allowed by the grammer.
**	09-feb-95 (cohmi01)
**	    For RAW I/O, support locname:extent_name in create, modify, index.
**      07-mar-95 (newca01)
**          Added code in INSERT INTO to change value for "NULL" on 
**          long varchar field.
**      22-Mar-95 (liibi01)
**          Notice: the grammer of 'ALTER USER' has changed again. Before
**          ingres is the default user if user name is not specified in 
**          ALTER USER statement, now user name is a mandatory entry. Also  
**          fix bug 67621, 'Alter user with password = whatever' will change
**          every user with the new password.
**      23-mar-95 (harpa06)
**	    Bug #67655 - When incorrect syntax for 'revoke all on database
**	    <database name> from public <some trash>' is given, the syntax
**	    for GRANT is given to the user instead of the correct REVOKE syntax.
**	23-mar-95 (peeje01)
**	    Cross integration of double byte changes from 6500db_su4_us42:
**	    10-Mar-94 (twai)
**	        Split the declaration char *ch2 = ch1 + CMbytecnt(ch1) into two 
**	        statement, and CMbytecnt(".") to 1 as both of cannot be
**		determine until runtime.
**	    See the definition of CMbytecnt
**      13-apr-95 (sarjo01)
**          Bug 64311: at cdbp_procname:, test for ident case treatment
**          before storing iierrornumber and iirowcount in variables
**          symbol table.
**      14-apr-95 (wolf)
**          Fix a typo in one of the doublebyte ifndef's
**      14-apr-95 (dilma04) 
**          Add support for the SQL-92 <set transaction statement>.
**	12-may-1995 (shero03)
**	    Add support for RTREE in Create Index
**	17-may-95 (dilma04)
**	    Add table status checks and error handling when attempting to
**	    perform INSERT, DELETE and UPDATE against a READONLY table.
**      1-june-1995 (hanch04)
**          Removed NO_OPTIM su4_us5, installed sun patch
**	22-sep-95 (harpa06)
**	    Bug #68171: Block CREATE/DROP DBEVENT and RAISE ERROR from being 
**	    executed when the user is using a STAR database since these are not
**	    yet supported as of this date.
**	03-nov-95 (pchang)
**	    Database and location name should always be in lowercase in order 
**	    for them to be case insensitive.  However, they get converted to
**	    uppercase on ISO/ANSI SQL-92 compliant installation, where the 
**	    scanner translates all names to uppercase.  Hence, we revert that 
**	    in db_loc_obj (B71356).
**      28-nov-95 (stial01)
**          Added WITH xa_xid clause to COMMIT,ROLLBACK. This clause is also
**          supported in SET SESSION  via changes to psluser.c
**          Also added xaprepare production.
**      22-jan-95 (stial01)
**          commit production: Moved the pst_commit_dsql() call to the 
**          original commit production as it was before the XA changes.
**          This cannot be done in the XA case until we get to the sequencer
**          and find the correct scb. Note that scs_sequencer() calls
**          psf_call(PSQ_COMMIT) which calls pst_commit_dsql(). The 
**          call to pst_commit_dsql() in the commit production seems to be
**          redundant, but I don't want to change it.
**      24-jan-1996 (angusm)
**          auth_ident rule (Identifiers for authorisations) (GRANT)
**          should accept SCONSTs i.e. single-quote delimited strings,
**          for backward compatibility with 6.4 (bug 73943)
**	05-Feb-1996 (allmi01)
**	    Added dgi_us5 to NO_OPTIM string to corrected SQL92 
**	    related problems.
**      21-Feb-1996 (mckba01)
**	    Fix for #66715, Changes to cdbp_whilestmt: and psl_backpatch.
**	    An ENDLOOP immediately after a WHILE statement must now generate 
**	    a ENDLOOP statement.  This must then be used by psl_backpatch
**	    to link up WHILE.pst_next before proceeding down the true branch.
**	22-Feb-1996 (allmi01)	
**	    Added dgi_us5 to NO_OPTIM to fix sql92 problems
**	4-mar-1996 (angusm)
**  	    If repeat qry contains global temp tables, include the unique
**	    session id so that other sessions executing this query are not
**	    bound to the same global temporary (bug 74863)
**      06-mar-1996 (nanpr01)
**          To support increased tuple length. Donot check the length
**	    in parser. Leave it upto the other layers like OPF/QEF and DMF.
**      18-mar-1996 (angusm)
**          If repeat qry contains global temp tables, include the unique
**          session id so that other sessions executing this query are not
**          bound to the same global temporary (bug 74863)
**	11-june-1996(angusm)
**	    Flag DECLARE GLOBAL TEMPORARY TABLE so scanner can interpret
**	    comma in spec of DECIMAL column correctly if 
**	    II_DECIMAL="," (bug 76902)
**	26-jun-96 (nick)
**	    Permit use of 'save <tab> until ...' on iiqeflist tables used
**	    by VERIFYDB. #73248
**	    Remove unused rule usr_adp_spec1 - it was never reduced.
**	30-oct-1996 (prida01)
**	    If there are views in the range table save them in the pss_viewrng
**	    table and reuse this range table for each open.
**	28-jan-1997(angusm)
**	    Bug 40477: invalidate RDF cache for table after SAVE
**	3-jul-96 (inkdo01)
**	    Added support for infix use of predicate functions in boolean
**	    expressions.
**      23-jul-1996 (ramra01 for bryanp)
**          Add support for ALTER TABLE ADD COLUMN and DROP COLUMN.
**          Added new reserved word "COLUMN"
**	28-oct-1996 (hanch04)
**	    Changed E_PS0572_CANT_DROP_INGRES_SCHEMA to 
**	    E_PS0572_CANT_DROP_SYSCAT_SCHEMA
**	17-dec-96 (inkdo01)
**	    Moved detection of error 3857 (alter table add column consistency
**	    check) into psl_ct14_typedesc. Also added error 0472 to psl_p_telem
**	    for faulty check constraints in alter table add column statements.
**	27-Feb-1997 (jenjo02)
**	    Extended <set transaction statement> to include <transaction 
**	    access mode> (READ ONLY | READ WRITE) per SQL-92.
**	25-Mar-1997 (jenjo02)
**	    Table priority project:
**	    Use psl_nm_eq_no for production of MODIFY table TO priority = 
**	    <table_priority>
**	28-may-1997 (nanpr01)
**	    bug 79275 : create/alter user is accepting blank/null
**	    as group name.
**	19-jun-97 (hayke02)
**	    Location names should always be in lowercase in order for them 
**	    to be case insensitive. However, they get converted to uppercase
**	    on ISO/ANSI SQL-92 compliant installations, where the scanner
**	    translates all names to uppercase. For 'set work locations ...
**	    (sw_locname COMMA sw_loclist)' sw_locname (db_loc_name) is now
**	    set to lowercase for ISO/ANSI SQL-92. This change fixes bug 82756.
**	24-jun-1997(angusm)
**	    Flag up cross-table updates so we can do the right thing
**	    later on (bugs 77040, 79623, 80750)
**	23-jun-97 (nanpr01)
**	    Fixup the error parameters.
**	30-jun-97 (nanpr01)
**	    Fix typo. Also fix bug 83315 which causes create user message to
**	    be displayed instead of ALTER USER.
**	21-jul-97 (inkdo01)
**	    Changed CREATE TABLE ... AS SELECT to permit parameter markers (?)
**	    in WHERE of PREPAREd statement.
**	21-jul-97 (inkdo01)
**	    Added SET [NO]FLATTEN to permit changing subselect flattening 
**	    without needing trace point privileges (as with op132)
**	27-aug-1997 (i4jo01)
**	    Make note of INSERT...SELECT so we can bypass select tuple width
**	    check later on. (resdoms of insert columns truncates to the
**	    correct size). 
**	24-sep-1997 (sarjo01)
**	    Bugs 84044, 85255: In psl_p_tlist(), force nullability of resdom
**	    nodes that are columns of inner tables of outer joins. Involves
**	    adding argument to psl_p_telem().
**	26-sep-97 (inkdo01)
**	    Changed outer join syntax to support LEFT [OUTER] JOIN, FULL [OUTER]
**	    JOIN, RIGHT [OUTER] JOIN, and also to permit "a left join b left
**	    join c on y on x", as a valid alternative to "a left join b on x
**	    left join c on y". Both these changes are aimed at supporting a 
**	    more complete ANSI syntax.
**	14-oct-1997 (nanpr01)
**	    86211 : set result_structure cheap/chash/cisam/cbtree gets
**	    segmentation fault.
**	14-oct-97 (stial01)
**		Added support for SET SESSION WITH ISOLATION LEVEL
**		Moved SET SESSION accessmode into SET SESSION WITH, but
**		left accessmode after WITH in case anyone was using it already.
**	17-oct-1997 (schte01) - clear qso handle prior to a retry in create
**       procedure. Without being cleared, the parser frees the text
**       stream and the sequencer on retry, tries to free the text stream
**       resulting in an E_QS000F_BAD_HANDLE error.
**	19-nov-97 (inkdo01)
**	    Added $Yinhaving variable to detect count(*) refs in where, but
**	    not nested inside having (as must be the case).
**	20-nov-1997 (nanpr01)
**	    bug 86867  : Create integrity on secondary index should
**	    return error.
**	16-dec-1997 (hayke02)
**	    The call to pst_header() in the update 'set updatelist where_cur'
**	    section now has hdr_mask or'ed with mask. This allows the
**	    PST_1INSERT_TID bit to be passed for a STAR 'update ... not exists
**	    ...' type query. This change fixes bug 79311.
**	24-feb-1998 (i4jo01)
**	    After changing journaling status, invalidate RDF information
**	    about the table. (b87131)
**      26-mar-1998 (sarjo01)
**          Bug 88006: Do not do unnecessary promote to nullable for case of
**          columns of inner JOIN.
**	30-mar-98 (inkdo01)
**	    Changes to support ANSI constraint WITH options (for index 
**	    specification).
**	10-may-1998 (nanpr01)
**	    Parallel Create Index semantic change.
**	22-jul-98 (inkdo01)
**	    Changes to psl_p_tlist to more accurately identify "x.*"
**	    constructs.
**      29-jun-98 (sarjo01) from 17-apr-98 (hayke02) change 43597
**          Modified fixes for 84044, 85225 and 88006 to correctly deal
**          with inner joins and nested outer joins (using PSS_INNER_RNGVAR,
**          which is set in psl_set_jrel()). Also, we now only modify the
**          nullability of the result columns if this is a prepared outer
**          join statement. This change fixes bug 90099.
**	    Extended change to apply to CREATE VIEW so that iiattribute  
**	    now reflects correct nullability of outer join view columns.
**      23-jul-98 (i4jo01)
**          Need to initialize range variable pointer so we do not segv
**          processing dbp's with scalar functions. (b89353).
**	15-sep-98 (sarjo01)
**	    Added new param, TIMEOUTABORT nnn, to SET JOINOP
**	13-oct-98 (inkdo01)
**	    Rework constraint "with" clause rules to lift ordering requirement
**	    placing column constraints after all of default, null and 
**	    "system_maintained" specs.
**	19-oct-98 (inkdo01)
**	    Many changes (from last several months) to support 3.0 row producing 
**	    procedure feature (for-loop, return row, result row, repeat until).
**	20-oct-98 (inkdo01)
**	    Added "no action" referential action as required by ANSI.
**      05-Nov-98 (hanal04)
**          Record pss_viewrng.pss_maxrng in the statement prototype.
**          This structure has a one to one mapping with the statement
**          to be executed and can therefore be reliably used to
**          set sess_cb->pss_viewrng.pss_maxrng in pst_execute. b90168.
**	10-nov-98 (sarjo01)
**	    Added db priv check for TIMEOUTABORT.
**	1-dec-98 (inkdo01)
**	    Add support of expressions and non-select list columns to order by.
**	19-Jan-1999 (shero03)
**	    Add SET RANDOM_SEED.
**      21-jan-1999 (hanch04)
**          replace nat and longnat with i4
**	26-jan-99 (toumi01)
**	    Added NO_OPTIM for lnx_us5 to correct SQL-92 related problems.
**      02-feb-1999 (hanch04)
**          replace longnat with i4
**	25-feb-99 (inkdo01)
**	    Changed references to "row" from nonkeyword to ROW (for row producing 
**	    procedures).
**	02-apr-1999 (popri01)
**	    As of Unixware 7 (usl_us5), NO_OPTIM is required in order to
**	    avoid "E_RD0002 Requested table is not known to DMF", which
**	    appeared in the run_all synonym test suite.
**	20-Apr-1999 (shero03)
**	    Support multivariate functions (3 & 4 operands)
**	26-apr-1999 (hanch04)
**	    Added casts to quite compiler warnings
**      28-apr-1999 (hanch04)
**          Replaced STlcopy with STncpy
**	24-may-1999 (somsa01)
**	    In the cname: case, initialize varnode before calling pst_node().
**	9-june-99 (inkdo01)
**	    Minor change to OJ grammar to make inner joins look like inner joins.
**	24-Jun-1999 (shero03)
**	    Added ISO4 date format.
**	 7-jul-99 (hayke02)
**	    Mark having clause query node with PST_HAVING. This change
**	    fixes bug 95906.
**	01-Jul-1999 (shero03)
**	    Support II_MONEY_FORMAT=NONE for sir 92541
**      31-Aug-1999 (johco01)
**        Cross Integrate chage 439089 (gygro01)
**        Took out change 438631 because it introduced bug 94175.
**        Change 437081 solves bugs 90168 and 94175
**	2-sep-99 (inkdo01)
**	    Add "case" function support.
**	10-sep 1999 (hayke02)
**	    9-june-99 (inkdo01)
**	    Minor change to OJ grammar to make inner joins look like inner
**	    joins.
**	06-oct-99 (toumi01)
**	    Change Linux config string from lnx_us5 to int_lnx.
**	27-oct-99 (inkdo01)
**	    Various changes to enforce restrictions on select list entries and 
**	    having clause contents in the face of group by expressions.
**	26-nov-1999 (hayke02)
**	    Modify fix for bug 95906 to use PST_5HAVING and to only set
**	    this flag if this is a '...having [not] exists...' style query.
**	    This change fixes bug 99570.
**	4-feb-00 (inkdo01)
**	    Allow delimited identifiers in element lists (as in location = ...)
**	    in modify statements (fixes bug 98206).
**	10-feb-00 (inkdo01)
**	    Replace DB_DATAVAL by individual fields in CASE_NODE for 64 bits.
**	6-jul-00 (inkdo01)
**	    Add code to assure valid datatypes in group by columns/exprs.
**	7-jul-00 (inkdo01)
**	    Fix case expression code (simple_when_list and searched_when_list
**	    rules) to permit more than 2 when clauses.
**      17-March-2000 (hanal04) Bug 100899 INGSRV 1133.
**          Small correction to inkdo01's 9-June-1999 change. Although the
**          current join id should be decremented for INNER joins the join_id
**          for the join itself should be set to PST_NOJOIN.
**      19-Mar-2000 (linke01)
**          Added NO_OPTIM for usl_us5 to correct SQL-92 related problems.
**          Symptom is when select count(*) is used, got an error message said
**          it should be contained in "group by" clause.  
**	17-jul-2000 (hayke02)
**	    Set PSS_INNER_OJ in pss_stmt_flags if we have an inner outer join
**	    which has been converted to a normal inner join by the fix for SIR
**	    94906.
**	21-jul-2000 (somsa01)
**	    The last cross-integration accidentally duplicated a section
**	    of code.
**	22-aug-2000 (somsa01)
**	    Added NO_OPTIM for ibm_lnx to correct SQL-92 related problems.
**	12-sep-00 (inkdo01)
**	    Do "in target list" check for between clause, too, since it can be
**	    in "case" expression.
**	13-sep-00 (inkdo01)
**	    Remove change to OJ parse for SIR 94906 (caused other problems - now
**	    fixed in OPF).
**      01-Jun-2001 (hanal04) Bug 104607 INGSRV 1442
**          Resolve ULM memory corruption caused by calls to pst_node()
**          which do not generate a PST_UOP node as requested.
**          This occurs when pst_node() shortcuts the need for a PST_UOP
**          by setting the new node to the address of the 'adjusted'
**          PST_CONST node. If this happens we have only reserved space
**          for pst_s_cont and can not reference the pointer as a
**          pst_s_op pointer.
**	3-mar-00 (inkdo01)
**	    Add support for "select first n ..." syntax.
**	 2-may-01 (hayke02)
**	    Remove restriction on 'create table ... as select ...'
**	    (PSQ_RETINTO) for creation of a linked list of key attributes
**	    (reskey->pst_nxtkey->...). This prevents only the first
**	    attribute being used from the key = (<columnname>{, <columnname>})
**	    clause. This change fixes bug 104477.
**	14-nov-2000 (abbjo03) bug 102580
**	    Fix parsing of default values with FLOAT/DECIMAL if II_DECIMAL is
**	    a comma.
**	10-Jan-2001 (jenjo02)
**	    Supply session's SID to QSF in qsf_sid.
**	    Deleted qef_dmf_id, use qef_sess_id instead.
**	    Added *PSS_SELBLK parm to psf_mopen(), psf_mlock(), psf_munlock(),
**	    psf_malloc(), psf_mclose(), psf_mroot(), psf_mchtyp(),
**	    psl_rptqry_tblids(), psq_tout(), psq_tmulti_out().
**	17-Jan-2001 (jenjo02)
**	    Added *PSS_SESBLK parm to psq_prt_tabname().
**	18-Jan-2001 (jenjo02)
**	    Short-circuit calls to psy_secaudit() if not C2SECURE.
**	9-feb-01 (inkdo01)
**	    Add logic to groupby processing to make SQL funcagg results "not
**	    null" if their parms are not null (for better ADF operand alignment)
**	26-Feb-2001 (jenjo02)
**	    Set session_id in QEF_RCB;
**	01-Mar-2001 (jenjo02)
**	    Remove references to obsolete DB_RAWEXT_NAME, remove support
**	    for locname:extent_name syntax from create/modify index.
**	19-mar-01 (inkdo01)
**	    Fix syntax error caused in "unique_scope = row" by addition of row as
**	    reserved word.
**	21-mar-01 (inkdo01)
**	    Fix syntax error caused in "enable security_audit row" and fix 
**	    detection of non-select DML's at head of for-loop.
**	27-mar-01 (inkdo01)
**	    Detect & flag "return row" in proc with no "result row" declaration.
**	02-Apr-2001 (jenjo02)
**	    Added RAWBLOCKS syntax to CREATE LOCATION (thanks, Doug!).
**	04-apr-01 (toumi01)
**	    Fix syntax errors for
**		"modify ... with unique_scope = row"
**		"create table ... with label_granularity = row"
**	    by addition of row as a reserved word.
**	06-apr-01 (inkdo01)
**	    Fix US096F error from row producing procedures.
**	10-apr-01 (inkdo01)
**	    Detect "return row" statement with fewer entries than corresponding
**	    "result row" clause.
**      16-apr-2001 (stial01)
**          Changes in ternary function code for tableinfo function
**	30-apr-01 (inkdo01)
**	    Add error message for "first n" syntax in wrong places. Also
**	    add support for "first n" to be used in "insert ... select" and
**	    "create table ... as select".
**	11-May-2001 (jenjo02)
**	    Replaced "RAWBLOCKS" with "RAWPCT" in CREATE LOCATION.
**	14-June-2001 (inifa01)
**	    (X-INT of change 435091 bug 74559 nicph02)
**          Updated cdbp_exec_dbproc rule with INTO syntax when executing a
**          procedure from another procedure. Added 2 new rules : cdbp_into
**          and cdbp_into_var. This is bug 74559.
**      01-Jun-2001 (hanal04) Bug 104607 INGSRV 1442
**          Resolve ULM memory corruption caused by calls to pst_node()
**          which do not generate a PST_UOP node as requested.
**          This occurs when pst_node() shortcuts the need for a PST_UOP
**          by setting the new node to the address of the 'adjusted'
**          PST_CONST node. If this happens we have only reserved space
**          for pst_s_cont and can not reference the pointer as a
**          pst_s_op pointer.
**	15-june-01 (inkdo01)
**	    Further changes to fix US096F in for-loop selects in procedures.
**	25-june-01 (inkdo01)
**	    Re-enable binary aggregates and leave their results nullable.
**	4-july-01 (inkdo01)
**	    Fix building of parse tree for 4-parm functions.
**	29-jul-2001 (toumi01)
**	    Early definition of MIN/MAX for i64_aix to avoid conflict with
**	    system header macros with the same names.
**	16-aug-2001 (toumi01)
**	    speculative i64_aix NO_OPTIM change for beta xlc_r - FIXME !!!
**	05-sep-2001 (somsa01)
**	    Fixed number of arguments for psf_malloc(), introduced with
**	    cross of change 451221.
**	05-Sept-2001 (hanje04)
**	    Removed duplicate definitions added by crossing of change 451221.
**	28-sep-2001 (toumi01)
**	    Add RAWPCT as keyword to avoid syntactic ambiguity between
**	    loc_rawpct_tok and loc_area_tok in the loc_with rule.  This
**	    fixes bug 105929.
**	4-oct-01 (inkdo01)
**	    Updated msg PS091F placement to indicate "first n" not allowed 
**	    in Star queries.
**	09-oct-01 (hayke02)
**	    Do "in target list" check for in clause, too, since it can be
**	    in "case" expression. This change fixes bug 105998.
**	15-Oct-2001 (jenjo02)
**	    E_US18DE_INVALID_USAGE changed to E_US18DE_6366_INVALID_RAW_USAGE
**	23-oct-01 (inkdo01)
**	    Added "as" noise word between table name and correlation name 
**	    (as per SQL99).
**	5-dec-01 (inkdo01)
**	    Permit pattern string to be any string expression (same as ANSI).
**	20-dec-01 (hayke2)
**	    Remove test for same_scope == 0 when checking for ambiguous
**	    attributes from the select list so that error 2101 (E_US0835)
**	    is now returned correctly. This change fixes bug 106656.
**	28-jan-02 (inkdo01)
**	    Insert derived names in result row columns for row-producing procs
**	    (to fix bug 106935).
**	26-feb-02 (toumi01)
**	    Remove erroneous cloned lines in cdbp_row_elem, which cause
**	    a reference to a null pointer testing Solaris DBL.  This has
**	    not shown up before because 1) the address computations are
**	    never used and so may be optimized out and 2) the CMbytecnt
**	    reference to the address is, on single-byte platforms, a macro
**	    that just returns the value 1.
**      22-feb-02 (stial01)
**          Check status immediately after call to psl_do_insert() (b107294)
**      05-mar-2002 (horda03)
**          SQLWARN4 should only be set for DELETE/UPDATE statements in s
**          PREPARE which do not contain a WHERE clause. This fixes
**          bug 106509.
**	6-mar-02 (inkdo01)
**	    Grammar for create/alter/drop sequence.
**	1-may-02 (toumi01)
**	    issue 11873547 bug 107626 dbproc order by unselected cols
**	    If parsing a dbproc, pass the address of the INTO list tree
**	    to pst_sqlsort so that if RESDOMs are added for unselected
**	    sort fields, we can add them there. We will be substituting
**	    the INTO clause tree for the current LH branch when the
**	    "query:" rule fires. Also needed to enhance the edit of the
**	    resulting tree to allow for non WRITE PROTECTED builtins if
**	    pst_print = FALSE.
**	16-may-02 (inkdo01)
**	    Dynamic SQL parameter markers result in uninit'ed pst_fdesc's that 
**	    cause problem in having clause analysis (bug 107795).
**	06-jun-2002 (toumi01)
**	    Set/reset new PSQ_PARSING_ORDER_BY flag so that we can test grammar
**	    context for the FIRST keyword in the scanner.
**	14-jun-02 (hayke02)
**	    Added E_PS03AB_AGGR_IN_GROUP_BY (cloned from
**	    E_PS03AA_AGGR_IN_ORDER_BY) for cases where we have aggregates
**	    in the group by clause - $Yin_groupby_clause TRUE for a PST_AGHEAD
**	    node. This change fixes bug 107026.
**	13-Nov-2003 (wanfr01) Bug 110586, INGSRV 2415
**	    Initialized tree in insertkwd intname incolspec subselect
**	    to avoid segmentation fault should psl_do_insert return an
**	    error code.
**	22-jul-02 (inkdo01)
**	    Change set [no]optimizeonly to not require tp auth.
**	10-Sep-2002 (hanch04)
**	    Use the macro for DB_TEXT_STRING to make sure structure is aligned.
**	21-oct-02 (inkdo01)
**	    Change RESULT reserved word to RESULTROW 2-word reserved word.
**	1-nov-02 (inkdo01)
**	    Introduce "cross join" and named column joins, and re-introduce
**	    natural join (even if it isn't quite standard).
**      04-nov-2002 (chash01) remove tuple size check from REGISTER TABLE,
**          configurable tuple size can only be checked in DMF.
**	26-nov-02 (inkdo01)
**	    Changes to support increased range table size - largely in 
**	    from_list_item and join productions that return range table 
**	    bit maps.
**      02-jan-2003 (huazh01)
**          In psl_ordGroup(), if the target result domain contains an
**          PST_AGHEAD node, then returns E_PS03AB_AGGR_IN_GROUP_BY
**          error to the user.
**          This fixes bug 109012, INGSRV/1989.
**      7-jan-03 (stial01)
**          Don't issue E_PS049E_CANT_EXEC_SYSGEN_PROC if UPGRADEDB
**	13-jan-03 (inkdo01)
**	    Slight change to alter security_audit to account for RESTART
**	    as reserved word (part of sequence implementation).
**	22-jan-03 (inkdo01)
**	    Minor fix to sequence error handling to pick up syntax errors
**	    with "as" reserved word.
**      22-jan-03 (chash01)
**          Integrate bug109055 fix, change#460569
**          Remove code that checks tuple too wide under reg_gateway_tab, so
**          that RMS gateway can expand its tuple width beyond traditional
**          2008 bytes.
**	23-Jan-2003 (hanal04) Bug 111631 INGSRV2675
**          When processing a cname we were generating a PST_CONST node
**          instead of a PST_VAR node for an order by clause specified
**          as column name only, if there was a matching var in the
**          DBP. The var is not valid as an order by clause so we must
**          check for a matching RESDOM in the order by case regardless
**          of whether or not there is a matching var. This prevents
**          E_US0872 being generated in pst_sqlsort().
**	21-feb-03 (inkdo01)
**	    Add mask parm to psy_gsequence calls to direct which sequence
**	    owners to search for.
**	28-feb-03 (inkdo01)
**	    Add message US018B3 to note bad sequence data type.
**	21-mar-03 (inkdo01)
**	    Add revoke syntax for sequences (oops).
**      28-Mar-2003 (hanal04) Bug 109879 INGEMB 78
**          In psl_p_tlist() we must test to see whether tab.* columns
**          are the INNER of an OUTER join. If they are they should be
**          made nullable in the same way tab.col1, tab.col2... are.
**	24-apr-03 (inkdo01)
**	    Pre-fetch iisequence row for "drop sequence" and perform general 
**	    sequence error cleanup.
**      01-May-2003 (hanch04)
**          Added PSS_DBPROC_LHSVAR for bug 110041.  If II_DECIMAL=','
**          then variable assignments should be allow to have ','
**          instead of '.' in CREATE PROCEDURE statements.
**	21-may-03 (inkdo01)
**	    Add union select resolution logic for union queries in procs.
**	4-june-03 (inkdo01)
**	    Add "set [no]ojflatten" and "set joinop [no]new" statements.
**	10-jun-2003 (devjo01)
**	    Prevent careless/malicious user from clobbering useful
**	    files with SET TRACE OUTPUT. b110302.
**	11-june-03 (inkdo01)
**	    Also added "set [no]hash" statement.
**	17-jul-2003 (toumi01)
**	    Add to PSF some flattening decisions.
**	4-sep-03 (toumi01)
**	    Modify correlation name rule so that "as" is no longer pure
**	    noise, but can be used (in addition to quoting) to signal that
**	    the next token is a correlation name, even if that next token
**	    is a keyword (e.g. select no.col1 from tab1 as no).
**      22-Sep-2003 (wanfr01)
**          Bug 51716, INGSRV 2264
**          Short comments are now enabled for table.
**          See issue 12559245, March 13 2003 updates.
**	2-oct-03 (inkdo01)
**	    Add "greedy"/"nogreedy" as "set joinop" synonyms for "newenum"/
**	    "nonewenum".
**      02-oct-03 (chash01)
**          check gateway indice not to contain multi-column of heterogenous
**          data types.
**      21-oct-03 (chash01)
**          The above change introduced an error,
**                    MEcopy(idx_att[i]->key_attr_name.db_att_name,
**                           (u_i4)DB_MAXNAME, colname);
**           should be
**                    MEcopy(idx_att[i]->attr_name.db_att_name,
**                           (u_i4)DB_MAXNAME, colname);
**	2-dec-03 (inkdo01)
**	    Dropped NO from token list. It's only used in double words.
**	4-dec-03 (inkdo01)
**	    Fixed 3-operand SUBSTRING to make PST_OPERANDs when used 
**	    in all contexts other than select-list. How did this bug make
**	    it this far???
**	12-dec-03 (inkdo01)
**	    Changed IN-list production to accumulate constants from the
**	    list into a single chain hung from "=" BOP node. 
**	16-Dec-2003 (hanje04)
**	    Removed duplicate line added by bad X-integ
**      02-jan-2004 (stial01)
**          Changes for SET [NO]BLOBJOURNALING, SET [NO]BLOBLOGGING
**	    Changes for new with clause, WITH [NO]BLOBJOURNALING
**          Changes to expand number of WITH CLAUSE options
**      14-jan-2004 (stial01)
**          set [no]blobjournaling only when table specified.
**	23-Jan-2004 (schka24)
**	    Take out KEY, PRIMARY, and FOREIGN as separate tokens, define
**	    double-word tokens for primary key and foreign key;  remove
**	    all the "key" special-casing.
**	    Make BASE TABLE STRUCTURE a triple-keyword.  (! if a little is
**	    good, more must be better...?) to eliminate extra production
**	    in index WITH clause.  Consolidate all the table structuring
**	    WITH clauses (except COPY), so that PARTITION= only needs to
**	    go into one place.
**	    In a titanic power struggle, fight yacc to a draw, implement
**	    PARTITION= parsing.
**	12-feb-04 (inkdo01)
**	    Change update/delete to request 8-byte tids.
**	19-feb-2004 (gupsh01)
**	    changes for SET [NO]UNICODE_SUBSTITUTION.
**	23-feb-2004 (schka24)
**	    More partition changes: modify table partition lp.lp...
**	4-mar-04 (inkdo01)
**	    Implement "set [no]parallel [n]" for parallel query processing.
**	4-mar-04 (inkdo01)
**	    Crossed old 3.0 ANSI function changes (CAST, COALESCE, etc.).
**	18-mar-04 (inkdo01)
**	    Explicitly allocate/init NULL constant.
**	22-Mar-2004 (schka24)
**	    Need delim-id on with-clause index= RHS.
**	14-apr-2004 (rigka01) bug#10067, INGSRV2242
**	    Recover the "with nojournal_check" option of "alter table" which
**	    was lost between revision 153 and 154. 
**	16-apr-2004 (somsa01)
**	    Initialize dmu_cb for relocate.
**	26-Apr-2004 (schka24)
**	    Call sequence change for COPY.
**	15-Apr-2004 (gupsh01)
**	    Added support for alter table alter column.
**	22-Apr-2004 (karbh01) Bug 111944 INGSRV2760
**	    Prevent invalid E_US09CF when running modify <tbl_name> to 
**	    unique_scope=row
**	5-may-04 (inkdo01)
**	    Fix incorrect length in null constant node.
**	5-may-04 (inkdo01)
**	    Remove IN-list packing for "not in" lists.
**      13-may-2004 (stial01)
**          Removed support for SET [NO]BLOBJOURNALING ON table.
**      22-Jun-04 (vansa02) bug#112375, INGSRV 2839
**          While creating parallel index, the keyword unique may be mentioned
**          in two place either immediately after create or immediately
**          after column name. The parser is checking for 'unique'
**          immediately after passing the first possible place where the
**          unique can be specified with out looking at the second possible
**          place where unique can be specified.
**      15-jun-04 (zhahu02)
**          Updated for inserting null value to page_size =32k with large
**          varchar column (INGSRV2863/b112487).
**      04-08-13 (wanfr01)
**        Bug 112828, INGSRV2799
**          increment pss_targparm if found parameter in target list
**          set PSS_PARSING_TARGET_LIST inside
**	09-nov-04 (hayke02)
**	    Change the insert select syntax from subselect to query_expr. This
**	    means that union'ed selects are now possible in an insert. This
**	    change fixes problem INGSRV 3032, bug 113346.
**	10-dec-04 (hayke02)
**	    Above change causes E_US096C/2412 for a 'insert into ... select'
**	    query in a DBP. Limit E_US096C/2412 to non-insert queries. This
**	    change fixes problem INGSRV 3079, bug 113606.
**	22-jun-04 (inkdo01)
**	    Tidy defaults for "set [no]parallel" and tart up "message/raise error"
**	    syntax.
**	26-jul-2004 (gupsh01)
**	    Fixed message statements in procderes that do not support variables 
**	    of type nchar/nvarchar as parameters. 
**	05-Aug-2004 (schka24)
**	    Allow explicit scale of 0 in create sequence.  Gah.
**	25-aug-04 (toumi01)
**	    Exempt STAR from changed IN-list production because the DDB
**	    code generation doesn't know how to handle the resulting tree.
**      27-aug-2004 (stial01)
**          Removed SET NOBLOBLOGGING statement
**	03-Sep-2004 (shaha03)
**		Modified the code to give detailed error message in case of 
**		invalid security_audit type.
**      07-sep-04 (srisu02)
**          Commented out masking of the error bit in case of outer joins
**          which use 'using'.
**          This is to display the exact error message in case of errors which
**          arise when the using operator is used with columns that have
**          incompatible datatypes i.e using(long varchar)
**	28-sep-04 (inkdo01)
**	    Switched sequence name/owner name in the x.y.nextval version
**	    of next value syntax.
**      07-sep-04 (srisu02)
**          Commented out masking of the error bit in case of outer joins
**          which use 'using'.
**          This is to display the exact error message in case of errors which
**          arise when the using operator is used with columns that have
**          incompatible datatypes i.e using(long varchar)

**	20-oct-04 (inkdo01)
**	    Fix named column join problem.
**      25-Oct-2004 (shaha03)
**          SIR #112918, added configurable default cursor open mode support.
**	26-oct-04 (inkdo01)
**	    Fix bug 112053 - fails to detect invalid use of VLUP in 
**	    insert ... select.
**	2-dec-04 (inkdo01)
**	    Add explicit collation support.
**	03-Dec-04 (shaha03)
**	    SIR #112918, fixed the problem with earlier submission for 
**	    the same SIR.
**	6-jan-05 (inkdo01)
**	    Add support for ASYMMETRIC/SYMMETRIC options of BETWEEN predicate.
**	6-jan-05 (inkdo01)
**	    Collate clause goes at end of column definition.
**	11-jan-05 (inkdo01)
**	    Add "set parallel", "set hash" and "set ojflatten" to immediate
**	    stmts.
**	18-Jan-2005 (gupsh01)
**	    Fixed raise_event to support nchar/nvarchar variables.
**	3-Feb-2005 (schka24)
**	    Add i4-tid compatability hack.
**	4-mar-05 (inkdo01)
**	    Added PST_MOP, PST_OPERAND to psl_tingx check to permit SUBSTRING
**	    in group by expressions.
**	21-mar-05 (inkdo01)
**	    Enable "(<subsel>) <compop> <something>", same as "<something>
**	    <compop> (<subsel>)" that already works.
**      22-Mar-2005 (thaju02)
**         Disallow altering of journal status if table is
**         the independent object of a references constraint. (B114000)
**	15-apr-05 (inkdo01)
**	    Copy collID to resdom in psl_p_tlist.
**	13-june-05 (inkdo01)
**	    Changes to <subselect>, <target_spec> to support the vitally 
**	    important "select *, something else, ..." feature (SIR 114668).
**	19-July-2005 (toumi01)
**	    Support WITH PASSWORD=X'<encrypted>'.
**	28-Jul-2005 (thaju02)
**	    Enable select of column w/ delimited space(s) column
**	    name. (B114947)
**	22-aug-05 (inkdo01)
**	    Fixes to support avg() transform in having clause, too.
**	25-aug-05 (inkdo01)
**	    Slight change to 112053 fix (from 26-oct-04) to only prevent 
**	    VLUPs in repeat insert ... select for aggregate selects. This
**	    retains pre-r3 behaviour for most applications.
**	14-sep-05 (inkdo01)
**	    Made OJ syntax check slightly smarter for Star (so it doesn't
**	    flag SQL 1992 inner join syntax).
**	10-oct-05 (inkdo01)
**	    Added left/right/full anti joins & intersect joins in syntax.
**	23-Nov-2005 (kschendel)
**	    Use storage structure lookup for result-structure stmt.
**	29-nov-05 (toumi01)
**	    For distributed (Star) disallow CREATE GLOBAL TEMPORARY TABLE
**	    with a clear message. It was erroring with E_PS0BD0 as if the
**	    WITH NORECOVERY clause were missing (it was not). Confusing.
**	29-nov-05 (inkdo01)
**	    Removed Fromwords, Bywords compound reserved words to avoid
**	    reserved word problems with "role".
**	7-dec-05 (inkdo01)
**	    Added support for Unicode literals.
**	16-jan-06 (dougi)
**	    Permit "create/drop trigger" for rules - also allow "when"
**	    instead of "where" - for syntax unification.
**	17-jan-06 (dougi)
**	    Add support of "default values" in insert and "default" as a
**	    value for insert and update.
**	23-jan-06 (dougi)
**	    Changes to finally support subselects in the FROM clause.
**	1-feb-06 (dougi)
**	    Add collation ID to cast syntax.
**	3-feb-06 (dougi)
**	    Sample implementation of several query hints.
**	 6-mar-06 (hayke02)
**	    Only modify the datatype of INSERT resdom nodes if this is not
**	    a union query. This prevents overwriting the datatypes chosen by
**	    pst_union_resolve() and inappropriate datatypes for the resdom
**	    nodes of the union view created by opa_cunion(). This change fixes
**	    bug 115638.
**	31-mar-06 (dougi)
**	    New group by syntax (cube, rollup, grouping sets).
**	8-Apr-2006 (kschendel)
**	    Re-work nonreswd-func production so that we can parse functions
**	    with arbitrary number of args;  also, to clarify code.
**	27-Apr-2006 (kschendel)
**	    Above edit broke ANSI substring because it doesn't use the "func"
**	    lead-in production, and I forgot to copy the param-list stacking
**	    stuff.  Fix.
**	9-May-2006 (kschendel)
**	    Fix cast parse goof where junk in db_pdata.db_data could get
**	    into the parse tree node, causing later E_PS0D32.
**	9-May-2006 (kschendel)
**	    Rule changes for BY last fall missed changing a $n param number,
**	    causing create security_alarm ... by <username> to generate
**	    garbage for the grtype and ending up "public".
**	22-May-2006 (kschendel)
**	    Roy Hann discovered that (subsel) compop expr wasn't giving the
**	    right answer all the time;  turns out that we should be reversing
**	    the operator, not inverting it.  e.g. (subsel) > n should become
**	    n < (subsel), not n <= (subsel).
**	24-May-2006 (kschendel)
**	    Implement grammar changes for DESCRIBE INPUT.
**	    Rip out the long-obsolete J_FREESZn set statements.
**	29-may-06 (dougi)
**	    Assign pss_stmtno to pst_lineno.
**	6-Jun-2006 (kschendel)
**	    Fine tune the restrictions on when parameter markers are allowed,
**	    so that the grammar agrees with the pstdsql stuff.
**	7-june-06 (dougi)
**	    Add IN, INOUT, OUT options to parameter declarations and support
**	    BEFORE in rule definition.
**	14-jun-06 (toumi01)
**	    Allow session temporary tables to be referenced without the
**	    "session." in DML. This eliminates the need for this Ingres-
**	    specific extension, which is a hinderance to app portability.
**	    After calls to psl_rngent warn that a session table name
**	    unqualified by "session." was found, call
**	    psl_valid_session_schema_use to make sure the usage is valid
**	    in the current context.
**	23-Jun-2006 (kschendel)
**	    Fix wee oops with inout parm stuff, flags member wasn't inited;
**	    simply use = instead of |=.
**	06-Jul-06 (kiria01) b116230
**	    psl_print becomes PSL_RS_PRINT bit in new field psl_rsflags
**	    to allow for extra flags in PST_RSDM_NODE
**	20-july-06 (dougi)
**	    Set PSS_DERTAB_INQ flag for queries with derived tables to guide
**	    view processing in psy_view().
**       14-aug-2006 (huazh01)
**          enable the flag PST_6HAVING if there are two PST_AGHEAD nodes
**          hanging under the 'having' clause. On opa_varsub(), don't
**          substitues 'self join' variables if such flag is ON.
**          This fixes b116202.
**	25-aug-06 (dougi)
**	    Add grammar to parse ANSI date/time types in procedure parameter
**	    lists.
**	29-aug-2006 (gupsh01)
**	    Added support for ANSI date/time literals and ANSI system 
**	    Constants.
**	31-aug-06 (toumi01)
**	    Allow DROP TABLE for session tables with syntax shortcut.
**	13-sep-2006 (dougi)
**	    Add logic to "insert ... values" to tolerate string/numeric
**	    mixtures.
**	11-oct-2006 (dougi)
**	    Add optional precision to "interval day to second".
**	19-oct-2006 (dougi)
**	    Syntax changes to disable hints and group by enhancements for 2006u1.
**       6-Nov-2006 (hanal04) SIR 117044
**          Add int.rpl for Intel Rpath Linux build.
**	28-dec-2006 (dougi)
**	    Add support for scalar subqueries and SQL standard with clauses
**	    (a.k.a. common query expressions).
**	28-Dec-2006 (kibro01) b117252/b117253
**	    Ensure that a table is not registered for IMA gateway with
**	    either JOURNALING or UPDATE specified in the 'with' clause
**	 3-Jan-2007 (kibro01) b117253
**	    Allow table registration with UPDATE if "from 'objects'"
**	    (i.e. a flat table rather than a cross table)
**	9-jan-2007 (dougi)
**	    Add derived tables to range table built during prepare.
**	10-jan-2007 (dougi)
**	    Deduce NOT NULL from PRIMARY KEY or UNIQUE column constraints.
**	12-jan-2007 (dougi)
**	    Process interval literals here rather than scanner (they're too
**	    complex).
**	15-jan-2007 (dougi)
**	    Add ANSI-style EXTRACT function (noise word in parmlist).
**	17-jan-2007 (dougi)
**	    Add SCROLL cursor option.
**	18-jan-2007 (dougi)
**	    Minor change to grammar rules for "copy" to resolve problem
**	    with column names that are reserved words.
**	19-jan-2007 (dougi - change of the day)
**	    Fiddle "func" rules slightly to allow interval() to be a function
**	    (as it has been for eons) even though INTERVAL is now a reserved
**	    word (because of interval literal changes).
**	19-jan-2007 (dougi - twice daily)
**	    Adjust sequence data type check to prevent tinyint, smallint and
**	    bigint (though bigint will likely be added later).
**	22-jan-2007 (dougi - honest, these are all different problems)
**	    Pass nonupdateability from derived tables to containing query.
**	1-feb-2007 (dougi)
**	    Add microseconds, nanoseconds to valid extract() fields.
**      14-feb-2007 (stial01)
**          col_constraint: Always set $$.
**	12-feb-2007 (dougi)
**	    Tidy up the scrollable cursor declaration c/w keyset.
**	21-feb-2007 (gupsh01)
**	    Fixed INTERVAL year to month and day to second as a valid data type.
**	21-feb-2007 (dougi)
**	    Change behaviour of aggs in GROUP BY to treat it like constant.
**	23-feb-2007 (dougi)
**	    Slight tweak to fix interval constants.
**	27-Feb-2007 (kibro01) b117546
**	    Don't allow IMA table with structure other than sortkeyed
**	5-mar-2007 (dougi)
**	    Enable "null" as a standalone attribute of a column definition,
**	    as well as "with null".
**	15-mar-2007 (dougi)
**	    Honour declared fractions of seconds in interval literals.
**	20-mar-2007 (dougi)
**	    Fix union to support DISTINCT and ALL.
**	30-mar-2007 (dougi)
**	    Slight change to permit "substring(a, b, c)" instead of requiring
**	    "substring(a from b for c)".
**	3-apr-2007 (dougi)
**	    Tweak CAST to choose result length from source value for length-
**	    qualified result types with no explicit length.
**	10-apr-2007 (dougi)
**	    Additional editing for KEYSET SCROLL cursors.
**	27-apr-2007 (dougi)
**	    Add UNICODE_FRENCH_COLL to list of collations.
**	4-may-2007 (dougi)
**	    Minor change to grammar to allow NULL in coalesce() list.
**	4-may-2007 (dougi)
**	    Add "unique_scope = statement" as option to "modify ... to
**	    <structure> unique".
**	8-may-2007 (dougi)
**	    Updateable scrollable cursors imply KEYSET.
**	9-may-2007 (dougi)
**	    Add FREE LOCATOR statement.
**      17-may-2007 (stial01)
**          Changed psq_locator to DB_DATA_VALUE type
**      17-may-2007 (stial01)
**          Changed psq_locator to DB_DATA_VALUE type
**	18-may-2007 (dougi)
**	    Force DIRECT for scrollable updateable cursors.
**	24-may-2007 (dougi)
**	    Save PSS_CONS * for check constraints.
**	31-may-2007 (toumi01 for dougi)
**	    Implicit updateable scrollable cursor should be handled like
**	    explicit KEYSET.
**	1-june-2007 (dougi)
**	    Add message for LOBs found in scrollable cursor result set.
**	19-june-2007 (dougi)
**	    Look for dyn parms in derived tables & common query expressions.
**	19-june-2007 (dougi)
**	    Error to show scalar subqueries not yet supported.
**	19-june-2007 (dougi)
**	    Error for update/keyset scrollable cursors on Star dbs.
**	23-june-2007 (dougi)
**	    Properly initialize pst_rsflags - broke an aggregate query.
**	27-june-2007 (dougi)
**	    Fix typo in detection of LOBs in scrollable cursors.
**	13-aug-2007 (dougi)
**	    Extend CAST grammar to include date/time types.
**	15-Aug-2007 (kiria01) b118942
**	    CROSS JOIN and NATURAL JOIN would not parse correctly in the context
**	    of sub-selects due to a restricted rule form. Rule from_list_item1
**          has been dropped and instead the broader from_list_item used. The
**          resulting parser conflicts have been resolved by indicating the left
**          associativity of the join operators in the from clause.
**	28-Aug-2007 (kibro01) b114883/b112053
**	    Allow VLUPs in the where clause of an aggregated query since
**	    it is possible to exclude them later from the GROUP BY segment
**	    which means the queries work (since the VLUP has a constant value
**	    within the query anyway and therefore isn't required in the
**	    GROUP BY clause).
**	3-Sep-2007 (kibro01) b119050
**	    It should not be possible to specify NOINDEX or INDEX = BASE TABLE
**	    STRUCTURE with any other options.
**	12-oct-2007 (dougi)
**	    Changes to support new date/time literals in partition definitions.
*/
%{
/*[@forward_type_references@]*/

/*
**  Forward and/or External function references.
*/

GLOBALREF PSF_SERVBLK *Psf_srvblk;
FUNC_EXTERN DB_STATUS	gwf_call();
FUNC_EXTERN DB_STATUS	rdf_call();
FUNC_EXTERN DB_STATUS	qsf_call();

static DB_STATUS
chkcnst(
	PST_QNODE *tp);
static bool
psl_valid_session_schema_use(
	i4		qmode,
	PSS_SESBLK	*sess_cb,
	char		*obj_name,
	DB_ERROR	*err_blk);
static DB_STATUS
psl_tbl_ref(
	PSQ_CB		*psq_cb,
	PSS_SESBLK	*sess_cb,
	PSS_COL_REF	*col_ref,
	i4		in_target_clause,
	i4		cur_scope,
	PSS_TBL_REF	**tbl_refs,
	PSS_RNGTAB	**rngtab);
static DB_STATUS
psl_reg_struct(
	i4     *pst_struct,
	DMU_CB      *dmu_cb,
	char        *ssname,
	i4         dmu_c_flag,
	DB_ERROR    *err_blk);
static DB_STATUS
psl_usr_func(
	     char	    *fname,
	     PSS_SESBLK	    *sess_cb,
	     bool	    in_join_cond,
	     PSS_JOIN_INFO  *join_info,
	     PST_QNODE	    **newnode,
	     DB_ERROR	    *err_blk);
static DB_STATUS
psl_vrule_tree_convert(
	    PST_QNODE	*rootnode,
	    PST_QNODE	*vtree,
	    PSS_SESBLK	*sess_cb,
	    DB_ERROR	*err_blk);
static DB_STATUS
psl_set_function(
	    PSS_SESBLK	*sess_cb,
	    PSQ_CB	*psq_cb,
	    PSS_YYVARS	*yyvarsp,
	    char	*func_name,
	    i4		distinct,
	    i4		count_or_any,
	    PST_QNODE	*expr1_node,
	    PST_QNODE	*expr2_node,
	    PST_QNODE	**aghdnodep);
static bool
psl_validate_collation_name(
	char	*collname,
	i4	*collID);
static bool
psl_validate_collation_mix(
	i2	collID1,
	i2	collID2);
static DB_STATUS
psl_vrule_subtree(
	    PSS_SESBLK	*sess_cb,
	    PST_QNODE	**subtree,
	    PST_QNODE	*vtree,
	    PSS_DUPRB	*dup_rb);
static void
psl_bld_tid_descr(
	    DMT_ATT_ENTRY	*attribute,
	    PSS_SESBLK		*cb);
static i4
psl_reserved_ident(
	char		*name,
	PSS_SESBLK	*sess_cb,
	PSQ_CB		*psq_cb,
	i4		force_check);
static DB_STATUS
psl_simple_compare(
	PSS_SESBLK	*sess_cb,
	PST_QNODE	*operand1,
	PST_QNODE	*operand2,
	ADI_OP_ID	operator,
	i4		is_escape,
	char		escape_char,
	PSS_TREEINFO	**treeinfo,
	bool		in_join_search,
	bool		in_target_clause,
	PSS_JOIN_INFO	*join_info,
	PSQ_CB		*psq_cb);


static DB_STATUS
psl_subsel_compare(
	PSS_SESBLK	*sess_cb,
	PST_QNODE	*expr,
	PST_QNODE	*subsel,
	ADI_OP_ID	operator,
	i4		meta_op,
	PSS_TREEINFO	**treeinfo,
	bool		in_join_search,
	PSS_JOIN_INFO	*join_info,
	bool		subsel_illegal,
	i4		err_msgno,
	PSQ_CB		*psq_cb);
static DB_STATUS
psl_1ary_func_extra_proc(
	    PSS_SESBLK	    *sess_cb,
	    i4		    op_id,
	    PST_QNODE	    *arg1,
	    PST_QNODE	    **prec_scale,
	    DB_ERROR	    *err_blk);
static DB_STATUS
psl_2ary_func_extra_proc(
	    PSS_SESBLK	    *sess_cb,
	    i4		    op_id,
	    PST_QNODE	    *arg1,
	    PST_QNODE	    *arg2,
	    DB_ERROR	    *err_blk);
static DB_STATUS
psl_3ary_func_extra_proc(
	    i4		    op_id,
	    PST_QNODE	    *arg2,
	    PST_QNODE	    *arg3,
	    DB_ERROR	    *err_blk);

static DB_STATUS psl_arg_room(
	PSS_SESBLK *cb,
	PSQ_CB *psq_cb,
	PSS_YYVARS *yyvarsp,
	i4 n);

static DB_STATUS psl_nary_func(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PSS_YYVARS	*yyvarsp,
	ADI_OPINFO	*func,
	PST_QNODE	**result_ptr);

static DB_STATUS
psl_mfunc_param(
	PSQ_CB		*psq_cb,
	PSS_SESBLK	*cb,
	PST_QNODE	*argument,
	PST_QNODE	**result);

static DB_STATUS
psl_bld_col_spec_grant_template(
	PTR		txt_chain,
	char		*priv_str,
	bool		cols_excluded,
	PSF_QUEUE	*colq,
	DB_ERROR	*err_blk);
static DB_STATUS
psl_add_grantee(
	PSS_SESBLK	*sess_cb,
	char		*grantee_name,
	PSS_ID_TYPE	grantee_type,
	DB_ERROR	*err_blk);
static DB_STATUS
psl_remove_single_quotes(
	char		*text_chain,
	char		*identifier,
	DB_ERROR	*err_blk);
static DB_STATUS
psl_prepend_schemaname(
	char		*text_chain,
	char		*obj_name,
	u_char		*schema_name,
	DB_ERROR	*err_blk);
static bool
psl_seqop_search(
	PST_QNODE	*nodep);
static DB_STATUS
psl_push_yyvars(
	PSQ_CB		*psq_cb,
	PSS_SESBLK	*sess_cb,
	PSS_YYVARS	**yyvpp);
static bool
psl_aop_nooj(
	PST_QNODE	*nodep,
	PSS_YYVARS	*yyvarsp);
static bool 
psl_agginExpr(
	PST_QNODE	*nodep);
static DB_STATUS
psl_groupingsets_fromcr(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	i4		crtype,
	PST_QNODE	*listp,
	PST_QNODE	**newnodep);
static DB_STATUS
psl_groupingsets_normalize(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PST_QNODE	**rootp);
static DB_STATUS
psl_groupingsets_expand(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PST_QNODE	**rootp,
	bool		*alldonep);
static DB_STATUS
psl_groupingsets_tidy(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PST_QNODE	*nodep,
	i4		*rsdmnop);
static DB_STATUS
psl_ansi_strtodt(
        PSS_SESBLK      *cb,
        PSQ_CB          *psq_cb,
	DB_DT_ID	ansitype,
	i4		intparts,
        DB_TEXT_STRING	*instr,
        PST_QNODE       **newnode,
	DB_DATA_VALUE	*dataval,
	i2		secfrac);
/*[@function_reference@]...*/

/*
**  Defines of other constants.
*/

/* define flags known to psl_fatt() */	    
					  /* only try to find attribute */
#define			FIND_ONLY	(i4) 0x01
/* if attr was found, and FIND_ONLY is not set, allocate space for a VAR node */
#define			ALLOC_NODE	(i4) 0x02
/*
** when processing a join_search qualification, we only want to consider
** relations involved in the join
*/
#define			JOINREL_MASK 	(i4) 0x04

/*
** used to distinguish between select * and select " ".
** Intended to add a flag member to the PST_VAR_NODE, but
** doing so would require change of the RDF tree version
** number and possibly upgradedb (VAR nodes are 
** part of the RDF query trees). 
*/ 
#define			PST_STAR_SEEN	-1

/*[@group_of_defined_constants@]...*/
/*[@type_definitions@]*/
/*[@global_variable_definitions@]*/
/*[@static_variable_or_function_definitions@]*/
%}

/*
** YACC starting symbol.
*/

%start          stmt

/*
** Union of types for tokens and non-terminal symbols.
*/

%union
{
    i4              psl_tytype;         /* Operator types, etc. */
    PST_QNODE       *psl_trtype;        /* Query tree node pointer */
    PSS_RNGTAB	    *psl_rngtype;	/* Range table entry */
    i4	    psl_inttype;	/* General-purpose number */
    u_i4	    psl_u_inttype;	/* same as above, but unsigned*/
    i2		    *psl_i2type;
    i4		    *psl_i4type;
    i8		    *psl_i8type;
    u_char	    *psl_dectype;
    f4		    *psl_f4type;
    f8		    *psl_f8type;
    char	    *psl_strtype;
    DB_TEXT_STRING  *psl_textype;	/* A text string, with 2-byte count */
    DB_NVCHR_STRING *psl_utextype;	/* A Unicode string, with 2-byte 
					** code point count */
    PST_QTREE	    *psl_qttype;	/* Query tree type */
    DB_CURSOR_ID    *psl_cursid;	/* A cursor id */
    PSC_CURBLK	    *psl_crblk;		/* A cursor control block */
    DB_DATA_VALUE   *psl_dbval;		/* A db data value */
    bool	    psl_bool;		/* a boolean */
    PST_RESKEY	    *psl_reskey;	/* key struct ptr */
    PST_STATEMENT   *psl_stmt;		/* statement node ptr */
    PSS_DECVAR	    *psl_decvar;	/* ptr to var declaration */
    PSS_LOOP 	    *psl_while;		/* ptr to while label */
    PST_PROCEDURE   *psl_prtype;	/* procedure node ptr. */
    PSS_DBPINFO	    *psl_dbpinfo;	/* Database procedure info */
    PSS_OBJ_NAME    *psl_objspec;	/* object name spec	*/
    PSS_TREEINFO    *psl_treeinfo_type; /* node ptr + info about a subtree */
    PSS_COL_REF	    *psl_col_ref;	/* description of a column reference */
    PSS_CONS	    *psl_constype;	/* constraint info */
    PSY_COL	    *psl_coltype;	/* column name */
    ADI_OPINFO	    *psl_opinfo;	/* operator/function information */
    PST_J_MASK	    *psl_varmap;	/* range table bit map */
}

/*
** Definitions of all tokens in the grammar, and their datatypes.
*/

%token              ABORT ALL ALTER AND ANY APPEND AS ASC AT AUTHORIZATION AVG

%token		    ADD

%token		    ALTGROUP ALTROLE ALTUSER ALTLOC ALTSEQ

%token		    ASYMMETRIC

/*
** A binary arithmetic operator: *.
*/
%token              BAOP

/*
** A high precedence binary arithmetic operator: **.
*/
%token              BAOPH

/* BASE TABLE STRUCTURE triple-keyword.  This is used to trick out the
** grammar so that index = base table structure falls into the
** name = name WITH-production, and allows it to be parsed that way.
*/
%token		    BASE_TABLE_STRUCTURE

/*
** A binary arthimetic operator: /.
*/
%token		    BDIVP
/*
** A binary comparison operator: <, <=, >, >=.
*/
%token              BDOP

/*
** "begin transaction" taken a a single token.
*/
%token              BGNXACT

%token              BEGIN BETWEEN BY BYREF

%token		    CALLPROC CASCADE CLOSE CLUSTER

%token		    CASE CACHE CAST COALESCE CYCLE

/*
** A colon character: :
*/
%token              COLON

/*
** A comma character: ,
*/
%token		    COMMA

%token		    COPY 

%token		    COPY_FROM COPY_INTO
/* COMMENT ON taken as a single token */
%token		    COMMENT_ON

%token              CREATE CHECK
 
%token              COLUMN COMMIT COMMITTED CONTINUE COUNT 

%token		    CROSSJOIN CUBE CURRENT CURRVAL CURSOR

/** "create integrity" taken as a single token.**/
%token		    CRTINTEG

/*
** "create link" taken as a single token.
*/
%token		    CRTLINK

/*
** "create permit" taken as a single token.
*/
%token		    CRTPERM

/*
** "create view" taken as a single token.
*/
%token		    CRTVIEW

%token		    CRTGROUP CRTROLE CRTRULE CRTUSER CREATEEVENT CRTSYNONYM

%token		    CRTUSR CRTSECALM CRTLOC CRTSEQ

%token		    COLLATE

/* $DBA */
%token		    DBA

/*Ansi type designator used in date literals eg date'xxx' */
%token		    DCONST

/*
** A packed decimal constant
*/
%token		    DECCONST

/*
** The "for deferred" token.
*/
%token		    DEFERUPD

/*
** "define query" taken as a single token.
*/
%token		    DEFQRY

/*
** a delimited identifier
*/
%token		    DELIM_IDENT

/*
** The "for direct" token.
*/
%token		    DIRECTUPD

/*
** "disable security_audit" taken as a single token
*/
%token		    DISECAUDIT

/* DESCRIBE is "describe" or "describe output".
** DESCINPUT is "describe input".
*/
%token              DELETE DECLARE DESCRIBE DESCINPUT DISTINCT DO DROP

/*
** "drop integrity" taken as a single token.
*/
%token		    DROPINTEG

/*
** "drop link" taken as a single token.
*/
%token		    DROPLINK

/*
** "drop permit" taken as a single token.
*/
%token		    DROPPERM

/*
** "drop synonym" taken as a single token
*/
%token		    DROPSYNONYM

/*
** "drop view" taken as a single token.
*/
%token		    DROPVIEW

%token		    DROPGROUP DROPROLE DROPRULE DROPUSER DROPEVENT

%token		    DROPLOC DROPSECALM DROPSEQ

/*
** A dollar sign: $.
*/
%token              DOLLAR

/*
** "end transaction" taken as a single token.
*/
%token              ENDXACT

/*
** "enable security_audit" taken as a single token
*/
%token		    ENSECAUDIT

/*
** An inequality operator: !=.
*/
%token              EOP

/*
** An equality operator: =.
*/
%token              EQUAL

%token              ELSE ELSEIF END ENDFOR ENDIF ENDLOOP ENDREPEAT ENDWHILE 
%token              ESCAPE EXCEPT EXECUTE EXISTS EXCLUDING

/*
** The "for readonly" symbol.
*/
%token		    FORREADONLY

/*
** Four and eight byte floating-point constants.
*/
%token              F4CONST F8CONST

%token		    FETCH FIRST FOR FREELOCATOR FROM

%token		    FULLANTI FULLJOIN FULLOUTER
%token		    GLOBAL
%token		    GRANT GROUP GROUPING GROUPINGSETS

%token		    HAVING

/*
** hex constants x'....'
*/
%token		    HEXCONST

/*
** Bit constants b'...'
*/
%token		    BITCONST

/*
** Two and four byte integer constants.
*/
%token              I2CONST I4CONST I8CONST

%token              IF IMMEDIATE IMPORT IN INDEX

/* $INGRES */
%token		    INGRES

%token		    INCREMENT INNERJOIN INOUT INSERT INTO INTEGRITY

%token		    INTERSECT INTERSECTJOIN

/*Ansi type designator used in interval literals eg interval'xxx'year to month */
%token		    INTERVAL

/*
** The word "is".
*/
%token              IS ISOLATION

%token		    JOIN LEAVE LEFTANTI LEFTJOIN LEFTOUTER LEVEL

%token		    LIKE

/*
** A left curly bracket: {.
*/
%token              LCURLY

%token		    LOCAL

/*
** A left parenthesis: (.
*/
%token              LPAREN

%token              MAX MESSAGE MIN MODIFY MODULE

%token              MAXVALUE MINVALUE

/*
** A sequence of characters that begins with a letter or underscore, and
** contains letters, digits, and underscores.  PUT SOMETHING HERE ABOUT
** ESCAPED NAMES.
*/
%token              NAME

%token		    NATURAL NEXT NEXTVAL

%token		    NOCACHE NOCYCLE NOMAX NOMIN NOORDER

%token              NOT NULLIF NULLWORD NOTLIKE

%token              OF ON OPEN OPTION OR ORDER OUT OUTER

%token		    ONAPPLICATION ONCOMMIT ONCURRENT ONDATABASE ONEVENT

%token              ONLOCATION ONLY ONPROCEDURE ONSEQUENCE
/*
** A period character: .
*/
%token              PERIOD

%token		    PERMIT PREPARE PRESERVE PRIVILEGES PROCEDURE PUBLIC

%token		    QDATA QUESTIONMARK QUERYID

%token		    RAISE RAISEERROR RAISEEVENT RAWPCT READ  REFERENCING 

%token		    REGISTER REGISTEREVENT

%token              RELOCATE REMOVE REMOVEEVENT REPEAT REPEATABLE
 
%token              REPLACE RESTRICT RESULTROW RETURN RESTART REVOKE

%token		    RIGHTANTI RIGHTJOIN RIGHTOUTER ROLLBACK ROLLUP ROW ROWS

/*
** A right curly bracket: }.
*/
%token              RCURLY

/*
** A right parenthesis: )
*/
%token		    RPAREN

%token              SAVE SAVEPOINT

%token              SCHEMA

/*
** A string constant of the TEXT type, consisting of a two-byte count followed
** by an array of characters.
*/
%token              SCONST SCROLL

%token              SELECT SEMICOLON SERIALIZABLE SESSION SET

/*
** "set aggregate" taken as a single token.
*/
%token		    SETAGGR

/*
** "set autocommit" taken as a single token.
*/
%token		    SETAUTOCOMMIT

/*
** "set cpufactor" taken as a single token.
*/
%token		    SETCPUFACT

/*
** "set date_format" taken as a single token.
*/
%token		    SETDATEFMT

/*
** "set ddl_concurrency" taken as a single token.
*/
%token		    SETDDLCONCUR

/*
** "set decimal" taken as a single token.
*/
%token		    SETDECIMAL

/*
** "set flatten/noflatten" taken as a single token.
*/
%token		    SETFLATTEN

/*
** "set [no]hash" taken as a single token.
*/
%token		    SETHASH

/*
** "set io_trace/noiotrace" taken as a single token.
*/
%token		    SETIOTRACE

/*
** "set [no]joinop" taken as a single token.
*/
%token		    SETJOINOP

/*
** "set [no]journaling" taken as a single token.
*/
%token		    SETJOURNAL

/*
** "set lockmode" taken as a single token.
*/
%token		    SETLOCKMODE

/*
** "set logging" taken as a single token.
*/
%token		    SETLOGGING

/*
** "set log_trace" taken as a single token.
*/
%token		    SETLOGTRACE

/*
** "set [no]maxio" taken as a single token 
*/
%token		    SETMXIO

/*
** "set [no]maxrow" taken as a single token 
*/
%token		    SETMXROW

/*
** "set [no]maxcpu" taken as a single token 
*/
%token		    SETMXCPU

/*
** "set [no]maxpage" taken as a single token 
*/
%token		    SETMXPAGE

/*
** "set [no]maxcost" taken as a single token 
*/
%token		    SETMXCOST

/*
** "set lock_trace/nolock_trace" taken as a single token.
*/
%token		    SETLOCKTRACE

/*
** "set money_format" taken as a single token.
*/
%token		    SETMNYFMT

/*
** "set money_prec" taken as a single token.
*/
%token		    SETMNYPREC

/* "set [no]optimizeonly" as a single token */
%token		    SETOPTIMIZEONLY
/*
** "set printqry" taken as a single token.
*/
%token		    SETPRINTQRY

/*
** "set [no]maxidle" taken as a single token 
*/
%token		    SETMXIDLE

/*
** "set [no]maxconnect" taken as a single token 
*/
%token		    SETMXCONNECT

/*
** "set [no]printxxxx" taken as a single token.
*/
%token		    SETPRTRULES SETPRTEVENTS

%token		    SETLOGEVENTS SETRULES

/*
** "set ojflatten/noojflatten" token as a single token.
*/
%token		    SETOJFLATTEN

/*
** "set parallel/noparallel n" token as a single token.
*/
%token		    SETPARALLEL

/*
** "set [no]qep" taken as a single token.
*/
%token		    SETQEP

/*
** "set random_seed" taken as a single token.
*/
%token		    SETRANDOMSEED

/*
** "set result_structure" taken as a single token.
*/
%token		    SETRESSTRUCT

/*
** "set ret_into" taken as a single token.
*/
%token		    SETRETINTO

/*
** "set session" taken as a single token.
*/
%token		    SETSESSION

/*
** "set statistics" taken as a single token.
*/
%token		    SETSTATS

/*
** "set [no]trace" taken as a single token.
*/
%token		    SETTRACE

/*
** "set transaction" taken as a single token */
%token              SETTRANSACTION
 
/* WITH SHORT_REMARK taken as a single token */
%token		    SHORT_REMARK

/* "set unicode_substitution"  taken as a single token */
%token              SETUNICODESUB

/* "set update_rowcount" taken as a single token. */
%token              SETUPDROWCNT

/* "set work" taken as a single token. */
%token		    SETWORK

%token              SOME SQL SUM START

%token              SYSTEM_MAINTAINED

/* "set role" taken as a single token. */
%token		    SETROLE

%token		    SUBSTRING SYMMETRIC

%token              TABLE TEMPORARY THEN TO TRANSACTION

%token		    TOGROUP TOROLE TOUSER

/* dummy token for readahead in scanner */
%token		    TARGET

/*Ansi type designator for time and timestamp literals eg: time'xx:xx:xx' */
%token		    TMWOCONST TMWCONST TMECONST
%token		    TSWOCONST TSWCONST TSTMPCONST

/*
** A unary arithmetic operator: +, -.
*/
%token		    UAOP

%token		    UCONST

%token              UNCOMMITTED UNION UNIQUE UNTIL UPDATE USER USING

%token		    VALUES VIEW

%token		    WHEN WHERE WHILE WITH WORK WRITE

/*
** WITH/WITHOUT TIME/LOCAL for date/time declarations
*/
%token		    WLOCAL WTIME WITHOUT WOTIME

/* constraint and default tokens
 */
%token		    DEFAULT REFERENCES PRIMARYKEY FOREIGNKEY
%token		    CONSTRAINT CURRENT_USER
%token		    CURDATE CURTIME CURTIMESTAMP 
%token		    LOCTIME LOCTIMESTAMP

%token		    INITIAL_USER SESSION_USER SYSTEM_USER

%token		    ALTSECAUDIT

%token		    CRTPROFILE ALTPROFILE DROPPROFILE

/* Special PARTITION= clause tokens.  These are not normally keywords.
** They are only scanned as keywords when the start of a twith_list_partition
** is being parsed.  (There are a few other keywords recognized in that
** context, like ON and VALUES, but they are already defined as tokens.)
*/
%token		AUTOMATIC HASH LIST RANGE PARTITION

/*[@yacc_token_definition@]*//*...*/

/*
** Datatypes of tokens and non-terminal symbols.
*/

%type   <psl_tytype>  BAOP BAOPH BDOP EOP IS UAOP BY TARGET BETWEEN BDIVP
%type   <psl_f4type>  F4CONST
%type	<psl_f8type>  F8CONST index_relem 
%type	<psl_dectype> DECCONST
%type	<psl_i2type>  I2CONST
%type	<psl_i4type>  I4CONST
%type	<psl_i8type>  I8CONST
%type	<psl_tytype>  NOT AND OR EQUAL
%type	<psl_strtype> NAME DELIM_IDENT name_or_interval
%type	<psl_textype> SCONST HEXCONST BITCONST 
%type	<psl_textype> DCONST TMWOCONST TMWCONST TMECONST 
%type	<psl_textype> TSWOCONST TSWCONST TSTMPCONST
%type	<psl_utextype> UCONST
%type	<psl_tytype>  SETHASH SETJOINOP SETJOURNAL SETTRACE SETIOTRACE
%type   <psl_tytype>  SETLOGTRACE SETLOGGING SETFLATTEN SETOJFLATTEN
%type   <psl_tytype>  SETPARALLEL
%type   <psl_tytype>  SETQEP SETSTATS SETPRINTQRY SETLOCKTRACE SETPRTRULES
%type	<psl_tytype>  SETMXIO SETMXROW SETMXCPU SETMXPAGE SETMXCOST
%type   <psl_tytype>  SETPRTEVENTS SETLOGEVENTS SETRULES SETOPTIMIZEONLY
%type   <psl_tytype>  SETUPDROWCNT SETWORK
%type   <psl_tytype>  SETMXIDLE SETMXCONNECT SETROLE SETUNICODESUB
%type	<psl_cursid>  QUERYID cursor_id
%type	<psl_dbval>   QDATA 

%type	<psl_inttype> intconst_p month from from_word intconst_e
%type	<psl_inttype> interval_type interval_junk2
%type	<psl_inttype> crl_tbl_stmt_list crl_tbl_stmt 
%type	<psl_varmap>  from_list_item joined_table qualified_join 
%type	<psl_varmap>  cross_join natural_join
%type	<psl_inttype> intsetparam setjint parconst
%type	<psl_inttype> timeofday distinct int2_int4 int2_int4_p first_n
%type	<psl_inttype> ras_ev_with comment_obj
%type	<psl_inttype> on_or_off isolation_level access_mode
%type	<psl_inttype> aseqopwd oseqopwd collate
%type	<psl_strtype> strsetparam tname typedesc cdbp_label crname
%type	<psl_strtype> strconst strconst_e cdbp_lhs_var name_or_sconst corr_name
%type	<psl_strtype> corr_name1 dt_wquals
%type   <psl_strtype> generic_ident internal_ident nonkeyword nonkey_or_sconst
%type   <psl_strtype> auth_ident user_ident tbl_spec col_spec schema_spec
%type   <psl_strtype> cdbp_while_label cdbp_forlabel cdbp_replabel
%type	<psl_strtype> cp_delim entname owner_name
%type   <psl_strtype> create_schema_auth newcolname sconst_ident cdbp_into_var
%type	<psl_tytype>  settracestmnt comparison set_fun_dist avg_min_max_sum
%type	<psl_tytype>  set_fun_all_dist
%type	<psl_opinfo>  func
%type	<psl_tytype>  query_clause cur_updmode permspec drop_behaviour
%type   <psl_tytype>  like is_null in symmetric between setlockkey
%type   <psl_tytype>  alm_priv_spec tbl_priv_obj_spec user_role_auth_list
%type	<psl_tytype>  grant_auth_spec rev_auth_spec alm_cond_spec alm_auth_spec
%type	<psl_tytype>  asc_desc bin_op index_unique m_asc_desc sign_op
%type	<psl_tytype>  union cdbp_noise cdbp_parmmode subsel_pred_qualifier
%type	<psl_tytype>  crl_tbl_when crl_ref_clause crl_tbl_with_clause
%type	<psl_tytype>  crl_tbl_row_or_stmt
%type	<psl_tytype>  setmxio_kwd setmxrow_kwd setmxcpu_kwd
%type	<psl_tytype>  setmxidle_kwd setmxconnect_kwd 
%type	<psl_tytype>  setmxpage_kwd setmxcost_kwd sec_aud_type
%type	<psl_tytype>  loc_use_type loc_rawpct_type
%type	<psl_tytype>  reg_tvp reg_keywd union_opt
%type	<psl_trtype>  query_term query_expr query_expr_1 
%type	<psl_treeinfo_type> boolean_expr boolean_term boolean_factor
%type   <psl_treeinfo_type> boolean_primary predicate check_cons
%type	<psl_trtype>  subselect sel_expr_or_null select_expr_or_subselect
%type	<psl_trtype>  groupby target_spec select_expr where arith_term
%type	<psl_trtype>  arith_factor primary group_list
%type	<psl_inttype> group_by keyset_opt
%type	<psl_trtype>  incol incolspec invallist incollist inexpr invalspec
%type	<psl_trtype>  newcolspec newcollist newcol updatelist update_item 
%type	<psl_trtype>  having cname element target_list target_item 
%type	<psl_trtype>  order_column constant set_or_scalar_function into_clause
%type	<psl_trtype>  nonreswd_function where_cur sel_expr_list cdbp_retval
%type	<psl_trtype>  case_function case_body simple_case searched_case  
%type	<psl_trtype>  simple_when_list simple_when_list_item case_else
%type	<psl_trtype>  searched_when_list searched_when_list_item 
%type	<psl_trtype>  trim_or_extract_spec
%type	<psl_trtype>  coalesce_list coalesce_list_item cast_expr
%type	<psl_trtype>  cdbp_parmlvar cdbp_mesparm cdbp_lvar cdbp_lvar_list
%type	<psl_trtype>  crl_tbl_where crl_proc_arg_list
%type	<psl_trtype>  crl_rule_cond crl_tbl_rule crl_exec_proc
%type	<psl_trtype>  null_word cdbp_mesparm_2 cdbp_rhs_asgn
%type 	<psl_trtype>  exdbp_arguments exdbp_arg_list exdbp_arg exdbp_arg_val
%type 	<psl_trtype>  ras_ev_value def_value cdbp_retrow_spec1
%type 	<psl_trtype>  seq_operator ansi_seqop oracle_seqop
%type	<psl_qttype>  cdbp_dml1stmt query delete insert update repeat_query
%type	<psl_rngtype> integtbl permtbl set_stat_tbl from_item alt_tbl
%type	<psl_dbval>   cast_type number seq_type part_const_stringish
%type	<psl_bool>    with_check for_rdonly using_list reg_idx_key
%type	<psl_crblk>   curop_ini curop_ini_1 curop_ini_2 curop_ini_dsql
%type	<psl_prtype>  exe_stmnt
%type	<psl_stmt>    cdbp_beblock cdbp_stmtlst cdbp_stmtlist cdbp_stmt
%type	<psl_stmt>    cdbp_ctrlstmt cdbp_txstmt cdbp_return cdbp_message
%type	<psl_stmt>    cdbp_whilestmt cdbp_ifstmt cdbp_elsepart cdbp_declare
%type	<psl_stmt>    cdbp_elseifpart cdbp_elseif cdbp_assignstmt cdbp_forstmt
%type	<psl_stmt>    cdbp_whileinit cdbp_endloop cdbp_ifkwd cdbp_elseifkwd
%type	<psl_stmt>    cdbp_raise_error cdbp_exec_dbproc execute_dbproc
%type	<psl_stmt>    register_event remove_event raise_event event_tail
%type	<psl_stmt>    cdbp_event_stmt cdbp_ev_stmt cdbp_retrow_stmt
%type	<psl_stmt>    cdbp_repeatstmt cdbp_repinit cdbp_forinit cdbp_dmlstmt
%type	<psl_decvar>  cdbp_varname cdbp_varnamelst cdbp_lhs_asgn cdbp_into
%type	<psl_dbpinfo> exdbp_name
%type	<psl_textype> long_remark short_remark bit_or_hex_const 
%type	<psl_trtype>  interval_const
%type	<psl_objspec> obj_spec reg_name reg_idx_name 
%type	<psl_u_inttype>	permission
%type	<psl_col_ref>	col_ref all_col_ref
%type   <psl_inttype>   usr_priv usr_priv_list alm_obj_spec
%type	<psl_strtype>	twith_nkw_kwd twith_nkw_bts name_or_alt_kwd
%type	<psl_reskey>	twith_list_clist_elem twith_list_inside
%type	<psl_reskey>	twith_list_partition twith_list_commalist

/* constraint and default tokens
 */
%type	<psl_inttype>	type_qual_list type_qual_list1 type_qual default
%type	<psl_inttype>	with_noise null_constraint col_constraint unique_spec
%type	<psl_inttype>	logical_key tbl_constraint user_default ref_action_item
%type	<psl_inttype>	con_with
%type	<psl_constype>	col_constraint2 tbl_constraint2 col_refcon tbl_refcon
%type	<psl_constype>	ref_action
%type	<psl_strtype>	constraint_name
%type	<psl_coltype>	cons_colspec cons_collist cons_col

%left CROSSJOIN FULLANTI FULLJOIN FULLOUTER INNERJOIN INTERSECTJOIN JOIN LEFTANTI LEFTJOIN LEFTOUTER NATURAL RIGHTANTI RIGHTJOIN RIGHTOUTER

/*
** The semantic actions associated with the following productions
** should not be bypassed when recognizing CREATE SCHEMA:
*/
%nobypass	create_schema create_schema_key create_schema_auth
%nobypass	create_schema_list create_schema_element

%nobypass	create_table crt_tbl_kwd
%nobypass	tbl_constraint tbl_constraint2 constraint_name 
%nobypass	col_constraint col_constraint2
%nobypass	cons_colspec cons_collist cons_col
%nobypass	crname newcolname from_item
%nobypass	twith_list twith_list_prefix

%nobypass	create_view viewstmnt

%nobypass	grant grant_kwd tbl_priv_obj

%nobypass	obj_spec generic_ident
%nobypass	schema_spec user_ident internal_ident sconst_ident
%nobypass	auth_ident col_spec

%%

/*
** Rules Section.
*/

stmt:		    abort
	  |	    alter_role
	  |	    alter_group
	  |	    alter_user
	  |	    alter_location
	  |	    alter_table
	  |	    alter_profile
	  |	    alter_sequence
          |	    btransact
	  |	    comment
	  |	    commit
          |	    copy
	  |	    create_event
	  |	    create_role
	  |	    create_group
	  |	    create_index
	  |	    create_integrity
	  |	    create_link
	  |	    create_permit
	  |	    create_rule
	  |	    create_synonym
	  |	    create_schema
	  |	    create_table
	  |	    create_user
	  |	    create_location
	  |	    create_secalm
	  |	    create_view
	  |	    create_dbproc
	  |	    create_profile
	  |	    create_sequence
	  |	    cursor_close
	  |	    cursor_fetch
	  |	    cursor_open
	  |	    cursor_open_dsql
	  |	    define_query
	  |	    delete
	  |	    describe
	  |	    describe_input
	  |	    dgtt_stmt
	  |	    dircon
	  |	    dir_exec_immed
	  |	    drop_event
	  |	    drop_role
	  |	    drop_group
	  |	    drop_dbproc
	  |	    drop_tvis
	  |	    drop_schema
	  |	    dropinteg
	  |	    dropperm
	  |	    drop_rule
	  |	    drop_user
	  |	    drop_location
	  |	    drop_profile
	  |	    drop_secalm
	  |	    drop_sequence
	  |	    disable_secaud
	  |	    enable_secaud
	  |	    alter_secaud
	  |	    etransact
	  |	    execute_dbproc
	  |	    execute
	  |	    execute_imdte
	  |	    free_locator
          |	    grant
          |	    insert
          |	    modify
	  |	    prepare
	  |	    query
	  |	    reg_gateway_idx
	  |	    reg_gateway_tab
	  |	    reg_distr_idx
	  |	    reg_distr_tv
	  |	    rollback
	  |	    relocate
	  |	    revoke
	  |	    register_event	
	  |	    remove_event
	  |	    raise_event
          |	    save
	  |	    savepoint
	  |	    setaggr
	  |	    setautocommit
	  |	    setcpufact
          |	    setdatefmt
	  |	    setddl_concur
	  |	    setdecimal
	  |	    set_sess_auth_id
	  |	    setflatten
	  |	    sethash
	  |	    setiotrace
	  |	    setjoinop
          |	    setjournal
          |	    setjtimeout
          |	    setlockmode
	  |	    setlocktrace
	  |	    setlogging
	  |	    setlogtrace
	  |	    setmnyfmt
	  |	    setmnyprec
	  |	    setmxio
	  |	    setmxrow
	  |	    setmxcpu
	  |	    setmxidle
	  |	    setmxconnect
	  |	    setmxpage
	  |	    setmxcost
	  |	    setojflatten
	  |	    setoptimizeonly
	  |	    setparallel
	  |	    setprintqry
	  |	    setprintrules
	  |	    setprintevents
	  |	    setlogevents
	  |	    setqep
	  |	    setrandomseed
	  |	    setresstruct
	  |	    setretinto
	  |	    setrules
	  |	    setsession
	  |	    setstats
	  |	    settrace
          |         settransaction
	  |	    setupdrowcnt	
	  |	    setrole
	  |	    setwork
	  |	    setunicodesub
	  |	    update
	  |         xaprepare
	  |	    error
    {
	YYABORT;
    }
;

create_schema:	create_schema_key create_schema_auth create_schema_list
    {
	DB_STATUS		status;

#ifdef	xDEBUG
	psl_debug();
#endif

	status = psl_cs01s_create_schema(cb, psq_cb, $2);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	create_schema_key create_schema_auth
    {
	DB_STATUS		status;

#ifdef	xDEBUG
	psl_debug();
#endif

	status = psl_cs01s_create_schema(cb, psq_cb, $2);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

create_schema_key:	CREATE SCHEMA
    {
	DB_STATUS		status;

	i4		err_code;

#ifdef	xDEBUG
	psl_debug();
#endif

	psq_cb->psq_mode = PSQ_CREATE_SCHEMA;

	/* "create schema" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CREATE SCHEMA")-1, "CREATE SCHEMA");
	    return (E_DB_ERROR);	/* non-zero return means error */
	}

	status = psl_cs02s_create_schema_key(cb, psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/*
	** Bypass remaining semantic actions, except those identified
	** by the %nobypass directive above.
	*/
	$Ybypass_actions = TRUE;
    }
;

create_schema_auth:	AUTHORIZATION auth_ident
    {
	/* test username for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT($2, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	$$ = $2;
    }
;

create_schema_list:	create_schema_list create_schema_element
	|		create_schema_element
;

create_schema_element:	create_table
	|		create_view
	|		grant
;

abort:             abstmnt TO generic_ident
    {
	QEF_RCB                *qef_rcb;
	DB_STATUS	       status;
	DB_SP_NAME	       *spname;

	psq_cb->psq_mode = PSQ_ABSAVE;

	/* Allocate memory for savepoint name */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(DB_SP_NAME), 
	    (PTR *) &spname, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Give QEF pointer to name */
	STmove($3, ' ', sizeof(DB_SP_NAME), (char *) spname);
	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_spoint = spname;

	/* destroy all dynamic SQL statement prototypes */
	status = pst_commit_dsql(psq_cb, cb);
	if (status != E_DB_OK)
	    return (status);
    }
          |
                    abstmnt TO intconst_p
    {
	QEF_RCB                *qef_rcb;
	DB_STATUS	       status;
	DB_SP_NAME	       *spname;
	char		       numbuf[25];

	psq_cb->psq_mode = PSQ_ABSAVE;

	/* Allocate memory for savepoint name */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(DB_SP_NAME), 
	    (PTR *) &spname, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Give QEF pointer to name */
	CVla((i4) $3, (PTR) numbuf);
	STmove(numbuf, ' ', sizeof(DB_SP_NAME), (char *) spname);
	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_spoint = spname;

	/* destroy all dynamic SQL statement prototypes */
	status = pst_commit_dsql(psq_cb, cb);
	if (status != E_DB_OK)
	    return (status);
    }
          |
                    abstmnt
    {
	QEF_RCB                *qef_rcb;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_ABORT;
	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_spoint = (DB_SP_NAME *) NULL;

	/* destroy all dynamic SQL statement prototypes */
	status = pst_commit_dsql(psq_cb, cb);
	if (status != E_DB_OK)
	    return (status);
    }
;

abstmnt:	    ABORT
    {
	DB_STATUS              status;
	QEF_RCB		       *qef_rcb;

	/* Set mode for error recovery purpose only */
	psq_cb->psq_mode = PSQ_ABSAVE;

	/* Create the QEF control block for abort */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;
    }
;

btransact:         BGNXACT
    {
	DB_STATUS              status;
	QEF_RCB		       *qef_rcb;

	psq_cb->psq_mode = PSQ_BGNTRANS;

	/* Allocate QEF control block for begin transaction */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_modifier = QEF_MSTRAN;
	qef_rcb->qef_sess_id = cb->pss_sessid;
	qef_rcb->qef_db_id = cb->pss_dbid;
	qef_rcb->qef_flag = 0;

	/* destroy all dynamic SQL statement prototypes */
	status = pst_commit_dsql(psq_cb, cb);
	if (status != E_DB_OK)
	    return (status);
    }
;

commit:             commitstmt work 
    {
	DB_STATUS              status; 

	psq_cb->psq_mode = PSQ_COMMIT;
	/* Destroy all prepare statements, if any */
	if (cb->pss_defqry != PSQ_PREPARE)
	{
	    status = pst_commit_dsql(psq_cb, cb);
	    if (status != E_DB_OK)
		return (status);
	}
    }
          |             commitstmt work WITH xa_xid_parm
    {
	psq_cb->psq_mode = PSQ_XA_COMMIT;
	/*
	** Above we destroy all prepare statements. 
	** This can't be done for the XA commit until we find the
	** correct scb in scsqncr.c.
	** In any case the above call to pst_commit_dsql() seems to be
	** redundant. The same thing gets done again from the sequencer:
	**
	**  scs_sequencer(...) -> psq_call(PSQ_COMMIT...) -> pst_commit_dsql(..)
	*/
    }
;

commitstmt:	    COMMIT
    {
	QEF_RCB                *qef_rcb;
	DB_STATUS	       status;

	/* Allocate the QEF control block for commit */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
							    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream,cb->pss_object,&psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;
    }
;

work:		    WORK
	  |
;

xaprepare:          xa_prepare_stmt WITH xa_xid_parm
    {
	QEF_RCB                *qef_rcb;
	DB_STATUS	       status;

	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
							    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream,cb->pss_object,&psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;

	psq_cb->psq_mode = PSQ_XA_PREPARE;
    }
;

xa_prepare_stmt: PREPARE TO COMMIT 
{
	DB_STATUS              status;

	/* Allocate the QEF control block for xaprepare */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
}
;

create_index:     index_prefix index_defs
    {
	DMU_CB *dmu_cb;
	QEU_CB *qeu_cb, *temp_cb, *end;
	DMU_CHAR_ENTRY  *char_entry;
	i4         char_count, ix, ixcount;
	DB_TAB_ID 	save_tab;
	i4		err_code;
	bool		c_idx, concurrent_idx = FALSE;

	qeu_cb = (QEU_CB *) cb->pss_save_qeucb;	/* get the first one */
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;
	save_tab = dmu_cb->dmu_tbl_id;

	char_entry = 
	      (DMU_CHAR_ENTRY *) ((char *) dmu_cb->dmu_char_array.data_address);
	char_count = dmu_cb->dmu_char_array.data_in_size/sizeof(DMU_CHAR_ENTRY);
	for (ix = 0; ix < char_count; ix++)
	{
	    switch (char_entry[ix].char_id)
	    {
		case DMU_CONCURRENT_ACCESS:
		    if (char_entry[ix].char_value == DMU_C_ON)
	  		concurrent_idx = TRUE;
		    break;
		default :
		    continue;
	    }
	}

	for (end = qeu_cb->qeu_prev, temp_cb = qeu_cb, ixcount = 1; ;
	     temp_cb = temp_cb->qef_next, ixcount++)
	{
	    dmu_cb = (DMU_CB *) temp_cb->qeu_d_cb;
	    if (save_tab.db_tab_base != dmu_cb->dmu_tbl_id.db_tab_base)
	    {
	        (VOID) psf_error(9349, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 1,
			(i4) sizeof("CREATE INDEX")-1, "CREATE INDEX");
		return(E_DB_ERROR);
	    }
	    char_entry = 
	      (DMU_CHAR_ENTRY *) ((char *) dmu_cb->dmu_char_array.data_address);
	    char_count = 
	      dmu_cb->dmu_char_array.data_in_size/sizeof(DMU_CHAR_ENTRY);
	    
	    c_idx = FALSE;
	    for (ix = 0; ix < char_count; ix++)
	    {
		switch (char_entry[ix].char_id)
		{
		    case DMU_CONCURRENT_ACCESS:
			if ((char_entry[ix].char_value == DMU_C_ON) &&
				 (!concurrent_idx))
			{
	        	    (VOID) psf_error(9351, 0L, PSF_USERERR,
					&err_code, &psq_cb->psq_error, 1,
					(i4) sizeof("CREATE INDEX")-1, 
					"CREATE INDEX");
			    return(E_DB_ERROR);
			}
			else if ((char_entry[ix].char_value == DMU_C_OFF) &&
				 (concurrent_idx))
			{
	        	    (VOID) psf_error(9351, 0L, PSF_USERERR,
					&err_code, &psq_cb->psq_error, 1,
					(i4) sizeof("CREATE INDEX")-1, 
					"CREATE INDEX");
			    return(E_DB_ERROR);
			}
	    		c_idx = TRUE;
		        break;
		    default:
			continue;
		}
	    } 
	    if ((concurrent_idx) && (!c_idx)) 
	    {
	        (VOID) psf_error(9351, 0L, PSF_USERERR, &err_code, 
				 &psq_cb->psq_error, 1,
				 (i4) sizeof("CREATE INDEX")-1, 
				 "CREATE INDEX");
		return(E_DB_ERROR);
	    }

	    if (temp_cb->qef_next == end)
		break;
	}
	if (ixcount > PSS_MAX_CONCURRENT_IDX)
	{
	    (VOID) psf_error(9352, 0L, PSF_USERERR, &err_code, 
				 &psq_cb->psq_error, 1,
				 (i4) sizeof("CREATE INDEX")-1, 
				 "CREATE INDEX");
	    return(E_DB_ERROR);
	}
    }
;

index_defs:	  index_def
    {

    }
		| index_list 
    {

    }
;

index_list:	  LPAREN index_def RPAREN
    {

    }
		| index_list COMMA LPAREN index_def RPAREN
    {

    }
;

index_def:       indexlocname ON indexrel
		    LPAREN indexcols RPAREN index_unique tbl_with_clause
    {
	DB_STATUS	status;
	i4		unique = FALSE;
	i4		err_code;

	/* cannot specify 2 unique options */
        if (($Yunique) && ($7 == TRUE))
	{
	    (VOID) psf_error(9350, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 1,
			(i4) sizeof("CREATE INDEX")-1, "CREATE INDEX");
	    return(E_DB_ERROR);
	}

	/* 
	** if parallel style index is specified and old style unique is 
	** specified, consider all the indexes unique as long as the
	** syntax does not have in unique in individual create indexes.
	*/
	if ($Yunique)
	    unique = TRUE;
	else
	    unique = $7;

	/* Now dmu_cb char_id must be fixed up for unique indexes */
	status = psl_ci1_create_index(cb, &$Ywith_clauses, unique,
					&psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

index_prefix:	    CREATE index_unique INDEX
    {
	DB_STATUS		status;

	/*
	** set query mode here since psl_ci2_index_prefix() also gets called for
	** RMSGW's REGISTER INDEX
	*/
	psq_cb->psq_mode = PSQ_INDEX;
	cb->pss_object = (PTR) 0;
	cb->pss_save_qeucb = (PTR) 0;
	$Yunique = $2;
        
	/*
	** next we will be parsing the name of the new index; we are trying to
	** produce a meaningful mesdsage if the user issues CREATE INDEX
	** SESSION.<name>
	*/
	cb->pss_stmt_flags |= PSS_NEW_OBJ_NAME;
    }
;

index_unique:	    UNIQUE
    {
	$$ = TRUE;
	/* Set unique-with here in case this is inside an index-def
	** (new style) rather than the old style unique prefix.
	*/
	PSS_WC_SET_MACRO(PSS_WC_UNIQUE, &$Ywith_clauses);
    }
	    |
    {
	$$ = FALSE;
    }
;

indexlocname:	    NAME COLON obj_spec
    {
	DB_STATUS		status;

	status = psl_ci2_index_prefix(cb, psq_cb, &$Ywith_clauses, $Yunique);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	status = psl_ci5_indexlocname(cb, $1, $3, &$Ywith_clauses, psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* 
	** test indexname for reserved name
	*/
	if (PSL_IS_RESERVED_IDENT($3->pss_orig_obj_name, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	/* finished parsing the name of the new object */
	cb->pss_stmt_flags &= ~PSS_NEW_OBJ_NAME;
    }
	|	    obj_spec
    {
	DB_STATUS		status;

	status = psl_ci2_index_prefix(cb, psq_cb, &$Ywith_clauses, $Yunique);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	status = psl_ci5_indexlocname(cb, (char *) NULL, $1, &$Ywith_clauses,
	    psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* test indexname for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT($1->pss_orig_obj_name, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	/* finished parsing the name of the new object */
	cb->pss_stmt_flags &= ~PSS_NEW_OBJ_NAME;
    }
;

indexrel:           obj_spec
    {
	DB_STATUS		status;

	status = psl_ci3_indexrel(cb, $1, &psq_cb->psq_error, psq_cb->psq_mode);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

indexcols:	    indexcol
	  |	    indexcols COMMA indexcol
;

indexcol:	    col_spec asc_desc
    {
	DB_STATUS		status;

	status = psl_ci4_indexcol(cb, $1, &psq_cb->psq_error, FALSE);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

asc_desc:	    /* empty = ASC */
    {
	$$ = PSS_ASCENDING;
    }
	    |	    ASC
    {
	$$ = PSS_ASCENDING;
    }
	    |	    nonkeyword
    {
	if (STcompare($1, "desc"))
	{
	    psl_yerror(3, cb, psq_cb);
	    return (E_DB_ERROR);
	}

	$$ = PSS_DESCENDING;
    }
;


copy:              copstmnt copytable coparam keywd
		   copyfile copywith
    {
	DB_STATUS		status;

	status = psl_cp1_copy(cb, psq_cb, &$Yxlated_qry,
			$Yscanbuf_ptr, &$Ywith_clauses, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
;

copstmnt:          COPY copy_tbl_kwd
    {
	DB_STATUS		status;
	
	status = psl_cp2_copstmnt( cb, &psq_cb->psq_mode, &$Ywith_clauses,
				   &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
;

copy_tbl_kwd:	    TABLE
		|
;

copytable:	    obj_spec
    {
	DB_STATUS           	status;
	i4			rngvar_info;
	PSS_RNGTAB		*resrange;

	if ($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, "", &$1->pss_owner,
			 &$1->pss_obj_name, cb, FALSE, &resrange,
			 psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, -1, "", &$1->pss_obj_name, cb,
		FALSE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
		&rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    $1->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (DB_FAILURE_MACRO(status))
	    return (status);

	status = psl_cp3_copytable(cb, resrange, &$1->pss_obj_name,
		&$Yxlated_qry, psq_cb->psq_ldbdesc, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
;

coparam:           LPAREN cospecs RPAREN
    {
    }
          |	   LPAREN RPAREN
    {
	DB_STATUS           	status;

	status = psl_cp4_coparam(cb, &$Yxlated_qry, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
;

cospecs:	    entname EQUAL fmtspec
    {
	DB_STATUS           	status;

	status = psl_cp5_cospecs(cb, &$Yxlated_qry, $1,
		$Yscanbuf_ptr, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
	    |	    cospecs COMMA entname EQUAL fmtspec
    {
	DB_STATUS           	status;

	status = psl_cp5_cospecs(cb, &$Yxlated_qry, $3,
		$Yscanbuf_ptr, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
;

entname:	    col_spec
    {
	DB_STATUS		status;

	status = psl_cp6_entname(cb, $1, &psq_cb->psq_error, &$Yscanbuf_ptr);

	if (DB_FAILURE_MACRO(status))
	    return (status);

	cb->pss_stmt_flags &= ~PSS_CP_DUMMY_COL;
	$$ = $1;
    }
;

fmtspec:	    coent
	    |	    coent WITH NULLWORD
    {
	DB_STATUS		status;

	status = psl_cp7_fmtspec(cb, &psq_cb->psq_error, FALSE);

	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
	    |	    coent WITH NULLWORD LPAREN covalue RPAREN
    {
	DB_STATUS		status;

	status = psl_cp7_fmtspec(cb, &psq_cb->psq_error, TRUE);

	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
;

cp_delim:
    {
	/* no delimiter */
	$$ = (char *) NULL;
    }
	|	    nonkey_or_sconst
    {
	$$ = $1;
    }
	|	    NULLWORD
    {
	$$ = "null";
    }
;

coent:             nonkey_or_sconst
    {
	DB_STATUS		status;

	/*
	** This is a column type, possibly with a delimiter, possibly quoted.
	**     - i4
	**     - c0tab
	**     - date
	**     - 'd0null'
	*/

	status = psl_cp8_coent(cb, psq_cb, (bool) TRUE, $1, 0, (i4 *) NULL,
	    (char *) NULL);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	  tname LPAREN intconst_p RPAREN cp_delim
    {
	DB_STATUS		status;
	i4			len = (i4) $3;

	/*
	** This is a column type, length and, possibly, a delimiter (which
	** may be quoted).
	**     - text(40)[[']nl[']]
	*/

	status = psl_cp8_coent(cb, psq_cb, (bool) FALSE, $1, 1, &len, $5);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	tname LPAREN intconst_p COMMA intconst_p RPAREN cp_delim
    {
	DB_STATUS		status;
	i4			len[2];

	/*
	** This is a column type, length and, possibly, a delimiter (which
	** may be quoted).
	**     - decimal(15,2)[[']nl[']]
	*/

	len[0] = $3;
	len[1] = $5;
	status = psl_cp8_coent(cb, psq_cb, (bool) FALSE, $1, 2, len, $7);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

covalue:	    sign_op I2CONST
    {
	QEF_RCB		*qef_rcb;
	QEU_CPDOMD	*cpdom_desc;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    cpdom_desc = qef_rcb->qeu_copy->qeu_fdesc->cp_cur_fdd;

	    if ($1 == ADI_MINUS_OP)
		*$2 = -(*$2);
	    cpdom_desc->cp_nulldbv.db_datatype = DB_INT_TYPE;
	    cpdom_desc->cp_nulldbv.db_prec = 0;
	    cpdom_desc->cp_nulldbv.db_length = sizeof(i2);
	    cpdom_desc->cp_nulldbv.db_data = (PTR) $2;
	}
    }
	    |	    sign_op I4CONST
    {
	QEF_RCB		*qef_rcb;
	QEU_CPDOMD	*cpdom_desc;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    cpdom_desc = qef_rcb->qeu_copy->qeu_fdesc->cp_cur_fdd;

	    if ($1 == ADI_MINUS_OP)
		*$2 = -(*$2);
	    cpdom_desc->cp_nulldbv.db_datatype = DB_INT_TYPE;
	    cpdom_desc->cp_nulldbv.db_prec = 0;
	    cpdom_desc->cp_nulldbv.db_length = sizeof(i4);
	    cpdom_desc->cp_nulldbv.db_data = (PTR) $2;
	}
    }
	    |	    sign_op I8CONST
    {
	QEF_RCB		*qef_rcb;
	QEU_CPDOMD	*cpdom_desc;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    cpdom_desc = qef_rcb->qeu_copy->qeu_fdesc->cp_cur_fdd;

	    if ($1 == ADI_MINUS_OP)
		*$2 = -(*$2);
	    cpdom_desc->cp_nulldbv.db_datatype = DB_INT_TYPE;
	    cpdom_desc->cp_nulldbv.db_prec = 0;
	    cpdom_desc->cp_nulldbv.db_length = sizeof(i8);
	    cpdom_desc->cp_nulldbv.db_data = (PTR) $2;
	}
    }
	    |	    sign_op DECCONST
    {
	QEF_RCB		*qef_rcb;
	QEU_CPDOMD	*cpdom_desc;
	i2		prec_scale;
	i4		prec;
	i4		scale;
	u_char		tmp[DB_MAX_DECLEN];
	PTR		d;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    cpdom_desc = qef_rcb->qeu_copy->qeu_fdesc->cp_cur_fdd;

	    I2ASSIGN_MACRO(*$2, prec_scale);
	    prec  = DB_P_DECODE_MACRO(prec_scale);
	    scale = DB_S_DECODE_MACRO(prec_scale);
	    d     = (PTR)($2 + sizeof(i2));

	    if ($1 == ADI_MINUS_OP)
	    {
		MEcopy(d, DB_PREC_TO_LEN_MACRO(prec), (PTR)tmp);
		MHpkneg((PTR)tmp, prec, scale, d);
	    }
	
	    cpdom_desc->cp_nulldbv.db_datatype = DB_DEC_TYPE;
	    cpdom_desc->cp_nulldbv.db_prec = prec_scale;
	    cpdom_desc->cp_nulldbv.db_length = DB_PREC_TO_LEN_MACRO(prec);
	    cpdom_desc->cp_nulldbv.db_data = d;
	}
    }
	    |	    sign_op F4CONST
    {
	QEF_RCB		*qef_rcb;
	QEU_CPDOMD	*cpdom_desc;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    cpdom_desc = qef_rcb->qeu_copy->qeu_fdesc->cp_cur_fdd;

	    if ($1 == ADI_MINUS_OP)
		*$2 = -(*$2);
	    cpdom_desc->cp_nulldbv.db_datatype = DB_FLT_TYPE;
	    cpdom_desc->cp_nulldbv.db_prec = 0;
	    cpdom_desc->cp_nulldbv.db_length = sizeof(f4);
	    cpdom_desc->cp_nulldbv.db_data = (PTR) $2;
	}
    }
	    |	    sign_op F8CONST
    {
	QEF_RCB		*qef_rcb;
	QEU_CPDOMD	*cpdom_desc;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    cpdom_desc = qef_rcb->qeu_copy->qeu_fdesc->cp_cur_fdd;

	    if ($1 == ADI_MINUS_OP)
		*$2 = -(*$2);
	    cpdom_desc->cp_nulldbv.db_datatype = DB_FLT_TYPE;
	    cpdom_desc->cp_nulldbv.db_prec = 0;
	    cpdom_desc->cp_nulldbv.db_length = sizeof(f8);
	    cpdom_desc->cp_nulldbv.db_data = (PTR) $2;
	}
    }
	    |	    HEXCONST
    {
	QEF_RCB		*qef_rcb;
	QEU_CPDOMD	*cpdom_desc;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    cpdom_desc = qef_rcb->qeu_copy->qeu_fdesc->cp_cur_fdd;

	    cpdom_desc->cp_nulldbv.db_datatype = DB_VCH_TYPE;
	    cpdom_desc->cp_nulldbv.db_prec = 0;
	    cpdom_desc->cp_nulldbv.db_length = 
				(i4)$1->db_t_count + DB_CNTSIZE;
	    cpdom_desc->cp_nulldbv.db_data = (PTR) $1;
	}
    }
	    |	    SCONST
    {
	QEF_RCB		*qef_rcb;
	QEU_CPDOMD	*cpdom_desc;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    cpdom_desc = qef_rcb->qeu_copy->qeu_fdesc->cp_cur_fdd;

	    cpdom_desc->cp_nulldbv.db_datatype = DB_VCH_TYPE;
	    cpdom_desc->cp_nulldbv.db_prec = 0;
	    cpdom_desc->cp_nulldbv.db_length = 
				(i4)$1->db_t_count + DB_CNTSIZE;
	    cpdom_desc->cp_nulldbv.db_data = (PTR) $1;
	}
    }
;

sign_op:	UAOP
    {
	if ($1 == ADI_SUB_OP)
	    $$ = ADI_MINUS_OP;
	else
	    $$ = ADI_PLUS_OP;
    }
	|
    {
	$$ = ADI_PLUS_OP;
    }
;

keywd:             INTO
    {
	QEF_RCB			*qef_rcb;
	DB_STATUS	status;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    qef_rcb->qeu_copy->qeu_direction = CPY_INTO;
	}
	else
	{
	    status = psq_x_add(cb, "", &cb->pss_ostream,
				$Yxlated_qry.pss_buf_size,
				&$Yxlated_qry.pss_q_list,
				(i4) -1,	
				(char *)NULL, (char *)NULL, "into ", 
				&psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}
    }
          |
                    FROM
    {
	QEF_RCB			*qef_rcb;
	DB_STATUS	status;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    qef_rcb->qeu_copy->qeu_direction = CPY_FROM;
	}
	else
	{
	    status = psq_x_add(cb, "", &cb->pss_ostream,
				$Yxlated_qry.pss_buf_size,
				&$Yxlated_qry.pss_q_list,
				(i4) -1,	
				(char *)NULL, (char *)NULL, "from ", 
				&psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}
    }
;

copyfile:	    strconst
    {
	QEF_RCB		*qef_rcb;
	QEU_COPY	*qe_copy;
	DB_STATUS	status;

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    status = psq_x_add(cb, $1, &cb->pss_ostream,
				$Yxlated_qry.pss_buf_size,
				&$Yxlated_qry.pss_q_list,
				(i4)STlength((char *)$1),	
				"\'", "\'", (char *) NULL, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	    $Yscanbuf_ptr = (PTR) cb->pss_nxtchar;
	}
	else
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    qe_copy = qef_rcb->qeu_copy;

	    /*
	    ** Copy the filename to the control block.
	    */
	    status = psf_malloc(cb, &cb->pss_ostream, STlength((char *) $1) + 1,
		(PTR *) &qe_copy->qeu_fdesc->cp_filename, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	    STcopy((char *) $1, qe_copy->qeu_fdesc->cp_filename);
	}
    }
	  |
		    nonkeyword
    {
	QEF_RCB		*qef_rcb;
	i4		err_code;


	if (STcompare($1, "program") != 0)
	{
	    (VOID) psf_error(5851L, 0L, PSF_USERERR, &err_code, 
		    &psq_cb->psq_error, 1, STlength($1), $1);
	    return (E_DB_ERROR);
	}

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    qef_rcb->qeu_copy->qeu_stat |= CPY_PROGRAM;
	}
    }
;

copywith:
	|    WITH copyclause
    {
    }
;

copyclause:	    copyoption
    {
    }
	  |
		    copyclause COMMA copyoption
    {
    }
;

copyoption:	    nonkeyword EQUAL nonkeyword
    {
	DB_STATUS	status;

    	status = psl_cp9_nm_eq_nm(cb, $1, $3, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	  |	    nonkeyword EQUAL CONTINUE
    {
	DB_STATUS	status;

    	status = psl_cp9_nm_eq_nm(cb, $1, "continue", &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	  |	    ROLLBACK EQUAL nonkeyword
    {
	DB_STATUS	status;

    	status = psl_cp9_nm_eq_nm(cb, "rollback", $3, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	  |	    nonkeyword EQUAL SCONST
    {
	DB_STATUS	status;

    	status = psl_cp10_nm_eq_str(cb, $1, sconvert($3), &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	  |	    nonkeyword EQUAL int2_int4_p
    {
	DB_STATUS	status;

    	status = psl_cp11_nm_eq_no( cb, $1, $3, &$Ywith_clauses, 
				    &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	  |	    nonkeyword EQUAL QDATA
    {
	DB_STATUS	status;

    	status = psl_cp12_nm_eq_qdata(cb, psq_cb, $1, $3, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
        |	nonkeyword
    {
	DB_STATUS	status;

    	status = psl_cp13_nm_single(cb, $1, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

create_integrity:   integstmnt ON integtbl IS boolean_expr
    {
	DB_STATUS       status;
	PST_RT_NODE	root;
	PST_QNODE	*rootnode;
	PST_QTREE	*tree;
	PSY_CB		*psy_cb;
	i4		err_code;
	PST_PROCEDURE   *pnode;

	/* Make the ROOT node */
	root.pst_rtuser = TRUE;
	root.pst_union.pst_next  = 0;
	root.pst_dups   = PST_ALLDUPS;
	MEcopy((char *)&$Yflists[cb->pss_qualdepth], sizeof(PST_J_MASK),
				(char *)&$Yfrom_list);
	root.pst_tvrc   = BTcount((char *) &$Yfrom_list, BITS_IN($Yfrom_list));
	MEcopy((char *)&$Yfrom_list, sizeof(PST_J_MASK), 
					(char *)&root.pst_tvrm);
	/* the range var map is actually filled again in psydint.c */

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    $5->pss_tree, PST_ROOT,
	    (PTR) &root, sizeof(PST_RT_NODE), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &rootnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	    return (status);

	/* make sure no tids in the integrity */
	if (psy_qscan(rootnode, cb->pss_resrng->pss_rgno, DB_IMTID))
	{
	    (VOID) psf_error(3496L, 0L, PSF_USERERR, &err_code, 
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	/* Make the query tree header */
	status = pst_header(cb, psq_cb, PST_UNSPECIFIED, (PST_QNODE *) NULL,
	    rootnode, &tree, &pnode, ($Yisdbp) ? 0 : PST_0FULL_HEADER,
	    &$Yxlated_qry);
	if (status != E_DB_OK)
	    return (status);

	/* Make sure there are no aggregates in qualification */
	if (tree->pst_agintree)
	{
	    (VOID) psf_error(3490L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname);
	    return (E_DB_ERROR);
	}
	/* make sure there are no subselects in qualification */
	if (tree->pst_subintree)
	{
	    (VOID) psf_error(3497L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname);
	    return (E_DB_ERROR);
	}
	
	/* Make sure the integrity has only one range variable */
	if (cb->pss_auxrng.pss_maxrng > 0)
	{
	    (VOID) psf_error(3491L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname);
	    return (E_DB_ERROR);
	}

	/*
	** By definition, integrity can not possibly involve a join.  Since
	** pst_numjoins was set to PST_NOJOIN in pst_header(), we do not need to
	** do it here.
	*/

	/* Set the root in QSF */
	if (pnode != (PST_PROCEDURE *) NULL)
	{
	    status = psf_mroot(cb, &cb->pss_ostream, (PTR) pnode, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	}

	/* Put the query text in a contiguous block in QSF */
	status = psq_tout(cb, (PSS_USRRANGE*) NULL, 
	    cb->pss_tchain, &cb->pss_tstream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/*
	** We want to give the control block back to the caller.  However,
	** the control block has been allocated using the control block
	** stream, and it's the output stream that gets handed back to the
	** caller.  Therefore, we must swap the control block and output
	** streams.
	*/
	/* Copy the query tree stream so we can re-use it */
	STRUCT_ASSIGN_MACRO(cb->pss_ostream, cb->pss_cbstream);

	/* Create the PSY_CB for the integrity definition */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return(status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Fill in QSF object ids for query tree and modified query text */
	STRUCT_ASSIGN_MACRO(cb->pss_tstream.psf_mstream, psy_cb->psy_qrytext);
	STRUCT_ASSIGN_MACRO(cb->pss_cbstream.psf_mstream, psy_cb->psy_intree);

	/* Fill in table id and table name */
	STRUCT_ASSIGN_MACRO($3->pss_tabid, psy_cb->psy_tables[0]);
	STRUCT_ASSIGN_MACRO($3->pss_tabname, psy_cb->psy_tabname[0]);
    }
;

integstmnt:        CRTINTEG
    {
	i4                err_code;
	DB_STATUS	       status;
	PTR		       piece;

	psq_cb->psq_mode = PSQ_INTEG;

	/* "create integrity" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(3495L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Open the memory stream for allocating the query tree */
	if ($Yisdbp == FALSE)
	{
	    status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
		&psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}

	/*
	** The "create integrity" statement requires query text to be stored in
	** the iiqrytext relation.  Open a text chain and put the initial
	** words "create integrity " in it.  The text chain will be coalesced
	** into a contiguous block later.
	*/
	cb->pss_stmt_flags |= PSS_TXTEMIT;	    /* Indicate to emit text */
	status = psq_topen(&cb->pss_tchain, &cb->pss_memleft,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
	status = psq_tadd(cb->pss_tchain, (u_char *) "create integrity ",
	    sizeof("create integrity ") - 1, &piece, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* The FROM clause is not present, therefore
	** the bitmap needs to be initialized.
	*/
	MEfill(sizeof(PST_J_MASK), 0, (char *)&$Yflists[cb->pss_qualdepth]);

	/*
	** If the name of the object on which the integrity is being created is
	** that of a synonym, we will replace it with the name of the actual
	** table.
	*/
	$Yqry_mask |= PSS_REPL_SYN_WITH_ACTUAL;
    }
;

integtbl:	    from_item
    {
	i4     err_code;
	i4	    mask;
	i4     mask2;
	i4	    err_no = 0L;

	/*
	** On an integrity definition, remember what the result range variable
	** is.  This can't be stored in the result range variable slot in
	** the user range table, because that is not for "real" range variables,
	** only for result tables (as in an append).
	*/
	cb->pss_resrng = $1;

	mask = cb->pss_resrng->pss_tabdesc->tbl_status_mask;
	mask2 = cb->pss_resrng->pss_tabdesc->tbl_2_status_mask;

	/*
	** Check for integrities on views.
	*/
	if (mask & DMT_VIEW)
	{
	    err_no = 3493L;
	}
	else if (mask & DMT_IDX)
	{
	    err_no = 9348;
	}
	else if ((mask & DMT_CATALOG) || (mask2 & DMT_TEXTENSION))
	{
	    /* If not an extended catalog and no catalog update
	    ** permission - error.
	    */
	    if (~mask & DMT_EXTENDED_CAT
		&& !(cb->pss_ses_flag & PSS_CATUPD) )
	    {
		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    DB_STATUS	local_status;
		    DB_ERROR	e_error;
		    /*
		    ** Audit failure to create integrity
		    */
		    local_status = psy_secaudit( FALSE, cb, 
			    cb->pss_resrng->pss_tabname.db_tab_name, 
			    &cb->pss_resrng->pss_ownname,
			    sizeof(cb->pss_resrng->pss_tabname),
			    SXF_E_TABLE, I_SX203D_INTEGRITY_CREATE,
			    SXF_A_FAIL | SXF_A_CONTROL, 
			    &e_error);
		}
		/*
		** let user know if name supplied by the him was resolved to a
		** synonym
		*/
		if ($Yrngvar_info & PSS_BY_SYNONYM)
		{
		    psl_syn_info_msg(cb, cb->pss_resrng, &$Yobj_spec,
			$Yrngvar_info, sizeof("CREATE INTEGRITY")-1,
			"CREATE INTEGRITY", &psq_cb->psq_error);
		}				      

		(VOID) psf_error(3498L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2, 
		    sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(sizeof(DB_TAB_NAME),
			(char *) &cb->pss_resrng->pss_tabname),
		    &cb->pss_resrng->pss_tabname);
		return (E_DB_ERROR);
	    }
	}
	/* Check for integrity on table owned by someone else. */
	else if (MEcmp((PTR) &cb->pss_user, 
	               (PTR) &cb->pss_resrng->pss_tabdesc->tbl_owner,
		       sizeof(DB_OWN_NAME)))
	{
	    err_no = 3494L;
	}

	if (err_no != 0L)
	{
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_STATUS	local_status;
		DB_ERROR	e_error;
		/*
		** Audit failure to create integrity
		*/
		local_status = psy_secaudit( FALSE, cb, 
		    cb->pss_resrng->pss_tabname.db_tab_name, 
		    &cb->pss_resrng->pss_ownname,
		    sizeof(cb->pss_resrng->pss_tabname),
		    SXF_E_TABLE, I_SX203D_INTEGRITY_CREATE,
		    SXF_A_FAIL | SXF_A_CONTROL, 
		    &e_error);
	    }
	    /*
	    ** let user know if name supplied by the user was resolved to a
	    ** synonym
	    */
	    if ($Yrngvar_info & PSS_BY_SYNONYM)
	    {
		psl_syn_info_msg(cb, cb->pss_resrng, &$Yobj_spec, $Yrngvar_info,
		    sizeof("CREATE INTEGRITY")-1, "CREATE INTEGRITY",
		    &psq_cb->psq_error);
	    }				      

	    (VOID) psf_error(err_no, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname);
	    return (E_DB_ERROR);
	}

	$$ = $1;
    }
;

create_permit:         permit_prefix permtd where
    {
	DB_STATUS       status;
	PSF_MSTREAM	tempstream;
	PST_QNODE	*rootnode;
	PST_RT_NODE	root;
	PSY_CB		*psy_cb;
	PST_QTREE	*tree;
	i4		err_code;

	/* Restore mode in case subselect in where clause changed it */
	psq_cb->psq_mode = PSQ_PROT;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* mark if we have a qualification */
	if (($3)->pst_sym.pst_type != PST_QLEND)
	{
	    PST_PROCEDURE   *pnode;

	    psy_cb->psy_istree = TRUE;

	    /* Make the ROOT node */
	    root.pst_rtuser = TRUE;
	    root.pst_union.pst_next  = 0;
	    root.pst_dups   = PST_ALLDUPS;
	    MEcopy((char *)&$Yflists[cb->pss_qualdepth], sizeof(PST_J_MASK),
				(char *)&$Yfrom_list);
	    root.pst_tvrc   = BTcount((char *) &$Yfrom_list,
		BITS_IN($Yfrom_list));
	    MEcopy((char *)&$Yfrom_list, sizeof(PST_J_MASK), 
					(char *)&root.pst_tvrm);
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL, $3, 
		PST_ROOT, (PTR) &root, sizeof(PST_RT_NODE), DB_NODT, (i2) 0,
		(i4) 0, (DB_ANYTYPE *) NULL, &rootnode, &psq_cb->psq_error,
		(i4) 0);
	    if (status != E_DB_OK)
		return (status);

	    /* Make the query tree header */
	    status = pst_header(cb, psq_cb, PST_UNSPECIFIED, (PST_QNODE *) NULL,
		rootnode, &tree, &pnode, ($Yisdbp) ? 0 : PST_0FULL_HEADER,
		&$Yxlated_qry);
	    if (status != E_DB_OK)
		return (status);

	    /* set pst_numjoins.  $Yjoin_id contains the highest join id */
	    tree->pst_numjoins = $Yjoin_id;


	    /* Set the root in QSF */
	    if (pnode != (PST_PROCEDURE *) NULL)
	    {
		status = psf_mroot(cb, &cb->pss_ostream, (PTR) pnode,
		    &psq_cb->psq_error);
		if (status != E_DB_OK)
		    return (status);
	    }

	    /*
	    ** Copy the object ids for the query tree and query text to the
	    ** control block.
	    */
	    STRUCT_ASSIGN_MACRO(cb->pss_ostream.psf_mstream,
				psy_cb->psy_intree);

	    /*
	    ** Issue a warning  here; this permit is not GRANT compatible
	    ** it contains a qualification.
	    */
	    (VOID) psf_error(2331L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(sizeof(DB_TAB_NAME),
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname);
	}
	else
	{
	    /* There is no QTREE, so close QTREE stream */
	    status = psf_mclose(cb, &cb->pss_ostream, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	    cb->pss_ostream.psf_mstream.qso_handle = (PTR) NULL;
	}


	/*
	** We want to give the control block back to the caller.  However,
	** the control block has been allocated using the control block
	** stream, and it's the output stream that gets handed back to the
	** caller.  Therefore, we must swap the control block and output
	** streams.
	*/
	if (psy_cb->psy_istree)
	{
	    STRUCT_ASSIGN_MACRO(cb->pss_ostream, tempstream);
	    STRUCT_ASSIGN_MACRO(cb->pss_cbstream, cb->pss_ostream);
	    STRUCT_ASSIGN_MACRO(tempstream, cb->pss_cbstream);
	}
	else
	{
	    STRUCT_ASSIGN_MACRO(cb->pss_cbstream, cb->pss_ostream);
	    cb->pss_cbstream.psf_mstream.qso_handle = (PTR) NULL;
	}
	/* Put the query text in a contiguous block in QSF */
	status = psq_tout(cb, (PSS_USRRANGE*) NULL, 
	    cb->pss_tchain, &cb->pss_tstream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	STRUCT_ASSIGN_MACRO(cb->pss_tstream.psf_mstream, psy_cb->psy_qrytext);
    }
;

permit_prefix:	    permstmnt permspec
    {
	PTR		piece;
	DB_STATUS	status;
	char		*str;

	/*
	** The "create permit" statement requires query text to be stored in
	** the iiqrytext relation.  Open a text chain and store the initial
	** string.  Note the initial string includes a placeholder for a
	** privilege name (one of SELECT, INSERT, DELETE, UPDATE) if more than
	** one privilege has been specified; otherwise that actual privilege
	** name will be inserted.
	** The text chain will be coalesced into a contiguous block later.
	*/
	cb->pss_stmt_flags |= PSS_TXTEMIT;	    /* Indicate to emit text */

	status = psq_topen(&cb->pss_tchain, &cb->pss_memleft,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** initial string has to be different depending on how the privileges
	** were specified;  if ALL was specified, ON has not been seen by the
	** scanner yet, on the other hand, if a privilege list was specified,
	** scanner has already seen ON, so we must include ON in the initial
	** string
	*/
	if ($2 == 1)	    /* CREATE PERMIT ALL */
	{
	    str = "create permit ??????";
	}
	else		    /* CREATE PERMIT <privileges> */
	{
	    PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;

	    /*
	    ** if only one privilege was specified, we will insert it into the
	    ** template now; otherwise, we will store the placeholder
	    */

	    if (BTcount((char *) &psy_cb->psy_opmap, BITS_IN(psy_cb->psy_opmap))
		    > 1)
	    {
		str = "create permit ?????? on";
	    }
	    else if (psy_cb->psy_opmap == DB_RETRIEVE)
	    {
		str = "create permit select on";
	    }
	    else if (psy_cb->psy_opmap == DB_REPLACE)
	    {
		str = "create permit update on";
	    }
	    else if (psy_cb->psy_opmap == DB_DELETE)
	    {
		str = "create permit delete on";
	    }
	    else
	    {
		str = "create permit insert on";
	    }
	}

	status = psq_tadd(cb->pss_tchain, (u_char *) str, STlength(str), &piece,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

    }
		    permword permtbl permtarg permwho permplace
    {
	PSY_CB	*psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** If a list of columns to which privilege(s) will or will not (using
	** EXCLUDING clause) apply and priivleges other than UPDATE have been
	** specified, this permit is not GRANT-compatible (only column-specific
	** UPDATE is currently allowed with GRANT statement), so issue a warning
	** 
	** pretty soon it will allow column-specific INSERT as well, so we will
	** have to remember to change this test
	*/
	if (psy_cb->psy_numcols && psy_cb->psy_opmap & ~DB_REPLACE)
	{
	    i4	err_code;

	    (VOID) psf_error(2331L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname);
	}

	/*
	** We want to replace all references to synonyms in the where-clause of
	** the permit definition with the actual table names + all table names
	** in the from list(s) must be prefixed with their owner name.
	*/
	$Yqry_mask |= (PSS_REPL_SYN_WITH_ACTUAL | PSS_PREFIX_WITH_OWNER);
    }
;

permstmnt:         CRTPERM
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_PROT;

	/* "create permit" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(3596L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Open the memory stream for allocating the query tree */
	if ($Yisdbp == FALSE)
	{
	    status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
		&psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	}

	/* Allocate the PSY_CB for the create permit statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_cbstream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_grant = PSY_CPERM;	    /* indicate not GRANT stmnt */

	/* Default terminal name is "" */
	MEfill(sizeof(psy_cb->psy_terminal), ' ', (PTR) &psy_cb->psy_terminal);

	/* default user name is " " */
	MEfill(sizeof(psy_cb->psy_user), ' ', (PTR) &psy_cb->psy_user);
	
	/*
	** Default time is all day, starting at 00:00 and ending at 24:00,
	** given as minutes after 00:00.
	*/
	psy_cb->psy_timbgn = 0;
	psy_cb->psy_timend = 1440;

	/*
	** Default days are all week, starting with Sunday and ending with
	** Saturday.  Sunday = 0, Saturday = 6.
	*/
	psy_cb->psy_daybgn = 0;
	psy_cb->psy_dayend = 6;

	/* The FROM clause is not present, therefore
	** the bitmap needs to be initialized.
	*/
	MEfill(sizeof(PST_J_MASK), 0, (char *)&$Yflists[cb->pss_qualdepth]);

	/*
	** If the name of the object for which the permit is being created is
	** that of a synonym, we will replace it with the name of the actual
	** table.
	*/
	$Yqry_mask |= PSS_REPL_SYN_WITH_ACTUAL;
    }
;
    
permspec:	    permlist
    {
	$$ = 0;
    }
	  |         ALL
    {
	PSY_CB                 *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;
	psy_cb->psy_opmap = psy_cb->psy_opctl =
	    DB_RETRIEVE | DB_APPEND | DB_REPLACE | DB_DELETE;

	$$ = 1;
    }
;

permlist:           permission
    {
	PSY_CB		*psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_opmap |= $1;
	psy_cb->psy_opctl |= $1;
    }
          |         permlist COMMA permission
    {
	PSY_CB		*psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_opmap |= $3;
	psy_cb->psy_opctl |= $3;
    }
;

permission:         SELECT
    {
	$$ = DB_RETRIEVE;
    }
          |	    DELETE
    {
	$$ = DB_DELETE;
    }
          |	    INSERT
    {
	$$ = DB_APPEND;
    }
          |	    UPDATE
    {
	$$ = DB_REPLACE;
    }
;

permword:           ON
          |	    OF
          |	    TO
;

permtbl:	    from_item
    {
	PSY_CB		*psy_cb;
	i4		mask = $1->pss_tabdesc->tbl_status_mask;
	DB_STATUS	status;
	PSY_TBL		*psy_tbl;

	cb->pss_resrng = $1;

	/*
	** For the time being CREATE PERMIT can be used to create permits on
	** 1) objects owned by the current user,
	** 2) catalogs if the current user has CATUPD and
	** 3) extended catalogs if the current user is DBA;
	** the last two conditions will be eventually phased out, until then we
	** will not try to call psy_tbl_grant_check() (in psy_dperm()) to check
	** if the user can actually CREATE a permit on an object not owned by
	** him
	*/

	/*
	** One no longer has to be a DBA or $INGRES in order to
	** CREATE permission on tables other than catalogues.
	** psy_permit_ok() will be used to determine if permit may
	** be CREATEd
	*/

	if (!psy_permit_ok(mask, cb, &$1->pss_ownname))
	{
	    i4	err_code;

	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_STATUS	local_status;
		DB_ERROR	e_error;

		/* Must audit CREATE PERMIT failure. */
		
		local_status = psy_secaudit(FALSE, cb,
			    (char *)&$1->pss_tabdesc->tbl_name,
			    &$1->pss_tabdesc->tbl_owner,
			    sizeof(DB_TAB_NAME), SXF_E_TABLE,
			    I_SX2016_PROT_TAB_CREATE, SXF_A_FAIL | SXF_A_MOD_DAC,
			    &e_error);
	    }

	    /*
	    ** let user know if name supplied by the him was resolved to a
	    ** synonym
	    */
	    if ($Yrngvar_info & PSS_BY_SYNONYM)
	    {
		psl_syn_info_msg(cb, cb->pss_resrng, &$Yobj_spec,
		    $Yrngvar_info, sizeof("CREATE PERMIT")-1,
		    "CREATE PERMIT", &psq_cb->psq_error);
	    }				      

	    (VOID) psf_error(3592L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME), (char *) &$1->pss_tabname),
		&$1->pss_tabname);
	    return (E_DB_ERROR);
	}

	/* Copy table id and table name to control block */
	psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** Allocate memory for a table entry - use the same stream from which
	** PSY_CB was allocated - pss_cbstream
	*/
	status = psf_malloc(cb, &cb->pss_cbstream, (i4) sizeof(PSY_TBL),
	    (PTR *) &psy_tbl, &psq_cb->psq_error);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/*
	** Copy table id, table name, and owner name in table entry.
	*/
	STRUCT_ASSIGN_MACRO(cb->pss_resrng->pss_tabid, psy_tbl->psy_tabid);
	STRUCT_ASSIGN_MACRO(cb->pss_resrng->pss_tabname, psy_tbl->psy_tabnm);
	STRUCT_ASSIGN_MACRO(cb->pss_resrng->pss_ownname, psy_tbl->psy_owner);
	
	/* remember the object type */
	if (mask & DMT_VIEW)
	{
	    psy_tbl->psy_mask = PSY_OBJ_IS_VIEW;
	}
	else if (mask & DMT_IDX)
	{
	    psy_tbl->psy_mask = PSY_OBJ_IS_INDEX;
	}
	else
	{
	    psy_tbl->psy_mask = PSY_OBJ_IS_TABLE;
	}

	/*
	** Attach element to the list.
	*/
	(VOID) QUinsert((QUEUE *) psy_tbl, (QUEUE *) &psy_cb->psy_tblq);

	$$ = $1;
    }
;

permtarg:           LPAREN permtlist RPAREN
	  |	    EXCLUDING LPAREN permtlist RPAREN
    {
	PSY_CB  *psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_flags |= PSY_EXCLUDE_COLUMNS;
    }
          |
;

permtlist:          permtelm
          |	    permtlist COMMA permtelm
;

permtelm:           generic_ident
    {
	DMT_ATT_ENTRY	       *attribute;
	DB_ATT_NAME	       attname;
	i4		       err_code;
	PSY_CB		       *psy_cb;

	/* Look up the attribute number */
	STmove($1, ' ', sizeof(DB_ATT_NAME), (char *) &attname);
	attribute = pst_coldesc(cb->pss_resrng, &attname);

	/* Check for attribute not found */
	if (attribute == (DMT_ATT_ENTRY *) NULL)
	{
	    psf_error(2100L, 0L, PSF_USERERR, &err_code, &psq_cb->psq_error, 4,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname,
		psf_trmwhite(sizeof(DB_OWN_NAME), 
		    (char *) &cb->pss_resrng->pss_ownname),
		&cb->pss_resrng->pss_ownname,
		STtrmwhite($1), $1);
	    return (E_DB_ERROR);
	}

	/* Copy the attribute number to the control block */
	psy_cb = (PSY_CB *) cb->pss_object;
	if (psy_cb->psy_numcols >= DB_MAX_COLS)
	{
	    (VOID) psf_error(2113L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, sizeof (cb->pss_lineno), &cb->pss_lineno);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_cols[psy_cb->psy_numcols++].db_att_id =
	    (i2) attribute->att_number;
    }
;

permwho:	    TO user_ident
    {
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;

	/* {@fix_me@} */	/* Check validity of user name? */

	STmove($2, ' ', sizeof(DB_OWN_NAME), (char *) &psy_cb->psy_user);

	/* granted to a user */
	psy_cb->psy_gtype = DBGR_USER;
    }
          |	    TO ALL
    {
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;

	/* granted to public */
	psy_cb->psy_gtype = DBGR_PUBLIC;

	/* psy_cb->psy_user has already been blank-filled */
    }
;

permplace:         AT NAME
    {
	PSY_CB                 *psy_cb = (PSY_CB *) cb->pss_object;

#ifdef NOT_NEEDED
	/* Check validity of terminal name */
	if (!TEvalid($2))
	{
	    i4		err_code;

	    (VOID) psf_error(3590L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, STtrmwhite($2), $2);
	    return (E_DB_ERROR);
	}
#endif
	/* Copy terminal name to control block */
	STmove($2, ' ', sizeof(DB_TERM_NAME), (char *) &psy_cb->psy_terminal);
    }
          |
                    AT ALL  /* Default already filled in */
          |
;

permtd:             permtime permday
          |
                    permday
          |
                    permtime
          |
;

permtime:	    FROM timeofday TO timeofday
    {
	PSY_CB                 *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;
	psy_cb->psy_timbgn = $2;
	psy_cb->psy_timend = $4;
    }
;

timeofday:	    intconst_e COLON intconst_e
    {
	i4                err_code;

	/* Check validity of hours */
	if ($1 > 24 || $1 < 0)
	{
	    (VOID) psf_error(2136L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof (cb->pss_lineno), &cb->pss_lineno,
		sizeof($1), &($1));
	    return (E_DB_ERROR);
	}

	/* Check validity of minutes */
	if ($3 > 59 || $3 < 0)
	{
	    (VOID) psf_error(2137L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof (cb->pss_lineno), &cb->pss_lineno,
		sizeof($3), &($3));
	    return (E_DB_ERROR);
	}

	/* If hours are 24, make sure minutes are 0 (e.g. 24:10 illegal) */
	if ($1 == 24 && $3 != 0)
	{
	    (VOID) psf_error(2138L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof (cb->pss_lineno), &cb->pss_lineno,
		sizeof($3), &($3));
	    return (E_DB_ERROR);
	}

	$$ = ($1 * 60) + $3;
    }
;

permday:           ON NAME TO NAME
    {
	PSY_CB                 *psy_cb;
	i4		       err_code;
	i4		       daynum;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Convert beginning day of week string to number */
	daynum = psq_cvtdow($2);
	if (daynum < 0)
	{
	    (VOID) psf_error(3594L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname,
		STtrmwhite($2), $2);
	    return (E_DB_ERROR);
	}
	psy_cb->psy_daybgn = daynum;

	/* Convert ending day of week string to number */
	daynum = psq_cvtdow($4);
	if (daynum < 0)
	{
	    (VOID) psf_error(3594L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname,
		STtrmwhite($4), $4);
	    return (E_DB_ERROR);
	}
	psy_cb->psy_dayend = daynum;
    }
;

/*
** Yacc production:  create_event	- Create an event
**
** Statement Syntax:
**	CREATE DBEVENT event_name
** Return State:
**	PSQ_CB.psq_mode    = PSQ_EVENT
**	PSY_CB.psy_event   = Event tuple constructed (name & type)
**	      .psy_qrytext = Text of statement
*/
create_event:	crev_kwd obj_spec
    {
	i4         err_code;
	DB_STATUS	status;
	PSY_CB		*psy_cb;
	PTR		piece;
	i4		name_len;
	u_char		*name;
	u_char		delim_id[DB_MAX_DELIMID];

        if (cb->pss_distrib & DB_3_DDB_SESS)
        {
            (VOID) psf_error(6350L, 0L, PSF_USERERR,
                &err_code, &psq_cb->psq_error, 1,
                (i4) sizeof("CREATE DBEVENT")-1, "CREATE DBEVENT");
            return (E_DB_ERROR);    /* non-zero return means error */
        }

	/* test event name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT($2->pss_orig_obj_name, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	/* If name was qualified, it'd better be the same as the user */
	if ($2->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp((PTR) &$2->pss_owner, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME)))
	{
	    (VOID) psf_error(E_PS0421_CRTOBJ_NOT_OBJ_OWNER, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof("CREATE DBEVENT") - 1, "CREATE DBEVENT",
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &$2->pss_owner),
		&$2->pss_owner);
	    return(E_DB_ERROR);
	}

	/* Allocate the PSY_CB for the CREATE DBEVENT statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* The "create dbevent" statement requires query text to be saved */
	status = psq_topen(&cb->pss_tchain, &cb->pss_memleft,
			   &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	name = (u_char *) ERx("create dbevent ");
	status = psq_tadd(cb->pss_tchain,  name, STlength((char *) name), 
			  &piece, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* add the event name to the text
	 */
	name     = (u_char *) $2->pss_obj_name.db_tab_name;
	name_len = psf_trmwhite(DB_MAXNAME, $2->pss_obj_name.db_tab_name);

	if ($Yid_type != PSS_ID_REG)
	{
	    /* delimit the name
	     */
	    status = psl_norm_id_2_delim_id(&name, &name_len, 
					    delim_id, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}	    
	status = psq_tadd(cb->pss_tchain,  (u_char *) name, name_len, 
			  &piece, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psq_tout(cb, (PSS_USRRANGE *)NULL, cb->pss_tchain, 
			  &cb->pss_tstream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	/* Copy query text object into control block */
	STRUCT_ASSIGN_MACRO(cb->pss_tstream.psf_mstream, psy_cb->psy_qrytext);

	/* Set control block and tuple fields to defaults and initial values */
	psy_cb->psy_istree = FALSE;   		
	MEfill(sizeof(psy_cb->psy_tuple.psy_event), NULLCHAR,
	       (PTR)&psy_cb->psy_tuple.psy_event);
	STmove($2->pss_orig_obj_name, ' ', sizeof(DB_NAME),
	       (char *)&psy_cb->psy_tuple.psy_event.dbe_name);
	psy_cb->psy_tuple.psy_event.dbe_type = DBE_T_ALERT;
    }
;
crev_kwd: 	CREATEEVENT
    {
	psq_cb->psq_mode = PSQ_EVENT;
    }
;

/*
** Yacc production:  drop_event	- Drop an event
**
** Statement Syntax:
**	DROP DBEVENT event_name
** Return State:
**	PSQ_CB.psq_mode    = PSQ_EVDROP
**	PSY_CB.psy_event   = Event tuple constructed (name & type)
*/
drop_event:	drev_kwd obj_spec
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

        if (cb->pss_distrib & DB_3_DDB_SESS)
        {
            (VOID) psf_error(6350L, 0L, PSF_USERERR,
                &err_code, &psq_cb->psq_error, 1,
                (i4) sizeof("DROP DBEVENT")-1, "DROP DBEVENT");
            return (E_DB_ERROR);    /* non-zero return means error */
        }

	/* If name was qualified, it'd better be the same as the user */
	if ($2->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp((PTR) &$2->pss_owner, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME)))
	{
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		/*
		** Audit failure to drop dbevent
		*/
		DB_ERROR	e_error;

		(VOID) psy_secaudit(FALSE, cb, (char *) &$2->pss_obj_name,
		    (DB_OWN_NAME *)&$2->pss_owner, sizeof($2->pss_obj_name),
		    SXF_E_EVENT, I_SX203C_EVENT_DROP,
		    SXF_A_FAIL | SXF_A_DROP, 
		    &e_error);
	    }

	    (VOID) psf_error(E_PS0420_DROPOBJ_NOT_OBJ_OWNER, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof("DROP DBEVENT") - 1, "DROP DBEVENT",
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &$2->pss_owner),
		&$2->pss_owner);
	    return(E_DB_ERROR);
	}

	/* Allocate the PSY_CB for the DROP DBEVENT statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Initialize dbevent tuple */
	MEfill(sizeof(psy_cb->psy_tuple.psy_event), NULLCHAR,
	       (PTR)&psy_cb->psy_tuple.psy_event);
	STmove($2->pss_orig_obj_name, ' ', sizeof(DB_NAME),
	       (char *)&psy_cb->psy_tuple.psy_event.dbe_name);
	psy_cb->psy_tuple.psy_event.dbe_type = DBE_T_ALERT;
    }
;
drev_kwd:	DROPEVENT
    {
	psq_cb->psq_mode = PSQ_EVDROP;
    }
;

drop_schema:	    DROP SCHEMA
    {
	{
	    i4	val1, val2;
	    /*
	    ** in 6.5 we are not officially supporting DROP SCHEMA; in order to
	    ** execute this statement, one must have set trace point ps150
	    */

	    if (!ult_check_macro(&cb->pss_trace, PSS_ENABLE_DROP_SCHEMA,
		    &val1, &val2))
	    {
		psl_yerror(3, cb, psq_cb);
		return(E_DB_ERROR);
	    }
	}
	
	psq_cb->psq_mode = PSQ_DROP_SCHEMA;

	/* "DROP SCHEMA" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	    err_code;
	    
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("DROP SCHEMA")-1, (PTR) "DROP SCHEMA");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    }
		    generic_ident drop_behaviour
    {
	DB_SCHEMA_NAME	    schema_name;
	DB_STATUS	    status;
	i4		    err_code;
	i4		    name_len = STlength($4);
	PSY_CB		    *psy_cb;
	DB_IISCHEMA	    *schema_tuple;
	
	/*
	** in 6.5 a user can have at most one schema; its name must be the same
	** as the user name; just for the sake of argument, let's say that no
	** one may drop $ingres
	*/

	MEmove(name_len, (PTR) $4, ' ', sizeof(schema_name),
	    (PTR) schema_name.db_schema_name);

	if (!MEcmp((PTR) &schema_name, (PTR) cb->pss_cat_owner,
		sizeof(schema_name)))
	{
	    /* can't drop schema "$ingres" owned by $ingres */
	    (void) psf_error(E_PS0572_CANT_DROP_SYSCAT_SCHEMA, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return(E_DB_ERROR);
	}

	if (MEcmp((PTR) &schema_name, (PTR) &cb->pss_user, DB_MAXNAME))
	{
	    /* can't drop a schema owned by a different user */
	    (void) psf_error(E_PS0573_CANT_DROP_OTHERS_SCHEMA, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		name_len, (PTR) $4, name_len, (PTR) $4);
	    return(E_DB_ERROR);
	}

	/* Allocate the PSY_CB for the DROP SCHEMA statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;
	schema_tuple = &psy_cb->psy_tuple.psy_schema;
	
	/* store schema name and schema owner name into PSY_CB */
	STRUCT_ASSIGN_MACRO(cb->pss_user, schema_tuple->db_schowner);
	STRUCT_ASSIGN_MACRO(schema_name, schema_tuple->db_schname);

	if ($5 == CASCADING_DESTRUCTION)
	    psy_cb->psy_flags |= PSY_DROP_CASCADE;
    }
;

/*
** Yacc rule:  create_rule	- Create a rule
**
** Statement Syntax:
**	CREATE RULE rule_name
**	    table_condition  | time_condition
**	    EXECUTE PROCEDURE procedure_name
**		[(param_name = value, {param_name = value})]
**
**	    table_condition :==
**		AFTER statement_type {, statement_type} ON table_name
**		[REFERENCING [OLD AS old_cor_name] [NEW AS new_cor_name]]
**		[WHERE qualification]
**	    statement_type :==
**		DELETE | INSERT | UPDATE [(column_name)]
**	    qualification :==
**		boolean_expression w/o set functions, subselects, unqualified
**		column names
**	    time_condition :==
**		AT date REPEAT interval
**
** Return State:
**	PSY_CB.psy_rule	      = Rule tuple constructed
**	      .psy_tabname[0] = Table name (if table-type rule)
**	      .psy_istree     = Tree used?
**	      .psy_intree     = Tree (if used)
**	      .psy_qrytext    = Text of statement
*/
create_rule:		crl_kword crl_rule_name crl_rule_cond crl_exec_proc
    {
	DB_STATUS       status;
	PSF_MSTREAM	tempstream;
	PST_QNODE	*rootnode;
	PST_RT_NODE	root;
	PST_PROCEDURE   *pnode;
	PSY_CB		*psy_cb;
	PST_QTREE	*tree;
	i4                err_code;

	psq_cb->psq_mode = PSQ_RULE;		/* Restore mode - safety */
	$Yin_rule = 0;

	psy_cb = (PSY_CB *)cb->pss_object;

	if ((psy_cb->psy_tuple.psy_rule.dbr_flags & DBR_F_BEFORE) && 
		cb->pss_dbp_flags & PSS_DATA_CHANGE)
	{
	    /* Can't have a BEFORE rule triggering a procedure with 
	    ** a data change statement (INSERT, UPDATE, DELETE). */
	    _VOID_ psf_error(E_US18B5_6325_NODCBEFORE, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* Check if we need a tree - parameter list and/or qualification */
	if ($3 != NULL || $4 != NULL)
	{
	    psy_cb->psy_istree = TRUE;

	    /* Make the ROOT node */
	    root.pst_rtuser          = TRUE;
	    root.pst_union.pst_next  = NULL;
	    root.pst_dups  	     = PST_ALLDUPS;
	    root.pst_tvrc   	     = 0;
	    MEfill(sizeof(PST_J_MASK), 0, (char *)&root.pst_tvrm);
	    /*	Left = params, right = qualification */
	    status = pst_node(cb, &cb->pss_ostream, $4, $3,
		PST_ROOT, (PTR)&root, sizeof(PST_RT_NODE), DB_NODT, (i2) 0,
		(i4)0, (DB_ANYTYPE *)NULL, &rootnode, &psq_cb->psq_error,
		(i4) 0);
	    if (status != E_DB_OK)
		return (status);

	    /*
	    ** if a rule is being created on a view, we will replace references
	    ** to the view's attributes in the qualification and/or parameter
	    ** tree with references to the attributes of the view's underlying
	    ** base table.  To do this we will use a copy of a view tree which
	    ** was pumped through qrymod in crl_tbl_name production.
	    */
	    if (cb->pss_resrng->pss_tabdesc->tbl_status_mask & DMT_VIEW)
	    {
		status = psl_vrule_tree_convert(rootnode, $Yrule_view_tree,
		    cb, &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return(status);
	    }
	    
	    /* Make the query tree header */
	    status = pst_header(cb, psq_cb, PST_UNSPECIFIED, (PST_QNODE *) NULL,
		rootnode, &tree, &pnode, ($Yisdbp) ? 0 : PST_0FULL_HEADER,
		&$Yxlated_qry);
	    if (status != E_DB_OK)
		return (status);

	    /* set pst_numjoins.  $Yjoin_id contains the highest join id */
	    tree->pst_numjoins = $Yjoin_id;

	    /* Set the root in QSF */
	    if (pnode != NULL)
	    {
		status = psf_mroot(cb, &cb->pss_ostream, (PTR)pnode,
				   &psq_cb->psq_error);
		if (status != E_DB_OK)
		    return (status);
	    }

	    /* Save QSF object id for the query tree */
	    STRUCT_ASSIGN_MACRO(cb->pss_ostream.psf_mstream,psy_cb->psy_intree);
	}
	else
	{
	    /* There is no tree, so close tree stream */
	    status = psf_mclose(cb, &cb->pss_ostream, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	    cb->pss_ostream.psf_mstream.qso_handle = NULL;
	} /* If tree or not */


	/*
	** We want to give the control block back to the caller.  However,
	** the control block has been allocated using the control block
	** stream, and it's the output stream that gets handed back to the
	** caller.  Therefore, we must swap the control block and output
	** streams.
	*/
	if (psy_cb->psy_istree)
	{
	    STRUCT_ASSIGN_MACRO(cb->pss_ostream, tempstream);
	    STRUCT_ASSIGN_MACRO(cb->pss_cbstream, cb->pss_ostream);
	    STRUCT_ASSIGN_MACRO(tempstream, cb->pss_cbstream);
	}
	else
	{
	    STRUCT_ASSIGN_MACRO(cb->pss_cbstream, cb->pss_ostream);
	    cb->pss_cbstream.psf_mstream.qso_handle = NULL;
	}

	/* Put the query text in a contiguous block in QSF and save id */
	status = psq_tout(cb, (PSS_USRRANGE *)NULL, cb->pss_tchain,
			  &cb->pss_tstream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	STRUCT_ASSIGN_MACRO(cb->pss_tstream.psf_mstream, psy_cb->psy_qrytext);
    }
;
crl_kword:		CRTRULE
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;
	PTR		       piece;

	psq_cb->psq_mode = PSQ_RULE;

	/* "create rule" is not allowed in Star */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    _VOID_ psf_error(E_US18A0_6304_RULE_STAR, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* Open object stream for allocating the tree (may be needed) */
	status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/*
	** The "create rule" statement requires query text to be saved.
	** Open a text chain and put the initial words "create rule " in it.
	** The text chain will be built later.
	*/
	cb->pss_stmt_flags |= PSS_TXTEMIT;	    /* Indicate to emit text */
	status = psq_topen(&cb->pss_tchain, &cb->pss_memleft,
			   &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psq_tadd(cb->pss_tchain, (u_char *)"create rule ",
	    		  sizeof("create rule ")-1, &piece, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Allocate the PSY_CB for the CREATE RULE statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_cbstream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set control block fields to defaults and initial values */
	psy_cb->psy_istree = FALSE;   			/* Assume no tree yet */
	psy_cb->psy_tabname[0].db_tab_name[0] = EOS;	/* Table name */
	(VOID) QUinit((QUEUE *) &psy_cb->psy_colq);	/* Column name list */
	MEfill(sizeof(psy_cb->psy_tuple.psy_rule), EOS,
	       (PTR)&psy_cb->psy_tuple.psy_rule);

	/* No FROM clause so initialize bitmap - not really needed */
	MEfill(sizeof(PST_J_MASK), 0, (char *)&$Yflists[cb->pss_qualdepth]);

	$Yin_rule = 1;		/* For condition checking */

	/*
	** group and role permits will be disregarded when parsing definitions
	** of views, rules, and database procedures
	*/
	cb->pss_stmt_flags |= PSS_DISREGARD_GROUP_ROLE_PERMS;
    }
;

crl_rule_name:		obj_spec
    {
	i4		err_code;
	char		*ch1 = (char *) $1->pss_orig_obj_name;
# ifndef DOUBLEBYTE
	char		*ch2 = ch1 + CMbytecnt(ch1);
# else
	char		*ch2 ;
	
	ch2 = ch1 + CMbytecnt(ch1);
# endif /* #ifndef DOUBLEBYTE */

	/* If name was qualified, it'd better be the same as the user
	** (unless this is a system-generated rule [used for constraints])
	*/
	if ($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp((PTR) &$1->pss_owner, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME))
	    && ((psq_cb->psq_info == (PST_INFO *) NULL)
		|| (~psq_cb->psq_info->pst_execflags & PST_SYSTEM_GENERATED)))
	{
	    (VOID) psf_error(E_PS0421_CRTOBJ_NOT_OBJ_OWNER, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof("CREATE RULE") - 1, "CREATE RULE",
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &$1->pss_owner),
		&$1->pss_owner);
	    return(E_DB_ERROR);
	}

	/* If "ii" then must be "ingres" */
	if (!CMcmpnocase(ch1, &SystemCatPrefix[0]) &&
	    !CMcmpnocase(ch2, &SystemCatPrefix[1]))
	{
	    if (MEcmp((PTR)&cb->pss_user, (PTR)cb->pss_cat_owner,
		      sizeof(DB_OWN_NAME)) != 0)
	    {
		_VOID_ psf_error(E_US18A1_6305_RULE_II, 0L, PSF_USERERR,
				 &err_code, &psq_cb->psq_error, 2,
				 STlength($1->pss_orig_obj_name),
				 $1->pss_orig_obj_name,
				 STlength(SystemCatPrefix),
				 SystemCatPrefix);
		return (E_DB_ERROR);
	    }
	}

	/* test rule name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT($1->pss_orig_obj_name, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	STmove($1->pss_orig_obj_name, ' ', sizeof(DB_NAME),
	      (char *)&((PSY_CB *)cb->pss_object)->psy_tuple.psy_rule.dbr_name);
    }
;
crl_rule_cond:		crl_tbl_rule
    {
	$$ = $1;
    }
	|		crl_time_rule
    {
	$$ = NULL;		/* Never any tree */
    }
;
crl_tbl_rule:		crl_tbl_when crl_tbl_stmt_list crl_tbl_on crl_tbl_name
			crl_tbl_reference crl_tbl_where crl_tbl_with_clause 
    {
	DMT_ATT_ENTRY   *att;
	PSY_CB		*psy_cb;
	PSY_COL		*col;
	DB_IIRULE	*rule_tup;
	i4		err_code;

	psy_cb = (PSY_CB *)cb->pss_object;
	rule_tup = &(psy_cb->psy_tuple.psy_rule);

	if (($1 & DBR_F_BEFORE) && $7 == DBR_T_STMT)
	{
	    /* No support yet for statement level before rules. */
	    _VOID_ psf_error(E_US18B4_6324_NOSTMTBEFORE, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	rule_tup->dbr_type      = $7;
	rule_tup->dbr_statement = $2;
	rule_tup->dbr_flags     = $1;

	/* if have list of column names, convert it to a bitmap;
	** also check for duplicates and non-existent columns
	*/
	if (psy_cb->psy_colq.q_next != &(psy_cb->psy_colq))
	{
	    /* for each column in the list, find its postion in the table
	    ** and add it to the bitmap.
	    ** Return an error if duplicate name or column not in table.
	    */ 
	    for (col = (PSY_COL *) psy_cb->psy_colq.q_next; 
		 col !=(PSY_COL *) &(psy_cb->psy_colq);
		 col = (PSY_COL *) col->queue.q_next)
	    {
		att = pst_coldesc(cb->pss_resrng, &col->psy_colnm);
		
		if (att == (DMT_ATT_ENTRY *) NULL)
		{
		    _VOID_ psf_error(E_US18A2_6306_RULE_COLTAB, 0L, PSF_USERERR,
				     &err_code, &psq_cb->psq_error, 2,
				     psf_trmwhite(sizeof(DB_TAB_NAME),
						  (char *) &col->psy_colnm),
				     &col->psy_colnm,
				     psf_trmwhite(sizeof(DB_TAB_NAME),
					 (char *) &cb->pss_resrng->pss_tabname),
				     &cb->pss_resrng->pss_tabname);
		    return (E_DB_ERROR);
		}

		if (BTtest(att->att_number,
			   (char *) rule_tup->dbr_columns.db_domset))
		{
		    /* duplicate, so return error 
		     */
		    _VOID_ psf_error(E_PS0460_DUP_UPD_COL, 0L, PSF_USERERR,
				     &err_code, &psq_cb->psq_error, 1,
				     psf_trmwhite(sizeof(DB_TAB_NAME),
						  (char *) &col->psy_colnm),
				     &col->psy_colnm);
		    return (E_DB_ERROR);
		}

		/* otherwise, set bit in column bitmap
		 */
	
		BTset(att->att_number, 
		      (char *) rule_tup->dbr_columns.db_domset);

	    } /* end for */
	} /* end if have list of columns */
	else
	{
	    /* table-level rule, so set ALL bits in column bitmap 
	     */
	    MEfill(sizeof(rule_tup->dbr_columns.db_domset), 
		   (unsigned char) 0xff, (PTR) rule_tup->dbr_columns.db_domset);
	}

	/* if PST_INFO flags are set, set special bits in rule tuple
	**
	** (For CONSTRAINTS, QEF will build an Execute Immediate CREATE RULE
	**  statement, and set bits in the PST_INFO structure.)
	*/
       	if (psq_cb->psq_info != (PST_INFO *) NULL)
	{
	    if (psq_cb->psq_info->pst_execflags & PST_SYSTEM_GENERATED)
	    {
		rule_tup->dbr_flags |= DBR_F_SYSTEM_GENERATED;
	    }
	
	    if (psq_cb->psq_info->pst_execflags & PST_NOT_DROPPABLE)
	    {
		rule_tup->dbr_flags |= DBR_F_NOT_DROPPABLE;
	    }

	    if (psq_cb->psq_info->pst_execflags &
		    PST_CASCADED_CHECK_OPTION_RULE)
	    {
		rule_tup->dbr_flags |= DBR_F_CASCADED_CHECK_OPTION_RULE;
	    }
	}

	$$ = $6;	/* May be NULL */
    }
;

crl_tbl_when:	    	nonkeyword
    {
	i4	err_code;

	if (STcompare($1, "after") == 0)
	    $$ = DBR_F_AFTER;
	else if (STcompare($1, "before") == 0)
	    $$ = DBR_F_BEFORE;
	else
	{
	    _VOID_ psf_error(E_US18A7_6311_RULE_WHEN, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
    }
;

crl_tbl_stmt_list:	crl_tbl_stmt
    {
	$$ = $1;
    }
		|	crl_tbl_stmt_list COMMA crl_tbl_stmt
    {
	i4		err_code;

	/* check if same stmt specified more than once
	 */
	if ($1 & $3)
	{
	    _VOID_ psf_error(E_US18A3_6307_RULE_STMT, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	$$ |= $3;
    }
;
crl_tbl_stmt:		DELETE
    {
	$$ = DBR_S_DELETE;
    }
	    	|	INSERT
    {
	$$ = DBR_S_INSERT;
    }
		|	UPDATE
    {
	$$ = DBR_S_UPDATE;
    }
		|	UPDATE LPAREN crl_tbl_collist RPAREN
    {
	$$ = DBR_S_UPDATE;

	/* columns are now in a queue pointed to by psy_cb->psy_colq
	 */
    }
;
crl_tbl_collist:	crl_tbl_col
    |			crl_tbl_collist COMMA crl_tbl_col
;
crl_tbl_col:		col_spec
    {
	DB_STATUS   status;
	PSY_COL     *psy_col;
	PSY_CB      *psy_cb;

	/* Allocate memory for a column entry
	 */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSY_COL),
			    (PTR *) &psy_col, &psq_cb->psq_error);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/*
	** Copy update column name to column entry.
	*/
	STmove($1, ' ', sizeof(DB_ATT_NAME),
		psy_col->psy_colnm.db_att_name);

	/*
	** Attach element to the list.
	*/
	psy_cb = (PSY_CB *) cb->pss_object;
	QUinsert((QUEUE *) psy_col, (QUEUE *) &psy_cb->psy_colq);
    }
;

crl_tbl_on:		ON
    |			FROM
    |			INTO
    |			OF
;

crl_tbl_name:		obj_spec
    {
	DB_STATUS       status;
	i4		rngvar_info;
	PSS_RNGTAB	*resrange;
	i4		err_code, err_num;
	PSY_CB		*psy_cb = (PSY_CB *) cb->pss_object;

	/* Enter into range table as implicit NEW */
	if ($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, $1->pss_orig_obj_name,
			&$1->pss_owner, &$1->pss_obj_name, cb, FALSE, &resrange,
			psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, cb->pss_qualdepth,
			 $1->pss_orig_obj_name, &$1->pss_obj_name, cb, FALSE,
			 &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
			 &rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    $1->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}
	
	if (status != E_DB_OK)
	    return (status);
	
	/* Save name (for errors in psy_tabname) and table id in rule tuple */
	STRUCT_ASSIGN_MACRO(resrange->pss_tabname, psy_cb->psy_tabname[0]);
	STRUCT_ASSIGN_MACRO(resrange->pss_tabid,
		      psy_cb->psy_tuple.psy_rule.dbr_tabid);

	/*
	** Check for rules on catalogs and ownership of table
	**
	** NOTE:
	**	now rules may be created on updatable views.
	**	Also, referential constraints may need to create rules
	**	on other users' tables, so don't return 'not owner' error
	**	for system-generated rules.
	*/
	if ((resrange->pss_tabdesc->tbl_status_mask & DMT_CATALOG) ||
	    (resrange->pss_tabdesc->tbl_2_status_mask & DMT_TEXTENSION))
	{
	    /* Check if user has CATALOG UPDATE privilege */
	    if (! (cb->pss_ses_flag & PSS_CATUPD) )
	    {
		err_num = E_US18A9_6313_RULE_CAT;
		status = E_DB_ERROR;
	    }
	}
	else if (MEcmp((PTR) &cb->pss_user,
		       (PTR) &resrange->pss_tabdesc->tbl_owner,
		       sizeof(DB_OWN_NAME))
		 && ((psq_cb->psq_info == (PST_INFO *) NULL)
		     || (~psq_cb->psq_info->pst_execflags 
			 		& PST_SYSTEM_GENERATED)))
	{
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_STATUS	local_status;
		DB_ERROR	e_error;

		/*
		** Write Security Audit Record, indicating that the attempt
		** to create a rule on a table failed.
		*/
		local_status = psy_secaudit(FALSE, cb,
			    (char *)&resrange->pss_tabname,
			    &resrange->pss_tabdesc->tbl_owner,
			    sizeof(DB_TAB_NAME), SXF_E_RULE,
			    I_SX202F_RULE_ACCESS, SXF_A_FAIL | SXF_A_CREATE,
			    &e_error);
	    }

	    err_num = E_US18A5_6309_RULE_OWN;
	    status = E_DB_ERROR;
	}

	if (DB_FAILURE_MACRO(status))
	{
	    /*
	    ** let user know if name supplied by the user was resolved to a
	    ** synonym
	    */
	    if (rngvar_info & PSS_BY_SYNONYM)
	    {
		psl_syn_info_msg(cb, resrange, $1, rngvar_info,
		    sizeof("CREATE RULE")-1, "CREATE RULE",
		    &psq_cb->psq_error);
	    }

	    _VOID_ psf_error(err_num, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &resrange->pss_tabname),
		&resrange->pss_tabname);
	    return(status);
	}
	
	/*
	** if user has referred to the object using name of a synonym, we need 
	** to replace synonym name with the real object name in the text which 
	** will be stored in IIQRYTEXT
	*/
        if (rngvar_info & PSS_BY_SYNONYM)
        {
	    PTR		*obj_name_ptr;
	    PTR		newpiece;
	    i4  	name_len;
	    u_char  	*actual_obj_owner = (u_char *) &resrange->pss_ownname;
	    u_char	delim_id[DB_MAX_DELIMID];
#ifdef BYTE_ALIGN
	    PTR	align_ptr;
#else
#undef   align_ptr
#define  align_ptr  (*obj_name_ptr)
#endif

	    /* The piece ptr is stored after the null terminated string */
	    obj_name_ptr = (PTR *) ((char *) $1->pss_orig_obj_name +
				    STlength($1->pss_orig_obj_name) + 1);
#ifdef BYTE_ALIGN
	    MECOPY_CONST_MACRO((PTR)obj_name_ptr, sizeof(PTR), (PTR)&align_ptr);
#endif
	    /*
	    ** if synonym name was qualified with owner name, and the owner
	    ** of the synonym is different from the owner of the actual
	    ** object, we will replace name of the owner of the synonym with
	    ** that of the actual object
	    */
	    if ($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	        MEcmp((PTR) &$1->pss_owner, (PTR) actual_obj_owner,
		    sizeof(DB_OWN_NAME)))
	    {
	        PTR	syn_owner = psq_tbacktrack(align_ptr, 2);
    
	        /*
	        ** psq_tsubs() may replace a name with preceding blank(s)
	        ** with one without them.  This is undesirable, e.g.
	        ** 
	        **	    create synonym andre.x for eric.t;
	        **	    create rule r after update of andre.x...;
	        **
	        ** would result in text
	        **
	        **	    create rule r after update oferic.t 
	        **
	        ** Therefore, we must add a space before the actual object
	        ** owner name.
	        */

	        status = psq_tinsert(cb->pss_tchain, (u_char *) " ",
		    sizeof(" ") - 1, &newpiece, syn_owner,
		    &psq_cb->psq_error);
	        if (DB_FAILURE_MACRO(status))
		    return (status);

		/* 
		** convert owner name to a delimited identifier
		** (obj_owner pointer gets overwritten)
		*/
		name_len = psf_trmwhite(DB_MAXNAME, (char *) actual_obj_owner);

	        status = psl_norm_id_2_delim_id(&actual_obj_owner,
		    &name_len, delim_id, &psq_cb->psq_error);
	        if (DB_FAILURE_MACRO(status))
		    return(status);

		status = psq_tsubs(cb->pss_tchain, syn_owner,
		    actual_obj_owner, name_len,
		    &newpiece, &psq_cb->psq_error);
	        if (DB_FAILURE_MACRO(status))
	        {
		    return(status);
	        }
	    }

	    /*
	    ** if (synonym name was different from the actual object name)
	    ** {
	    **     replace synonym name with actual object name;
	    ** }
	    */
	    if (MEcmp((PTR) &$1->pss_obj_name, (PTR) &resrange->pss_tabname,
		      sizeof(DB_TAB_NAME)))
	    {
		u_char	*actual_tbl = (u_char *) &resrange->pss_tabname;

		/* 
		** convert table name to a delimited identifier
		** (actual_tbl pointer gets overwritten)
		*/
		name_len = psf_trmwhite(DB_MAXNAME, (char *) actual_tbl);

	        status = psl_norm_id_2_delim_id(&actual_tbl, &name_len, 
		    delim_id, &psq_cb->psq_error);
	        if (DB_FAILURE_MACRO(status))
		    return(status);

		/*
		** if the schema name was not explicitly specified, psq_tsubs()
		** may strike again; it may substitute a string for a string 
		** preceeded by at least one blank and screw things up; to make
		** sure that it does not, insert a blank before the object name
		** unless the schema name was explicitly specified
		*/

		if (~$1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
		{
		    /* Add a blank */
		    status = psq_tinsert(cb->pss_tchain, (u_char *) " ",
		        sizeof(" ") - 1, &newpiece, align_ptr,
		        &psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
		        return (status);
		}

		status = psq_tsubs(cb->pss_tchain, align_ptr, actual_tbl, 
		    name_len, &newpiece, &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return(status);
	    }
	}

	/*
	** if creating a rule on a view, verify that it is, indeed, updatable;
	** because we allow updates on views someof whose columns are not
	** updatable, it would be unreasonable to require that only updatable
	** columns of such view are referenced in the rule definition (inside
	** <column list> in UPDATE(<column list), WHERE-clause, or parameter
	** list) - but we will verify that the view is updatable
	**
	** to accomplish this, we will obtain a view tree from RDF and pump its
	** copy through qrymod; after qrymod, we will know whether a view is
	** updatable + we will know underlying columns of each of the view's
	** columns - this info will be used when we translate a rule tree (if
	** any) to reference attributes of the view's underlying base table
	** instead of referencing attributes of the view itself
	** 
	*/
	if (resrange->pss_tabdesc->tbl_status_mask & DMT_VIEW)
	{
	    RDF_CB	    rdfcb, *rdf_cb = &rdfcb;
	    RDR_RB	    *rdf_rb = &rdf_cb->rdf_rb;
	    PST_PROCEDURE   *pnode;
	    PST_QTREE	    *header;
	    PST_QNODE	    *root;
	    PST_VRMAP	    viewmap;
	    i4		    i;
	    PST_QNODE	    *tree_copy;
	    PSS_USRRANGE    *rngtab = &cb->pss_auxrng;
	    DB_ERROR	    *err_blk = &psq_cb->psq_error;
	    i4		    nonupdt_info;
	    PSS_RNGTAB      *rngvar;
	    i4		    rgno;
	    PST_J_ID	    dummy;
	    i4         qrymod_resp_mask;

	    /* initialize static fields in rdf_cb used to retrieve view trees */
	    pst_rdfcb_init(rdf_cb, cb);
	    
	    rdf_rb->rdr_types_mask = RDR_VIEW | RDR_QTREE;
	    STRUCT_ASSIGN_MACRO(resrange->pss_tabid, rdf_rb->rdr_tabid);
	    rdf_rb->rdr_rec_access_id = NULL;
	    rdf_cb->rdf_info_blk = resrange->pss_rdrinfo;
	    rdf_rb->rdr_qtuple_count = 1;

	    /* call RDF to get the view tree */
	    status = rdf_call(RDF_GETINFO, (PTR) rdf_cb);

	    /*
	    ** RDF may choose to allocate a new info block and return its
	    ** address in rdf_info_blk - we need to copy it over to pss_rdrinfo
	    ** to avoid memory leak and other assorted unpleasantries
	    */
	    resrange->pss_rdrinfo = rdf_cb->rdf_info_blk;

	    if (DB_FAILURE_MACRO(status))
	    {
		if (rdf_cb->rdf_error.err_code == E_RD0002_UNKNOWN_TBL)
		{
		    (VOID) psf_error(E_PS0903_TAB_NOTFOUND, 
			rdf_cb->rdf_error.err_code, PSF_INTERR,
			&err_code, err_blk, 1,
			psf_trmwhite(sizeof(DB_TAB_NAME), 
			    (char *) &resrange->pss_tabname),
			&resrange->pss_tabname);
		}
		else
		{
		    (VOID)psf_rdf_error(RDF_GETINFO, &rdf_cb->rdf_error,
			err_blk);
		}

		return(status);
	    }

	    pnode =
		(PST_PROCEDURE *) rdf_cb->rdf_info_blk->rdr_view->qry_root_node;
		
	    header = pnode->pst_stmts->pst_specific.pst_tree;

	    /*
	    ** determine whether the view is updatable - rules cannot be
	    ** created on non-updatable views
	    */
	    if (!psy_view_is_updatable(header, (i4) PSQ_RULE, &nonupdt_info))
	    {
		err_num = 0;
		
		if (nonupdt_info & PSY_UNION_IN_OUTERMOST_SUBSEL)
		    err_num = E_PS0590_UNION_IN_RULE_VIEW;
		else if (nonupdt_info & PSY_DISTINCT_IN_OUTERMOST_SUBSEL)
		    err_num = E_PS0591_DISTINCT_IN_RULE_VIEW;
		else if (nonupdt_info & PSY_AGGR_IN_OUTERMOST_SUBSEL)
		    err_num = E_PS0594_AGGR_IN_RULE_VIEW;
		else if (nonupdt_info & PSY_GROUP_BY_IN_OUTERMOST_SUBSEL)
		    err_num = E_PS0593_GROUP_BY_IN_RULE_VIEW;
		else if (nonupdt_info & PSY_MULT_VAR_IN_OUTERMOST_SUBSEL)
		    err_num = E_PS0592_MULT_VARS_IN_RULE_VIEW;
		else if (nonupdt_info & PSY_NO_UPDT_COLS)
		    err_num = E_PS0595_CANNOT_UPDT_RULE_VIEW;

		if (err_num)
		{
		    if (rngvar_info & PSS_BY_SYNONYM)
		    {
			psl_syn_info_msg(cb, resrange, $1, rngvar_info,
			    sizeof("CREATE RULE")-1, "CREATE RULE",
			    err_blk);
		    }

		    _VOID_ psf_error(err_num, 0L, PSF_USERERR, &err_code,
			err_blk, 1,
			psf_trmwhite(sizeof(DB_TAB_NAME), 
			    (char *) &resrange->pss_tabname),
			&resrange->pss_tabname);
		    return(E_DB_ERROR);
		}
	    }
	    
	    root = header->pst_qtree;
	    
	    $Ydup_rb.pss_tree = root;
	    $Ydup_rb.pss_dup  = &tree_copy;
	    status = pst_treedup(cb, &$Ydup_rb);

	    if (status != E_DB_OK)
		return (status);

	    /* create a bitmap of vars used in the view */
	    psy_varset(tree_copy, &viewmap);

	    /*
	    ** reinitialize the range table since we are about to pump the view
	    ** tree through qrymod and we want the range table to contain only
	    ** the view's underlying tables.  Once we are done with this
	    ** exercise, we will reinitialize the range table and reenter the
	    ** var corresponding to the view on which a rule is being created
	    */
	    status = pst_clrrng(cb, rngtab, err_blk);
	    if (DB_FAILURE_MACRO(status))
		return (status);

	    /* remember range number of the view's underlying table/view */
	    rgno = BTnext(-1,
		(char *) &root->pst_sym.pst_value.pst_s_root.pst_tvrm,
		PST_NUMVARS);
	    
	    /* merge the view's range variables into the range table */
	    for (i = -1; (i = BTnext(i, (char *) &viewmap, PST_NUMVARS)) != -1;)
	    {
		status = pst_rgent(cb, rngtab, -1, "!", PST_SHWID,
		    (DB_TAB_NAME *) NULL, (DB_TAB_OWN *) NULL,
		    &header->pst_rangetab[i]->pst_rngvar, FALSE, 
		    &rngvar, (i4) 0, err_blk);
		    
		if (DB_FAILURE_MACRO(status))
		{
		    /* If table could not be found return a user error
		    ** so that things can be retried.
		    */
		    if (err_blk->err_code == E_PS0903_TAB_NOTFOUND)
		    {
			(VOID) psf_error(2120L, 0L, PSF_USERERR,
			    &err_code, err_blk, 0);
		    }
		    return(status);
		}

		/*
		** copy inner and outer join maps into the new range table
		** entry
		*/
		STRUCT_ASSIGN_MACRO(header->pst_rangetab[i]->pst_inner_rel,
		    rngvar->pss_inner_rel);
		STRUCT_ASSIGN_MACRO(header->pst_rangetab[i]->pst_outer_rel,
		    rngvar->pss_outer_rel);

		/*
		** if this is the view's underlying table/view, mark
		** pss_var_mask of the range variable corresponding to that
		** table/view accordingly
		*/
		if (i == rgno)
		{
		    rngvar->pss_var_mask |= PSS_RULE_RNG_VAR;
		}
	    }

	    dummy = header->pst_numjoins;

	    /*
	    ** pump the view tree through qrymod; this will enable us to
	    ** determine whether the view is, indeed, updatable + we will have a
	    ** tree representing attributes of the view which can be used when
	    ** we need to replace references to attributes of the view with
	    ** references to the attributes of its underlying base table
	    */
	    status = psy_qrymod(tree_copy, cb, psq_cb, &dummy,
		&qrymod_resp_mask);
	    if (DB_FAILURE_MACRO(status))
	    {
		err_num = 0;
		
		if (qrymod_resp_mask & PSY_UNION_IN_UNDERLYING_VIEW)
		    err_num = E_PS0596_CRT_RULE_UNION_IN_UV;
		else if (qrymod_resp_mask & PSY_DISTINCT_IN_UNDERLYING_VIEW)
		    err_num = E_PS0597_CRT_RULE_DISTINCT_IN_UV;
		else if (qrymod_resp_mask & PSY_MULT_VAR_IN_UNDERLYING_VIEW)
		    err_num = E_PS0598_CRT_RULE_MULT_VARS_IN_UV;
		else if (qrymod_resp_mask & PSY_GROUP_BY_IN_UNDERLYING_VIEW)
		    err_num = E_PS0599_CRT_RULE_GROUP_BY_IN_UV;
		else if (qrymod_resp_mask & PSY_SET_FUNC_IN_UNDERLYING_VIEW)
		    err_num = E_PS059A_CRT_RULE_AGGR_IN_UV;
		else if (qrymod_resp_mask &PSY_NO_UPDT_COLS_IN_UNDRLNG_VIEW)
		    err_num = E_PS059B_CRT_RULE_CANNOT_UPDT_UV;

		if (err_num)
		{
		    (VOID) psf_error(err_num, 0L, PSF_USERERR, &err_code,
			err_blk, 1,
			STlength($1->pss_orig_obj_name),
			$1->pss_orig_obj_name);
		}

		return(status);
	    }

	    /*
	    ** OK, the view seems to be updatable; store address of the tree
	    ** returned from psy_qrymod(), clear the range table, and reenter
	    ** the view on which a rule is being created
	    */
	    $Yrule_view_tree = tree_copy;

	    status = pst_clrrng(cb, rngtab, err_blk);
	    if (DB_FAILURE_MACRO(status))
		return (status);

	    status = pst_rgent(cb, rngtab, -1, "!", PST_SHWID,
		(DB_TAB_NAME *) NULL, (DB_TAB_OWN *) NULL,
		&psy_cb->psy_tuple.psy_rule.dbr_tabid, FALSE, 
		&resrange, (i4) 0, err_blk);
		
	    if (DB_FAILURE_MACRO(status))
	    {
		/* If table could not be found return a user error
		** so that things can be retried.
		*/
		if (err_blk->err_code == E_PS0903_TAB_NOTFOUND)
		{
		    (VOID) psf_error(2120L, 0L, PSF_USERERR,
			&err_code, err_blk, 0);
		}
		
		return(status);
	    }

	}

	resrange->pss_image = PST_AFTER;	/* Default as "new */

	cb->pss_resrng = resrange;
    }
;

crl_tbl_reference:	REFERENCING crl_ref_clause crl_ref_clause
		|	REFERENCING crl_ref_clause
    {
	DB_STATUS       status;
	i4		rngvar_info;
	PSS_RNGTAB	*resrange;
	char		*corr_name;

	/*
	** default correlation name must match the default case of regular
	** identifiers
	*/
	if (*cb->pss_dbxlate & CUI_ID_REG_U)
	{
	    corr_name = ($2 == PST_BEFORE) ? "NEW" : "OLD";
	}
	else
	{
	    corr_name = ($2 == PST_BEFORE) ? "new" : "old";
	}
	
	/* Enter old/new - whichever one wasn't entered */
	status = psl_orngent(&cb->pss_auxrng, cb->pss_qualdepth, corr_name,
		     &cb->pss_resrng->pss_ownname, &cb->pss_resrng->pss_tabname,
		     cb, FALSE, &resrange, psq_cb->psq_mode,
		     &psq_cb->psq_error, &rngvar_info);
	if (status != E_DB_OK)
	    return (status);
	resrange->pss_image = $2 == PST_BEFORE ? PST_AFTER : PST_BEFORE;

	/* copy the mask field */
	resrange->pss_var_mask = cb->pss_resrng->pss_var_mask;
    }
		|	/* No REFERENCING clause - Enter "old" and "new" */
    {
	DB_STATUS       status;
	i4		rngvar_info;
	PSS_RNGTAB	*resrange;

	/* Enter "old" and "new" as default correlation variables */
	status = psl_orngent(&cb->pss_auxrng, cb->pss_qualdepth,
	    (*cb->pss_dbxlate & CUI_ID_REG_U) ? "OLD" : "old",
	    &cb->pss_resrng->pss_ownname, &cb->pss_resrng->pss_tabname,
	    cb, FALSE, &resrange, psq_cb->psq_mode,
	    &psq_cb->psq_error, &rngvar_info);
	if (status != E_DB_OK)
	    return (status);

	/* copy the mask field */
	resrange->pss_var_mask = cb->pss_resrng->pss_var_mask;
	
	resrange->pss_image = PST_BEFORE;
	
	status = psl_orngent(&cb->pss_auxrng, cb->pss_qualdepth,
	    (*cb->pss_dbxlate & CUI_ID_REG_U) ? "NEW" : "new",
	    &cb->pss_resrng->pss_ownname, &cb->pss_resrng->pss_tabname,
	    cb, FALSE, &resrange, psq_cb->psq_mode,
	    &psq_cb->psq_error, &rngvar_info);
	if (status != E_DB_OK)
	    return (status);

	/* copy the mask field */
	resrange->pss_var_mask = cb->pss_resrng->pss_var_mask;
	
	resrange->pss_image = PST_AFTER;
    }
;

crl_ref_clause:		nonkeyword noise_row noise_as tbl_spec
    {
	DB_STATUS       status;
	i4		rngvar_info;
	PSS_RNGTAB	*resrange;
	i4		old_new_image;
	i4		err_code;

	if (STcompare($1, "old") == 0)
	{
	    old_new_image = PST_BEFORE;
	}
	else if (STcompare($1, "new") == 0)
	{
	    old_new_image = PST_AFTER;
	}
	else
	{
	    _VOID_ psf_error(E_US18A6_6310_RULE_OLDNEW, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 1,
			     STlength($1), $1);
	    return (E_DB_ERROR);
	}
	status = psl_orngent(&cb->pss_auxrng, cb->pss_qualdepth, $4,
		     &cb->pss_resrng->pss_ownname, &cb->pss_resrng->pss_tabname,
		     cb, FALSE, &resrange, psq_cb->psq_mode,
		     &psq_cb->psq_error, &rngvar_info);
	if (status != E_DB_OK)
	    return (status);

	/* copy the mask field */
	resrange->pss_var_mask = cb->pss_resrng->pss_var_mask;

	$$ = resrange->pss_image = old_new_image;
    }
;

noise_row:		/* nuffin' */
		|	ROW
;

noise_as:		/* nuffin' */
		|	AS
;

crl_tbl_where:    	crl_where_word boolean_expr
    {
	$$ = $2->pss_tree;
    }
		|	/* No WHERE clause */
    {
	$$ = NULL;
    }
;

crl_where_word:		where_word
		|	WHEN
;

crl_time_rule:	    	AT crl_time_date crl_time_repeat
    {
	i4	    err_code;

	/* Not implemented yet */
	_VOID_ psf_error(2411L, 0L, PSF_USERERR,
			 &err_code, &psq_cb->psq_error, 0);
	return (E_DB_ERROR);
    }
;
crl_time_date:	    	strconst
    {
	/*
	** FIXME: Convert string $1 into date pointed at by dbr_tm_date.
	** dbstr -> $1;
	** dbdte -> &((PSY_CB *)cb->pss_object)->psy_tuple.psy_rule.dbr_tm_date;
	** adc_cvinto(dbstr, dbdte);
	** check errors
	*/
    }
;

crl_time_repeat:    	REPEAT strconst
    {
	/*
	** FIXME: Convert string $1 into date pointed at by dbr_tm_date.
	** dbstr -> $1;
	** dbdte -> &((PSY_CB *)cb->pss_object)->psy_tuple.psy_rule.dbr_tm_int;
	** adc_cvinto(dbstr, dbdte);
	** check errors
	*/
    }
	    	|	/* No interval */
    {
	/*
	** FIXME: MEfill with 0, sizeof(DB_DATE)
	*/
    }
;

crl_tbl_with_clause:	/* empty: normal row-level rule */
    {
	$$ = DBR_T_ROW;
    }
		|	FOR nonkeyword crl_tbl_row_or_stmt
    {
	i4	err_code;
	i4 lineno = 1;
	i4	val1=0, val2=0;  /* for trace point checking */
	
	/* this is for internal statement-level rules,
	** for which the syntax is RULE_SCOPE = STATEMENT.
	** Users are not allowed to use this syntax (yet)
	** (and this syntax has not passed the LRC, either).    22-dec-92
	*/
	/* This syntax has been altered to the ANSI "for each {row | statement}"
	** option. A corresponding change has been made to qef!qeq!qeaddl.c,
	** where statement level rule syntax is currently built under the 
	** covers. The syntax has also been externalized to permit users
	** to code their own statement level rules (they used to be 
	** restricted to internally generated rules built to implement
	** referential and check constraints). The error check which used
	** to be here has now been removed. */


	if (STcasecmp($2, "each") != 0)
	{
	    psf_error(2076L, 0L, PSF_USERERR,
		      &err_code, &psq_cb->psq_error, 1,
		      STlength($2), $2);
	    return(E_DB_ERROR);
	}
 
	$$ = $3;	/* return ROW or STATEMENT */

    } /* end crl_tbl_with_clause */
;

crl_tbl_row_or_stmt	:	ROW
    {
	$$ = DBR_T_ROW;
    }
	      | nonkeyword
    {
	i4	err_code;

	/* valid value is STATEMENT 
	 */
	if (STbcompare($1, 0, "statement", 0, TRUE) == 0)
	{
	    $$ = DBR_T_STMT;
	}	    
	else
	{
	    psf_error(2076L, 0L, PSF_USERERR,
		      &err_code, &psq_cb->psq_error, 1,
		      STlength($1), $1);
	    return(E_DB_ERROR);
	}

    } /* end crl_row_or_stmt */
;

crl_exec_proc:		EXECUTE PROCEDURE crl_proc_name
					  LPAREN crl_proc_arg_list RPAREN
    {
	$$ = $5;
    }
		|	EXECUTE PROCEDURE crl_proc_name
    {
	$$ = NULL;
    }
;

crl_proc_name:		exdbp_name
    {
	/* A dbpinfo has been filled when validating the procedure name */
	STRUCT_ASSIGN_MACRO($1->pss_ptuple.db_dbpname,
		   ((PSY_CB *)cb->pss_object)->psy_tuple.psy_rule.dbr_dbpname);
	STRUCT_ASSIGN_MACRO($1->pss_ptuple.db_owner,
		   ((PSY_CB *)cb->pss_object)->psy_tuple.psy_rule.dbr_dbpowner);
	((PSY_CB *)cb->pss_object)->psy_tuple.psy_rule.dbr_dbpparam = 0;
	if ($1->pss_ptuple.db_mask[0] & DBP_DATA_CHANGE)
	    cb->pss_dbp_flags |= PSS_DATA_CHANGE;
	else cb->pss_dbp_flags &= ~PSS_DATA_CHANGE;
    }
;

crl_proc_arg_list:	exdbp_arg_list
    {
	/* How many parameters were there - highest resdom number? */
	((PSY_CB *)cb->pss_object)->psy_tuple.psy_rule.dbr_dbpparam = 
				$1->pst_sym.pst_value.pst_s_rsdm.pst_rsno;
    }
;

crt_syn:	    CRTSYNONYM
    {
	i4                err_code;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_CSYNONYM;

	/* "CREATE SYNONYM" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CREATE SYNONYM")-1, "CREATE SYNONYM");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the CREATE SYNONYM statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	/* we are about to process the new synonym name */
	cb->pss_stmt_flags |= PSS_NEW_OBJ_NAME;
    }
;

create_synonym:	    crt_syn crname 
    {
	/* we are done processing the new object name */
	cb->pss_stmt_flags &= ~PSS_NEW_OBJ_NAME;
    }
	    	    FOR obj_spec
    {
	DB_STATUS           status;
	i4		    rngvar_info;
	PSS_RNGTAB	    *resrange;
	DB_IISYNONYM	    *syn_tuple;

	if ($5->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, "", &$5->pss_owner,
		&$5->pss_obj_name, cb, TRUE, &resrange, psq_cb->psq_mode,
		&psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, -1, "", &$5->pss_obj_name, cb,
		TRUE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
		&rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    $5->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (DB_FAILURE_MACRO(status))
	    return (status);

	if (rngvar_info & PSS_BY_SYNONYM)
	{
	    i4	    err_code;

	    /* can't create synonyms on other synonyms */
	    (VOID) psf_error(E_PS0455_CRT_SYN_ON_SYN, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		STlength($5->pss_orig_obj_name), $5->pss_orig_obj_name);
	    return (E_DB_ERROR);
	}
	
	/* Allocate DB_IISYNONYM structure */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_IISYNONYM),
			    (PTR *) &syn_tuple, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* initialize DB_IISYNONYM tuple */
	STmove($2, ' ', sizeof(DB_SYNNAME), syn_tuple->db_synname.db_synonym);
	MEmove(sizeof(cb->pss_user), cb->pss_user.db_own_name, ' ',
	       sizeof(DB_SYNOWN), syn_tuple->db_synowner.db_syn_own);
	STRUCT_ASSIGN_MACRO(resrange->pss_tabid, syn_tuple->db_syntab_id);

	((PSY_CB *) cb->pss_object)->psy_tupptr = (PTR) syn_tuple;

    }
;

dgtt_kwd:	    DECLARE GLOBAL TEMPORARY TABLE
    {
	i4			    err_code;
	DB_STATUS 		    status;

	/* "DECLARE GLOBAL TEMPORARY TABLE" is not allowed in distributed */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(5118L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		sizeof("DECLARE GLOBAL TEMPORARY TABLE") - 1,
		"DECLARE GLOBAL TEMPORARY TABLE");
	    return (E_DB_ERROR);
	}

	psq_cb->psq_mode = PSQ_DGTT;
	cb->pss_stmt_flags |= PSS_CREATE_DGTT; /* bug 76902 */
	status = psl_ct10_crt_tbl_kwd(cb, psq_cb, &$Ywith_clauses, 1L);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* we are about to process a new object name */
	cb->pss_stmt_flags |= PSS_NEW_OBJ_NAME;
    }
;

dgtton:		    ONCOMMIT PRESERVE ROWS
	    |
    {
	i4		    err_code;

	(VOID) psf_error(E_PS0BD6_MUST_USE_ON_COMMIT,
			0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1, 
			sizeof("DECLARE GLOBAL TEMPORARY TABLE")-1,
			"DECLARE GLOBAL TEMPORARY TABLE");
	return (E_DB_ERROR);		
    }

dgtt_stmt:	dgtt_kwd new_loc_name LPAREN tbl_elem_list RPAREN dgtton tbl_with_clause
    {
	DB_STATUS		    status;

	status = psl_ct1_create_table(cb, psq_cb, (PSS_CONS *) NULL);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	    |	    dgtt_kwd new_loc_name newcolspec AS query_expr
    {
	DB_STATUS		status;

	/*
	** we are (almost) done processing DGTT AS SELECT; reset the query
	** mode; resetting it before query_expr was processed would require
	** additional changes in the qrymod functions and would not buy us
	** anything
	*/
	psq_cb->psq_mode = PSQ_DGTT_AS_SELECT;

	/* Even though DGTT doesn't allow partitioning, do the column
	** name fixup here to stay in sync with "real" create table.
	*/
	status = psl_crtas_fixup_columns(cb, $3, $5, psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
		    dgtton tbl_with_clause
    {
	DB_STATUS		status;

	status = psl_ct2s_crt_tbl_as_select(cb, $3, $5, psq_cb, &$Yjoin_id,
					   &$Yxlated_qry, $Yfirst_n);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

create_table:	    crt_tbl_kwd new_loc_name LPAREN tbl_elem_list RPAREN tbl_with_clause
    {
	DB_STATUS		    status;

#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Special processing for CREATE SCHEMA
	    */
	    status = psl_cs03s_create_table(cb, psq_cb,
			 $Ystmtstart, $Ydeplist, $Ycons_list);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	    return(E_DB_OK);
	}

	status = psl_ct1_create_table(cb, psq_cb, $Ycons_list);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    status = psl_ct16_distr_create(cb, &$Yxlated_qry, TRUE, psq_cb);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
    }
	    |	    crt_tbl_kwd new_loc_name newcolspec crt_tbl_askwd query_expr
    {
	DB_STATUS status;
	i4 err_code;

#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** ERROR - No DML allowed in CREATE TABLE within CREATE SCHEMA
	    */
	    (VOID) psf_error(6656L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		(i4) sizeof("CREATE SCHEMA")-1, "CREATE SCHEMA",
		(i4) sizeof("CREATE TABLE ... AS SELECT")-1,
				 "CREATE TABLE ... AS SELECT");
	    return (E_DB_ERROR);	/* non-zero return means error */
	}
	    
	/*
	** we are (almost) done processing CREATE AS SELECT; reset the query
	** mode; resetting it before query_expr was processed would require
	** additional changes in the qrymod functions and would not buy us
	** anything
	*/
	psq_cb->psq_mode = PSQ_RETINTO;

	/* Do column name and other fixes before the with clause, so that
	** partition definition sees a reasonably good set of columns.
	*/
	status = psl_crtas_fixup_columns(cb, $3, $5, psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* The query tree isn't hooked up until after the with clause, yet
	** the with clause (partition) needs to get at the column names!
	** Drop a copy of the tree pointer into the yyvars for partition
	** definition, so that it can check out column names..
	*/
	$Ypart_crtas_qtree = $5;
	
    }
		    tbl_with_clause
    {
	DB_STATUS		status;

	status = psl_ct2s_crt_tbl_as_select(cb, $3, $5, psq_cb, &$Yjoin_id,
					   &$Yxlated_qry, $Yfirst_n);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    status = psl_ct16_distr_create(cb, &$Yxlated_qry, FALSE, psq_cb);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
    }
;

crt_tbl_askwd:	    AS
    {
	/* This simply forces execution of the flag set prior to parsing 
	** the accompanying SELECT, which in turn allows the detection of
	** valid parameter markers in the WHERE clause of PREPAREd RETINTOs.
	*/

	$Yqry_mask |= PSS_CRTAB_AS_SELECT;
    }
;

crt_tbl_kwd:	    CREATE TABLE
    {
	DB_STATUS 		    status;

#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Special handling for CREATE SCHEMA
	    */
	    $Ysubmode = PSQ_CREATE;
	    $Ydeplist = (PST_OBJDEP *) NULL;
	    $Ystmtstart = (char *) cb->pss_prvgoval;
	    $Ycons_list = (PSS_CONS *) NULL;
	    return(E_DB_OK);
	}
	    
	psq_cb->psq_mode = PSQ_CREATE;
	status = psl_ct10_crt_tbl_kwd(cb, psq_cb, &$Ywith_clauses, 0L);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* we are about to process a new object name */
	cb->pss_stmt_flags |= PSS_NEW_OBJ_NAME;
    }
;

new_loc_name:	    NAME COLON crname
    {
	DB_STATUS		    status;

	status = psl_ct9_new_loc_name(cb, psq_cb, $1, $3, &$Ywith_clauses,
					&$Yxlated_qry);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* 
	** distributed thread must convert location: to a
	** WITH-clause item
	*/
	cb->pss_distr_sflags |= PSS_LOCATION;
    }
          |	    crname
    {
	DB_STATUS		    status;

	status = psl_ct9_new_loc_name(cb, psq_cb, (char *) NULL,
				      $1, &$Ywith_clauses, &$Yxlated_qry);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

crname:		    obj_spec
    {
	DB_STATUS               status;

	/* test object name for reserved name;
	** (this production is used for synonym, table, view creation)
	*/
	if (PSL_IS_RESERVED_IDENT($1->pss_orig_obj_name, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Capture object name for CREATE SCHEMA
	    */
	    return(psl_cs06s_obj_spec(cb, psq_cb, &($Ydeplist), $1,
				        (u_i4)PST_DEP_NOORDER));
	}

	status = psl_ct12_crname(cb, psq_cb, $1);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	$$ = $1->pss_orig_obj_name;
    }
	|	    error
    {
	(VOID) psl_sx_error(2721L, cb, psq_cb);
	YYABORT;
    }
;

newcolspec:	    LPAREN newcollist RPAREN
    {
	DB_STATUS           status;
	char		    *name;
	i4		    err_code;
	register PST_QNODE  *node, *node1;
	i4		    num_attrs;

	/* we are done processing the new object/column names */
	cb->pss_stmt_flags &= ~PSS_NEW_OBJ_NAME;

	/*
	** See if there are duplicate column names.
	*/
	for (node = $2; node != (PST_QNODE *) NULL; node = node->pst_left)
	{
	    /* to save on dereferencing */
	    name = node->pst_sym.pst_value.pst_s_rsdm.pst_rsname;
	    
	    for (node1 = node->pst_left; node1 != (PST_QNODE *) NULL;
					 node1 = node1->pst_left )
	    {	    
		if ((MEcmp((PTR) name,
			   (PTR) node1->pst_sym.pst_value.pst_s_rsdm.pst_rsname,
			   DB_MAXNAME) == 0)
		   )
		{
		    (VOID) psf_error(2013L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1, 
			psf_trmwhite(DB_MAXNAME, (char*) name), (char*) name);
		     return (E_DB_ERROR); 
		}
	    }
	}

	/*
	** Find the leftmost node in the tree.
	*/
	for (node = $2, num_attrs = 0; 
	     node->pst_left != (PST_QNODE *) NULL;
	     node = node->pst_left, num_attrs++)
	;

	if (num_attrs > DB_MAX_COLS)
	{
	    char	command[PSL_MAX_COMM_STRING];
	    i4 	len;
	    i4		max_cols = DB_MAX_COLS;

	    psl_command_string(psq_cb->psq_mode, cb->pss_lang, command, &len);

	    (VOID) psf_error(E_PS0BE0_TOO_MANY_COLS, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 3,
		len, (PTR) command,
		(i4) sizeof(num_attrs), (PTR) &num_attrs,
		(i4) sizeof(max_cols), (PTR) &max_cols);
	    return(E_DB_ERROR);
	}

	/* Allocate the PST_TREE node */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		(PST_QNODE *) NULL, PST_TREE, (PTR) NULL, 0, DB_NODT, (i2) 0,
		(i4) 0, (DB_ANYTYPE *) NULL, &node->pst_left,
		&psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = $Yresdmhd = $2;
    }
	    |	    /* empty */
    {
	$$ = $Yresdmhd = (PST_QNODE *) NULL;
    }
;

newcollist:	    newcol
    {
	$$ = $1;
    }
	  |	    newcollist COMMA newcol
    {
	$$ = pst_tlprpnd($1, $3);
    }
;

newcol:		    col_spec
    {
	DB_STATUS	    status;
	PST_QNODE	    *resdomnode;
	PST_RSDM_NODE	    resdom;

	/* Normalize the attribute name */
	STmove($1, ' ', sizeof(resdom.pst_rsname),
	    (char *) resdom.pst_rsname);

	resdom.pst_rsno = (i4) 1;
	resdom.pst_ntargno = (i4) 0;
	resdom.pst_ttargtype = (i4) PST_USER;
	resdom.pst_rsupdt = (i4) FALSE;
	resdom.pst_rsflags = PST_RS_PRINT;
	resdom.pst_dmuflags = 0;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_RESDOM, (char *) &resdom,
	    sizeof(PST_RSDM_NODE), DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
	    &resdomnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = resdomnode;
    }
	|	    error
    {
	(VOID) psl_sx_error(2720L, cb, psq_cb);
	YYABORT;
    }
;

tbl_elem_list:      tbl_elem
          |	    tbl_elem_list COMMA tbl_elem
;

tbl_elem:           newcolname typedesc
    {
        DB_STATUS               status;

	/* test column name for reserved name;
	 */
	if (PSL_IS_RESERVED_IDENT($1, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    status = psl_ct17_distr_specs(cb, $Yscanbuf_ptr, &$Yxlated_qry,
				    &psq_cb->psq_error);

	    if (DB_FAILURE_MACRO(status))
		return (status);
	}
    }
          |	    tbl_constraint
    {
	DB_STATUS status;
	
	/* check that constraints are allowed for this statement 
	 */
	status = psl_ct22s_cons_allowed(cb, psq_cb, yyvarsp);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

type_qual_list:      /* empty */
    {
	/* nothing specified implies ->
	** 	with null <no default> not system_maintained
	** schang : RMS gateway dictates that nothing implies
	**	    not null with default
	**	PROBLEM : for other gateways that want to comply
	**	    with INGRES rules, we have to defer the this flag
	**	    setting actuntil we know what kind of gateway we
	**	    are using.
        ** schang :  the fips constraint project makes it possible to
        **      use the following flag for RMS GW
	*/
	if (psq_cb->psq_mode == PSQ_REG_IMPORT)
	    $$ = (PSS_TYPE_DEFAULT | PSS_TYPE_NOT_NULL);
	else
	    $$ = PSS_TYPE_NULL;   /* don't want PSS_TYPE_DEFAULT here
                                  ** because WITH NULL implies a default of NULL
                                  ** and the new PSS_TYPE_DEFAULT implies a
                                  ** default of 0 or blank depending on
                                  ** the datatype   (rjb  10/11/92)
                                  */
    }
          |	    type_qual_list1
;

type_qual_list1:    type_qual
          |	    type_qual_list1 type_qual
    {   
	DB_STATUS               status;

	/* check for duplicate and conflicting qualifications
	 */
	status = psl_ct18s_type_qual(psq_cb->psq_mode, $1, $2, cb, $Ydbpinfo,
				     &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
		  
	/* build up bitmap of qualifications specified
	 */
	$$ = $1 | $2;
    }
;

type_qual:	    default
    {
	$Yinconstraint = FALSE;
	cb->pss_stmt_flags &= ~PSS_DEFAULT_VALUE;
    }
          |	    logical_key    
    {
	$Yinconstraint = FALSE;
    }
          |	    null_constraint
    {
	$Yinconstraint = FALSE;
    }
	  |	    col_constraint
    {
	$Yinconstraint = TRUE;
	if ($1 & PSS_TYPE_NOT_NULL)
	    $$ = PSS_TYPE_NOT_NULL;
	else $$ = 0;		/* column constraints return zippo */
    }
	  |	    con_with
    {
	$Yinconstraint = FALSE;
	$$ = 0;		/* column constraint with's too */
    }
;


default:            NOT DEFAULT
    {
	$$ = PSS_TYPE_NDEFAULT;
    }
          |	    user_default
    {
	$$ = $1;
    }
;
             /* the WITH keyword is optional for user-defined defaults,
	     ** but not for INGRES defaults, so use the with_noise production
	     */
user_default:       with_noise DEFAULT 
    {
	DB_STATUS status;
	
	/* get the string version of the default value by opening
	** a text chain and having the scanner put text into it;
	** use TXTEMIT2 and tchain2 because the first chain (pss_tchain) will
	** be used for procedure text if this is inside a CREATE PROCEDURE.
	*/
	status = psq_topen(&cb->pss_tchain2, 
			   &cb->pss_memleft, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	cb->pss_stmt_flags |= PSS_TXTEMIT2;	    /* Indicate to emit text */
	cb->pss_stmt_flags |= PSS_DEFAULT_VALUE;
    }
		    def_value
    {
	DB_STATUS	status;
	DB_TEXT_STRING	*def_txt;
	i4 	err_code, err;
	char		command[PSL_MAX_COMM_STRING];
	i4 	length;
	
	/* turn off text-emit flag; 
	 */
	cb->pss_stmt_flags &= ~PSS_TXTEMIT2;
    
	if ($4 != (PST_QNODE *) NULL)  /* <=== */
	{
	    /*** have user-defined default 
	     ***/
	    $$ = PSS_TYPE_DEFAULT | PSS_TYPE_USER_DEFAULT;

	    /* store away the default value string;
	    ** will be passed to psl_ct14s_typedesc for processing
	    */
	    status = psq_tmulti_out(cb, (PSS_USRRANGE *) NULL,
				    cb->pss_tchain2, &cb->pss_ostream,
				    &def_txt, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return(status);

	    $Ydefault_text = def_txt;

	    /* store away the node representing the default value;
	    ** will be passed to ADF to check that it matches column's datatype
	    */
	    $Ydefault_node = $4;  /* <=== */

	    /* in 6.5, user-defined defaults are only allowed 
	    ** in CREATE TABLE statements;
	    ** if TEMP table, CREATE PROCEDURE, or gateway, return error;
	    ** also, if distributed (STAR), return error
	    ** Added support for alter table alter column.
	    */
	    if ((cb->pss_distrib & DB_3_DDB_SESS)
		|| ( (psq_cb->psq_mode != PSQ_CREATE) &&
		     (psq_cb->psq_mode != PSQ_ATBL_ADD_COLUMN) && 
		     (psq_cb->psq_mode != PSQ_ATBL_ALTER_COLUMN) ) )
	    {
		psl_command_string(psq_cb->psq_mode, 
				   cb->pss_lang, command, &length);
		
		if (cb->pss_distrib & DB_3_DDB_SESS)
		    err = E_PS0489_DDB_USER_DEFAULT_NOT_ALLOWED;
		else 
		    err = E_PS0476_USER_DEFAULT_NOTALLOWED;
		
		_VOID_ psf_error(err, 0L, PSF_USERERR,
				 &err_code, &psq_cb->psq_error, 1,
				 length, command);
		return (E_DB_ERROR);
	    }
	} /* end if ($4 != NULL) */
	else
	{
	    /* have INGRES default 
	     */
	    $$ = PSS_TYPE_DEFAULT;

	    /* clear the default value pointers
	     */
	    $Ydefault_text = (DB_TEXT_STRING *) NULL;
	    $Ydefault_node = (PST_QNODE *) NULL;

	    /* make sure WITH keyword was present
	     */
	    if ($1 == FALSE)
	    {
		/* return error
		 */
		psl_command_string(psq_cb->psq_mode, 
				   cb->pss_lang, command, &length);

		if ( (psq_cb->psq_mode == PSQ_CREATE) ||
		     (psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) || 
		     (psq_cb->psq_mode == PSQ_ATBL_ALTER_COLUMN) )
		{
		    /* give error noting DEFAULT <value> as an option
		     */
		    err = E_PS0477_BAD_DEFAULTSYNTAX_SQL92;
		}
		else
		{   /* give error noting WITH DEFAULT option only 
		     */
		    err = E_PS0478_BAD_DEFAULT_SYNTAX;
		}
		_VOID_ psf_error(err, 0L, PSF_USERERR,
				 &err_code, &psq_cb->psq_error, 1,
				 length, command);
		return (E_DB_ERROR);

	    } /* end if error */

	} /* end else have INGRES default */
	
	/* close text chain and clear its pointer
	** so we don't try to close/free it again 
	*/
	status = psq_tclose(cb->pss_tchain2, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
	cb->pss_tchain2 = (PTR) NULL;
	
    }
;

def_value:	    /* empty */	    /* INGRES default */
    {
	$$ = (PST_QNODE *) NULL;
    }
          |	    null_word
          |	    constant	    /* includes USER and CURRENT_USER */
          |	    UAOP constant   /* 'constant' is positive numbers only,
				     * so we handle negative numbers here */
    {
	PST_QNODE              *newnode;
	PST_OP_NODE	       opnode;
	DB_STATUS	       status;

	/*
	** The scanner is unable to distinguish between unary and binary +,
	** and unary and binary -.  Therefore, translate the binary operator
	** ids to unary ones here.
	*/
	if ($1 == ADI_ADD_OP)
	    opnode.pst_opno = ADI_PLUS_OP;
	else if ($1 == ADI_SUB_OP)
	    opnode.pst_opno = ADI_MINUS_OP;

	opnode.pst_opmeta   = PST_NOMETA;
	opnode.pst_isescape = PST_DOESNT_APPLY;

	status = pst_node(cb, &cb->pss_ostream, $2, (PST_QNODE *) NULL,
	    PST_UOP, (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, 0);

	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
	| seq_operator		/* NEXT VALUE FOR sequence */
;

with_noise:         WITH
    {
	$$ = TRUE;    /* set flag that WITH was seen; check in WITH DEFAULT */
    }
          |	    
    {
	$$ = FALSE;
    }
;

null_constraint:    NOT NULLWORD    
    {
	DB_STATUS	status;
	PSS_CONS	*cons;
	i4		val1=0, val2=0;  /* for trace point checking */
	
	/* don't create a NOT NULL constraint for temp tables or dbprocs;
	** only create the constraint for create table, 
	** and then only if the correct trace point is set (see below).
	**
	** Due to performance problems caused by generating the dummy NOT NULL
	** constraints, we are not generating these constraints in 6.5.
	** These constraints are only needed for Intermediate SQL92
	** catalogs, and we don't need to be compliant with that yet.
	**
	** But a trace point has been added to turn on the dummy-constraint
	** generation so that it can continue to be tested (so that future
	** changes will not break this feature).      B58442
	** 				-roger blumer   01/04/94
	*/
	if (   ( (psq_cb->psq_mode == PSQ_CREATE) ||
	         (psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) || 
	         (psq_cb->psq_mode == PSQ_ATBL_ALTER_COLUMN) )
	    && (ult_check_macro(&cb->pss_trace,	
				PSS_GENERATE_NOT_NULL_CONS, &val1, &val2)))
	{
	    /* build a constraint info block
	     */
	    status = psl_ct19s_constraint(cb, 
		       (i4) PSS_CONS_CHECK|PSS_CONS_COL|PSS_CONS_NOT_NULL,
				  (PSY_COL *) &($Ylastcol),
				  (PSS_OBJ_NAME *) NULL,
				  (PSY_COL *) NULL, (PSS_TREEINFO *) NULL,
				  &cons, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return(status);
		  
	    /* attach new constraint to the list
	     */
	    status = psl_ct21s_cons_name((char *) NULL, cons, &($Ycons_list));
	    /*
	     ** NOTE: when decide to implement Intermediate Level SQL92,
	     ** will have to allow a constraint name to be specified 
	     ** for NOT NULL; 
	     ** to do so, just add the constraint_name production as
	     ** the first part of this production and
	     ** replace the NULL ptr in psl_ct21s_cons_name with $1
	     */
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}

	$$ = PSS_TYPE_NOT_NULL;
    }
          |	    WITH NULLWORD	/* not really a constraint */
    {
	$$ = PSS_TYPE_NULL;
    }
    /* NOTE: the following introduces an irreconcilable shift/reduce conflict
    ** in (for example) "col1 int with default null". The conflict is harmless
    ** because in such cases, it will assume that null is the default and that 
    ** the column is nullable - just as one would wish. */
          |	    NULLWORD		/* same without WITH */
    {
	$$ = PSS_TYPE_NULL;
    }
;

logical_key:        WITH SYSTEM_MAINTAINED
    {  
	i4	    err_code;

	/* schang: GW error : not allowed for RMSGW */
	if (psq_cb->psq_mode == PSQ_REG_IMPORT)
	{
	    (VOID) psf_error(8004L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 1,
			     (i4) STtrmwhite("system_maintained"),
			     "system_maintained");
	    return (E_DB_ERROR);
	}

	$$ = PSS_TYPE_SYS_MAINTAINED;
    }
          |	    NOT SYSTEM_MAINTAINED
    {  
	i4	    err_code;

	/* schang: GW error : not allowed for RMSGW */
	if (psq_cb->psq_mode == PSQ_REG_IMPORT)
	{
	    (VOID) psf_error(8004L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 1,
			     (i4) STtrmwhite("system_maintained"),
			     "system_maintained");
	    return (E_DB_ERROR);
	}

	$$ = PSS_TYPE_NOT_SYS_MAINTAINED;
    }
;

col_constraint:     constraint_name col_constraint2 
    {   
	DB_STATUS	status;
	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	/* we have processed the constraint;
	** turn new_object bit back on, as we could still see more column names
	*/
	cb->pss_stmt_flags |= PSS_NEW_OBJ_NAME;

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Special handling for CREATE SCHEMA
	    */
	    if ($2 == (PSS_CONS *) NULL)	/* Ignore if not REFERENTIAL */
		return(E_DB_OK);
	}

	if ((psq_cb->psq_mode == PSQ_CREATE) &&
	    (psq_cb->psq_info != (PST_INFO *) NULL) &&
	    (psq_cb->psq_info->pst_execflags & PST_SCHEMA_MODE))
	{
	    /*
	    ** Don't drive this semantic action for CREATE TABLE
	    ** REFERENCES clauses if being done on behalf of CREATE SCHEMA
	    */
	    if ($2 == (PSS_CONS *) NULL)	/* Ignore if REFERENTIAL */
	        return(E_DB_OK);
	}

	status = psl_ct21s_cons_name($1, $2, &($Ycons_list));

	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* If PRIMARY KEY or UNIQUE, NOT NULL is implied. */
	if ($2 && ($2->pss_cons_type & PSS_CONS_UNIQUE))
	    $$ = PSS_TYPE_NOT_NULL;
	else
	    $$ = 0;
    }
;

col_constraint2:    unique_spec
    {   
	DB_STATUS	status;
	PSS_CONS	*cons;
	
#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Don't drive this semantic action for CREATE SCHEMA
	    */
	    $$ = (PSS_CONS *) NULL;	/* Signal that this action not taken */
	    return(E_DB_OK);
	}

	/* check that constraints are allowed for this statement 
	 */
	status = psl_ct22s_cons_allowed(cb, psq_cb, yyvarsp);

	if (DB_FAILURE_MACRO(status))
	    return(status);

	status = psl_ct19s_constraint(cb, $1 | PSS_CONS_COL, 
				      (PSY_COL *) &($Ylastcol),
				      (PSS_OBJ_NAME *) NULL,
				      (PSY_COL *) NULL, (PSS_TREEINFO *) NULL,
				      &cons, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
		  
	cb->pss_curcons = cons;		/* save for with analysis */
	$$ = cons;
    }
          |	    check_cons
    {   
	DB_STATUS	status;
	PSS_CONS	*cons;
	
#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Don't drive this semantic action for CREATE SCHEMA
	    */
	    $$ = (PSS_CONS *) NULL;	/* Signal that this action not taken */
	    return(E_DB_OK);
	}
	
	status = psl_ct19s_constraint(cb, 
				      (i4) PSS_CONS_CHECK | PSS_CONS_COL,
				      (PSY_COL *) &($Ylastcol),
				      (PSS_OBJ_NAME *) NULL,
				      (PSY_COL *) NULL, $1,
				      &cons, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
		  
	$$ = cons;
    }
	  |	    col_refcon ref_action_list
    {
	$$ = $1;
    }
;

col_refcon:	 REFERENCES obj_spec LPAREN cons_col RPAREN
    {   
	DB_STATUS	status;
	PSS_CONS	*cons;
	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Capture object name for CREATE SCHEMA
	    */
	    status = psl_cs06s_obj_spec(cb, psq_cb, &($Ydeplist), $2,
				        (u_i4)PST_DEP_NOORDER);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}

	if ((psq_cb->psq_mode == PSQ_CREATE) &&
	    (psq_cb->psq_info != (PST_INFO *) NULL) &&
	    (psq_cb->psq_info->pst_execflags & PST_SCHEMA_MODE))
	{
	    /*
	    ** Don't drive this semantic action for CREATE TABLE
	    ** if being done on behalf of CREATE SCHEMA
	    */
	    $$ = (PSS_CONS *) NULL;	/* Signal that this action not taken */
	    return(E_DB_OK);
	}
	
	/* check that constraints are allowed for this statement 
	 */
	status = psl_ct22s_cons_allowed(cb, psq_cb, yyvarsp);

	if (DB_FAILURE_MACRO(status))
	    return(status);

	status = psl_ct19s_constraint(cb, (i4) PSS_CONS_REF | PSS_CONS_COL,
				      (PSY_COL *) &($Ylastcol), $2, $4,
				      (PSS_TREEINFO *) NULL,
				      &cons, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
		  
	cb->pss_curcons = cons;		/* save for with analysis */
	$$ = cons;
    }
          |	    REFERENCES obj_spec
    {   
	DB_STATUS	status;
	PSS_CONS	*cons;
	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Capture object name for CREATE SCHEMA
	    */
	    status = psl_cs06s_obj_spec(cb, psq_cb, &($Ydeplist), $2,
				        (u_i4)PST_DEP_NOORDER);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}

	if ((psq_cb->psq_mode == PSQ_CREATE) &&
	    (psq_cb->psq_info != (PST_INFO *) NULL) &&
	    (psq_cb->psq_info->pst_execflags & PST_SCHEMA_MODE))
	{
	    /*
	    ** Don't drive this semantic action for CREATE TABLE
	    ** if being done on behalf of CREATE SCHEMA
	    */
	    $$ = (PSS_CONS *) NULL;	/* Signal that this action not taken */
	    return(E_DB_OK);
	}
	
	/* check that constraints are allowed for this statement 
	 */
	status = psl_ct22s_cons_allowed(cb, psq_cb, yyvarsp);

	if (DB_FAILURE_MACRO(status))
	    return(status);

	status = psl_ct19s_constraint(cb, (i4) PSS_CONS_REF | PSS_CONS_COL,
				      (PSY_COL *) &($Ylastcol), $2,
				      (PSY_COL *) NULL,
				      (PSS_TREEINFO *) NULL,
				      &cons, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
		  
	cb->pss_curcons = cons;		/* save for with analysis */
	$$ = cons;
    }
;

ref_action_list:	/* empty */
	  |	    ON ref_action
	  |	    ON ref_action ON ref_action
;

ref_action:	    UPDATE ref_action_item
    {
	PSS_CONS	*cons = cb->pss_curcons;

	if (cons->pss_cons_flags & (PSS_CONS_UPD_CASCADE |
	  PSS_CONS_UPD_SETNULL | PSS_CONS_UPD_RESTRICT | PSS_CONS_UPD_NOACT))
	{	/* already specified an update referential action */
	    i4	err_code;

	    (VOID) psf_error(E_PS04B2_CONS_REFOPTS, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	if ($2 == CASCADE) cons->pss_cons_flags |= PSS_CONS_UPD_CASCADE;
	else if ($2 == NULLWORD) cons->pss_cons_flags |= PSS_CONS_UPD_SETNULL;
	else if ($2 == RESTRICT) cons->pss_cons_flags |= PSS_CONS_UPD_RESTRICT;
	else if ($2 == 0) cons->pss_cons_flags |= PSS_CONS_UPD_NOACT;
    }
	  |	    DELETE ref_action_item
    {
	PSS_CONS	*cons = cb->pss_curcons;

	if (cons->pss_cons_flags & (PSS_CONS_DEL_CASCADE |
	  PSS_CONS_DEL_SETNULL | PSS_CONS_DEL_RESTRICT | PSS_CONS_DEL_NOACT))
	{	/* already specified a delete referential action */
	    i4	err_code;

	    (VOID) psf_error(E_PS04B2_CONS_REFOPTS, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	if ($2 == CASCADE) cons->pss_cons_flags |= PSS_CONS_DEL_CASCADE;
	else if ($2 == NULLWORD) cons->pss_cons_flags |= PSS_CONS_DEL_SETNULL;
	else if ($2 == RESTRICT) cons->pss_cons_flags |= PSS_CONS_DEL_RESTRICT;
	else if ($2 == 0) cons->pss_cons_flags |= PSS_CONS_DEL_NOACT;
    }
;

ref_action_item:	RESTRICT
    {
	$$ = RESTRICT;
    }
	  |	    CASCADE
    {
	$$ = CASCADE;
    }
	  |	    SET NULLWORD
    {
	$$ = NULLWORD;
    }
	  |	    nonkeyword nonkeyword
    {
	if (!STcompare($1, "no") && !STcompare($2, "action"))
		$$ = 0;
	else {
	    if (psq_cb->psq_mode == PSQ_CONS) psq_cb->psq_mode = $Ysavemode;
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}
    }
;

constraint_name:     /* empty */
    {
	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	$$ = (char *) NULL;   

	/* there was no new object/constraint name;
	** turn off bit until are done parsing rest of constraint
	*/
	cb->pss_stmt_flags &= ~PSS_NEW_OBJ_NAME;

    }
          |	    CONSTRAINT generic_ident
    {	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	/* test constraint name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT($2, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);
	    
	/* we have processed the new object/constraint name;
	** turn off bit until are done parsing rest of constraint
	*/
	cb->pss_stmt_flags &= ~PSS_NEW_OBJ_NAME;

	$$ = $2;
    }
;

unique_spec:        UNIQUE
    {
	$$ = PSS_CONS_UNIQUE;
    }
          |	    PRIMARYKEY
    {
	$$ = PSS_CONS_UNIQUE | PSS_CONS_PRIMARY;
    }
;


cons_colspec:       LPAREN cons_collist RPAREN
    {
	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	$$ = $2; 
    }
;

cons_collist:	    cons_col
    {
	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	$$ = $1;
    }
	    |	    cons_collist COMMA cons_col
    {
	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	/* attach newcol to end of column list 
	** (so they stay in the order the user specified; order is important!)
	*/
	QUinsert((QUEUE *) $3, $1->queue.q_prev);
		  
	$$ = $1;
    }
;

cons_col:	    col_spec	       /* includes delimited identifiers */
    {
	DB_STATUS	status;
	PSY_COL		*newcol;
	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	newcol = (PSY_COL *) NULL;
	
	status = psl_ct20s_cons_col(cb, &newcol, $1, &psq_cb->psq_error);
	
	if (DB_FAILURE_MACRO(status))
	    return(status);
		  
	/*
	** remember whether the column name was specified 
	** using a regular or a delimited identifier
	*/
	if ($Yid_type == PSS_ID_REG)
	{
	    newcol->psy_col_flags |= PSY_REGID_COLSPEC;
	}

	$$ = newcol;
    }
;

check_cons:	    CHECK 
    {
	PTR    	    piece;
	DB_STATUS   status;
	
	/* check that constraints are allowed for this statement 
	** (do this check a little earlier than for other constraints,
	**  as the txtemit code and boolean_expr code below will break
	**  for illegal statements [like CREATE PROC])
	*/
	status = psl_ct22s_cons_allowed(cb, psq_cb, yyvarsp);

	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* 
	** set flag that we are processing a check constraint;
        **
	** This is used in the boolean_expr productions to delay type
	** resolution because, for CREATE TABLE, we may not know the type
	** of the column yet (i.e. the CHECK constraint could come before
	** the column definition)
	*/
	cb->pss_stmt_flags |= PSS_PARSING_CHECK_CONS;	    


	/* emit text for CHECK constraints, 
	** so can store it in the constraint info block as the
	** user typed it in, instead of as the parser breaks it up
	** (e.g. as IN or BETWEEN instead of converted into several ORs).
	** This (first) text chain is stored in IIQRYTEXT for the user to see.
	** 
	** We also need to keep a 2nd text chain so that we can add the "NEW"
	** correlation name to its text; this text chain will be used in
	** creating a rule to enforce the constraint.
	*/
	cb->pss_stmt_flags |= PSS_TXTEMIT | PSS_TXTEMIT2;

	/* initialize text chain, and stick just-parsed CHECK word into it
	 */
	status = psq_topen(&cb->pss_tchain, 
			   &cb->pss_memleft, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
	status = psq_tadd(cb->pss_tchain, (u_char *) ERx("CHECK"),
			  sizeof("CHECK") - 1, &piece, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* initialize 2nd chain, and stick NOT into it (for rule)
	 */
	status = psq_topen(&cb->pss_tchain2, 
			   &cb->pss_memleft, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
	status = psq_tadd(cb->pss_tchain2, (u_char *) ERx("NOT "),
			  sizeof("NOT ") - 1, &piece, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** if processing ALTER TABLE, zero out $Ycheck_cons_cols which will
	** contain a map of attributes referenced inside the constraint
	*/
	if ( (psq_cb->psq_mode == PSQ_ALTERTABLE) ||
	     (psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) )
	{
	    i4	    i;

	    DB_COLUMN_BITMAP_INIT(($Ycheck_cons_cols.db_domset), i, 0);
	}
	
    }
		    LPAREN boolean_expr RPAREN
    {
	i4	err_code;

	if (psl_seqop_search($4->pss_tree))
	{
	    /* No sequence operators in check constraints. */
	    (void)psf_error(6319L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* turn off CHECK_CONS flag
	 */
	cb->pss_stmt_flags &= ~PSS_PARSING_CHECK_CONS;	    

	/* turn off TXTEMIT flag; the text is actually copied 
	** and the text chain is freed in psl_ct19s_constraint
	*/
	cb->pss_stmt_flags &= ~PSS_TXTEMIT;
	cb->pss_stmt_flags &= ~PSS_TXTEMIT2;

	$$ = $4;
    }
;

con_with:	    WITH 
    {
	if (!$Yinconstraint)	/* better be following constraint def */
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}
	$Ysavemode = psq_cb->psq_mode;		/* save query mode */
	psq_cb->psq_mode = PSQ_CONS;		/* & reset for checks */
	/* reset options */
	MEfill(sizeof ($Ywith_clauses), 0, &$Ywith_clauses); 
    }
		    con_with_list
    {
	psq_cb->psq_mode = $Ysavemode;		/* reset query mode */
	$$ = 0;
	/* reset options */
	MEfill(sizeof ($Ywith_clauses), 0, &$Ywith_clauses);
    }
;

con_with_list:	    nonkeyword INDEX
    {	/* with no index */
	if (!STcompare($1, "no"))
	    cb->pss_curcons->pss_cons_flags |= PSS_CONS_NOINDEX;
	else {
	    if (psq_cb->psq_mode == PSQ_CONS) psq_cb->psq_mode = $Ysavemode;
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}
    }
	  |	    tblwithopt
    {
	/* Show the presence of index with-opts (one or many) */
	cb->pss_curcons->pss_cons_flags |= PSS_CONS_INDEX_OPTS;
    }
	  |	    LPAREN tblwithlist RPAREN
    {
	cb->pss_curcons->pss_cons_flags |= PSS_CONS_INDEX_OPTS;
    }
;

tbl_constraint:     constraint_name tbl_constraint2 con_with1
    {   
	DB_STATUS	status;
	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	/* we have processed the constraint;
	** turn new_object bit back on, as we could still see more column names
	*/
	cb->pss_stmt_flags |= PSS_NEW_OBJ_NAME;

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Special handling for CREATE SCHEMA
	    */
	    if ($2 == (PSS_CONS *) NULL)	/* Ignore if not REFERENTIAL */
		return(E_DB_OK);
	}

	if ((psq_cb->psq_mode == PSQ_CREATE) &&
	    (psq_cb->psq_info != (PST_INFO *) NULL) &&
	    (psq_cb->psq_info->pst_execflags & PST_SCHEMA_MODE))
	{
	    /*
	    ** Don't drive this semantic action for CREATE TABLE
	    ** REFERENCES clauses if being done on behalf of CREATE SCHEMA
	    */
	    if ($2 == (PSS_CONS *) NULL)	/* Ignore if REFERENTIAL */
	        return(E_DB_OK);
	}

	status = psl_ct21s_cons_name($1, $2, &($Ycons_list));

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

con_with1:	    con_with
	  |	/* nuttin' */
;

tbl_constraint2:    unique_spec cons_colspec
    {   
	DB_STATUS	status;
	PSS_CONS	*cons;
	
#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** This semantic action is not driven by CREATE SCHEMA
	    */
	    $$ = (PSS_CONS *) NULL;	/* Signal that this action not taken */
	    return(E_DB_OK);
	}
	
	status = psl_ct19s_constraint(cb, $1, $2,
				      (PSS_OBJ_NAME *) NULL,
				      (PSY_COL *) NULL, (PSS_TREEINFO *) NULL,
				      &cons, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
		  
	cb->pss_curcons = cons;		/* save for with analysis */
	$Yinconstraint = TRUE;		/* to allow "with" parsing */
	$$ = cons;
    }
          |	    check_cons
    {   
	DB_STATUS	status;
	PSS_CONS	*cons;
	
#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** This semantic action is not driven by CREATE SCHEMA
	    */
	    $$ = (PSS_CONS *) NULL;	/* Signal that this action not taken */
	    return(E_DB_OK);
	}
	
	status = psl_ct19s_constraint(cb, (i4) PSS_CONS_CHECK,
				      (PSY_COL *) NULL, (PSS_OBJ_NAME *) NULL,
				      (PSY_COL *) NULL, $1,
				      &cons, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/*
	** if this CHECK constraint was specified using ALTER TABLE statement,
	** we need to copy the map of attributes referenced in the <search
	** condition> from $Ycheck_cons_cols into *cons->pss_check_cons_cols
	*/
	if (psq_cb->psq_mode == PSQ_ALTERTABLE) 
	{
	    status = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_COLUMN_BITMAP),
		(PTR *) &cons->pss_check_cons_cols, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return(status);

	    STRUCT_ASSIGN_MACRO($Ycheck_cons_cols,
				(*cons->pss_check_cons_cols));
	}
	
	$Yinconstraint = TRUE;		/* to allow "with" parsing */
	$$ = cons;
	cb->pss_curcons = cons;		/* save for with analysis (even if
					** it doesn't make sense for check) */
    }
	  |	    tbl_refcon ref_action_list
    {
	$Yinconstraint = TRUE;		/* to allow "with" parsing */
	$$ = $1;
    }
;
	
tbl_refcon:	    FOREIGNKEY cons_colspec REFERENCES obj_spec cons_colspec
    {   
	DB_STATUS	status;
	PSS_CONS	*cons;
	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Capture object name for CREATE SCHEMA
	    */
	    status = psl_cs06s_obj_spec(cb, psq_cb, &($Ydeplist), $4,
				        (u_i4)PST_DEP_NOORDER);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}

	if ((psq_cb->psq_mode == PSQ_CREATE) &&
	    (psq_cb->psq_info != (PST_INFO *) NULL) &&
	    (psq_cb->psq_info->pst_execflags & PST_SCHEMA_MODE))
	{
	    /*
	    ** Don't drive this semantic action for CREATE TABLE
	    ** if being done on behalf of CREATE SCHEMA
	    */
	    $$ = (PSS_CONS *) NULL;	/* Signal that this action not taken */
	    return(E_DB_OK);
	}

	status = psl_ct19s_constraint(cb, (i4) PSS_CONS_REF,
				      $2, $4, $5, (PSS_TREEINFO *) NULL,
				      &cons, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
		  
	cb->pss_curcons = cons;		/* save for with analysis */
	$$ = cons;
    }
          |	    FOREIGNKEY cons_colspec REFERENCES obj_spec
    {   
	DB_STATUS	status;
	PSS_CONS	*cons;
	
#ifdef	xDEBUG
	psl_debug();
#endif

	/*
	** This semantic action is driven for CREATE SCHEMA
	*/

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Capture object name for CREATE SCHEMA
	    */
	    status = psl_cs06s_obj_spec(cb, psq_cb, &($Ydeplist), $4,
				        (u_i4)PST_DEP_NOORDER);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}

	if ((psq_cb->psq_mode == PSQ_CREATE) &&
	    (psq_cb->psq_info != (PST_INFO *) NULL) &&
	    (psq_cb->psq_info->pst_execflags & PST_SCHEMA_MODE))
	{
	    /*
	    ** Don't drive this semantic action for CREATE TABLE
	    ** if being done on behalf of CREATE SCHEMA
	    */
	    $$ = (PSS_CONS *) NULL;	/* Signal that this action not taken */
	    return(E_DB_OK);
	}

	status = psl_ct19s_constraint(cb, (i4) PSS_CONS_REF,
				      $2, $4, (PSY_COL *) NULL, 
				      (PSS_TREEINFO *) NULL,
				      &cons, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
		  
	cb->pss_curcons = cons;		/* save for with analysis */
	$$ = cons;
    }
;
	
newcolname:	    col_spec
    {
        DB_STATUS               status;

	/*
	** Capture column name for reconstruction of
	** column-level constraints
	*/
	STmove($1, ' ', sizeof(DB_ATT_NAME),
		(char *) &($Ylastcol.psy_colnm.db_att_name));
	$Yinconstraint = FALSE;

	/*
	** If we are doing CREATE SCHEMA, we are done.
	*/
	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	    return(E_DB_OK);

	/*
	** This rule is part of production used by CREATE TABLE and (gateway)
	** REGISTER TABLE.  For Star's REGISTER, error will be issued in
	** 'typedesc' rule.
	*/
	if (psq_cb->psq_mode != PSQ_REG_LINK)
	{
	    if (   cb->pss_distrib & DB_3_DDB_SESS
		&& $Yid_type == PSS_ID_DELIM)
	    {
		cb->pss_distr_sflags |= PSS_DELIM_COLNAME;
	    }
	    status = psl_ct13_newcolname(cb, $1, psq_cb, &$Yxlated_qry,
					&$Yscanbuf_ptr);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}

	$$ = $1;
    }
	|	    error
    {
	(VOID) psl_sx_error(2720L, cb, psq_cb);
	YYABORT;
    }
;

typedesc:          tname type_qual_list collate
    {
	DB_STATUS		status;

	if (psq_cb->psq_mode == PSQ_REG_LINK)
	{
	    i4	    err_code;

		/* user error 2036 is mapped to cater for REGISTER PROCEDURE */

	    (VOID) psf_error(E_PS1206_REGISTER, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 2, (i4) sizeof(cb->pss_lineno), 
				&cb->pss_lineno, (i4) STtrmwhite($1), $1);
		return (E_DB_ERROR);
	}

	status = psl_ct14_typedesc(cb, $1, 0, (i4 *) NULL, 
			   $2, $Ydefault_node, $Ydefault_text, psq_cb, $3);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
	$$ = $1;
    }
	|         tname LPAREN intconst_e RPAREN type_qual_list collate
    {
	DB_STATUS               status;
	i4			len = $3;

	if (psq_cb->psq_mode == PSQ_REG_LINK)
	{
	    i4	    err_code;

	    (VOID) psf_error(E_PS1206_REGISTER, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 2, (i4) sizeof(cb->pss_lineno),
			&cb->pss_lineno, (i4) STtrmwhite($1), $1);
		return (E_DB_ERROR);
	}
	status = psl_ct14_typedesc(cb, $1, 1, &len, 
			   $5, $Ydefault_node, $Ydefault_text, psq_cb, $6);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
	$$ = $1;
    }
	|         tname LPAREN intconst_e COMMA intconst_e RPAREN type_qual_list
    {
	i4			parms[2];
	DB_STATUS               status;

	if (psq_cb->psq_mode == PSQ_REG_LINK)
	{
	    i4	    err_code;

	    (VOID) psf_error(E_PS1206_REGISTER, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 2, (i4) sizeof(cb->pss_lineno),
			&cb->pss_lineno, (i4) STtrmwhite($1), $1);
		return (E_DB_ERROR);
	}
	parms[0] = $3;
	parms[1] = $5;
	status = psl_ct14_typedesc(cb, $1, 2, parms, 
			   $7, $Ydefault_node, $Ydefault_text, psq_cb, -1);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
	$$ = $1;
    }
	|	tname dt_wquals tname type_qual_list
    {
	DB_STATUS		status;
	char			*value;

	if (psq_cb->psq_mode == PSQ_REG_LINK)
	{
	    i4	    err_code;

		/* user error 2036 is mapped to cater for REGISTER PROCEDURE */

	    (VOID) psf_error(E_PS1206_REGISTER, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 2, (i4) sizeof(cb->pss_lineno), 
				&cb->pss_lineno, (i4) STtrmwhite($1), $1);
		return (E_DB_ERROR);
	}

	/* One of the TIME/TIMESTAMP's. Glue all the bits together. */
	status = psl_ct11_tname_name_name(cb, psq_cb, $1, $2, $3, &value);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	status = psl_ct14_typedesc(cb, value, 0, (i4 *) NULL, 
			   $4, $Ydefault_node, $Ydefault_text, psq_cb, -1);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
	$$ = $1;
    }
	|	tname TO tname type_qual_list
    {
	DB_STATUS		status;
	char			*value;

	if (psq_cb->psq_mode == PSQ_REG_LINK)
	{
	    i4	    err_code;

		/* user error 2036 is mapped to cater for REGISTER PROCEDURE */

	    (VOID) psf_error(E_PS1206_REGISTER, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 2, (i4) sizeof(cb->pss_lineno), 
				&cb->pss_lineno, (i4) STtrmwhite($1), $1);
		return (E_DB_ERROR);
	}

	/* One of the INTERVAL xxx TO xxx type's. Glue the bits together. */
	status = psl_ct11_tname_name_name(cb, psq_cb, $1, "to", $3, 
						&value);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	status = psl_ct14_typedesc(cb, value, 0, (i4 *) NULL, 
			   $4, $Ydefault_node, $Ydefault_text, psq_cb, -1);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
	$$ = $1;
    }
	|	tname TO tname LPAREN intconst_e RPAREN type_qual_list
    {
	DB_STATUS		status;
	char			*value;
	i4			len = $5;

	if (psq_cb->psq_mode == PSQ_REG_LINK)
	{
	    i4	    err_code;

		/* user error 2036 is mapped to cater for REGISTER PROCEDURE */

	    (VOID) psf_error(E_PS1206_REGISTER, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 2, (i4) sizeof(cb->pss_lineno), 
				&cb->pss_lineno, (i4) STtrmwhite($1), $1);
		return (E_DB_ERROR);
	}

	/* One of the INTERVAL xxx TO xxx type's. Glue the bits together. */
	status = psl_ct11_tname_name_name(cb, psq_cb, $1, "to", $3, 
						&value);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	status = psl_ct14_typedesc(cb, value, 1, &len,
			   $7, $Ydefault_node, $Ydefault_text, psq_cb, -1);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
	$$ = $1;
    }
	|	tname LPAREN intconst_e RPAREN dt_wquals tname type_qual_list
    {
	DB_STATUS		status;
	char			*value;
	i4			len = $3;

	if (psq_cb->psq_mode == PSQ_REG_LINK)
	{
	    i4	    err_code;

		/* user error 2036 is mapped to cater for REGISTER PROCEDURE */

	    (VOID) psf_error(E_PS1206_REGISTER, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 2, (i4) sizeof(cb->pss_lineno), 
				&cb->pss_lineno, (i4) STtrmwhite($1), $1);
		return (E_DB_ERROR);
	}

	/* One of the multi-name date/time's. Glue all the bits together. */
	status = psl_ct11_tname_name_name(cb, psq_cb, $1, $5, $6, &value);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	status = psl_ct14_typedesc(cb, value, 1, &len,
			   $7, $Ydefault_node, $Ydefault_text, psq_cb, -1);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
	$$ = $1;
    }
;

dt_wquals	: WTIME
{
	$$ = "with time";
}
	|	WLOCAL
{
	$$ = "with local";
}
	|	WOTIME
{
	$$ = "without time";
}
;

tname:		NAME
    {
	$$ = $1;
    }
	|	NAME NAME
    {
	DB_STATUS		status;
	char			*value;

	status = psl_ct11_tname_name_name(cb, psq_cb, $1, $2, 
						(char *)NULL, &value);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	$$ = value;
    }
	|	INTERVAL NAME
    {
	DB_STATUS		status;
	char			*value;

	status = psl_ct11_tname_name_name(cb, psq_cb, "interval", $2, 
						(char *)NULL, &value);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	$$ = value;
    }
	|      NAME NAME NAME
    {
	DB_STATUS		status;
	char			*value;

	status = psl_ct11_tname_name_name(cb, psq_cb, $1, $2, $3, &value);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	$$ = value;
    }
	|      NAME NAME NAME NAME
    {
	DB_STATUS		status;
	char			*value;

	status = psl_ct11_tname_name_name(cb, psq_cb, $1, $2, $3, &value);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	status = psl_ct11_tname_name_name(cb, psq_cb, value, $4,
						(char *) NULL, &value);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	$$ = value;
    }
;

collate:		/* empty */
    {
	$$ = -1;
    }
	    |	    COLLATE generic_ident
    {
	i4			collID;

	if (!psl_validate_collation_name($2, &collID))
	{
	    /* report error in collation name. */
	    i4	    err_code;

	    (VOID) psf_error(6424L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) STtrmwhite($2), $2);
	    return (E_DB_ERROR);
	}
	$$ = collID;
    }
;

tbl_with_clause:    tbloptionalwith
    {
	DB_STATUS		status;

	status = psl_ct3_crwith(cb, psq_cb->psq_mode, &$Ywith_clauses,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

tbloptionalwith:    WITH tblwithlist
	    |
;


tblwithlist:	    tblwithopt
	    |	    tblwithlist COMMA tblwithopt
;

tblwithopt:	    twith_name
	    |	    twith_ix_name
	    |	    twith_nm_eq_str
	    |	    twith_tb_eq_id
	    |	    twith_num
	    |	    twith_word
	    |	    twith_list
;


/* name = name clause in WITH.  For Star, the only productions that can
** get here are CREATE TABLE-related, Star doesn't do CREATE INDEX or
** MODIFY.
*/
twith_name:	    nonkeyword EQUAL twith_nkw_kwd
    {
	DB_STATUS		status;

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    status = psl_ct15_distr_with(cb, $1, $3,
			&$Yxlated_qry, FALSE, psq_cb);
	}
	else
	{
	    status = psl_nm_eq_nm(cb, $1, $3, &$Ywith_clauses, psq_cb->psq_mode,
		&psq_cb->psq_error);
	}
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

/* Some rhs names in WITH name=name options are keywords, unkeyword them */
twith_nkw_kwd:	nonkeyword
	|	TABLE { $$="table";}
	|	ROW { $$="row";}
	;


/* This one's for the RHS of with .. index=, so it's either an ID
** or the funky base table structure triplet.
*/
twith_nkw_bts:	generic_ident
	|	BASE_TABLE_STRUCTURE { $$="base table structure";}
	;

/* WITH-clause: INDEX = name
** it sort-of fits into nm = nm, except that INDEX is a keyword so it
** needs its own production.   INDEX = BASE TABLE STRUCTURE is special
** anyway, do its semantic check here.
*/
twith_ix_name:  INDEX EQUAL twith_nkw_bts
    {
	DB_STATUS		status;

	/* Need special by-hand check for INDEX = BASE TABLE STRUCTURE,
	** because it's only allowed from ALTER TABLE which is in $Ysavemode.
	*/
	if (STcompare($3,"base table structure") == 0)
	{
	    if (psq_cb->psq_mode == PSQ_CONS && $Ysavemode == PSQ_ALTERTABLE)
	    {
		cb->pss_curcons->pss_cons_flags |= PSS_CONS_BASETAB;
	    }
	    else
	    {
		if (psq_cb->psq_mode == PSQ_CONS) psq_cb->psq_mode = $Ysavemode;
		psl_yerror(3, cb, psq_cb);
		return(E_DB_ERROR);
	    }
	}
	else
	{
	    status = psl_nm_eq_nm(cb, ERx("index"), $3, &$Ywith_clauses, 
		psq_cb->psq_mode, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
    }
;

/* WITH clause: name = 'thing', only allowed in Star */
twith_nm_eq_str:    nonkeyword EQUAL SCONST
    {
	DB_STATUS		status;

	/* No quotes allowed in non-distributed */
	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	err_code;

	    (VOID) psf_error(E_PS03A7_QUOTED_WITH_CLAUSE, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	status = psl_ct15_distr_with(cb, $1, sconvert($3),
		    		&$Yxlated_qry, TRUE, psq_cb);

        if (DB_FAILURE_MACRO(status))
	    return (status);
    }
;

/* WITH clause: TABLE = id, this is another Star-only production. */
twith_tb_eq_id:	    twith_tb_wd EQUAL internal_ident
    {
	DB_STATUS		status;
	bool			quote_value = FALSE;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    /* This is essentially "error", there is no table= option
	    ** outside of STAR.
	    */
	    status = psl_nm_eq_nm(cb, "table", $3, &$Ywith_clauses,
		psq_cb->psq_mode, &psq_cb->psq_error);
	}
	else
	{
	    if ($Yid_type == PSS_ID_SCONST)
	    {
		cb->pss_distr_sflags |= PSS_QUOTED_TBLNAME;
		quote_value	= TRUE;
	    }
	    else if ($Yid_type == PSS_ID_DELIM)
	    {
		cb->pss_distr_sflags |= PSS_DELIM_TBLNAME;
	    }
	    status = psl_ct15_distr_with(cb, "table", $3,
				&$Yxlated_qry, quote_value, psq_cb);
	}

        if (DB_FAILURE_MACRO(status))
	    return (status);
    }
;

twith_tb_wd:    TABLE
    {
	/*
	** For Star, keep track of whether local object was delimited
	** so that we can disallow incompatible case translation scenarios
	** when we look up local object.  Turn off flags set in 'crname'
	** production if user has provided WITH TABLE clause.
	*/
	cb->pss_distr_sflags &= ~(PSS_DELIM_TBLNAME|PSS_DELIM_OWNNAME);
    }
;

/* WITH clause: name = nn */
twith_num:	    nonkeyword EQUAL intconst_e
    {
	DB_STATUS		status;

	status = psl_nm_eq_no(cb, $1, $3, &$Ywith_clauses, psq_cb->psq_mode,
	    &psq_cb->psq_error, &$Yxlated_qry);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

/* WITH clause: single-word options.  These tend to be quite specific to
** the statement being parsed, so call various semantic routines.
** Create table:  [no]duplicates [no]journaling
**		[no]compression nosecurity_audit_key norecovery.
** Create index: [no]compression [no]persistence [no]concurrent_access.
** Constraint-index: nojournal_check.
** Modify:	[no]compression [no]persistence (indexes only)
**		noextensions / extensions_only.
*/
twith_word:	    nonkeyword
    {
	DB_STATUS	status;
	i4		qmode;
	i4		toss_err;

	qmode = psq_cb->psq_mode;
	/* There aren't any single-word options allowed on a partition's
	** with clause.  Rather than add the test to all the various
	** places below, check it right away here.
	*/
	if (cb->pss_stmt_flags & PSS_PARTITION_DEF)
	{
	    (void) psf_error(E_US1931_6449_PARTITION_BADOPT, 0, PSF_USERERR,
			&toss_err, &psq_cb->psq_error, 2,
			0, uld_psq_modestr(qmode),
			STlength($1), $1);
	    return (E_DB_ERROR);
	}
	if (qmode == PSQ_CONS && $Ysavemode == PSQ_ALTERTABLE)
	{
	    /* Relocated check for only alter table add constraint option */
	    /* (schka24) This disallows "compression" as a constraint
	    ** index with-option, but I guess one can always use the
	    ** "compression=(key)" flavor.
	    */
	    if (STcompare($1, "nojournal_check"))
	    {
		psq_cb->psq_mode = $Ysavemode;
		psl_yerror(3, cb, psq_cb);
		return(E_DB_ERROR);
	    }
	    if (cb->pss_curcons)
		cb->pss_curcons->pss_cons_flags |= PSS_NO_JOURNAL_CHECK;
	    status = E_DB_OK;
	}
	else if (qmode == PSQ_INDEX)
	    status = psl_ci7_index_woword(cb, $1, &$Ywith_clauses,
		&psq_cb->psq_error);
	else if (qmode == PSQ_CREATE || qmode == PSQ_RETINTO
		 || qmode == PSQ_DGTT || qmode == PSQ_DGTT_AS_SELECT)
	    status = psl_ct6_cr_single_kwd(cb, $1, &$Ywith_clauses,
		psq_cb->psq_mode, &psq_cb->psq_error, &$Yxlated_qry);
	else if (qmode == PSQ_MODIFY)
	    status = psl_md9_modopt_word(cb, $1, &$Ywith_clauses,
		&psq_cb->psq_error);
	else
	{
	    psl_yerror(3, cb, psq_cb);
	    return (E_DB_ERROR);
	}
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
;

/* WITH clause: name = (inside);  "inside" is typically a comma
** separated list, although it can be pretty much anything (a
** partitioning definition, for example).
** This production is nobypassed so that it's executed during CREATE
** SCHEMA parsing;  we need the alternate keywords turned off.
*/
twith_list:    twith_list_prefix LPAREN twith_list_inside RPAREN
    {
	/* Turn off the funky special keyword stuff */
	cb->pss_yacc->yy_partalt_kwds = FALSE;

	/* FIXME get rid of this later along with pss_restab goop. */
	if ($Ycreate_with_key)
	    cb->pss_restab.pst_reskey = $3;
	$Ylist_clause = 0;		/* done with this clause */
	$Ycreate_with_key = FALSE;
    }
;

/* This production is nobypass-ed during create schema, to turn on alternate
** keyword handling for partitions.  Note that for create schema, the
** create-with-key flag will remain off, and no weird KEY= stuff happens.
*/
twith_list_prefix:   nonkeyword EQUAL 
    {
	DB_STATUS		status;

	$Ycreate_with_key = FALSE;
	status = psl_lst_prefix(cb, psq_cb, $1, yyvarsp);
	if (DB_FAILURE_MACRO(status))
	    return(status);
	/* **** TEMP until I get everything handled as dmu char */
	/* KEY= option on a create-table-ish thing is handled as a
	** linked list of reskey's
	*/
	if ($Ylist_clause == PSS_KEY_CLAUSE &&
	  (psq_cb->psq_mode == PSQ_CREATE || psq_cb->psq_mode == PSQ_RETINTO
	   || psq_cb->psq_mode == PSQ_DGTT
	   || psq_cb->psq_mode == PSQ_DGTT_AS_SELECT))
	    $Ycreate_with_key = TRUE;
	/* If we have a PARTITION= list, turn on the alternate keyword
	** list (replacing the normal keyword list).
	*/
	if (STcompare($1,"partition") == 0)
	    cb->pss_yacc->yy_partalt_kwds = TRUE;
    }
;

twith_list_inside:  twith_list_commalist
	    |	    twith_list_partition
;

twith_list_commalist:	twith_list_clist_elem
    {
	if ($Ycreate_with_key)
	    $$ = $1;
    }
	    |	    twith_list_commalist COMMA twith_list_clist_elem
    {
	if ($Ycreate_with_key)
	{
	    PST_RESKEY	*reskey;

	    /*
	    ** Find the last key in the list.
	    */
	    for (reskey = $1; reskey->pst_nxtkey; reskey = reskey->pst_nxtkey)
	    ;
     
	    reskey->pst_nxtkey = $3;

	    $$ = $1;
	}
    }
;

/* WITH clause: element of list in thing = (elem, elem, ...) */
/* Note: this production is defined as type psl_reskey because of the list
** hookup that you see in twith_list_commalist.  It's only REALLY a
** psl_reskey when the list is KEY= in a CREATE TABLE context.  The
** rest of the time, we have to return NULL to keep yacc's type checking
** happy.
*/
twith_list_clist_elem:	    generic_ident
    {
	DB_STATUS		status;
	char			*letter;
	i4			err_code;
	i4			id_len;
	i4			qmode;
	PST_RESKEY		*reskey;
	u_char			*id_name;
	u_char			delim_buf[DB_MAX_DELIMID+1];

	qmode = psq_cb->psq_mode;
	if ($Ylist_clause != PSS_KEY_CLAUSE)
	{
	    if ($Yid_type == PSS_ID_DELIM)
	    {
		/* delimited identifiers are not allowed here,
		** so return a syntax error.
		*/
		/* first un-normalize identifier (put double quotes back)
		 */
		id_len  = STlength($1);
		id_name = (u_char *) $1;
		(void) psl_norm_id_2_delim_id(&id_name, &id_len, 
					      delim_buf, &psq_cb->psq_error);
		psf_error(5343L, 0L, PSF_USERERR,
			  &err_code, &psq_cb->psq_error, 2,
			  0, uld_psq_modestr(qmode),
			  id_len, id_name);
		return (E_DB_ERROR);
	    }
	    /*
	    ** Translate nonkeywords to lower case
	    */
	    for (letter =  $1; *letter != EOS; CMnext(letter))
	        CMtolower(letter, letter);
	}

	if (qmode == PSQ_CREATE || qmode == PSQ_RETINTO
		|| qmode == PSQ_DGTT || qmode == PSQ_DGTT_AS_SELECT
		|| qmode == PSQ_CREATE_SCHEMA)
	{
	    /* Create-table-ish statements */
	    status = psl_ct8_cr_lst_elem(cb, $Ylist_clause, &$Ypart_locs, $1,
	    	$Ycreate_with_key ? &reskey : (PST_RESKEY **) NULL,
		&psq_cb->psq_error, &$Yxlated_qry);
	}
	else
	{
	    /* Index, modify, constraint-with */
	    status = psl_lst_elem(cb, $Ylist_clause, &$Ypart_locs, $1, qmode,
		&psq_cb->psq_error);
	}
	if (DB_FAILURE_MACRO(status))
	    return (status);
		    
	if ($Ycreate_with_key)
	    $$ = reskey;
    }
	|	index_rspec
    {
	/* Keep yacc type-checking happy */
	$$ = NULL;
    }
    ;

index_rspec:    LPAREN index_rlst RPAREN
    ;

index_rlst:     index_relem
	|	index_rlst COMMA index_relem
    ;

index_relem:    sign_op I2CONST
    {
	DB_STATUS	status;
	f8		tmp;

	if ($1 == ADI_MINUS_OP)
	  *$2 = -(*$2);
	tmp = *$2;
	status = psl_lst_relem(cb, $Ylist_clause, &tmp, PSQ_INDEX,
			    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
	    |    sign_op I4CONST
    {
	DB_STATUS	status;
	f8		tmp;

	if ($1 == ADI_MINUS_OP)
	  *$2 = -(*$2);
	tmp = *$2;
	status = psl_lst_relem(cb, $Ylist_clause, &tmp, PSQ_INDEX,
			    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }

	    |    sign_op DECCONST
    {
	DB_STATUS	status;
	i2		prec_scale;
	i4		prec;
	i4		scale;
	PTR		d;
	u_char	tmpdec[DB_MAX_DECLEN];
	f8		tmp;

	I2ASSIGN_MACRO(*$2, prec_scale);
	prec = DB_P_DECODE_MACRO(prec_scale);
	scale = DB_S_DECODE_MACRO(prec_scale);
	d = (PTR)($2 + sizeof(i2));

	if ($1 == ADI_MINUS_OP)
	{
	    MEcopy(d, DB_PREC_TO_LEN_MACRO(prec), (PTR)tmpdec);
	    MHpkneg((PTR)tmpdec, prec, scale, d);
	}
	CVpkf(d, prec, scale, &tmp);
	status = psl_lst_relem(cb, $Ylist_clause, &tmp, PSQ_INDEX,
				    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
	    |	sign_op F4CONST
    {
	DB_STATUS	status;
	f8		tmp;

	if ($1 == ADI_MINUS_OP)
	    *$2 = -(*$2);
	tmp = *$2;
	status = psl_lst_relem(cb, $Ylist_clause, &tmp, PSQ_INDEX,
				    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
	    |	sign_op F8CONST
    {
	DB_STATUS	status;
	f8		tmp;

	if ($1 == ADI_MINUS_OP)
	    *$2 = -(*$2);
	tmp = *$2;

	status = psl_lst_relem(cb, $Ylist_clause, &tmp, PSQ_INDEX,
				    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
;

/* WITH clause: partition definition */
/* Partition definition is either one dimension, or N dimensions
** in parens:  dim, or (dim) subpartition (dim) ...
** The partition definition is built up in little bits and pieces as
** parsing proceeds, so the various semantic actions are somewhat delicately
** interdependent.  It would be good to have some understanding of who
** does what, before doing any major surgery on the grammar.
**
** The return value on this production is just to satisfy yacc;
** some other with- list=() type productions have a return type,
** so they all have to have a return type.
*/
twith_list_partition:	partition_dim partition_def_done
    {
	$$ = NULL;
    }
		|	partition_dim_list partition_def_done
    {
	$$ = NULL;
    }
;

/* This empty production is just a way to hang an action off the end of
** the entire partition definition, regardless of dimensionality.
*/
partition_def_done:	/* empty */
    {
	/* Finish and validate the definition, copy to our QSF object */
	if (psl_partdef_end(cb, psq_cb, yyvarsp) != E_DB_OK)
	    return (E_DB_ERROR);
    }
;

/* Actually this syntax allows a single (dim) but that's OK. */
/* The production continues after the keyword check... */
partition_dim_list:	LPAREN partition_dim RPAREN
		|	partition_dim_list nonkeyword
    {
	char command[PSL_MAX_COMM_STRING];
	i4 toss_err;
	i4 len;

	if (STcompare($2,"subpartition") != 0)
	{
	    psl_command_string(psq_cb->psq_mode, cb->pss_lang, command, &len);
	    (void) psf_error(E_US1930_6448_PARTITION_EXPECTS,
		    0, PSF_USERERR, &toss_err, &psq_cb->psq_error,
		    3, len, command, sizeof("subpartition")-1, "subpartition",
		    STlength($2), $2);
	    return (E_DB_ERROR);
	}
	/* continue to parse more dimensions */
    }
		LPAREN partition_dim RPAREN
;

/* Each partitioning dimension type is slightly different.
** Automatic and hash don't require specific partitioning values,
** list and range do.  Automatic doesn't have a column list.  The
** value lists for list and range are different.
** Note, the production continues after each keyword/action block.
** Also note that the overall "start" action is buried inside the
** psl-lst-prefix routine when it sees partition=.
*/
partition_dim:	AUTOMATIC
    {
	if (psl_partdef_new_dim(cb, psq_cb, yyvarsp, DBDS_RULE_AUTOMATIC) != E_DB_OK)
	    return (E_DB_ERROR);
    }
		    nonval_partlist
	|	HASH
    {
	if (psl_partdef_new_dim(cb, psq_cb, yyvarsp, DBDS_RULE_HASH) != E_DB_OK)
	    return (E_DB_ERROR);
    }
		    partition_onlist nonval_partlist
	|	LIST
    {
	if (psl_partdef_new_dim(cb, psq_cb, yyvarsp, DBDS_RULE_LIST) != E_DB_OK)
	    return (E_DB_ERROR);
    }
		    partition_onlist list_partlist
	|	RANGE
    {
	if (psl_partdef_new_dim(cb, psq_cb, yyvarsp, DBDS_RULE_RANGE) != E_DB_OK)
	    return (E_DB_ERROR);
    }
		    partition_onlist range_partlist
;

/* Value-based dimensions need a column name list */
partition_onlist:	ON partition_col_list
    {
	/* Done with the list, build DB_PART_LIST for dimension */
	if (psl_partdef_partlist(cb, psq_cb, yyvarsp) != E_DB_OK)
	    return (E_DB_ERROR);
    }
;

partition_col_list:	partition_column
		|	partition_col_list COMMA partition_column
;

/* Add each partition ON-column to this dimension's list */
partition_column:	name_or_alt_kwd
    {
	if (psl_partdef_oncol(cb,psq_cb,yyvarsp,$1) != E_DB_OK)
	    return (E_DB_ERROR);
    }
;

/* This is just a trick to avoid enforcing partitioning keywords
** against column names.  (So yes, you can HASH ON hash ...)  In
** this context there are only a few keywords being recognized.
** Note, this isn't done for partition names, they aren't all that
** important - just column names.
** This production is pretty tedious, and if it gets much longer, a
** table lookup might be appropriate, or perhaps a trick production
** that returns the id flavor of any keyword.
*/
name_or_alt_kwd:	generic_ident
		|	ON {$$ = REG_ID_CASE_STRING(cb,"on","ON");}
		|	TO {$$ = REG_ID_CASE_STRING(cb,"to","TO");}
		|	AUTOMATIC {$$ = REG_ID_CASE_STRING(cb,"automatic","AUTOMATIC");}
		|	LIST {$$ = REG_ID_CASE_STRING(cb,"list","LIST");}
		|	HASH {$$ = REG_ID_CASE_STRING(cb,"hash","HASH");}
		|	RANGE {$$ = REG_ID_CASE_STRING(cb,"range","RANGE");}
		|	VALUES {$$ = REG_ID_CASE_STRING(cb,"values","VALUES");}
		|	PARTITION {$$ = REG_ID_CASE_STRING(cb,"partition","PARTITION");}
;

nonval_partlist:	nonval_partition
		|	nonval_partlist COMMA nonval_partition
;

/* "Non-value" partition definitions are for automatic and hash.  There
** is no user value, so the only thing needed is the number of partitions,
** optionally their names, and optionally a WITH clause.  (The presence
** of a WITH clause is why we don't make the user simply define all the
** relevant partitions in a single PARTITION clause.)
** Caution reading this production, there are 2 flavors with intermediate
** actions mixed into both.
*/
nonval_partition:	PARTITION optional_namelist
    {
	/* Not a typo, define 1 partition */
	if (psl_partdef_nonval(cb, psq_cb, yyvarsp, 1) != E_DB_OK)
	    return (E_DB_ERROR);
    }
			    partition_with
		|	intconst_p partition_s optional_namelist
    {
	/* Pass the number of partitions to make */
	if (psl_partdef_nonval(cb, psq_cb, yyvarsp, $1) != E_DB_OK)
	    return (E_DB_ERROR);
    }
			    partition_with
;

/* The user can write "1 PARTITION" or "n PARTITIONS".  Accept either
** one here.  PARTITIONS doesn't need to be a keyword.
** Don't bother cross-checking the "n" and the suffix!
*/
partition_s:		PARTITION
		|	nonkeyword
    {
	i4 toss_err;

	if (STcompare($1,"partitions") != 0)
	{
	    (void) psf_error(E_US1930_6448_PARTITION_EXPECTS,
		    0, PSF_USERERR, &toss_err, &psq_cb->psq_error,
		    3, $Yqry_len, $Yqry_name, sizeof("partitions")-1, "partitions",
		    STlength($1), $1);
	    return (E_DB_ERROR);
	}
    }
;

/* If there is more than one optional partition name, it has to be
** enclosed in parens.  (Else we've defined a two-token-lookahead
** grammar, and yacc gets all pissy.)  The alternative, which I
** almost did, is to separate the partition lists with spaces
** instead of commas.
*/
optional_namelist:	/* nothing */
		|	partition_name
		|	LPAREN partition_namelist RPAREN
;

partition_namelist:	partition_name
		|	partition_namelist COMMA partition_name
;

/* A partition name may not clash with any other partition name seen
** in the entire partition definition, nor with any reserved names.
*/
partition_name:	generic_ident
    {
	if (PSL_IS_RESERVED_IDENT($1, cb, psq_cb, TRUE) != E_DB_OK)
	    return(E_DB_ERROR);
	/* Also need to check for iixxx but pname will do that */
	if (psl_partdef_pname(cb, psq_cb, yyvarsp, $1, FALSE) != E_DB_OK)
	    return (E_DB_ERROR);
    }
;

/* The LIST partition spec gives a list of values that are directed
** to the specified partition.
*/
list_partlist:		list_partition
		|	list_partlist COMMA list_partition
;

/* Each LIST partition clause defines one logical partition, with
** potentially many values (hence many breaks).
*/
list_partition:
    {
	/* Get a list PARTITION clause started off:
	** All value-opers for LIST are "equal" unless we get a DEFAULT.
	*/
	$Yfirst_break = TRUE;
	$Yvalue_oper = DBDS_OP_EQ;
	/* continue production... */
    }
		PARTITION optional_name VALUES list_valuelist partition_with
;

optional_name:	/* nothing */
		|	partition_name
;

/* The value-list has to be in parens, even if there is only one.
** The parens are needed in the many-value case to avoid two-token
** lookahead.  (After a comma, do we have another value, or a PARTITION
** keyword.)  The parens are needed even in the single-value case
** because yacc gets a reduce-reduce conflict without them.
*/
list_valuelist:		LPAREN part_valuelist RPAREN
;

part_valuelist:		part_value_or_default
		|	part_valuelist COMMA part_value_or_default
;

/* Separate production for value-or-DEFAULT.  LIST uses DEFAULT,
** range doesn't.  The nonkeyword here has to be DEFAULT.
*/
part_value_or_default:	part_composite_value
		|	nonkeyword
    {
	char buf[2];
	DB_DATA_VALUE emptyval;
	i4 toss_err;
	i4 len;

	if (STcompare($1,"default") != 0)
	{
	    (void) psf_error(E_US1930_6448_PARTITION_EXPECTS,
			0, PSF_USERERR, &toss_err, &psq_cb->psq_error,
			3, $Yqry_len, $Yqry_name, 0, "default",
			STlength($1), $1);
	    return (E_DB_ERROR);
	}
	$Yvalue_oper = DBDS_OP_DFLT;
	emptyval.db_datatype = DB_LTXT_TYPE;
	emptyval.db_length = 0;
	emptyval.db_data = &buf[0];
	buf[0] = '\0';
	if (psl_partdef_value(cb,psq_cb,yyvarsp,0,&emptyval) != E_DB_OK)
	    return (E_DB_ERROR);
	$Yvalue_oper = DBDS_OP_EQ;
    }
;

/* A partition value is a constant.  Multi-column values are enclosed
** in parens, one constant per ON column.
*/
part_composite_value:	part_value
    {
	/* Just make sure we got one const per dimension ON-column */
	if (psl_partdef_value_check(cb, psq_cb, yyvarsp) != E_DB_OK)
	    return (E_DB_ERROR);
    }
;

part_value:	part_const
	|	LPAREN part_const_list RPAREN
;

part_const_list:	part_const
		|	part_const_list COMMA part_const
;

/* possibly signed number; quoted string; NULL.
** No QDATA here, but not for any good reason.
** No builtin variables like USER, etc -- we want true constants only.
*/
part_const:	sign_op number
    {
	if (psl_partdef_value(cb,psq_cb,yyvarsp,$1,$2) != E_DB_OK)
	    return (E_DB_ERROR);
    }
	|	part_const_stringish
    {
	if (psl_partdef_value(cb,psq_cb,yyvarsp,0,$1) != E_DB_OK)
	    return (E_DB_ERROR);
    }
	|	NULLWORD
    {
	if (psl_partdef_value(cb,psq_cb,yyvarsp,0,NULL) != E_DB_OK)
	    return (E_DB_ERROR);
    }
	|	DCONST	
    {
	DB_STATUS	status;
	DB_DATA_VALUE	dval;
	AD_ADATE	value;

	dval.db_data = (PTR)&value;

	if (psl_ansi_strtodt(cb, psq_cb, DB_ADTE_TYPE, 0,
			(DB_TEXT_STRING *)$1, (PST_QNODE **)NULL, &dval, 0))
	    return (status);

	if (psl_partdef_value(cb,psq_cb,yyvarsp,0,&dval) != E_DB_OK)
	    return (E_DB_ERROR);
    }
		|	TMWOCONST	
    {
	DB_STATUS	status;
	DB_DATA_VALUE	tval;
	AD_TIME		value;

	tval.db_data = (PTR)&value;

	if (psl_ansi_strtodt(cb, psq_cb, DB_TMWO_TYPE, 0,
		       (DB_TEXT_STRING *)$1, (PST_QNODE **)NULL, &tval, 0))
	    return (status);

	if (psl_partdef_value(cb,psq_cb,yyvarsp,0,&tval) != E_DB_OK)
	    return (E_DB_ERROR);
    }
		|	TMWCONST	
    {
	DB_STATUS	status;
	DB_DATA_VALUE	tval;
	AD_TIME		value;

	tval.db_data = (PTR)&value;

	if (psl_ansi_strtodt(cb, psq_cb, DB_TMW_TYPE, 0,
			(DB_TEXT_STRING *)$1, (PST_QNODE **)NULL, &tval, 0))
	    return (status);

	if (psl_partdef_value(cb,psq_cb,yyvarsp,0,&tval) != E_DB_OK)
	    return (E_DB_ERROR);
    }
		|	TMECONST	
    {
	DB_STATUS	status;
	DB_DATA_VALUE	tval;
	AD_TIME		value;

	tval.db_data = (PTR)&value;

	if (psl_ansi_strtodt(cb, psq_cb, DB_TME_TYPE, 0,
			(DB_TEXT_STRING *)$1, (PST_QNODE **)NULL, &tval, 0))
	    return (status);

	if (psl_partdef_value(cb,psq_cb,yyvarsp,0,&tval) != E_DB_OK)
	    return (E_DB_ERROR);
    }
		|	TSWOCONST
    {
	DB_STATUS	status;
	DB_DATA_VALUE	tsval;
	AD_TIMESTAMP	value;

	tsval.db_data = (PTR)&value;

	if (psl_ansi_strtodt(cb, psq_cb, DB_TSWO_TYPE, 0,
			(DB_TEXT_STRING *)$1, (PST_QNODE **)NULL, &tsval, 0))
	    return (status);

	if (psl_partdef_value(cb,psq_cb,yyvarsp,0,&tsval) != E_DB_OK)
	    return (E_DB_ERROR);
    }
		|	TSWCONST	
    {
	DB_STATUS	status;
	DB_DATA_VALUE	tsval;
	AD_TIMESTAMP	value;

	tsval.db_data = (PTR)&value;

	if (psl_ansi_strtodt(cb, psq_cb, DB_TSW_TYPE, 0,
			(DB_TEXT_STRING *)$1, (PST_QNODE **)NULL, &tsval, 0))
	    return (status);

	if (psl_partdef_value(cb,psq_cb,yyvarsp,0,&tsval) != E_DB_OK)
	    return (E_DB_ERROR);
    }
		|	TSTMPCONST	
    {
	DB_STATUS	status;
	DB_DATA_VALUE	tsval;
	AD_TIMESTAMP	value;

	tsval.db_data = (PTR)&value;

	if (psl_ansi_strtodt(cb, psq_cb, DB_TSTMP_TYPE, 0,
			(DB_TEXT_STRING *)$1, (PST_QNODE **)NULL, &tsval, 0))
	    return (status);

	if (psl_partdef_value(cb,psq_cb,yyvarsp,0,&tsval) != E_DB_OK)
	    return (E_DB_ERROR);
    }
;

/* A string-y thing recast as a db-data-value.  Accept single-quoted
** strings.  Later this could be extended to QDATA, maybe other stuff?
** It may be that strconst or strconst_e would be usable here, no time
** to fart around with it now.
*/
part_const_stringish:	SCONST
    {
	$Ydb_pdata.db_datatype	= DB_LTXT_TYPE;
	$Ydb_pdata.db_prec  	= 0;
	$Ydb_pdata.db_length	= $1->db_t_count + sizeof(u_i2);
	$Ydb_pdata.db_data	= (PTR) $1;
	$$ = &$Ydb_pdata;
    }
;

/* The RANGE partition spec uses a testing operator and a single value.
** Later on we'll check that the given inequalities form a set of ranges
** that completely cover the domain.
*/
range_partlist:		range_partition
		|	range_partlist COMMA range_partition
;

/* BDOP is conveniently <, <=, >, >=
** This is another continued production.
*/
range_partition:	PARTITION optional_name VALUES BDOP
    {
	i2	op;

	/* Translate/save the BDOP, then keep going */
	op = DBDS_OP_LT;
	if ($4 == ADI_LE_OP) op = DBDS_OP_LTEQ;
	else if ($4 == ADI_GE_OP) op = DBDS_OP_GTEQ;
	else if ($4 == ADI_GT_OP) op = DBDS_OP_GT;
	$Yvalue_oper = op;
	/* There's only one break per clause with RANGE, but set the
	** first-time flag anyway so that the value action Does The
	** Right Things.
	*/
	$Yfirst_break = TRUE;
	/* continue with production... */
    }
		part_composite_value partition_with
;

partition_with:	/* empty */
	|	WITH
    {
	/* This is a recursive WITH clause, save what's going on in the
	** outside world.  Fortunately we only have one level of recursion.
	*/
	$Ysave_list_clause = $Ylist_clause;
	$Ylist_clause = 0;
	MEcopy(&$Ywith_clauses, sizeof(PSS_WITH_CLAUSE), &$Ysave_with_clauses);
	MEfill(sizeof ($Ywith_clauses), 0, &$Ywith_clauses);
    }
		partition_with_clause
    {
	/* Copy any options seen to a physical-partition data block,
	** and restore the outer WITH context.  Also return to parsing
	** PARTITION keywords, as WITH-parsing uses normal keywords.
	*/
	if (psl_partdef_with(cb, psq_cb, yyvarsp) != E_DB_OK)
	    return (E_DB_ERROR);
	cb->pss_yacc->yy_partalt_kwds = TRUE;
    }
;

/* To prevent ambiguity, multiple with options are inside parens.  (otherwise
** we can't tell if a comma is a with-option separator or a partition-spec
** separator.)
*/
partition_with_clause:	tblwithopt
		|	LPAREN tblwithlist RPAREN
;


alter_table:		alt_tbl ADD tbl_constraint
    {
	DB_STATUS status;
	
	/* be sure to turn off new-object bit, as it gets reset during
	** tbl_constraint processing (but is only needed for CREATE TABLE
	** because it allows multiple constraints in one statement)
	*/
	cb->pss_stmt_flags &= ~PSS_NEW_OBJ_NAME;

	status = psl_alter_table(cb, psq_cb, $1, $Ycons_list);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|		alt_tbl DROP CONSTRAINT generic_ident drop_behaviour
    {
	DB_STATUS	status;

	status = psl_d_cons(cb, psq_cb, $1, $4,
	    (bool) ($5 == CASCADING_DESTRUCTION));
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|		alt_tbl_add_col newcolname typedesc
    {
	DB_ATT_NAME	       attname;
	DB_STATUS	       status;

	STmove($2, ' ', sizeof(DB_ATT_NAME), (char *) &attname);

	status = psl_alt_tbl_col_add(cb, psq_cb, attname, $Ycons_list);
	 
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|		alt_tbl_drop_col generic_ident drop_behaviour
    {
	DB_ATT_NAME	       attname;
	DB_STATUS	       status;

	STmove($2, ' ', sizeof(DB_ATT_NAME), (char *) &attname);

	/* allocate and populate the DMU_CB control block */
	 
	status = psl_alt_tbl_col(cb, psq_cb);

	if (DB_FAILURE_MACRO(status))
	   return(status);

	status = psl_alt_tbl_col_drop(cb, psq_cb, attname,
	    			      (bool) ($3 == CASCADING_DESTRUCTION));
	 
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|               alt_tbl_alter_col newcolname typedesc
    {
        DB_ATT_NAME            attname;
        DB_STATUS              status;

        STmove($2, ' ', sizeof(DB_ATT_NAME), (char *) &attname);

        status = psl_alt_tbl_col_add(cb, psq_cb, attname, $Ycons_list);

        if (DB_FAILURE_MACRO(status))
            return(status);
    }
;
 
alt_tbl_add_col:  	alt_tbl add_col_kwd
    {
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_ATBL_ADD_COLUMN;

	/* allocate and populate the DMU_CB control block */
	 
	status = psl_alt_tbl_col(cb, psq_cb);

	if (DB_FAILURE_MACRO(status))
	   return(status);
    }
;

alt_tbl_drop_col:	alt_tbl drop_col_kwd
    {
	psq_cb->psq_mode = PSQ_ATBL_DROP_COLUMN;
    }
;

alt_tbl_alter_col:      alt_tbl alter_col_kwd
    {
        DB_STATUS              status;

        psq_cb->psq_mode = PSQ_ATBL_ALTER_COLUMN;

        /* allocate and populate the DMU_CB control block */

        status = psl_alt_tbl_col(cb, psq_cb);

        if (DB_FAILURE_MACRO(status))
           return(status);
    }
;

alt_tbl:		alt_tbl_kwd obj_spec
    {
	DB_STATUS  status;
	PSS_RNGTAB *rngvar;

	/* verify that table exists, and put its info into cb->pss_usrrng
	 */
	status = psl_alt_tbl(cb, psq_cb, $2, &rngvar);

	if (DB_FAILURE_MACRO(status))
	    return(status);

	$$ = rngvar;
    }
;

alt_tbl_kwd:		ALTER TABLE
    {
	/* set query mode here, because it needs to be set before 
	** the obj_spec production (SESSION checks are done there)
	*/
	psq_cb->psq_mode = PSQ_ALTERTABLE;
    }
;

add_col_kwd:		ADD COLUMN
		|
			ADD
;

drop_col_kwd:		DROP COLUMN
		|
			DROP
;

alter_col_kwd:          ALTER COLUMN
                |
                        ALTER
;


create_view:		viewclause newcolspec 
    {
	/* we are done processing the new object names */
	cb->pss_stmt_flags &= ~PSS_NEW_OBJ_NAME;
    }
			AS query_expr with_check
    {
	DB_STATUS           status;
	i4		    err_code;

#ifdef	xDEBUG
	psl_debug();
#endif
	if ($Yseq_ops)
	{
	    /* No use of sequences in view definitions. */
	    (void)psf_error(6319L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Special processing for CREATE SCHEMA
	    */
	    status = psl_cs04s_create_view(cb, psq_cb, $Ystmtstart,
			$Ydeplist);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	    return(E_DB_OK);
	}

	/*
	** CAUTION: here I am using the knowledge that the $Y vars can be
	** accessed by dereferencing through yyvarsp
	*/
	status = psl_cv1_create_view(cb, psq_cb, $2, $5, $6, yyvarsp);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

viewclause:         viewstmnt crname
    {
	PST_STATEMENT	    *snode = (PST_STATEMENT *) cb->pss_object;
	PST_CREATE_VIEW     *crt_view = &snode->pst_specific.pst_create_view;
	QEUQ_CB		    *qeuq_cb = (QEUQ_CB *) crt_view->pst_qeuqcb;
	DMU_CB		    *dmu_cb = (DMU_CB *) qeuq_cb->qeuq_dmf_cb;

	/* Copy the table name into PST_CREATE_VIEW and DMU_CB */
	STmove($2, ' ', sizeof(DB_TAB_NAME), (char *) &crt_view->pst_view_name);
	STRUCT_ASSIGN_MACRO(crt_view->pst_view_name, dmu_cb->dmu_table_name);
    }
;

viewstmnt:	    CRTVIEW
    {
	DB_STATUS		status;

#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Special handling for CREATE SCHEMA
	    */
	    $Ysubmode = PSQ_VIEW;
	    $Ydeplist = (PST_OBJDEP *) NULL;
	    $Ystmtstart = (char *) cb->pss_prvtok;
	    $Ycons_list = (PSS_CONS *) NULL;
	    return(E_DB_OK);
	}

	status = psl_cv2_viewstmnt(cb, psq_cb, yyvarsp);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* we are about to process the new object name */
	cb->pss_stmt_flags |= PSS_NEW_OBJ_NAME;
    }
;

with_check:	    WITH CHECK OPTION
    {
	$$ = TRUE;
    }
	    |
    {
	$$ = FALSE;
    }
;

create_dbproc:	    cdbp_kwd cdbp_procname cdbp_parmspec
		    cdbp_resrow_spec cdbp_asword cdbp_beblock
    {
	PST_PROCEDURE	*pnode;
	DB_STATUS	status;
	i4		count = 0;
	i4		firstno=0;
	QSF_RCB		qsf_rb;
	i4		err_code;
	PSS_DBPALIAS	dbpid;
	DB_CURSOR_ID	*dbpidp = (DB_CURSOR_ID *) dbpid;
	ADF_CB		*adf_scb = (ADF_CB*) cb->pss_adfcb;
	PST_DECVAR	*decvar;
	i4		qsf_op;
	register PSS_DECVAR	*parm;
	register DB_DATA_VALUE	*db_data;
	register DB_PARM_NAME	*parm_name;
	register i4		*parm_mode;

	/* Set the query mode, as it was probably altered. */
   	psq_cb->psq_mode = PSQ_CREDBP;
	$Yisdbp = FALSE;

	/*
	** If we were parsing the dbproc to determine if it is grantable/active
	** and got this far, is is definitely grantable/active.  We don't need
	** to perform the rest of the actions (or, rather, performing some of
	** the actions in the body of this production (e.g. creating a new QP
	** object) is highly unadvisable)
	*/
	if (!(cb->pss_dbp_flags & (PSS_0DBPGRANT_CHECK | PSS_CHECK_IF_ACTIVE)))
	{
	    /* Count parms. */
	    for (parm = (PSS_DECVAR *) $Ydbpinfo->pss_varq.q_next;
		 parm != (PSS_DECVAR *) &$Ydbpinfo->pss_varq;
		 parm = (PSS_DECVAR *) parm->pss_queue.q_next
		)
	    {
		if (parm->pss_out)
		    continue;

		/* We're moving in the next direction, the last
		** one is really the first parm specified.
		*/
		firstno = parm->pss_no;

		count++;
	    }

	    /* Allocate memory for PST_DECVAR */
	    status = psf_malloc(cb, &cb->pss_ostream, (i4) (sizeof(PST_DECVAR)), 
		(PTR *) &decvar, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);

	    decvar->pst_nvars = count;
	    decvar->pst_first_varno = firstno;

	    if (count)
	    {
		/* Allocate memory for parm db_data array */
		status = psf_malloc(cb, &cb->pss_ostream,
		    (i4) (count * sizeof(DB_DATA_VALUE)), 
		    (PTR *) &decvar->pst_vardef, &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return (status);

		/* Allocate memory for parm name array */
		status = psf_malloc(cb, &cb->pss_ostream,
		    (i4) (count * sizeof(DB_PARM_NAME)), 
		    (PTR *) &decvar->pst_varname, &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return (status);

		/* Allocate memory for parm mode array */
		status = psf_malloc(cb, &cb->pss_ostream,
		    (i4) (count * sizeof(i4)), 
		    (PTR *) &decvar->pst_parmmode, &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return (status);

		/* Copy db data values, oldest one first */
		for (parm = (PSS_DECVAR *) $Ydbpinfo->pss_varq.q_prev,
		     db_data = decvar->pst_vardef,
		     parm_name = decvar->pst_varname,
		     parm_mode = decvar->pst_parmmode;
		     parm != (PSS_DECVAR *) &$Ydbpinfo->pss_varq;
		     parm = (PSS_DECVAR *) parm->pss_queue.q_prev
		    )
		{
		    if (parm->pss_out)
			continue;

		    STRUCT_ASSIGN_MACRO(parm->pss_dbdata, *db_data);
		    STRUCT_ASSIGN_MACRO(parm->pss_varname, *parm_name);
		    if (parm->pss_flags & PSS_PPOUT)
			*parm_mode = PST_PMOUT;
		    else if (parm->pss_flags & PSS_PPINOUT)
			*parm_mode = PST_PMINOUT;
		    else *parm_mode = PST_PMIN;

		    /* Allocate memory for default values as necessary. */
		    if (parm->pss_default)
		    {
			status = psf_malloc(cb, &cb->pss_ostream,
			    db_data->db_length, (PTR *) &db_data->db_data,
			    &psq_cb->psq_error);
			if (DB_FAILURE_MACRO(status))
			    return (status);
			status = adc_getempty (adf_scb, db_data);
			if (DB_FAILURE_MACRO(status))
			    return (status);
		    }

		    /* Increment array ptrs */
		    db_data++;
		    parm_name++;
		    parm_mode++;
		}
	    }
	    else
	    {
		decvar->pst_vardef = (DB_DATA_VALUE *) NULL;
		decvar->pst_varname = (DB_PARM_NAME *) NULL;
	    }

	    /* Allocate a procedure node */
	    status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_PROCEDURE),
		(PTR *) &pnode, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);

	    /* Fill in the procedure node */
	    pnode->pst_mode = (i2) psq_cb->psq_mode;
	    pnode->pst_vsn = (i2) PST_CUR_VSN;
	    pnode->pst_isdbp = TRUE;
	    pnode->pst_flags = 0;
	    pnode->pst_stmts = $6;
	    pnode->pst_parms = decvar;

	    if (cb->pss_dbp_flags & PSS_SET_INPUT_PARAM)
		pnode->pst_flags |= PST_SET_INPUT_PARAM;

	    /* Fix the root in QSF */
	    status = psf_mroot(cb, &cb->pss_ostream, (PTR) pnode,
	        &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
	        return (status);

	    if (cb->pss_dbp_flags & PSS_RECREATE)
	    {
		/* 
		** psq_recreate() has already done QSO_TRANS_OR_DEFINE and 
		** the QP object's BE id was placed into psq_cb->psq_cursid 
		** from which we will now copy it into pnode->pst_dbpid
		*/
		STRUCT_ASSIGN_MACRO(psq_cb->psq_cursid, pnode->pst_dbpid);
	    }
	    else
	    {
	        /* 
		** do special things if we are creating the procedure for the
	        ** first time (instead of parsing it to recreate the query plan)
	        */

	        /* build FE and BE object ids for the QP object */
	        psq_dbp_qp_ids(cb, dbpid, &pnode->pst_dbpid, 
		    &$Ydbpinfo->pss_ptuple.db_dbpname, 
		    &$Ydbpinfo->pss_ptuple.db_owner);

		/*
		** Finish emitting text properly. Put the query text
		** in a contiguous block in QSF.
		**
		** NOTE: this text stream is also used by psl_fill_proc_params
		**       to allocate memory for tuples passed to PSY.
		**       Thus, this must come BEFORE calling that procedure.
		*/
		status = psq_tout(cb, (PSS_USRRANGE*) NULL, 
		    cb->pss_tchain, &cb->pss_tstream, &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return (status);

		STRUCT_ASSIGN_MACRO(cb->pss_tstream.psf_mstream,
		    psq_cb->psq_txtout);

		/* check for a set-input parameter */
		if (cb->pss_dbp_flags & PSS_SET_INPUT_PARAM)
		{
		    /*
		    ** If we have a set-input parameter, we don't optimize the
		    ** query tree until the procedure is executed (because then
		    ** it will be re-created with an _instantiated_ set).  So
		    ** we change the query mode to show we are creating a
		    ** set-input dbproc, and SCF knows not to optimize it.
		    ** 		
		    ** But we don't free the query tree object because other
		    ** things besides the query tree are stored in that memory
		    ** stream.  That stream will get freed up by SCF after it
		    ** calls PSY.
		    */
		    psq_cb->psq_mode = PSQ_CRESETDBP;

		    /* set up procedure parameters for passing to RDF/QEF
		    ** (this is done by PSY)
		    */
		    status = psl_fill_proc_params(cb, 
						  $Ydbpinfo->pss_setparmno,
						  &$Ydbpinfo->pss_setparmq, 
						  TRUE, &psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
			return(status);

		}  /* end if PSS_SET_INPUT_PARAM */
		else
		{
		    /* set up procedure parameters for passing to RDF/QEF
		    ** (this is done by PSY).
		    */
		    status = psl_fill_proc_params(cb,
						  $Ydbpinfo->pss_procparmno,
						  &($Ydbpinfo->pss_varq), 
						  FALSE, &psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
			return(status);
		}		    

	        /*
	        ** For procedure we need to define or translate
	        ** the procedure id because QEPs are shareable.
	        */
		qsf_rb.qsf_type = QSFRB_CB;
		qsf_rb.qsf_ascii_id = QSFRB_ASCII_ID;
		qsf_rb.qsf_length = sizeof(qsf_rb);
		qsf_rb.qsf_owner = (PTR)DB_PSF_ID;
		qsf_rb.qsf_sid = cb->pss_sessid;
	        qsf_rb.qsf_feobj_id.qso_type = QSO_ALIAS_OBJ;
	        qsf_rb.qsf_feobj_id.qso_lname = sizeof(dbpid);
	        (VOID)MEcopy((PTR) dbpid, sizeof(dbpid),
		    (PTR) qsf_rb.qsf_feobj_id.qso_name);
	        qsf_rb.qsf_obj_id.qso_type = QSO_QP_OBJ;
	        qsf_rb.qsf_obj_id.qso_lname = sizeof(DB_CURSOR_ID);
	        (VOID)MEcopy((PTR) &pnode->pst_dbpid,
		    sizeof(DB_CURSOR_ID),
		    (PTR) qsf_rb.qsf_obj_id.qso_name);
    
	        /* 
		** if creating a set-input procedure for the first time,
	        ** we do not want to create (DEFINE) a query plan.
	        ** Yet we still want to destroy any existing query plans for a
	        ** procedure with the same name in the same schema,
	        ** so we still try to TRANSLATE the procedure name into a QP id.
	        */ 
		qsf_op = 
		    (psq_cb->psq_mode == PSQ_CRESETDBP) ? QSO_JUST_TRANS 
							: QSO_TRANS_OR_DEFINE;
    
	        qsf_rb.qsf_lk_state = QSO_FREE;
	        status = qsf_call(qsf_op, &qsf_rb);
    
	        if (DB_FAILURE_MACRO(status))
	        {
		    if ((qsf_rb.qsf_error.err_code == E_QS0019_UNKNOWN_OBJ)	
		        && (qsf_op == QSO_JUST_TRANS))
		    {
		        /* didn't find object, which is OK in this case */
		        status = E_DB_OK;
		    }
		    else
		    {
		        (VOID) psf_error(E_PS0379_QSF_T_OR_D_ERR,
				         qsf_rb.qsf_error.err_code, PSF_INTERR,
				         &err_code, &psq_cb->psq_error, 0);
		        return (status);
		    }
	        }	

	        if (qsf_rb.qsf_t_or_d == QSO_WASTRANSLATED)
	        {
		    /*
		    ** If not recreating procedure, may find an existing QEP
		    ** if same user/role is creating a procedure with the same
		    ** name in 2 different sessions OR if a user issues CREATE
		    ** PROCEDURE, does a rollback (destroying catalog entries),
		    ** and then runs CREATE PROCEDURE again.
		    ** 
		    ** At any rate, if an alias exists, we delete it
		    ** and create a new one.
		    */
 
		    /* Get ready to destroy the ALIAS. */
		    qsf_rb.qsf_lk_state = QSO_SHLOCK;
 
		    status = qsf_call(QSO_GETHANDLE, &qsf_rb);
 
		    if (DB_FAILURE_MACRO(status))
		    {
			_VOID_ psf_error(E_PS0A0B_CANTGETHNDLE,
			    qsf_rb.qsf_error.err_code, PSF_INTERR, &err_code,
			    &psq_cb->psq_error, 0);
			return(status);
		    }
 
		    /* Now destroy the ALIAS and the QP objects in QSF */
		    status = qsf_call(QSO_DESTROY, &qsf_rb);
 
		    if (DB_FAILURE_MACRO(status))
		    {
			_VOID_ psf_error(E_PS0A09_CANTDESTROY,
			    qsf_rb.qsf_error.err_code, PSF_INTERR, &err_code,
			    &psq_cb->psq_error, 0);
			return(status);
		    }
 
		    /* Reinitialize part of the QSF ctrl block,
		    ** because QSO_WASTRANSLATED code means that
		    ** the translated value was placed in 'qsf_obj_id'
		    */
		    qsf_rb.qsf_obj_id.qso_type = QSO_QP_OBJ;
		    qsf_rb.qsf_obj_id.qso_lname = sizeof(DB_CURSOR_ID);
		    MEcopy((PTR) &pnode->pst_dbpid, sizeof(DB_CURSOR_ID),
			(PTR) qsf_rb.qsf_obj_id.qso_name);
 
		    qsf_rb.qsf_lk_state = QSO_FREE;
		    status = qsf_call(qsf_op, &qsf_rb);
 
		    if (DB_FAILURE_MACRO(status))
		    {
			if ((qsf_rb.qsf_error.err_code == E_QS0019_UNKNOWN_OBJ)	
			    && (qsf_op == QSO_JUST_TRANS))
			{
			    /* didn't find object, which is OK in this case */
			    status = E_DB_OK;
			}
			else
			{
			    _VOID_ psf_error(E_PS0379_QSF_T_OR_D_ERR,
					qsf_rb.qsf_error.err_code, PSF_INTERR,
					&err_code, &psq_cb->psq_error, 0);
			    return (status);
			}
		    }
    
		    if (qsf_rb.qsf_t_or_d == QSO_WASTRANSLATED)
		    {
			/* We need to retry; looks like there is some
			** concurrent activity going on.
			*/
			psq_cb->psq_error.err_code = E_PS0008_RETRY;
			/* parser will free the stream, but this handle is never
		     cleared. The sequencer tries to free it on the retry.*/
			psq_cb->psq_txtout.qso_handle = (PTR) NULL;
			return (E_DB_ERROR);
		    }
	        }	/* end if QSO_TRANSLATED */
    
		/*
		** Following assignment is done so that SCF can extract
		** proc name and pass it in PSY_CB to psy_call when
		** creating a procedure.
		*/
		STRUCT_ASSIGN_MACRO(pnode->pst_dbpid, psq_cb->psq_cursid);
	    }

#ifdef	xDEBUG
	    {
		i4 val1;
		i4 val2;

		if (ult_check_macro(&cb->pss_trace, 15, &val1, &val2))
		{   
		    _VOID_ pst_dbpdump(pnode, 0);	    /* pst_next */
		}
	    }
#endif

	    /* As the very last action fix the pst_next ptrs where necessary,
	    ** also change pst_type in WHILE statements to PST_IF_TYPE.
	    */
	    _VOID_ psl_backpatch($6, (PST_STATEMENT *) NULL);

#ifdef	xDEBUG
	    {
		i4 val1;
		i4 val2;

		if (ult_check_macro(&cb->pss_trace, 14, &val1, &val2))
		{   
		    _VOID_ pst_dbpdump(pnode, 1);	    /* pst_link */
		}
	    }
#endif
	}
    }
;

cdbp_kwd:	    cdbp_noise PROCEDURE
    {
	i4                err_code;
	DB_STATUS	       status;
	PTR		       piece;

	/* "[CREATE] PROCEDURE" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(5118L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		sizeof("CREATE PROCEDURE") - 1, "CREATE PROCEDURE");
	    return (E_DB_ERROR);
	}

	/* Set the query mode for proper recovery from syntax errors.
	** the mode will be changed by any DML statement, but it shall
	** be later restored to the proper value.
	*/
	psq_cb->psq_mode = PSQ_CREDBP;

	$Yisdbp = TRUE;

	/* 
        ** Indicate to other routines that where are parsing a database
	** procedure
	*/
	cb->pss_dbp_flags |= PSS_DBPROC;

	/* Open the memory stream for allocating the query tree */
	status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** if processing a "true" [re]create (i.e. not reparsing a dbproc to
	** determine whether it is grantable or active), open a memory stream
	** for allocating lists of objects and privileges on which this dbproc
	** depends
	*/
	if (!(cb->pss_dbp_flags & (PSS_0DBPGRANT_CHECK | PSS_CHECK_IF_ACTIVE)))
	{
	    PSF_MSTREAM                 mem_stream;

	    status = psf_mopen(cb, QSO_QTEXT_OBJ, &mem_stream, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return(status);

	    /*
	    ** far out: we will allocate a stream descriptor using the stream
	    ** itself; sess_cb->pss_dependencies_stream will point at this new 
	    ** descriptor so that if an exception occurs, the exception handler
	    ** will be able to release the memory associated with the stream.
	    */
	    status = psf_malloc(cb, &mem_stream, sizeof(PSF_MSTREAM),
		(PTR *) &cb->pss_dependencies_stream, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return(status);

	    STRUCT_ASSIGN_MACRO(mem_stream, (*cb->pss_dependencies_stream));
	}
	    
	/*
	** We may need to determine if the dbproc is "grantable".
	** If we find that the dbproc is grantable, its QP will be
	** accessible to everyone; otherwise, we will create a QP
	** accessible only by the owner of the dbproc.
	** 
	** In general, until proven otherwise, we'll assume that dbproc is
	** grantable.
	**
	** 3/26/92 (andre)
	**	when trying to establish whether a dbproc P is "at least active"
	**	(as would happen when we are parsing a new dbproc or recreating
	**	a dormant dbproc for execution by its owner), we may end up
	**	reparsing dormant dbprocs invoked by P (this can be detected by
	**	checking whether PSS_CHECK_IF_ACTIVE is set).
	**	The alternative which I originally considered involved checking
	**	invoked dbproc on the subject of them being grantable and, based
	**	on this information, determining whether P is grantable.
	**	Unfortunately, maintaining and using a privilege list where some
	**	privileges are grantable and others are not makes the algorithm
	**	more complicated. Eventually, I may choose to do it that way,
	**	but for the time being I will not attempt to determine whether
	**	the invoked dbproc is grantable (i.e. we will not set
	**	PSS_DBPGRANT_OK bit.)
	*/
	if (~cb->pss_dbp_flags & PSS_CHECK_IF_ACTIVE)
	{
	    cb->pss_dbp_flags |= PSS_DBPGRANT_OK;
	}

	if (~cb->pss_dbp_flags & PSS_RECREATE)
	{
	    /*
	    ** The "create procedure" statement requires query text to be stored
	    ** in the iiqrytext relation.  Open a text chain and put the initial
	    ** words just parsed in it.  The text chain will be coalesced into
	    ** a contiguous block later.
	    */
	    cb->pss_stmt_flags |= PSS_TXTEMIT;	    /* Indicate to emit text */

	    status = psq_topen(&cb->pss_tchain, &cb->pss_memleft,
		&psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);

	    if ($1)
	    {
		status = psq_tadd(cb->pss_tchain,
		    (u_char *) "create procedure ",
		    sizeof("create procedure ") - 1, &piece,
		    &psq_cb->psq_error);
	    }
	    else
	    {
		status = psq_tadd(cb->pss_tchain, (u_char *) "procedure ",
		    sizeof("procedure ") - 1, &piece, &psq_cb->psq_error);
	    }
	    if (DB_FAILURE_MACRO(status))
		return (status);

	    /*
	    ** during parsing of dbproc definition we will insist on up-to-date
	    ** RDF cache info and report errors
	    */
	    cb->pss_retry = PSS_REPORT_MSGS | PSS_REFRESH_CACHE;
	}

	/*
	** group and role permits will be disregarded when parsing definitions
	** of views, rules, and database procedures
	*/
	cb->pss_stmt_flags |= PSS_DISREGARD_GROUP_ROLE_PERMS;
    }
;

cdbp_noise:	    CREATE
    {
	$$ = 1;
    }
	    |
    {
	$$ = 0;
    }
;

cdbp_procname:	    obj_spec
    {
	DB_STATUS	status;
	DB_DBP_NAME	dbpname;
	i4		dbpshow_flags;
	i4		err_code;
        DB_STATUS	local_status;
        i4              access = 0;
   
	/* If name was qualified, it'd better be the same as the user */
	if ($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp((PTR) &$1->pss_owner, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME)))
	{
	    (VOID) psf_error(E_PS0421_CRTOBJ_NOT_OBJ_OWNER, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof("CREATE PROCEDURE") - 1, "CREATE PROCEDURE",
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &$1->pss_owner),
		&$1->pss_owner);
	    return(E_DB_ERROR);
	}

	/* test procedure name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT($1->pss_orig_obj_name, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	STmove($1->pss_orig_obj_name, ' ', 
	       sizeof(DB_DBP_NAME), dbpname.db_dbp_name);

        /* Verify the user has CREATE_PROCEDURE permission */
        if (!(cb->pss_dbp_flags & PSS_RECREATE))
        {
	    char	*ch1 = $1->pss_orig_obj_name;
# ifndef DOUBLEBYTE
	    char	*ch2 = ch1 + CMbytecnt(ch1);
# else
	    char	*ch2;
	    
	    ch2 = ch1 + CMbytecnt(ch1);
# endif /* #ifndef DOUBLEBYTE */
	    
            status = psy_ckdbpr(psq_cb, (u_i4)DBPR_PROC_CREATE);
            if (status)
            {
		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    DB_ERROR	e_error;
		    /*
		    ** Audit failure to create procedure
		    */
		    local_status = psy_secaudit(FALSE, cb,
			    (char *)&dbpname, &cb->pss_user,
			    sizeof(DB_TAB_NAME), SXF_E_PROCEDURE,
			    I_SX2012_DBPROC_CREATE, SXF_A_FAIL | SXF_A_CREATE,
			    &e_error);
		}

                (VOID) psf_error(6246L, 0L, PSF_USERERR,
                                 &err_code, &psq_cb->psq_error, 0);
                return(status);
            }

	    /*
	    ** In case of a true CREATE nobody but $ingres user may
	    ** create procedures which name starts with 'ii'.
	    */

	    if (!CMcmpnocase(ch1, &SystemCatPrefix[0]) &&
		!CMcmpnocase(ch2, &SystemCatPrefix[1]) &&
		MEcmp((PTR) &cb->pss_user, (PTR) cb->pss_cat_owner,
		      sizeof(DB_OWN_NAME))
	       )
	    {
		(VOID) psf_error(2432L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1,
		    STlength($1->pss_orig_obj_name), $1->pss_orig_obj_name);
		return(E_DB_ERROR);
	    }
        }
  
	status = pst_dbpshow(cb, &dbpname, &$Ydbpinfo, (DB_OWN_NAME *) NULL,
	    (DB_TAB_ID *) NULL,
	    (cb->pss_dbp_flags & PSS_RECREATE)
		? PSS_USRDBP : (PSS_NEWDBP | PSS_USRDBP),
		psq_cb, &dbpshow_flags);
	if (DB_FAILURE_MACRO(status))
	    return (status);
	else if (dbpshow_flags & (PSS_MISSING_DBPROC | PSS_DUPL_DBPNAME))
	{
	    /*
	    ** if creating a new dbproc and the current user already owns a
	    ** dbproc with that name or if trying to recreate a dbproc which
	    ** does not exist, appropriate bits in dbpshow_flags will be set,
	    ** but status will not be set to E_DB_ERROR
	    */
	    return (E_DB_ERROR);
	}

	(VOID) QUinit(&$Ydbpinfo->pss_varq);	/* No parms yet */
	$Ydbpinfo->pss_curvar = (PSS_DECVAR *) NULL;
	$Ydbpinfo->pss_varno = 0;
	$Ydbpinfo->pss_bescope = 0;
	$Ydbpinfo->pss_inloop = 0;
	(VOID) QUinit(&$Ydbpinfo->pss_loopq);
	$Ydbpinfo->pss_link =
	    $Ydbpinfo->pss_last_stmt = (PST_STATEMENT *) NULL;
	(VOID) QUinit(&$Ydbpinfo->pss_ifq);
	$Ydbpinfo->pss_into_clause = (PST_QNODE *) NULL;    /* ptr to INTO
							    ** clause tree
							    */
	$Ydbpinfo->pss_flags = 0;
	$Ydbpinfo->pss_unreachable_stmt_lvl = 0;

	/* initialize variables used for set-input parameters
	 */
	$Ydbpinfo->pss_setparmname = (PSS_DECVAR *) NULL;
	$Ydbpinfo->pss_setparmno   = 0;
	(VOID) QUinit(&$Ydbpinfo->pss_setparmq);
	$Ydbpinfo->pss_resrowno   = 0;
	(VOID) QUinit(&$Ydbpinfo->pss_resrowq);

	$Ydbpinfo->pss_procparmno = 0;

	/* Initialize BUILT-INS now, they have to be processed before
	** first parm is seen by the parser, since built-ins are to occupy
	** first n slots in var array.
	*/
	{
	    bool		found = FALSE;
	    DB_PARM_NAME	varname;
	    PSS_DECVAR	*var;
            char		*tempstr;

	    /* iirowcount must be first, iierrornumber must be second;
	    ** (see defn of PST_RCNT and PST_ERNO).
	    */
            if (*cb->pss_dbxlate & CUI_ID_REG_U)
	        tempstr = "IIROWCOUNT";
            else
	        tempstr = "iirowcount";
	    STmove(tempstr, ' ', DB_MAXNAME, (char *) &varname);

	    /* Allocate memory for the var entry */
	    status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSS_DECVAR), 
		(PTR *) &var, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);

	    var->pss_next = (PSS_DECVAR *) NULL;
	    var->pss_no = $Ydbpinfo->pss_varno++;
	    STRUCT_ASSIGN_MACRO(varname, var->pss_varname);
	    var->pss_scope = $Ydbpinfo->pss_bescope;	/* universal */
	    var->pss_out = FALSE;
	    
	    var->pss_dbdata.db_data = (PTR) NULL;
	    var->pss_dbdata.db_length = 4;
	    var->pss_dbdata.db_prec = 0;
	    var->pss_dbdata.db_datatype = DB_INT_TYPE;
	    var->pss_dbdata.db_prec = (i2) 0;
	    var->pss_default = 1;

	    /* Attach element to the list, last one will be at the queue head. */
	    (VOID) QUinsert((QUEUE *) var, &$Ydbpinfo->pss_varq);
            if (*cb->pss_dbxlate & CUI_ID_REG_U)
	        tempstr = "IIERRORNUMBER";
            else
	        tempstr = "iierrornumber";
	    STmove(tempstr, ' ', DB_MAXNAME, (char *) &varname);

	    /* Allocate memory for the var entry */
	    status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSS_DECVAR), 
		(PTR *) &var, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);

	    var->pss_next = (PSS_DECVAR *) NULL;
	    var->pss_no = $Ydbpinfo->pss_varno++;
	    STRUCT_ASSIGN_MACRO(varname, var->pss_varname);
	    var->pss_scope = $Ydbpinfo->pss_bescope;	/* universal */
	    var->pss_out = FALSE;

	    var->pss_dbdata.db_data = (PTR) NULL;
	    var->pss_dbdata.db_prec = 0;
	    var->pss_dbdata.db_length = 4;
	    var->pss_dbdata.db_datatype = DB_INT_TYPE;
	    var->pss_dbdata.db_prec = (i2) 0;
	    var->pss_default = 1;
	    
	    /* Attach element to the list, last one will be at the queue head */
	    (VOID) QUinsert((QUEUE *) var, &$Ydbpinfo->pss_varq);
	}

	if (~cb->pss_dbp_flags & PSS_RECREATE)
	{
	    /* 
	    ** if creating procedure via an EXECUTE IMMEDIATE statement,
	    ** check for special flags set by QEF
	    */
	    if (psq_cb->psq_info != (PST_INFO *) NULL)
	    {
		if (psq_cb->psq_info->pst_execflags & PST_SYSTEM_GENERATED)
		    cb->pss_dbp_flags |= PSS_SYSTEM_GENERATED;

		if (psq_cb->psq_info->pst_execflags & PST_NOT_DROPPABLE)
		    cb->pss_dbp_flags |= PSS_NOT_DROPPABLE;

		if (psq_cb->psq_info->pst_execflags 
		    & PST_SUPPORTS_CONSTRAINT)
		    cb->pss_dbp_flags |= PSS_SUPPORTS_CONS;

	    }  /* end psq_info != NULL */
	}  /* end if (~cb->pss_dbp_flags & PSS_RECREATE) */
	else
	{
	    /* check if this is a system-generated procedure and set flag
	     */
	    if ($Ydbpinfo->pss_ptuple.db_mask[0] & DBP_SYSTEM_GENERATED)
	    {
		cb->pss_dbp_flags |= PSS_SYSTEM_GENERATED;
	    }
	}		    

	/*
	** we need to determine id of a base table (other than a core catalog)
	** on which this dbproc depends.  When recreating a dbproc, one could 
	** argue that we should search for dbproc ubt_id only if the dbproc is 
	** dormant and no independent object/privilege list exists for it.  
	** I am choosing to do it regardless of the current status of the dbproc
	** being recreated for fear that its status may change between the time
	** we obtain its description (in this production) and the time we 
	** actually get to make any changes to the IIPROCEDURE tuple
	*/
	cb->pss_dbp_ubt_id.db_tab_base = cb->pss_dbp_ubt_id.db_tab_index = 0;
    }
;

cdbp_parmspec:	    /* empty */
	    |	    LPAREN cdbp_parmlst RPAREN
    {
	/* record the number of parameters (before we add local variables)
	** 
	** Note that we must account for the built-in parameters 
	** (which start counting at 0, so we have to adjust by 1).
	*/
	$Ydbpinfo->pss_procparmno = $Ydbpinfo->pss_varno - (PST_DBPBUILTIN +1);
    }
	    |	    LPAREN cdbp_varname cdbp_equalnoise SET OF 
    {
	i4	err_code;
	char 	*dbpname;
	i4	val1=0, val2=0;  /* for trace point checking */

	/*   a set-input parameter is only allowed in a CREATE PROCEDURE
	** statement if it is generated by the system (i.e. QEF) in an 
	** Execute Immediate fashion (check PST_INFO to tell this);
	**     We also allow it if we are RECREATing a procedure
	** to re-generate its query plan.
	**     One final case: allow it if trace point PS177 is turned on.
	** If none of these hold true, return a syntax error,
	** as this syntax is not available to the user (yet).
	*/
	/* These limitations have all been removed as a result of the 
	** statement level rules project and the "temp table as 
	** procedure parm" project. */

	/* flag that we are parsing a set-input parameter
	 */
	cb->pss_dbp_flags |= PSS_PARSING_SET_PARAM;

	/* if recreating a set-input procedure for QEF, check that the
	** procedure hasn't changed since the set-input temp table was created.
	*/
	if (cb->pss_dbp_flags & PSS_RECREATE)
	{

	    /* compare the procid found by PSF with the one passed from QEF
	     */
    	    if (   ($Ydbpinfo->pss_ptuple.db_procid.db_tab_base
				    != psq_cb->psq_set_procid.db_tab_base)
		|| 
		   ($Ydbpinfo->pss_ptuple.db_procid.db_tab_index
				    != psq_cb->psq_set_procid.db_tab_index))
	    {
		dbpname = $Ydbpinfo->pss_ptuple.db_dbpname.db_dbp_name;

		if (psq_cb->psq_set_input_tabid.db_tab_base == 0)
				/* SET OF call w. scalar plist? */
			_VOID_ psf_error(2442L, 0L, PSF_USERERR, 
				 &err_code, &psq_cb->psq_error, 1,
				 psf_trmwhite(DB_MAXNAME, dbpname),
				 dbpname);
		else 		/* just plain didn't find it! */
			_VOID_ psf_error(2405L, 0L, PSF_USERERR, 
				 &err_code, &psq_cb->psq_error, 1,
				 psf_trmwhite(DB_MAXNAME, dbpname),
				 dbpname);
		return(E_DB_ERROR);
	    }
	}  /* end if PSS_RECREATE */


	/* remove set name from var queue, and store it away
	**  (QEF expects a set-input procedure to look like it has no params;
	**   QEF will look for the set-input param in the range table instead)
	*/
	$Ydbpinfo->pss_setparmname = (PSS_DECVAR *) QUremove((QUEUE *) $2);
	$Ydbpinfo->pss_varno--;

	/* flag to tell PSY that we are processing
	** a procedure with a set-input parameter
	*/
	cb->pss_dbp_flags |= PSS_SET_INPUT_PARAM;

    }
			LPAREN cdbp_parmlst RPAREN RPAREN 
    {
	DB_STATUS status;

	i4		maxparm;
	i4		err_code;
	PSS_DECVAR	*var;

	/* Check if the parm limit has been exceeded
	**  (NOTE that the parm limit for set-input procedures is less than
	**  that for other procedures.  Since the set is implemented via a
	**  temporary table, the set cannot have any more parameters (columns)
	**  than a table can.  Normal procedures allow twice that many parms)
	*/
	var = (PSS_DECVAR *) $Ydbpinfo->pss_setparmq.q_next;
	if (var != (PSS_DECVAR *) &$Ydbpinfo->pss_setparmq 
	    && var->pss_no >= DB_MAX_COLS)
	{
	    maxparm = DB_MAX_COLS;
	    (VOID) psf_error(2423L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, sizeof(maxparm), &maxparm);
	    return (E_DB_ERROR);
	}

	/* build a dummy range table for the set parameter,
	** storing it in pss_dbprng.
	** This will be used when SELECT and other statements attempt to
	** reference the set as a table.
	*/
	status = psl_cdbp_build_setrng(cb, psq_cb,
				       $Ydbpinfo, &cb->pss_dbprng);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* turn off flag since we are done parsing the set-input parameter
	 */
	cb->pss_dbp_flags &= ~PSS_PARSING_SET_PARAM;
    } 
;

cdbp_parmlst:	    cdbp_parmitem
	    |	    cdbp_parmlst COMMA cdbp_parmitem
    {
	i4		maxparm;	/* Fix bug if bad param to psf_error */
	i4		err_code;
	PSS_DECVAR	*var;
	QUEUE		*varq;

	if (cb->pss_dbp_flags & PSS_PARSING_SET_PARAM)
	    varq = &($Ydbpinfo->pss_setparmq);
	else
	    varq = &($Ydbpinfo->pss_varq);
    
	/* Check if the parm limit has been exceeded */
	var = (PSS_DECVAR *) varq->q_next;
	if ((var != (PSS_DECVAR *) varq)
	    && var->pss_no > PSS_DBPPARMMAX
	   )
	{
	    maxparm = PSS_DBPUSRMAX;
	    (VOID) psf_error(2423L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, sizeof(maxparm), &maxparm);
	    return (E_DB_ERROR);
	}
    }
;

cdbp_parmitem:	    cdbp_varname cdbp_equalnoise cdbp_typedesc
;

cdbp_varname:	    cdbp_parmmode generic_ident
    {
	i4		err_code;
	DB_STATUS	status;
	bool		found = FALSE;
	DB_PARM_NAME	varname;
	PSS_DECVAR	*var;
	QUEUE		*varq;
	char		*ch1 = $2;
# ifndef DOUBLEBYTE
	char		*ch2 = ch1 + CMbytecnt(ch1);
# else
	char		*ch2;
	
	ch2 = ch1 + CMbytecnt(ch1);
# endif /* ifndef DOUBLEBYTE */

	STmove($2, ' ', DB_MAXNAME, (char *) &varname);

	/* Name must not start with 'ii'. */
	if (!CMcmpnocase(ch1, &SystemCatPrefix[0]) &&
	    !CMcmpnocase(ch2, &SystemCatPrefix[1]))
	{
	    (VOID) psf_error(2433L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, STlength($2), $2,
		STlength(SystemCatPrefix), SystemCatPrefix);
	    return (E_DB_ERROR);	
	}

	/* Name must not start with '$'. */
	if (PSL_IS_RESERVED_IDENT($2, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	/* Check if var specified for the first time
	** at this scope level.
	** Actually in this release scope levels should
	** not be implemented, there can be only one
	** BEGIN-END block, moreover parameters should
	** be treated as being at the same scope as local vars
	** which implies that names should be unique.
	*/

	/* get appropriate queue
	 */
	if (cb->pss_dbp_flags & PSS_PARSING_SET_PARAM)
	    varq = &($Ydbpinfo->pss_setparmq);
	else if (cb->pss_dbp_flags & PSS_PARSING_RESULT_ROW)
	    varq = &($Ydbpinfo->pss_resrowq);
	else
	    varq = &($Ydbpinfo->pss_varq);

	for (var = (PSS_DECVAR *) varq->q_next;
	     var != (PSS_DECVAR *) varq;
	     var = (PSS_DECVAR *) var->pss_queue.q_next
	    )
	{
	    /* Commented out for the reason mentioned in
	    ** the comment above.
	    if (var->pss_scope != $Ydbpinfo->pss_bescope)
		continue;
	    */

	    if (MEcmp((PTR) &varname, (PTR) &var->pss_varname,
		sizeof(var->pss_varname)) == 0
	       )
	    {
		found = TRUE;
		break;
	    }
	}

	if (found == TRUE)
	{
	    /* Found a duplicate name */
	    (VOID) psf_error(2401L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, STlength($2), $2);
	    return (E_DB_ERROR);
	}

	/* Allocate memory for the var entry */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSS_DECVAR), 
	    (PTR *) &var, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	var->pss_next = (PSS_DECVAR *) NULL;
	STRUCT_ASSIGN_MACRO(varname, var->pss_varname);
	var->pss_scope = $Ydbpinfo->pss_bescope;
	var->pss_out = FALSE;
	var->pss_flags = $1;
	
	/* Attach element to the list, last one will be at the queue head.
	 */
	(VOID) QUinsert((QUEUE *) var, varq);

	/* Store var number and increment the appropriate counter
	 */
	if (cb->pss_dbp_flags & PSS_PARSING_SET_PARAM)
	    var->pss_no = $Ydbpinfo->pss_setparmno++;
	else if (cb->pss_dbp_flags & PSS_PARSING_RESULT_ROW)
	    var->pss_no = $Ydbpinfo->pss_resrowno++;
	else
	    var->pss_no = $Ydbpinfo->pss_varno++;

	$Ydbpinfo->pss_curvar = var;

	$$ = var;
    }
;

cdbp_equalnoise:    EQUAL
	    |
;

cdbp_parmmode:	/* nuffin' */
    {
	$$ = 0;
    }
	    | IN
    {
	$$ = PSS_PPIN;
    }
	    | OUT
    {
	cb->pss_dbp_flags |= PSS_OUT_PARMS;
	$$ = PSS_PPOUT;
    }
	    | INOUT
    {
	cb->pss_dbp_flags |= PSS_OUT_PARMS;
	$$ = PSS_PPINOUT;
    }
;

cdbp_resrow_spec:   |	/* nuthin' or ... */
		    RESULTROW 
    {
	cb->pss_dbp_flags |= PSS_PARSING_RESULT_ROW;
    }
		    LPAREN cdbp_rowelem_list RPAREN
    {
	cb->pss_dbp_flags &= ~PSS_PARSING_RESULT_ROW;
    }
;

cdbp_rowelem_list:  cdbp_row_elem
	    |	    cdbp_rowelem_list COMMA cdbp_row_elem
    {
	i4		maxparm;
	i4		err_code;
	PSS_DECVAR	*var;
	QUEUE		*varq;

	/* Just check for too many "columns". */
	var = (PSS_DECVAR *)$Ydbpinfo->pss_resrowq.q_next;
	if (var != (PSS_DECVAR *) &$Ydbpinfo->pss_resrowq &&
		var->pss_no > PSS_DBPROWMAX)
	{
	    maxparm = PSS_DBPROWMAX;
	    (VOID) psf_error(2423L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, sizeof(maxparm), &maxparm);
	    return (E_DB_ERROR);
	}
    }
;

cdbp_row_elem:
    {
	i4		err_code;
	DB_STATUS	status;
	bool		found = FALSE;
	DB_PARM_NAME	varname;
	PSS_DECVAR	*var;
	QUEUE		*varq;

	/* get appropriate queue
	 */
	varq = &($Ydbpinfo->pss_resrowq);

	for (var = (PSS_DECVAR *) varq->q_next;
	     var != (PSS_DECVAR *) varq;
	     var = (PSS_DECVAR *) var->pss_queue.q_next
	    )
	{
	    if (MEcmp((PTR) &varname, (PTR) &var->pss_varname,
		sizeof(var->pss_varname)) == 0
	       )
	    {
		found = TRUE;
		break;
	    }
	}

	/* Allocate memory for the var entry */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSS_DECVAR), 
	    (PTR *) &var, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	var->pss_next = (PSS_DECVAR *) NULL;
	STRUCT_ASSIGN_MACRO(varname, var->pss_varname);
	var->pss_scope = $Ydbpinfo->pss_bescope;
	var->pss_out = FALSE;
	
	/* Attach element to the list, last one will be at the queue head.
	 */
	(VOID) QUinsert((QUEUE *) var, varq);

	/* Store var number and increment the appropriate counter
	 */
	var->pss_no = $Ydbpinfo->pss_resrowno++;

	$Ydbpinfo->pss_curvar = var;
    }
	cdbp_typedesc	/* above code (cloned from cdbp_varname) required
			** to set up result row descriptor list - but entries
			** are name-less. */
    {
    }
;

cdbp_asword:	    AS
	    |	    EQUAL
;

cdbp_beblock:	    cdbp_declare cdbp_begin cdbp_stmtlist cdbp_end
    {
	PSS_DECVAR  	*var;
	PST_STATEMENT	*rnode, *lastnd;
	DB_STATUS	status;

	/*
	** Always allocate and add trailing RETURN statement node.  This cheap
	** node clarifies control during execution.  Lastnd could be null after
	** ENDLOOP though a trailing ENDLOOP couldn't really happen here.
	** Do not attach the RETURN node for internal procedures (PSQ_IPROC)
	** as they handle their own return status in QEF.
	*/
	for (lastnd = $3; lastnd != NULL && lastnd->pst_next != NULL;
	     lastnd = lastnd->pst_next)
	    ;
	if (   lastnd == NULL
	    || (lastnd->pst_mode != PSQ_RETURN && lastnd->pst_mode != PSQ_IPROC)
	   )
	{
	    status = psl_init_dbp_stmt(cb, $Ydbpinfo, PSQ_RETURN, PST_RTN_TYPE,
		&rnode, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);

	    rnode->pst_specific.pst_rtn.pst_rtn_value = NULL;

	    if (lastnd != NULL)
		lastnd->pst_next = rnode;
	}

	$1->pst_next = $3;

	/* Place local vars out of scope */
	for (var = (PSS_DECVAR *) $Ydbpinfo->pss_varq.q_next;
	     var != (PSS_DECVAR *) &$Ydbpinfo->pss_varq;
	     var = (PSS_DECVAR *) var->pss_queue.q_next
	    )
	{
	    if (var->pss_scope == $Ydbpinfo->pss_bescope)
		var->pss_out = TRUE;	    
	}

	/* The definition of the new scope ends here. */
	$Ydbpinfo->pss_bescope--;

	$$ = $1;
    }
;

cdbp_begin:	    BEGIN
    {
	/* For proper syntax error reporting */
	psq_cb->psq_mode = 0;
    }
	    |	    LCURLY
    {
	/* For proper syntax error reporting */
	psq_cb->psq_mode = 0;
    }
;

cdbp_end:	    END
	    |	    RCURLY
;

cdbp_declare:	    cdbp_declare1
    {
	DB_STATUS	status;
	i4		count = 0;
	i4		firstno = 0;
	PST_STATEMENT	*snode;
	ADF_CB		*adf_scb = (ADF_CB*) cb->pss_adfcb;
	PST_DECVAR	*decvar;
	register PSS_DECVAR	*var;
	register DB_DATA_VALUE	*db_data;

	/* Count vars. at this scope level */
	for (var = (PSS_DECVAR *) $Ydbpinfo->pss_varq.q_next;
	     var != (PSS_DECVAR *) &$Ydbpinfo->pss_varq;
	     var = (PSS_DECVAR *) var->pss_queue.q_next
	    )
	{
	    if (var->pss_scope != $Ydbpinfo->pss_bescope)
		continue;

	    /* We're moving in the next direction, therefore
	    ** the last local var is really the first one specified.
	    */
	    firstno = var->pss_no;

	    count++;
	}

	/* Allocate memory for PST_DECVAR */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) (sizeof(PST_DECVAR)), 
	    (PTR *) &decvar, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	decvar->pst_nvars = count;

	/*
	** if no vars were declared, both firstno and count will remain 0.
	** In this case, OPF would like to know the number of the first var in
	** this declare, had there been one
	*/
	decvar->pst_first_varno = (count > 0) ? firstno : $Ydbpinfo->pss_varno;

	if (count)
	{
	    /* Allocate memory for local variable array */
	    status = psf_malloc(cb, &cb->pss_ostream,
		(i4) (count * sizeof(DB_DATA_VALUE)), 
		(PTR *) &decvar->pst_vardef, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);

	    /* Copy db data values, oldest one first. */
	    for (var = (PSS_DECVAR *) $Ydbpinfo->pss_varq.q_prev,
		 db_data = decvar->pst_vardef;
		 var != (PSS_DECVAR *) &$Ydbpinfo->pss_varq;
		 var = (PSS_DECVAR *) var->pss_queue.q_prev
		)
	    {
		if (var->pss_scope != $Ydbpinfo->pss_bescope)
		    continue;

		STRUCT_ASSIGN_MACRO(var->pss_dbdata, *db_data);

		/* LRC requested that all local vars have a default value
		** assigned, even if 'not null not default' has been specified,
		** for this reason the if below has been commented out and
		** getempty will be called for all local vars.
		**
		** Allocate memory for default values as necessary. *
		if (var->pss_default)
		{ */
		    status = psf_malloc(cb, &cb->pss_ostream, db_data->db_length,
			(PTR *) &db_data->db_data, &psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
			return (status);
		    status = adc_getempty (adf_scb, db_data);
		    if (DB_FAILURE_MACRO(status))
			return (status);
	      /*}*/
		db_data++;
	    }
	}
	else
	{
	    decvar->pst_vardef = (DB_DATA_VALUE *) NULL;
	}

	decvar->pst_varname = (DB_PARM_NAME *) NULL;
	decvar->pst_parmmode = (i4 *) NULL;

	/* Allocate statement node. */
	status = psl_init_dbp_stmt(cb, $Ydbpinfo, psq_cb->psq_mode, PST_DV_TYPE,
	    &snode, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	snode->pst_specific.pst_dbpvar = decvar;

	$$ = snode;
    }
;

cdbp_declare1:	    cdbp_deckwd cdbp_varspec
	    |
    {
	/* New scope is being defined */
	$Ydbpinfo->pss_bescope++;
    }
;

cdbp_deckwd:	    DECLARE
    {
	/* Initialize query mode for proper handling of syntax errors. */
	/*
	** Please note that in the course of processing internal dbproc, we rely
	** on the fact that psq_mode is set to PSQ_VAR iff declare was present.
	** Do exersize care when changing this.
	*/
	psq_cb->psq_mode = PSQ_VAR;

	/* New scope is being defined */
	$Ydbpinfo->pss_bescope++;
    }
;

cdbp_varspec:	    cdbp_varitem
	    |	    cdbp_varspec cdbp_varitem
;

cdbp_varitem:	    cdbp_varnamelst cdbp_equalnoise
		    cdbp_typedesc SEMICOLON
    {
	register PSS_DECVAR  *decvar;

	/* The current one is already initialized. */
	for (decvar = $Ydbpinfo->pss_curvar->pss_next;
	     decvar != (PSS_DECVAR *) NULL;
	     decvar = decvar->pss_next
	    )
	{
	    /* Copy db_data_value and default info. */
	    STRUCT_ASSIGN_MACRO($Ydbpinfo->pss_curvar->pss_dbdata,
		decvar->pss_dbdata);
	    decvar->pss_default = $Ydbpinfo->pss_curvar->pss_default;
	}
    }
;

cdbp_varnamelst:    cdbp_varname
	    |	    cdbp_varnamelst COMMA cdbp_varname
    {
	/* Will create a linked list in the backwards
	** direction sort of, because previous var nodes
	** will be pointed to by the last processed node.
	*/
	$3->pss_next = $1;

	$$ = $3;
    }
;

cdbp_typedesc:	    tname type_qual_list
    {
	DB_STATUS		    status;

	status = psl_cdbp_typedesc(cb, $Ydbpinfo, $1, 0, (i4 *) NULL, $2,
	    psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|         tname LPAREN intconst_e RPAREN type_qual_list
    {
	DB_STATUS		    status;

	status = psl_cdbp_typedesc(cb, $Ydbpinfo, $1, 1, (i4 *) &$3, $5,
	    psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|         tname LPAREN intconst_e COMMA intconst_e RPAREN type_qual_list
    {
	DB_STATUS		    status;
	i4			    parms[2];

	parms[0] = $3;
	parms[1] = $5;

	status = psl_cdbp_typedesc(cb, $Ydbpinfo, $1, 2, parms, $7, psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	tname dt_wquals tname type_qual_list
    {
	DB_STATUS		    status;
	char			    *value;

	/* One of the TIME/TIMESTAMP types. Glue all the bits together. */
	status = psl_ct11_tname_name_name(cb, psq_cb, $1, $2, $3, &value);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	status = psl_cdbp_typedesc(cb, $Ydbpinfo, value, 0, (i4 *) NULL,
	    $4, psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	tname TO tname type_qual_list
    {
	DB_STATUS		    status;
	char			    *value;

	/* One of the INTERVAL xxx TO xxx types. Glue all the bits together. */
	status = psl_ct11_tname_name_name(cb, psq_cb, $1, "to", $3, &value);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	status = psl_cdbp_typedesc(cb, $Ydbpinfo, value, 0, (i4 *) NULL,
	    $4, psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	tname LPAREN intconst_e RPAREN dt_wquals tname type_qual_list
    {
	DB_STATUS		    status;
	char			    *value;

	/* One of the multi-name DATE/TIME types. Glue all the bits together. */
	status = psl_ct11_tname_name_name(cb, psq_cb, $1, $5, $6, &value);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	status = psl_cdbp_typedesc(cb, $Ydbpinfo, value, 1, (i4 *) &$3, $7,
	    psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

cdbp_seminoise:	    SEMICOLON
	    |
;

cdbp_opt_retrow: /* Nothin' */
	    |	    cdbp_retrow_stmt
;

cdbp_stmtlist:	    cdbp_stmtlst cdbp_seminoise
    {
	/*
	** if the block contained unreachable statements, decrement the level
	** counter (recall that if non-zero, it gets incremented for every block
	** entered);
	** in future we may choose to report it to the user
	*/
	if ($Ydbpinfo->pss_unreachable_stmt_lvl)
	{
	    $Ydbpinfo->pss_unreachable_stmt_lvl--;
	}

	$$ = $1;
    }
	    |	    EXECUTE nonkeyword cdbp_opt_retrow cdbp_seminoise 
    {
	PST_STATEMENT	*snode;
	char		*c1 = $Ydbpinfo->pss_ptuple.db_dbpname.db_dbp_name;
	DB_STATUS	status;
# ifndef DOUBLEBYTE
	char		*c2 = c1 + CMbytecnt(c1);
# else
	char		*c2;

	c2 = c1 + CMbytecnt(c1);
# endif /* # ifndef DOUBLEBYTE */

	/*
	** we are about to process the invocation of the internal dbproc.
	** To be correct, it must be true that
	** 1) procedure name must start with "ii"	AND
	** 2) user must have catalog update privilege	AND
	** 3) user must be $ingres			AND
	** 4) there should be no DECLARE section	AND
	** 5) EXECUTE INTERNAL must be the only statement (enforsed by the
	**						   grammar)
	*/

	if ((cb->pss_dbp_flags & PSS_RECREATE) == 0)
	{
	    if (CMcmpnocase(c1, &SystemCatPrefix[0])
		||
		CMcmpnocase(c2, &SystemCatPrefix[1]) 
		|| 
		!(cb->pss_ses_flag & PSS_CATUPD)
		||
		MEcmp((PTR)&cb->pss_user, (PTR)cb->pss_cat_owner,
		      sizeof(DB_OWN_NAME))
		||
		psq_cb->psq_mode == PSQ_VAR	 /* set to PSQ_VAR when see DECLARE */
		||
		STcompare($2, "internal"))
	    {
		i4	err_code;
		/*
		** report error to user.  Note that if any one of the above conditions
		** is violated, user had no business having EXECUTE NAME in his
		** database procedure
		*/

		(VOID) psf_error(2587L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 2, sizeof(cb->pss_lineno), &cb->pss_lineno,
		    sizeof("execute") - 1, "execute");
		return (E_DB_ERROR);
	    }
	}
    	cb->pss_dbp_flags |= PSS_IPROC;

	/* Allocate statement node. */
	status = psl_init_dbp_stmt(cb, $Ydbpinfo, PSQ_IPROC, PST_IP_TYPE,
	    &snode, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* For proper syntax error reporting */
	psq_cb->psq_mode = PSQ_CREDBP;

	$$ = snode;
    }
	    |	    cdbp_seminoise
    {
	i4		err_code;

	$$ = (PST_STATEMENT *) NULL;

	/* Empty statement blocks not allowed yet. */
	(VOID) psf_error(2425L, 0L, PSF_USERERR,
	    &err_code, &psq_cb->psq_error, 0);
	return (E_DB_ERROR);
    }
;

cdbp_stmtlst:	    cdbp_stmt
    {
	/* For proper syntax error reporting */
	psq_cb->psq_mode = 0;

	/*
	** if this block is unreachable, or if it is reachable but the first
	** statement in it is ENDLOOP or RETURN, increment the level counter;
	**
	** Note that ENDLOOP node will never be built if ENDLOOP is the first
	** statement in the block; if this is ever changed, we also need to test
	** for $1->pst_type == PST_ENDLOOP_TYPE
	*/
	if ($Ydbpinfo->pss_unreachable_stmt_lvl ||
	    $1 == (PST_STATEMENT *) NULL	||
	    $1->pst_type == PST_RTN_TYPE)
	{
	    $Ydbpinfo->pss_unreachable_stmt_lvl++;
	}
	
	/* $1 may actually point to 2 statements */
	$$ = $1;
    }
	    |	    cdbp_stmtlst SEMICOLON cdbp_stmt
    {
	/*
	** if some preceeding statement in this block or some preceeding
	** statement in one of the surrounding blocks was RETURN or ENDLOOP,
	** this statement is not reachable, so there is no need to attach it to
	** the statement list
	*/
	if ($Ydbpinfo->pss_unreachable_stmt_lvl == 0)
	{
	    if (!$3)	    /* ENDLOOP statement for which no block was built */
	    {
		$Ydbpinfo->pss_unreachable_stmt_lvl = 1;
	    }
	    else
	    {
		
		PST_STATEMENT	*snode;

		/* Find last stmt in the list */
		for (snode = $1;
		     snode->pst_next != (PST_STATEMENT *) NULL;
		     snode = snode->pst_next
		    )
		;

		/* $3 may actually point to 2 statements */
		snode->pst_next = $3;

		/*
		** if the last statement added to the list was RETURN or
		** ENDLOOP, any subsequent statements in this block and in any
		** blocks contained in this block and occurring after this
		** statement are unreachable
		*/
		if ($3->pst_type == PST_ENDLOOP_TYPE ||
		    $3->pst_type == PST_RTN_TYPE)
		{
		    $Ydbpinfo->pss_unreachable_stmt_lvl = 1;
		}
	    }
	}

	/* For proper syntax error reporting */
	psq_cb->psq_mode = PSQ_CREDBP;

	/* Return ptr to the first one */
	$$ = $1;
    }
;

cdbp_stmt:	    cdbp_ctrlstmt
	    |	    cdbp_dmlstmt
	    |	    cdbp_txstmt
    {
	$$ = $1;
    }
	    |	    cdbp_assignstmt
    {
	$$ = $1;
	cb->pss_rsdmno = 0;	/* Statement simulated via SELECT */
    }
	    |	    cdbp_exec_dbproc
    {
	$$ = $1;	/* May be a pair of statements */
    }
	    |	    cdbp_event_stmt
    {
	$$  = $1;
    }
;

cdbp_ctrlstmt:	    cdbp_ifstmt
	    |	    cdbp_whilestmt
	    |	    cdbp_forstmt
	    |	    cdbp_return
	    |	    cdbp_retrow_stmt
	    |	    cdbp_repeatstmt
	    |	    cdbp_message
	    |	    cdbp_raise_error
	    |	    cdbp_endloop
;

cdbp_dmlstmt:	    cdbp_dml1stmt
    {
	DB_STATUS	status;
	PST_STATEMENT	*snode;

	/* Allocate statement node. */
	status = psl_init_dbp_stmt(cb, $Ydbpinfo, psq_cb->psq_mode, PST_QT_TYPE,
	    &snode, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	snode->pst_specific.pst_tree = $1;

	/*
	** unlike views, dbproc is deemed ungrantable only if there is some
	** object (a table, a view, or a database procedure) which requires some
	** privilege P to be accessed in the manner specified in the database
	** procedure, but the dbproc's owner does not posess P WGO on that
	** object.
	**
	**  03-oct-91 (andre)
	**	If we were reparsing a dbproc to determine if it is grantable
	**	(processing GRANT ON PROCEDURE), dopro() will detect lack of
	**	required privileges and return E_DB_ERROR, so this point would
	**	not be reached.
	*/

	/* All necessary inter stmt cleanup within the create procedure
	** statement should occur here. This includes range tables, YACC
	** variables defined in yyvars.h, fields in PSQ_CB and PSS_SESBLK.
	** This a pain but we can't wait until CREATE PROCEDURE is parsed,
	** since the individual statements should parse pretty much the same
	** way as they usually do. The only exceptions are generation of the
	** query tree (whether it includes statement and procedure nodes)
	** and opening of memory streams.
	*/

	/* Start out outside of all where clauses */
	cb->pss_qualdepth = 0;

	/* Start out assuming we're not doing a "define query" command */
	cb->pss_defqry = 0;

	/* Start out with no result range variable */
	cb->pss_resrng = (PSS_RNGTAB *) NULL;

	/* Start out with no result domains */
	cb->pss_rsdmno = 0;

	/* Start out with no target list */
	cb->pss_tlist = (PST_QNODE *) NULL;

	/* Start out with no repeat query parameters */
	cb->pss_highparm = -1;
	cb->pss_targparm = -1;

	/* Start out with no cursor */
	cb->pss_crsr = (PSC_CURBLK *) NULL;

	/* Start out with no result range variable */
	cb->pss_resrng = NULL;

	/*
	** turn off all bits in pss_stmt_flags except for PSS_TXTEMIT which
	** would be set if this is a new procedure
	** 3/25/91 (andre)
	**	PSS_DISREGARD_GROUP_ROLE_PERMS must also stay set
	*/
	cb->pss_stmt_flags &=
	    (PSS_TXTEMIT | PSS_DISREGARD_GROUP_ROLE_PERMS);

	/* reset all bits in pss_flattening_flags */
	cb->pss_flattening_flags = 0;

	/* Initialize the PST_RESTAB struct contents */
	MEfill(sizeof (PST_RESTAB), (u_char) 0,
	    (PTR) &cb->pss_restab);
	MEfill(sizeof (DB_TAB_NAME), (u_char) ' ',
	    (PTR) &cb->pss_restab.pst_resname);
	MEfill(sizeof (DB_OWN_NAME), (u_char) ' ',
	    (PTR) &cb->pss_restab.pst_resown);
	MEfill(sizeof (DM_DATA), (u_char) 0,
	    (PTR) &cb->pss_restab.pst_resloc);
	cb->pss_restab.pst_resvno = -1;

	/* No rules for tree */
	cb->pss_row_lvl_usr_rules  =
	cb->pss_row_lvl_sys_rules  =
	cb->pss_stmt_lvl_usr_rules =
	cb->pss_stmt_lvl_sys_rules =
	cb->pss_row_lvl_usr_before_rules  =
	cb->pss_row_lvl_sys_before_rules  =
	cb->pss_stmt_lvl_usr_before_rules =
	cb->pss_stmt_lvl_sys_before_rules = (PST_STATEMENT *) NULL;

	psl_yinit(cb);

	status = pst_clrrng(cb, &cb->pss_auxrng, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** init AGG list stack for scope 0 (node that the scope, pss_qualdepth,
	** has been set to 0 above)
	*/
	*$Yagg_list_stack = (YYAGG_NODE_PTR *) NULL;
	$Ywith_journaling = 0;
	$Ywith_location	= 0;
	$Ywith_dups	= PST_DNTCAREDUPS;
	$Yis_heapsort	= 0;
	$Yin_target_clause = FALSE;
	$Yindex_struct_specified = 0;
	$Yindx_struct	= cb->pss_idxstruct;
	$Ysort_list	= 0;
	$Ysort_by	= 0;
	$Yagg_func	= 0;
	$Yaggr_allowed	= (PSS_AGG_ALLOWED | PSS_STMT_AGG_ALLOWED);
	$Ylist_clause	= 0;
	(VOID)MEfill(sizeof($Yfe_cursor_id), (u_char)0, (PTR)&$Yfe_cursor_id);
	$Yqp_shareable	= TRUE;
	MEfill(sizeof(PST_J_MASK), 0, (char *)&$Yflists[0]);
	$Yqry_mask      = 0L;
	$Ynonupdt	= FALSE;
	$Ynonupdt_reason = 0;

	$$ = snode;
    }
;

cdbp_dml1stmt:	    query
	    |	    insert
    {
	if ($Ydbpinfo->pss_flags & PSS_INFORQ)
	{
	    /* error - can only have query in for loop header */
	    i4		err_code;
	    (VOID) psf_error(2443L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	/* set on in the "insertkwd" production. */
	$Ydbpinfo->pss_flags &= ~PSS_1SUB_SEEN;
	cb->pss_dbp_flags |= PSS_DATA_CHANGE;
    }
	    |	    delete
    {
	if ($Ydbpinfo->pss_flags & PSS_INFORQ)
	{
	    /* error - can only have query in for loop header */
	    i4		err_code;
	    (VOID) psf_error(2443L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	/* set on in the "delstmnt" production. */
	$Ydbpinfo->pss_flags &= ~PSS_1SUB_SEEN;
	cb->pss_dbp_flags |= PSS_DATA_CHANGE;
    }
	    |	    update
    {
	if ($Ydbpinfo->pss_flags & PSS_INFORQ)
	{
	    /* error - can only have query in for loop header */
	    i4		err_code;
	    (VOID) psf_error(2443L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	/* set on in the "updatekwd" production. */
	$Ydbpinfo->pss_flags &= ~PSS_1SUB_SEEN;
	cb->pss_dbp_flags |= PSS_DATA_CHANGE;
    }
;

cdbp_txstmt:	    COMMIT work
    {
	PST_STATEMENT	*snode;
	DB_STATUS	status;

	/* Allocate statement node. */
	status = psl_init_dbp_stmt(cb, $Ydbpinfo, psq_cb->psq_mode = PSQ_COMMIT,
	    PST_CMT_TYPE, &snode, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$$ = snode;
    }
	    |	    ROLLBACK work
    {
	PST_STATEMENT	*snode;
	DB_STATUS	status;

	/* Allocate statement node. */
	status = psl_init_dbp_stmt(cb, $Ydbpinfo,
	    psq_cb->psq_mode = PSQ_ROLLBACK, PST_RBK_TYPE, &snode,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$$ = snode;
    }
;

cdbp_ifstmt:	    cdbp_ifkwd boolean_expr cdbp_thenkwd
		    cdbp_stmtlist cdbp_elsepart ENDIF
    {
	/* Processing of the IF statement will be done
	** using following scheme:
	**
	**  IF (c1) THEN	    IF (c1) THEN
	**	s1			s1
	**  ELSEIF (c2) THEN	    ELSE
	**	s2			IF (c2) THEN
	**  ELSEIF (c3) THEN	=	    s2
	**	s3			ELSE
	**  ELSE			    IF (c3) THEN
	**	s4				s3
	**  ENDIF			    ELSE
	**					s4
	**				    ENDIF
	**				ENDIF
	**			    ENDIF
	*/

	/* wrap up processing of the IF statement */
	psl_ifstmt($1, $2->pss_tree, $4, $5, $Ydbpinfo);

	$$ = $1;
    }
;

cdbp_ifkwd:	    IF
    {
	DB_STATUS	status;

	status = psl_ifkwd(cb, psq_cb, $Ydbpinfo, &$$);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    }
;

cdbp_thenkwd:	    THEN
    {
	psl_thenkwd($Ydbpinfo);
    }
;

cdbp_elsekwd:	    ELSE
    {
	psl_elsekwd($Ydbpinfo);
    }
;

cdbp_elsepart:	    cdbp_elsekwd cdbp_stmtlist
    {
	$$ = $2;
    }
	    |	    cdbp_elseifpart cdbp_elsekwd cdbp_stmtlist
    {
	PST_STATEMENT	*stmt;

	/* The ELSE part of last stmt in the elseifpart IF chain
	** takes on $3.
	*/
	for (stmt = $1;
	     stmt->pst_specific.pst_if.pst_false != (PST_STATEMENT *) NULL;
	     stmt = stmt->pst_specific.pst_if.pst_false
	    )
	{
	    /* Nothing to do */
	}

	stmt->pst_specific.pst_if.pst_false = $3;

	$$ = $1;
    }
	    |	    cdbp_elseifpart
    {
	$$ = $1;
    }
	    |
    {
	$$ = (PST_STATEMENT *) NULL;
    }
;

cdbp_elseifpart:    cdbp_elseif
    {
	$$ = $1;
    }
	    |	    cdbp_elseifpart cdbp_elseif
    {
	PST_STATEMENT	*stmt;

	/* The ELSE part of last stmt in the cdbp_elseifpart IF chain
	** takes on $2.
	*/
	for (stmt = $1;
	     stmt->pst_specific.pst_if.pst_false != (PST_STATEMENT *) NULL;
	     stmt = stmt->pst_specific.pst_if.pst_false
	    )
	{
	    /* Nothing to do */
	}

	stmt->pst_specific.pst_if.pst_false = $2;

	$$ = $1;
    }
;

cdbp_elseif:    cdbp_elseifkwd boolean_expr cdbp_thenkwd cdbp_stmtlist
    {
	$1->pst_specific.pst_if.pst_condition = $2->pss_tree;
	$1->pst_specific.pst_if.pst_true = $4;

	$$ = $1;
    }
;

cdbp_elseifkwd:	    ELSEIF
    {
	DB_STATUS	status;

	status = psl_ifkwd(cb, psq_cb, $Ydbpinfo, &$$);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    }
;

cdbp_forstmt:	    cdbp_forinit cdbp_dmlstmt cdbp_dokwd 
		    cdbp_stmtlist cdbp_endfor
    {
	DB_STATUS	status;
	PST_STATEMENT	*ifstmtp;

	if ($2 == NULL)
	{
	    /* error - no select stmt */
	    i4		err_code;
	    (VOID) psf_error(2443L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* Re-link so for->query->if->stmtlist */
	ifstmtp = $1->pst_specific.pst_for.pst_forhead;
	$1->pst_specific.pst_for.pst_forhead = $2;
	$2->pst_next = ifstmtp;
	ifstmtp->pst_specific.pst_if.pst_true = $4;
	ifstmtp->pst_next = $4;
	/* Fill in "if" condition to test iirowcount > 0 */
	status = psl_for_cond(cb, psq_cb, $Ydbpinfo,
		&ifstmtp->pst_specific.pst_if.pst_condition);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	((PSS_LOOP  *)$1->pst_opf)->pss_out = TRUE;

	/* Now, loop down the contained stmtlist, looking for the last one
	** which then must be attached to the QTREE of the select query.
	*/
	/* {
	    PST_STATEMENT	*snode;
	
	    for (snode = $4; snode && snode->pst_next; snode = snode->pst_next);
	    if (snode) snode->pst_next = $2;
	} */

	/*
	** pss_patch must now contain address of NULL , so that a correct
	** pointer gets updated should we encounter an ENDLOOP immediately
	** following FOR loop.
	*/
	$Ydbpinfo->pss_patch = (PST_STATEMENT **) NULL;

	$$ = $1;
    }
;

cdbp_forinit:	    cdbp_forlabel FOR
    {
	PSS_LOOP 	*fnode;
	DB_STATUS	status;
	char		label[DB_MAXNAME];

	if (FALSE && $Ydbpinfo->pss_flags & PSS_INFOR)
	{
	    /* error - no nested for's */
	    i4		err_code;
	    (VOID) psf_error(2444L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	if ($1 != (char *) NULL)
	{
	    bool		found = FALSE;
	    i4			err_code;

	    STmove($1, ' ', DB_MAXNAME, (char *) label);

	    /* Check if label specified for the first time. */
	    for (fnode = (PSS_LOOP  *) $Ydbpinfo->pss_loopq.q_next;
		 fnode != (PSS_LOOP  *) &$Ydbpinfo->pss_loopq;
		 fnode = (PSS_LOOP  *) fnode->pss_queue.q_next
		)
	    {
		/* Don't look at loops out of scope */
		if (fnode->pss_out == TRUE)
		    continue;

		if (MEcmp((PTR) label, (PTR) fnode->pss_label,
		    DB_MAXNAME) == 0
		   )
		{
		    found = TRUE;
		    break;
		}
	    }

	    if (found)
	    {
		/* Found a duplicate label */
		(VOID) psf_error(2406L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1, STlength($1), $1);
		return (E_DB_ERROR);
	    }
	}

	/* Allocate for node. */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(PSS_LOOP ),
	    (PTR *) &fnode, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	fnode->pss_out = FALSE;
	(VOID) QUinit(&fnode->pss_fixq);

	/* Fill in the name */
	if ($1 != (char *) NULL)
	{
	    (VOID) MEcopy((PTR) label, DB_MAXNAME, (PTR) fnode->pss_label);
	}
	else
	{
	    (VOID) MEfill(DB_MAXNAME, (u_char) ' ', (PTR) fnode->pss_label);
	}

	/* Attach element to the list, last one will be at the queue head. */
	(VOID) QUinsert((QUEUE *) fnode, &$Ydbpinfo->pss_loopq);

	/* Allocate FOR statement node. */
	status = psl_init_dbp_stmt(cb, $Ydbpinfo, PSQ_FOR, PST_FOR_TYPE,
	    &fnode->pss_stmt, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	fnode->pss_stmt->pst_opf = (PTR) fnode;

	/* Allocate FOR statement's IF node. */
	status = psl_init_dbp_stmt(cb, $Ydbpinfo, PSQ_FOR, PST_IF_TYPE,
	    &fnode->pss_stmt->pst_specific.pst_for.pst_forhead, 
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$Ydbpinfo->pss_flags |= PSS_INCOND;

	/*
	** The FOR statement is internally implemented
	** as a FOR node, followed by the qtree for the select, followed by
	** an IF to test for rows returned. The FOR and IF are allocated and
	** linked here. The QTREE for the select is linked in between in 
	** cdbp_forstmt. 
	*/
	psq_cb->psq_mode = PSQ_FOR;

	$$ = fnode->pss_stmt;
	$Ydbpinfo->pss_flags |= (PSS_INFOR | PSS_INFORQ);
    }
;

cdbp_forlabel:	    generic_ident COLON
    {
	$$ = $1;
    }
		|
    {
	$$ = (char *) NULL;
    }
;

cdbp_endfor:	    ENDFOR
    {
	$Ydbpinfo->pss_inloop--;
	$Ydbpinfo->pss_flags &= ~PSS_INFOR;
    }
;

cdbp_whilestmt:	    cdbp_whileinit boolean_expr cdbp_dokwd
		    cdbp_stmtlist cdbp_endwhile
    {
	$1->pst_specific.pst_if.pst_condition = $2->pss_tree;
	$1->pst_specific.pst_if.pst_true = $4;

	((PSS_LOOP  *)$1->pst_opf)->pss_out = TRUE;

	/*
	** pss_patch must now contain address of NULL , so that a correct
	** pointer gets updated should we encounter an ENDLOOP immediately
	** following WHILE...ENDWHILE
	*/
	$Ydbpinfo->pss_patch = (PST_STATEMENT **) NULL;

	$$ = $1;
    }
;

cdbp_while_label:   generic_ident COLON
    {
	$$ = $1;
    }
		|
    {
	$$ = (char *) NULL;
    }
;

cdbp_whileinit:	    cdbp_while_label WHILE
    {
	PSS_LOOP 	*wnode;
	DB_STATUS	status;
	char		label[DB_MAXNAME];

	if ($1 != (char *) NULL)
	{
	    bool		found = FALSE;
	    i4		err_code;

	    STmove($1, ' ', DB_MAXNAME, (char *) label);

	    /* Check if label specified for the first time. */
	    for (wnode = (PSS_LOOP  *) $Ydbpinfo->pss_loopq.q_next;
		 wnode != (PSS_LOOP  *) &$Ydbpinfo->pss_loopq;
		 wnode = (PSS_LOOP  *) wnode->pss_queue.q_next
		)
	    {
		/* Don't look at WHILEs out of scope */
		if (wnode->pss_out == TRUE)
		    continue;

		if (MEcmp((PTR) label, (PTR) wnode->pss_label,
		    DB_MAXNAME) == 0
		   )
		{
		    found = TRUE;
		    break;
		}
	    }

	    if (found)
	    {
		/* Found a duplicate label */
		(VOID) psf_error(2406L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1, STlength($1), $1);
		return (E_DB_ERROR);
	    }
	}

	/* Allocate while node. */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(PSS_LOOP),
	    (PTR *) &wnode, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	wnode->pss_out = FALSE;
	(VOID) QUinit(&wnode->pss_fixq);

	/* Fill in the name */
	if ($1 != (char *) NULL)
	{
	    (VOID) MEcopy((PTR) label, DB_MAXNAME, (PTR) wnode->pss_label);
	}
	else
	{
	    (VOID) MEfill(DB_MAXNAME, (u_char) ' ', (PTR) wnode->pss_label);
	}

	/* Attach element to the list, last one will be at the queue head. */
	(VOID) QUinsert((QUEUE *) wnode, &$Ydbpinfo->pss_loopq);

	/* Allocate statement node. */
	status = psl_init_dbp_stmt(cb, $Ydbpinfo, PSQ_IF, PST_WH_TYPE,
	    &wnode->pss_stmt, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	wnode->pss_stmt->pst_opf = (PTR) wnode;

	$Ydbpinfo->pss_flags |= PSS_INCOND;

	/*
	** The WHILE statement is internally implemented
	** as the IF statement, but let's indicate WHILE
	** for proper display of syntax errors.
	*/
	psq_cb->psq_mode = PSQ_WHILE;

	$$ = wnode->pss_stmt;
    }
;

cdbp_dokwd:	    DO
    {
	$Ydbpinfo->pss_flags &= ~(PSS_INCOND | PSS_INFORQ);
	$Ydbpinfo->pss_inloop++;
    }
;

cdbp_endwhile:	    ENDWHILE
    {
	$Ydbpinfo->pss_inloop--;
    }
;

/*
** 06-feb-91 (andre)
**	we may generate a statement block for endloop if it occured immediately
**	following IF...ENDIF (dbpinfo->pss_patch will be set to NULL)
*/
cdbp_endloop:	    cdbp_endloopkwd
    {
	psq_cb->psq_mode = PSQ_ENDLOOP;
    }
		    cdbp_label
    {
	PST_STATEMENT	*snode;
	i4		err_code;

	if ($Ydbpinfo->pss_inloop == 0)
	{
	    /* ENDLOOP only allowed in a WHILE. */
	    (VOID) psf_error(2426L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** if this statement is unreachable, avoid creating a fix block, and
	** here's why:
	**	Consider:
	**		a: WHILE <condition> DO
	**			...
	**			b: WHILE <condition> DO
	**				...
	**				IF <condition> THEN
	**				    ...
	**				ENDIF
	**				ENDLOOP a;
	**				** I know it doesn't make much sense,
	**				** but that is not to say that we should
	**				** not be able to handle it
	**				**
	**				ENDLOOP b;  
	**				...
	**			ENDWHILE;
	**		    ENDWHILE;
	**		    ...
	**  In this case, if we do not avoid creating a FIX block for the second
	**  ENDLOOP, pst_next in ENDLOOP statement node will be initialized
	**  before processing the body of the first WHILE (as it should be), but
	**  then it will be overwritten before processing the body of the second
	**  WHILE, so that instead of exiting the outer loop, we will simply
	**  exit the inner loop.  A similar example could be constructed with
	**  the two ENDLOOP statements switched if they follow a statement other
	**  then IF...ENDIF.  In that case, rather than exiting the inner loop,
	**  we will exit the outer loop.
	*/
	if ($Ydbpinfo->pss_unreachable_stmt_lvl != 0)
	{
	    snode = (PST_STATEMENT *) NULL;
	}
	else
	{
	    DB_STATUS	status;
	    PSS_LOOP 	*wnode, *wlast;
	    bool	found = FALSE;
	    PSS_FIXSTMT	*fix;
	    char	label[DB_MAXNAME];

	    if ($3)
	    {
		STmove($3, ' ', DB_MAXNAME, (char *) label);
	    }

	    for (wnode = (PSS_LOOP  *) $Ydbpinfo->pss_loopq.q_next,
		 wlast = (PSS_LOOP  *) &$Ydbpinfo->pss_loopq;
		 
		 wnode != wlast;

		 wnode = (PSS_LOOP  *) wnode->pss_queue.q_next
		)
	    {
		/* Don't look at WHILEs out of scope */
		if (wnode->pss_out == TRUE)
		    continue;

		/* If ENDLOOP specified label, compare names
		** otherwise the first WHILE is good enough.
		*/
		if ($3)
		{
		    if (MEcmp((PTR) label, (PTR) wnode->pss_label,
			DB_MAXNAME) == 0
		       )
		    {
			found = TRUE;
			break;
		    }
		}
		else
		{
		    found = TRUE;
		    break;
		}
	    }

	    if (!found)
	    {
		/* ENDLOOP doesn't have a matching WHILE or
		** label is undeclared.
		*/
		if ($3)
		{
		    (VOID) psf_error(2407L, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 1,
			STlength($3), $3);
		}
		else
		{
		    /*  This code should probably 
		    ** never be reached.
		    */
		    (VOID) psf_error(E_PS0B06_NOWHILE, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 0);
		}
		return (E_DB_ERROR);
	    }

	    /*
	    ** note that psl_init_dbp_stmt() may choose to not allocate a new
	    ** statement block, in which case snode will be set to NULL
	    */
	    status = psl_init_dbp_stmt(cb, $Ydbpinfo, psq_cb->psq_mode,
		PST_ENDLOOP_TYPE, &snode, &psq_cb->psq_error);

	    /* Allocate fix statement node. */
	    status = psf_malloc(cb, &cb->pss_ostream, sizeof(PSS_FIXSTMT),
		(PTR *) &fix, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);

	    fix->pss_flags = 0;

	    /*
	    ** if psl_init_dbp_stmt() alocated a statement node, we must
	    ** remember to fix it before the body of the WHILE statement is
	    ** processed
	    */

	    if (snode != (PST_STATEMENT *) NULL)
	    {
		fix->pss_flags |= PSS_FIX_EARLY;
	    }

	    /* Remember location to be fixed */
	    fix->pss_stmt_ptr = $Ydbpinfo->pss_patch;

	    /*
	    ** Attach element to the list, last one will be at the queue head.
	    */
	    (VOID) QUinsert((QUEUE *) fix, &wnode->pss_fixq);
	}

	/* snode will point at a statement block, if one was allocated */
	$$ = snode;
    }
;

cdbp_endloopkwd:    ENDLOOP
	    |	    LEAVE
;

cdbp_repeatstmt:   cdbp_repinit cdbp_stmtlist cdbp_untkwd 
		    boolean_expr cdbp_endrep
    {
	$1->pst_specific.pst_if.pst_condition = $4->pss_tree;
	$1->pst_specific.pst_if.pst_true = $2;

	((PSS_LOOP  *)$1->pst_opf)->pss_out = TRUE;
	$$ = $2;

	/*
	** pss_patch must now contain address of NULL , so that a correct
	** pointer gets updated should we encounter an ENDLOOP immediately
	** following REPEAT ... UNTIL ...
	*/
	/* Except, until I figure that stuff out, pss_patch will address 
	** the training "if"s pst_false. The pst_false will eventually have
	** to address the statement following the "repeat".
	*/
	$Ydbpinfo->pss_patch = &$1->pst_specific.pst_if.pst_false;

	/* Now, loop down the contained stmtlist, looking for the last one
	** which then must be attached to the trailing "if".
	*/
	{
	    PST_STATEMENT	*snode;
	
	    for (snode = $2; snode && snode->pst_next; snode = snode->pst_next);
	    if (snode) snode->pst_next = $1;
	    else $$ = NULL;
	}
    }
;

cdbp_repinit:	    cdbp_replabel REPEAT
    {
	PSS_LOOP 	*rnode;
	DB_STATUS	status;
	char		label[DB_MAXNAME];

	if ($1 != (char *) NULL)
	{
	    bool		found = FALSE;
	    i4			err_code;

	    STmove($1, ' ', DB_MAXNAME, (char *) label);

	    /* Check if label specified for the first time. */
	    for (rnode = (PSS_LOOP  *) $Ydbpinfo->pss_loopq.q_next;
		 rnode != (PSS_LOOP  *) &$Ydbpinfo->pss_loopq;
		 rnode = (PSS_LOOP  *) rnode->pss_queue.q_next
		)
	    {
		/* Don't look at loops out of scope */
		if (rnode->pss_out == TRUE)
		    continue;

		if (MEcmp((PTR) label, (PTR) rnode->pss_label,
		    DB_MAXNAME) == 0
		   )
		{
		    found = TRUE;
		    break;
		}
	    }

	    if (found)
	    {
		/* Found a duplicate label */
		(VOID) psf_error(2406L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1, STlength($1), $1);
		return (E_DB_ERROR);
	    }
	}

	/* Allocate repeat node. */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(PSS_LOOP ),
	    (PTR *) &rnode, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	rnode->pss_out = FALSE;
	(VOID) QUinit(&rnode->pss_fixq);

	/* Fill in the name */
	if ($1 != (char *) NULL)
	{
	    (VOID) MEcopy((PTR) label, DB_MAXNAME, (PTR) rnode->pss_label);
	}
	else
	{
	    (VOID) MEfill(DB_MAXNAME, (u_char) ' ', (PTR) rnode->pss_label);
	}

	/* Attach element to the list, last one will be at the queue head. */
	(VOID) QUinsert((QUEUE *) rnode, &$Ydbpinfo->pss_loopq);

	/* Allocate statement node. */
	status = psl_init_dbp_stmt(cb, $Ydbpinfo, PSQ_IF, PST_RP_TYPE,
	    &rnode->pss_stmt, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	rnode->pss_stmt->pst_opf = (PTR) rnode;

	$Ydbpinfo->pss_flags |= PSS_INCOND;

	/*
	** The REPEAT statement is internally implemented
	** as the IF statement, but let's indicate REPEAT
	** for proper display of syntax errors.
	*/
	psq_cb->psq_mode = PSQ_REPEAT;

	$$ = rnode->pss_stmt;
    }
;

cdbp_replabel:	    generic_ident COLON
    {
	$$ = $1;
    }
		|
    {
	$$ = (char *) NULL;
    }
;

cdbp_untkwd:	    UNTIL
    {
	$Ydbpinfo->pss_flags |= PSS_INCOND;
    }
;

cdbp_endrep:	    ENDREPEAT
    {
	$Ydbpinfo->pss_flags &= ~PSS_INCOND;
	$Ydbpinfo->pss_inloop--;
    }
;

cdbp_label:	    generic_ident
    {
	$$ = $1;
    }
	    |
    {
	$$ = (char *) NULL;
    }
;

/* FIXME int2_int4_int8 here? */
cdbp_retval:	    int2_int4
    {
	DB_STATUS	status;
	PST_CNST_NODE	cconst;
	PST_QNODE	*newnode;
	i4		intnum;

	intnum = (i4) $1;

	/* Non-parameter number constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), DB_INT_TYPE, (i2) 0, (i4) 4, 
	    (DB_ANYTYPE *) &intnum, &newnode, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	$$ = newnode;
    }
	    |	    cdbp_parmlvar
    {
	i4		err_code;
	i4		errnum = 0L;

	if ($1->pst_sym.pst_dataval.db_datatype < 0)
	{
	    /* Datatype must be non-nullable */
	    errnum = 2421L;
	}
	else if ($1->pst_sym.pst_dataval.db_datatype != DB_INT_TYPE)
	{
	    /* Type of $1 must be integer */
	    errnum = 2424L;
	}

	if (errnum)
	{
	    (VOID) psf_error(errnum, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	$$ = $1;
    }
	    |	    generic_ident
    {
	DB_STATUS	    status;
	PST_CNST_NODE	    cconst;
	PST_QNODE	    *newnode;
	DB_PARM_NAME	    varname;
	bool		    found = FALSE;
	i4		    err_code;
	register PSS_DECVAR *var;

	STmove($1, ' ', DB_MAXNAME, varname.db_parm_name);

	/* Find local var/parm by the specified name. */
	for (var = (PSS_DECVAR *) $Ydbpinfo->pss_varq.q_next;
	     var != (PSS_DECVAR *) &$Ydbpinfo->pss_varq;
	     var = (PSS_DECVAR *) var->pss_queue.q_next
	    )
	{
	    if (var->pss_out)
		continue;
	    if (MEcmp((PTR) &varname, (PTR) &var->pss_varname,
		sizeof(var->pss_varname)) == 0
	       )
	    {
		found = TRUE;
		break;
	    }
	}

	if (!found)
	{
	    /* Unknown local variable or parm spec'd. */
	    (VOID) psf_error(2403L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, STlength($1), $1);
	    return (E_DB_ERROR);
	}

	if (var->pss_dbdata.db_datatype < 0)
	{
	    /* Datatype must be non-nullable */
	    (VOID) psf_error(2421L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* Type of var must be integer */
	if (var->pss_dbdata.db_datatype != DB_INT_TYPE)
	{
	    (VOID) psf_error(2424L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* Parm or local variable */
	cconst.pst_tparmtype = PST_LOCALVARNO;
	cconst.pst_parm_no = var->pss_no;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), var->pss_dbdata.db_datatype,
	    (i2) var->pss_dbdata.db_prec, (i4) var->pss_dbdata.db_length, 
	    (DB_ANYTYPE *) var->pss_dbdata.db_data, &newnode,
	    &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$$ = newnode;
    }
	    |
    {
	$$ = (PST_QNODE *) NULL;
    }
;

cdbp_return:	    RETURN
    {
	/* For proper display of syntax errors. */
	psq_cb->psq_mode = PSQ_RETURN;
    }
		    cdbp_retval
    {
	PST_STATEMENT	*snode;
	DB_STATUS	status;

	/* Allocate statement node. */
	status = psl_init_dbp_stmt(cb, $Ydbpinfo, psq_cb->psq_mode,
	    PST_RTN_TYPE, &snode, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	snode->pst_specific.pst_rtn.pst_rtn_value = $3;

	$$ = snode;
    }
;

cdbp_retrow_stmt:   RETURN ROW cdbp_retrow_spec1 cdbp_retrow_spec2
    {
	DB_STATUS           status;
	PST_QNODE	    *resdomp, *qlend;
	PST_QNODE	    *rootnode;
	PST_RT_NODE	    root;
	i4		    err_code;
	PST_QTREE	    *tree;
	PST_PROCEDURE	    *pnode;
	PST_STATEMENT	    *snode;

	for (resdomp = $3; 
	    resdomp && resdomp->pst_sym.pst_type == PST_RESDOM;
	    resdomp = resdomp->pst_left)
	 if (resdomp->pst_right == (PST_QNODE *) NULL)
	{
	    /* Fewer entries in "return row" clause than "result row". */
	    (VOID) psf_error(2446L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* Create a QLEND node */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_QLEND, (PTR) NULL, 0, DB_NODT, (i2) 0,
	    (i4) 0, (DB_ANYTYPE *) NULL, &qlend, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Create the ROOT node */
	root.pst_rtuser = TRUE;
	root.pst_union.pst_next  = 0;
	root.pst_dups   = PST_ALLDUPS;
	root.pst_tvrc   = 0;
	MEfill(sizeof(PST_J_MASK), 0, (char *)&root.pst_tvrm);

	resdomp = $3;
	status = pst_node(cb, &cb->pss_ostream, resdomp, qlend, PST_ROOT,
	    (PTR) &root, sizeof(PST_RT_NODE), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &rootnode, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Create the query tree header */
	status = pst_header(cb, psq_cb, PST_UNSPECIFIED, (PST_QNODE *) NULL,
	    rootnode, &tree, &pnode, ($Yisdbp) ? 0 : PST_0FULL_HEADER, 
	    &$Yxlated_qry);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** set pst_numjoins.  $Yjoin_id contains the highest join id, in this
	** case, 0.
	*/
	tree->pst_numjoins = $Yjoin_id;

	/* No need to set root here */

	/* Allocate statement node. */
	status = psl_init_dbp_stmt(cb, $Ydbpinfo, psq_cb->psq_mode, PST_QT_TYPE,
	    &snode, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	snode->pst_specific.pst_tree = tree;
	snode->pst_after_stmt = NULL;

	$$ = snode;
    }
;

cdbp_retrow_spec1:  LPAREN 
    {
	PSS_DECVAR	*var;
	QUEUE		*varq;
	PST_QNODE	*resdomp;
	PST_QNODE	*node;
	DB_STATUS	status;
	i4		err_code;
	char		colname[DB_MAXNAME + 2];

	if ($Ydbpinfo->pss_resrowno <= 0)
	{
	    /* Must be a "result row" declaration to use "return row" */
	    (VOID) psf_error(2445L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	$Yaggr_allowed &= ~(PSS_AGG_ALLOWED | PSS_STMT_AGG_ALLOWED);
	psq_cb->psq_mode = PSQ_RETROW;
	
	/* Pre-allocate resdoms for each column in result row definition.
	** NOTE: we go backwards through the list to build RESDOMs in
	** expected sequence. */
	varq = &($Ydbpinfo->pss_resrowq);
	for (var = (PSS_DECVAR *)varq->q_prev, resdomp = (PST_QNODE *)NULL;
		var != (PSS_DECVAR *)varq;
		var = (PSS_DECVAR *)var->pss_queue.q_prev)
	{
	    status = pst_adresdom((char *)&var->pss_varname, 
		resdomp, (PST_QNODE *) NULL, cb, psq_cb, &resdomp);
	    if (DB_FAILURE_MACRO(status)) return(status);
	
	    resdomp->pst_sym.pst_value.pst_s_rsdm.pst_rsno = var->pss_no;
	    resdomp->pst_sym.pst_value.pst_s_rsdm.pst_ntargno = var->pss_no;
	    resdomp->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype = PST_RESROW_COL;
	    STRUCT_ASSIGN_MACRO(var->pss_dbdata, resdomp->pst_sym.pst_dataval);
	    STprintf(colname, "result element%d",
		    resdomp->pst_sym.pst_value.pst_s_rsdm.pst_rsno);
	    MEmove(STlength(colname), (PTR)colname, ' ',
		    DB_MAXNAME,
		    (PTR) resdomp->pst_sym.pst_value.pst_s_rsdm.pst_rsname); 
	}

	$Yresdmhd = resdomp;		/* save head of chain */

	/* Find the leftmost node in the tree */
	for (node = resdomp; node->pst_left != (PST_QNODE *) NULL; )
	{
	    node = node->pst_left;
	}

	/* Allocate the PST_TREE node */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_TREE, (PTR) NULL, 0, DB_NODT, (i2) 0,
	    (i4) 0, (DB_ANYTYPE *) NULL, &node->pst_left, &psq_cb->psq_error,
	    (i4) 0);
	if (DB_FAILURE_MACRO(status)) return(status);

	$$ = resdomp;
    }
;

cdbp_retrow_spec2:  invallist RPAREN
    {
    }
;

cdbp_message:	    cdbp_msgkwd cdbp_mesparm cdbp_mesparm cdbp_meswith
    {
	PST_STATEMENT	*snode;
	DB_DT_ID	dtype1, dtype2;
	i4		err_code;

	dtype1 = $2->pst_sym.pst_dataval.db_datatype;
	dtype2 = $3->pst_sym.pst_dataval.db_datatype;

	if (dtype1 < 0 || dtype2 < 0)
	{
	    /* Datatype must be non-nullable */
	    (VOID) psf_error(2422L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* Type of $2 must be integer (msg no.) */
	/* Type of $3 must be character (msg text) */
	if (dtype1 != DB_INT_TYPE)
	{
	    (VOID) psf_error(2408L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	if (dtype2 != DB_CHR_TYPE && dtype2 != DB_TXT_TYPE &&
	    dtype2 != DB_CHA_TYPE && dtype2 != DB_VCH_TYPE &&
	    dtype2 != DB_NCHR_TYPE && dtype2 != DB_NVCHR_TYPE
	   )
	{
	    (VOID) psf_error(2409L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** $Ydbpinfo->pss_last_stmt points to the last statement block allocated
	** for the dbproc
	*/
	snode = $Ydbpinfo->pss_last_stmt;

	snode->pst_specific.pst_msg.pst_msgnumber = $2;
	snode->pst_specific.pst_msg.pst_msgtext = $3;

	$$ = snode;
    }
	    |	    cdbp_msgkwd cdbp_mesparm cdbp_meswith
    {
	PST_STATEMENT	*snode;
	DB_DT_ID	dtype;
	i4		err_code;

	dtype = $2->pst_sym.pst_dataval.db_datatype;

	if (dtype < 0)
	{
	    /* Datatype must be non-nullable */
	    (VOID) psf_error(2422L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** $Ydbpinfo->pss_last_stmt points to the last statement block allocated
	** for the dbproc
	*/
	snode = $Ydbpinfo->pss_last_stmt;

	/* If type of $2 is integer we have msg no.
	** if character msg text.
	*/
	if (dtype == DB_INT_TYPE)
	{
	    snode->pst_specific.pst_msg.pst_msgnumber = $2;
	    snode->pst_specific.pst_msg.pst_msgtext = (PST_QNODE *) NULL;
	}
	else if (dtype == DB_CHR_TYPE || dtype == DB_TXT_TYPE ||
		 dtype == DB_CHA_TYPE || dtype == DB_VCH_TYPE ||
		 dtype == DB_NCHR_TYPE || dtype == DB_NVCHR_TYPE
		)
	{
	    snode->pst_specific.pst_msg.pst_msgnumber = (PST_QNODE *) NULL;
	    snode->pst_specific.pst_msg.pst_msgtext = $2;
	}
	else
	{
	    (VOID) psf_error(2410L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	$$ = snode;
     }
;

cdbp_msgkwd:	    MESSAGE
    {
	DB_STATUS       status;
	PST_STATEMENT	*snode;

	/* For proper display of syntax errors. */
	psq_cb->psq_mode = PSQ_MESSAGE;

        /* Allocate statement node. */
        status = psl_init_dbp_stmt(cb, $Ydbpinfo, psq_cb->psq_mode,
            PST_MSG_TYPE, &snode, &psq_cb->psq_error);
        if (DB_FAILURE_MACRO(status))
            return (status);

	snode->pst_specific.pst_msg.pst_msgdest = 0;
	snode->pst_specific.pst_msg.pst_msgnumber = 0;
	snode->pst_specific.pst_msg.pst_msgtext = NULL;
    }
; 

/* FIXME int2_int4_int8 here */
cdbp_mesparm:	    int2_int4
    {
	DB_STATUS       status;
	PST_CNST_NODE	cconst;
	PST_QNODE	*new1;
	i4		intnum;

	intnum = (i4) $1;

	/* Non-parameter number constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), DB_INT_TYPE, (i2) 0, (i4) 4, 
	    (DB_ANYTYPE *) &intnum, &new1, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$$ = new1;
    }
	    |	    SCONST
    {
	DB_STATUS       status;
	PST_CNST_NODE	cconst;
	PST_QNODE	*new2;

	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), DB_VCH_TYPE, (i2) 0,
	    (i4) ($1->db_t_count + DB_CNTSIZE),
	    (DB_ANYTYPE *) $1, &new2, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$$ = new2;
    }
	    |	    cdbp_parmlvar
    {
	$$ = $1;
    }
	    |	    generic_ident
    {
	DB_STATUS       status;
	PST_CNST_NODE	cconst;
	PST_QNODE	*newnode;
	DB_PARM_NAME	varname;
	bool		found = FALSE;
	i4		err_code;
	register PSS_DECVAR *var;

	STmove($1, ' ', DB_MAXNAME, varname.db_parm_name);

	/* Find local var/parm by the specified name. */
	for (var = (PSS_DECVAR *) $Ydbpinfo->pss_varq.q_next;
	     var != (PSS_DECVAR *) &$Ydbpinfo->pss_varq;
	     var = (PSS_DECVAR *) var->pss_queue.q_next
	    )
	{
	    if (var->pss_out)
		continue;
	    if (MEcmp((PTR) &varname, (PTR) &var->pss_varname,
		sizeof(var->pss_varname)) == 0
	       )
	    {
		found = TRUE;
		break;
	    }
	}

	if (!found)
	{
	    /* Unknown local variable or parm spec'd. */
	    (VOID) psf_error(2403L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		STlength($1), $1);
	    return (E_DB_ERROR);
	}

	/* Parm or local variable */
	cconst.pst_tparmtype = PST_LOCALVARNO;
	cconst.pst_parm_no = var->pss_no;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), var->pss_dbdata.db_datatype,
	    (i2) var->pss_dbdata.db_prec, (i4) var->pss_dbdata.db_length, 
	    (DB_ANYTYPE *) var->pss_dbdata.db_data,
	    &newnode, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$$ = newnode;
    }
	    |	    LPAREN select_expr RPAREN
    {
	$$ = $2;
    }
;

cdbp_parmlvar:	    COLON generic_ident
    {
	DB_STATUS       status;
	PST_CNST_NODE	cconst;
	PST_QNODE	*newnode;
	DB_PARM_NAME	varname;
	bool		found = FALSE;
	i4		err_code;
	register PSS_DECVAR *var;

        if (psq_cb->psq_mode == PSQ_DDEXECPROC)
        {
	    /* execution of regproc; by pass parsing */
	    $$ = NULL;
	    break;
	}

	if ($Yisdbp == FALSE)
	{
	    /* Only allowed in DB procedures */
	    (VOID) psf_error(2414L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, STlength($2), $2);
	    return (E_DB_ERROR);	    
	}

	STmove($2, ' ', DB_MAXNAME, varname.db_parm_name);

	/* Find local var/parm by the specified name. */
	for (var = (PSS_DECVAR *) $Ydbpinfo->pss_varq.q_next;
	     var != (PSS_DECVAR *) &$Ydbpinfo->pss_varq;
	     var = (PSS_DECVAR *) var->pss_queue.q_next
	    )
	{
	    if (var->pss_out)
		continue;
	    if (MEcmp((PTR) &varname, (PTR) &var->pss_varname,
		sizeof(var->pss_varname)) == 0
	       )
	    {
		found = TRUE;
		break;
	    }
	}

	if (!found)
	{
	    /* Unknown local variable or parm spec'd. */
	    (VOID) psf_error(2403L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		STlength($2), $2);
	    return (E_DB_ERROR);
	}

	/* Parm or local variable */
	cconst.pst_tparmtype = PST_LOCALVARNO;
	cconst.pst_parm_no = var->pss_no;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), var->pss_dbdata.db_datatype,
	    (i2) var->pss_dbdata.db_prec, (i4) var->pss_dbdata.db_length, 
	    (DB_ANYTYPE *) var->pss_dbdata.db_data,
	    &newnode, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$$ = newnode;
    }
;

cdbp_meswith:	WITH cdbp_destkey EQUAL LPAREN cdbp_destlist RPAREN
	    |
;

cdbp_destlist:	cdbp_dest
	    |	cdbp_destlist COMMA cdbp_dest
;

cdbp_destkey:	nonkeyword
    {
        i4     err_code;

        if (STcasecmp($1, "DESTINATION"))
        {
            _VOID_ psf_error(6353L, 0L, PSF_USERERR, &err_code,
                &psq_cb->psq_error, 2,
                (i4) sizeof("MESSAGE/RAISE ERROR")-1,
		"MESSAGE/RAISE ERROR",
                (i4) STtrmwhite($1), $1);
            return (E_DB_ERROR);
        }
    }
;

cdbp_dest:	nonkeyword
    {
	/*
	** recall that $Ydbpinfo->pss_last_stmt points at the last allocated
	** dbproc statement block
	*/
	PST_STATEMENT	*snode = $Ydbpinfo->pss_last_stmt;
        i4		err_code;

	if (!STcasecmp($1, "ERROR_LOG"))
	{
	    snode->pst_specific.pst_msg.pst_msgdest |= DB_MSGLOG;
	}
	else if (!STcasecmp($1, "AUDIT_LOG"))
	{
	    snode->pst_specific.pst_msg.pst_msgdest |= DB_MSGAUDIT;
	}
	else
        {
            _VOID_ psf_error(6353L, 0L, PSF_USERERR, &err_code,
                &psq_cb->psq_error, 2,
                (i4) sizeof("MESSAGE/RAISE ERROR")-1,
		"MESSAGE/RAISE ERROR",
                (i4) STtrmwhite($1), $1);
            return (E_DB_ERROR);    /* non-zero return means error */
        }
    }
	|   SESSION
    {
	/*
	** recall that $Ydbpinfo->pss_last_stmt points at the last allocated
	** dbproc statement block
	*/
	PST_STATEMENT	*snode = $Ydbpinfo->pss_last_stmt;

	snode->pst_specific.pst_msg.pst_msgdest |= DB_MSGUSER;
    }
;

/*
** Yacc rule:  cdbp_raise_error	- Raise an error (for rule firing).
**
** Statement Syntax:
**	RAISE ERROR error_number [error_text]
**		[WITH DESTINATION = (<dest>,{<dest>})]
**
**	where <dest> is SESSION or ERROR_LOG.
**
** Return State:
**	PST_STATEMENT constructed (PST_EMSG_TYPE) with error number and text.
*/
cdbp_raise_error:	cdbp_rserr_kwd cdbp_mesparm cdbp_mesparm_2 cdbp_meswith
    {
	PST_STATEMENT	*snode;
	DB_DT_ID	dtype1, dtype2;
	i4		err_code;


        if (cb->pss_distrib & DB_3_DDB_SESS)
        {
            (VOID) psf_error(6350L, 0L, PSF_USERERR,
                &err_code, &psq_cb->psq_error, 1,
                (i4) sizeof("RAISE ERROR")-1, "RAISE ERROR");
            return (E_DB_ERROR);    /* non-zero return means error */
        }

	dtype1 = $2->pst_sym.pst_dataval.db_datatype;
	dtype2 = $3 != NULL ? $3->pst_sym.pst_dataval.db_datatype : 0;

	/* Data types must be non-nullable, 1st = integer, [2nd = string] */
	if (dtype1 < 0 || dtype2 < 0)	/* Datatype must be non-nullable */
	{
	    _VOID_ psf_error(E_US0985_2437_RSER_NUL, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	if (    dtype1 != DB_INT_TYPE 
	    || (   dtype2 != 0 && dtype2 != DB_CHR_TYPE && dtype2 != DB_TXT_TYPE
		&& dtype2 != DB_CHA_TYPE && dtype2 != DB_VCH_TYPE)
	   )
	{
	    _VOID_ psf_error(E_US0984_2436_RSER_TYPE, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** $Ydbpinfo->pss_last_stmt points at the last allocated dbproc
	** statement block
	*/
	snode = $Ydbpinfo->pss_last_stmt;

	snode->pst_specific.pst_msg.pst_msgnumber = $2;
	snode->pst_specific.pst_msg.pst_msgtext   = $3;

	$$ = snode;
     }
;

cdbp_rserr_kwd:	    RAISEERROR
    {
	DB_STATUS       status;
	PST_STATEMENT	*snode;

	/* For proper display of syntax errors */
	psq_cb->psq_mode = PSQ_RS_ERROR;

        /* Allocate statement node. */
        status = psl_init_dbp_stmt(cb, $Ydbpinfo, psq_cb->psq_mode,
            PST_EMSG_TYPE, &snode, &psq_cb->psq_error);
        if (DB_FAILURE_MACRO(status))
            return (status);

	snode->pst_specific.pst_msg.pst_msgdest = 0;
	snode->pst_specific.pst_msg.pst_msgnumber = 0;
	snode->pst_specific.pst_msg.pst_msgtext = NULL;
    }
; 

cdbp_mesparm_2:		cdbp_mesparm
    {
	$$ = $1;
    }
	|		/* No second parameter */
    {
	$$ = NULL;
    }
;

cdbp_assignstmt:    cdbp_lhs_asgn
    {
	$Ydbpinfo->pss_flags |= PSS_INCOND;
	psq_cb->psq_mode = PSQ_ASSIGN;
    }
		    cdbp_rhs_asgn
    {
	DB_STATUS           status;
	PST_QNODE	    *resdomnode, *qlend;
	PST_QNODE	    *rootnode;
	PST_RT_NODE	    root;
	i4		    err_code;
	PSS_DECVAR	    *var = $1;
	PST_QTREE	    *tree;
	PST_PROCEDURE	    *pnode;
	PST_STATEMENT	    *snode;

	$Ydbpinfo->pss_flags &= ~PSS_INCOND;

	/* The assignment statement is implemented as a SELECT
	** query, we need therefore to generate a query tree here.
	** The query tree processing is simplified by the fact that
	** there are no underlying relations AND no QRYMOD routines
	** need to be called.
	*/

	/* Open memory stream for allocating query tree,
	** if not already open.
	*/
	if (!cb->pss_ostream.psf_mstream.qso_handle &&
	    (status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
	    &psq_cb->psq_error)) != E_DB_OK)
	{
	    return (status);
	}

	/* Initialize mode to true mode, PSQ_ASSIGN is
	** only used for proper recovery from syntax errors.
	*/
	psq_cb->psq_mode = PSQ_RETRIEVE;

	status = pst_adresdom((char *) &var->pss_varname, (PST_QNODE *)NULL, $3,
	    cb, psq_cb, &resdomnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	resdomnode->pst_sym.pst_value.pst_s_rsdm.pst_ntargno = var->pss_no;
	resdomnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype = PST_LOCALVARNO;
	STRUCT_ASSIGN_MACRO(var->pss_dbdata, resdomnode->pst_sym.pst_dataval);

	status = pst_parm_resolve(cb, psq_cb, resdomnode);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* Flag error if assigning the NULL constant to non-nullable variable */
	if (   resdomnode->pst_sym.pst_dataval.db_datatype > 0
	    && resdomnode->pst_right->pst_sym.pst_dataval.db_datatype
				== -DB_LTXT_TYPE
	    && resdomnode->pst_right->pst_sym.pst_dataval.db_length
				== DB_CNTSIZE + 1
	   )
	{
	    (VOID) psf_error(2777L, 0L, PSF_USERERR, &err_code,
		     &psq_cb->psq_error, 1,
		     psf_trmwhite(DB_MAXNAME, var->pss_varname.db_parm_name),
		     var->pss_varname.db_parm_name);
	    return (E_DB_ERROR);
	}

	/* Add a PST_TREE node */
	if (status = pst_trfix(cb, &cb->pss_ostream, resdomnode, &psq_cb->psq_error))
	    return (status);

	/* Create a QLEND node */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_QLEND, (PTR) NULL, 0, DB_NODT, (i2) 0,
	    (i4) 0, (DB_ANYTYPE *) NULL, &qlend, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Create the ROOT node */
	root.pst_rtuser = TRUE;
	root.pst_union.pst_next  = 0;
	root.pst_dups   = PST_ALLDUPS;
	root.pst_tvrc   = 0;
	MEfill(sizeof(PST_J_MASK), 0, (char *)&root.pst_tvrm);

	status = pst_node(cb, &cb->pss_ostream, resdomnode, qlend, PST_ROOT,
	    (PTR) &root, sizeof(PST_RT_NODE), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &rootnode, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Create the query tree header */
	status = pst_header(cb, psq_cb, PST_UNSPECIFIED, (PST_QNODE *) NULL,
	    rootnode, &tree, &pnode, ($Yisdbp) ? 0 : PST_0FULL_HEADER, 
	    &$Yxlated_qry);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** set pst_numjoins.  $Yjoin_id contains the highest join id, in this
	** case, 0.
	*/
	tree->pst_numjoins = $Yjoin_id;

	/* No need to set root here */

	/* Allocate statement node. */
	status = psl_init_dbp_stmt(cb, $Ydbpinfo, psq_cb->psq_mode, PST_QT_TYPE,
	    &snode, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	snode->pst_specific.pst_tree = tree;
	snode->pst_after_stmt = NULL;

	$$ = snode;
    }
;

cdbp_lhs_asgn:	    cdbp_lhs_var
    {
        DB_PARM_NAME	    varname;
	i4		    err_code;
	bool		    found = FALSE;
	PSS_DECVAR	    *var;

	/* normalize the var name */
	STmove((char *)$1, ' ', (u_i4)sizeof(DB_ATT_NAME), (char *)&varname);

	/* Search for the variable; innermost scope first. */
	for (var = (PSS_DECVAR *) $Ydbpinfo->pss_varq.q_next;
	     var != (PSS_DECVAR *) &$Ydbpinfo->pss_varq;
	     var = (PSS_DECVAR *) var->pss_queue.q_next
	    )
	{
	    if (var->pss_out)
		continue;
	    if (MEcmp((PTR) &varname, (PTR) &var->pss_varname,
		sizeof(var->pss_varname)) == 0)
	    {
		/* Must not be a built-in variable (READONLY). */
		if (var->pss_no == PST_RCNT || var->pss_no == PST_ERNO)
		{
		    (VOID) psf_error(2434L, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 1,
			sizeof(cb->pss_lineno), &cb->pss_lineno);
		    return (E_DB_ERROR);
		}
		found = TRUE;
		break;
	    }
	}
	if (found == FALSE)
	{
	    /* Var unknown */
	    (VOID) psf_error(2413L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, STlength($1), $1);
	    return (E_DB_ERROR);
	}
	$$ = var;
    }
;

cdbp_lhs_var:	    generic_ident EQUAL
    {
	cb->pss_stmt_flags |= PSS_DBPROC_LHSVAR;
	$$ = $1;
    }
	    |	    generic_ident COLON EQUAL
    {
	$$ = $1;
    }
	    |	    COLON generic_ident EQUAL
    {
	$$ = $2;
    }
	    |	    COLON generic_ident COLON EQUAL
    {
	$$ = $2;
    }
;

cdbp_rhs_asgn:	    select_expr
    {
	$$ = $1;
    }
	|	    null_word	/* Fix bug: disallowed := NULL assignment */
    {
	$$ = $1;
    }
;

/*
** Yacc rule:  cdbp_exec_dbproc	- Execute a procedure within another procedure.
**
** Statement Syntax:
**	[result_variable =] 
**	    EXECUTE PROCEDURE | CALLPROC procedure_name
**	    [(parameter_name = value {, parameter_name = value})];
**
** See execute_dbproc for details.
*/ 
cdbp_exec_dbproc:	execute_dbproc
    {
	/*
	** $Ydbpinfo ->pss_link and ->pss_patch have been already set in
	** execute_dbproc: production
	*/

	$$ = $1;	/* Single statement */
    }
	|	cdbp_lhs_asgn execute_dbproc
    {
	PSS_DECVAR	    *res_var = $1;	/* Result variable (left) */
	PST_RSDM_NODE	    *resdom;
	PST_STATEMENT	    *stmt_cp = $2;	/* CALLPROC statement */
	i4		    err_code;
	DB_STATUS           status;

	/*
	** This construct will simulate a SELECT statement after the
	** initial EXECUTE statement:
	**	CALLPROC procname (args);
	**	SELECT :result = :iirowcount; -- iirowcount has return value
	*/

	/* Check result variable type is an integer */
	if (abs(res_var->pss_dbdata.db_datatype) != DB_INT_TYPE)
	{
	    (VOID) psf_error(E_US0987_2439_EXEC_TYPE, 0L, PSF_USERERR,
	         &err_code, &psq_cb->psq_error, 1,
		 psf_trmwhite(DB_MAXNAME, (char *) &res_var->pss_varname),
		 &res_var->pss_varname);
	    return (E_DB_ERROR);
	}

	/* Generate a resdom node for left side */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_RSDM_NODE),
			    (PTR *) &resdom, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
	stmt_cp->pst_specific.pst_callproc.pst_return_status = resdom;
	resdom->pst_rsno      = 1;
	resdom->pst_ntargno   = res_var->pss_no;
	resdom->pst_ttargtype = PST_LOCALVARNO;
	resdom->pst_rsupdt    = FALSE;
	resdom->pst_rsflags   = PST_RS_PRINT;
	resdom->pst_dmuflags  = 0;
	MEcopy((char *)&res_var->pss_varname, DB_MAXNAME, resdom->pst_rsname);

	$$ = stmt_cp;
    }
         |       execute_dbproc cdbp_into
    { 
         PSS_DECVAR          *res_var = $2;      /* Result variable (left) */
         PST_RSDM_NODE       *resdom;
         PST_STATEMENT       *stmt_cp = $1;      /* CALLPROC statement */
         i4                  err_code;
         DB_STATUS           status;
  
         /*
         ** This construct will simulate a SELECT statement after the
         ** initial EXECUTE statement:
         **      CALLPROC procname (args);
         **      SELECT :result = :iirowcount; -- iirowcount has return value
         */
  
         /* Check result variable type is an integer */
         if (abs(res_var->pss_dbdata.db_datatype) != DB_INT_TYPE)
         {
             (VOID) psf_error(E_US0987_2439_EXEC_TYPE, 0L, PSF_USERERR,
                  &err_code, &psq_cb->psq_error, 1,
                  psf_trmwhite(DB_MAXNAME, (char *) &res_var->pss_varname),
                  &res_var->pss_varname);
             return (E_DB_ERROR);
         }
  
         /* Generate a resdom node for left side */
         status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_RSDM_NODE),
                             (PTR *) &resdom, &psq_cb->psq_error);
         if (DB_FAILURE_MACRO(status))
             return (status);
         stmt_cp->pst_specific.pst_callproc.pst_return_status = resdom;
         resdom->pst_rsno      = 1;
         resdom->pst_ntargno   = res_var->pss_no;
         resdom->pst_ttargtype = PST_LOCALVARNO;
         resdom->pst_rsupdt    = FALSE;
         resdom->pst_rsflags   = PST_RS_PRINT;
         resdom->pst_dmuflags  = 0;
         MEcopy((char *)&res_var->pss_varname, DB_MAXNAME, resdom->pst_rsname);
  
         $$ = stmt_cp;
     }
 ;
  
 cdbp_into:              cdbp_into_var
     {
         DB_PARM_NAME        varname;
         i4             err_code;
         bool                found = FALSE;
         PSS_DECVAR          *var;
  
         /* normalize the var name */
         STmove((char *)$1, ' ', sizeof(DB_ATT_NAME), (char *)&varname);
  
         /* Search for the variable; innermost scope first. */
         for (var = (PSS_DECVAR *) $Ydbpinfo->pss_varq.q_next;
              var != (PSS_DECVAR *) &$Ydbpinfo->pss_varq;
              var = (PSS_DECVAR *) var->pss_queue.q_next
             )
         {
             if (var->pss_out)
                 continue;
             if (MEcmp((PTR) &varname, (PTR) &var->pss_varname,
                 sizeof(var->pss_varname)) == 0)
             {
                 /* Must not be a built-in variable (READONLY). */
                 if (var->pss_no == PST_RCNT || var->pss_no == PST_ERNO)
                 {
                     (VOID) psf_error(2434L, 0L, PSF_USERERR,
                         &err_code, &psq_cb->psq_error, 1,
                         sizeof(cb->pss_lineno), &cb->pss_lineno);
                     return (E_DB_ERROR);
                 }
                 found = TRUE;
                 break;
             }
         }
         if (found == FALSE)
         {
             /* Var unknown */
             (VOID) psf_error(2413L, 0L, PSF_USERERR,
                 &err_code, &psq_cb->psq_error, 1, STlength($1), $1);
             return (E_DB_ERROR);
         }
         $$ = var;
     }
 ;
  
 cdbp_into_var:  INTO generic_ident
 {
         $$ = $2;
 }
              |  INTO COLON generic_ident
 {
         $$ = $3;
 }
;

/*
** Yacc production:  cdbp_event_stmt	- RAISE/REGISTER/REMOVE DBEVENT
**
** Statement Syntax:
**	RAISE DBEVENT [dbevent_owner.]dbevent_name [dbevent_text]
**	    [WITH [NO]SHARE]
**	REGISTER DBEVENT [dbevent_owner.]dbevent_name
**	REMOVE DBEVENT [dbevent_owner.]dbevent_name
**
** Return State:
**	See the statement productions.
**	The statement is added to the list of DBP statements.
*/
cdbp_event_stmt: cdbp_ev_stmt
    {
	/*
	** if this statement is not reachable, do not attach it to the list of
	** statements used by OPF (to save the cost of optimizing it)
	*/
	if ($Ydbpinfo->pss_unreachable_stmt_lvl == 0)
	{
	    if ($Ydbpinfo->pss_link != (PST_STATEMENT *) NULL)
		$Ydbpinfo->pss_link->pst_link = $1;
	    $Ydbpinfo->pss_link = $1;
	}

	$Ydbpinfo->pss_patch = &$1->pst_next;

        $$ = $Ydbpinfo->pss_last_stmt = $1;
    }	
;
cdbp_ev_stmt:	raise_event
    {
	$$ = $1;
    }
	|	register_event
    {
	$$ = $1;
    }
	|	remove_event
    {
	$$ = $1;
    }
;

cursor_close:	    CLOSE QUERYID
    {
	PSC_CURBLK             *cursor;
	DB_STATUS	       status;
	i4		       err_code;
	QEF_RCB		       *qef_rcb;

	psq_cb->psq_mode = PSQ_CLSCURS;

	/* Allocate a QEF control block for doing the close */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;

	/* Hand cursor id back to caller */
	STRUCT_ASSIGN_MACRO(*($2), psq_cb->psq_cursid);

	/* Look up the cursor */
	status = psq_crfind(cb, $2, &cursor, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	/* Complain if not found */
	if (cursor == (PSC_CURBLK *) NULL || cursor->psc_open == FALSE)
	{
	    (VOID) psf_error(2205L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(DB_MAXNAME, $2->db_cur_name),
		$2->db_cur_name);
	    return (E_DB_ERROR);
	}

	/* Get rid of the cursor control block */
	status = psq_crclose(cursor, &cb->pss_curstab, &cb->pss_memleft,
	    &psq_cb->psq_error);
 	if (status != E_DB_OK)
	    return (status);
    }
;

cursor_fetch:	    FETCH QUERYID
    {
	PSC_CURBLK             *cursor;
	DB_STATUS	       status;
	i4		       err_code;
	QEF_RCB		       *qef_rcb;

	psq_cb->psq_mode = PSQ_RETCURS;

	/* Look up the cursor */
	status = psq_crfind(cb, $2, &cursor, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Complain if not found */
	if (cursor == (PSC_CURBLK *) NULL || cursor->psc_open == FALSE)
	{
	    (VOID) psf_error(2205L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(DB_MAXNAME, $2->db_cur_name),
		$2->db_cur_name);
	    return (E_DB_ERROR);
	}

	/* Hand the cursor id back to the caller */
	STRUCT_ASSIGN_MACRO(*($2), psq_cb->psq_cursid);

	/* Allocate the QEF control block for fetch cursor */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;
    }
;

cursor_open:	    curop_ini query for_rdonly
    {
	DB_STATUS		status;

	if (cb->pss_defqry == PSQ_DEFCURS)
	{
	    /*
	    ** for repeat cursors, we want to insist that the cursor be opened
	    ** FOR READONLY.  Unfortunately, in cases when BE asks FE for the
	    ** cursor definition text (as would happen when a QP became
	    ** obsolete), FE sends the cursor definition text WITHOUT
	    ** FOR READONLY.
	    ** Since these changes are being made to make manman/X run faster
	    ** and are not for general consumption, we will take an easy way out
	    ** and will behave as if FOR READONLY was specified regardless of
	    ** whether it actually was
	    */
	    $3 = TRUE;
	}

	status = psl_crsopen(cb, psq_cb, $1, $2, $3,
	    $Yupdcollst, $Ynonupdt, $Yjoin_id);

	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	/* If this is a scrollable cursor, verify that no result columns 
	** are LOBs (though LOB locators are ok). */
	if (cb->pss_stmt_flags & PSS_SCROLL)
	{
	    PST_QNODE	*rsdmp;
	    DB_DT_ID	rtype;
	    i4		err_code;

	    for (rsdmp = $2->pst_qtree->pst_left; rsdmp && 
			rsdmp->pst_sym.pst_type == PST_RESDOM;
			rsdmp = rsdmp->pst_left)
	     if ((rtype = abs(rsdmp->pst_sym.pst_dataval.db_datatype)) ==
					DB_LVCH_TYPE ||
		rtype == DB_LBYTE_TYPE || rtype == DB_LNVCHR_TYPE)
	     {
		/* Display error. */
		(VOID) psf_error(2231L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2,
		    sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME, $1->psc_curid.db_cur_name),
		    $1->psc_curid.db_cur_name);
		return(E_DB_ERROR);
	     }
	}

	/* Check for KEYSET cursor. */
	if ($3 == 1)
	    cb->pss_stmt_flags &= ~PSS_KEYSET;	/* no KEYSET if READONLY*/
	else if (cb->pss_stmt_flags & PSS_KEYSET)
	{
	    i4		err_code, reason;
	    bool	nonupdt = FALSE;

	    /* Can't have KEYSET cursor on a Star DB. */
	    if (cb->pss_distrib & DB_3_DDB_SESS)
	    {
		/* Display error. */
		(VOID) psf_error(2232L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2,
		    sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME, $1->psc_curid.db_cur_name),
		    $1->psc_curid.db_cur_name);
		return(E_DB_ERROR);
	    }

	    /* Verify that it's updateable - if not, send errors. */
	    (VOID) psl_up(cb, &cb->pss_auxrng, $2, &nonupdt, &reason);

	    if (nonupdt)
	    {

		(VOID) psf_error(2229L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2,
		    sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME, $1->psc_curid.db_cur_name),
		    $1->psc_curid.db_cur_name);
		psl_nonupdt_err(psq_cb, cb, reason, &err_code);
		return(E_DB_ERROR);
	    }

	    /*
	    ** Valid KEYSET cursor.
	    ** Identify and flag result columns in keyset.
	    */
	    status = psl_crskeyflag(cb, $2);
	    if (DB_FAILURE_MACRO(status))
	    {
		/* don't have unique key covered by result set */
		(VOID) psf_error(2307L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2,
		    sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME, $1->psc_curid.db_cur_name),
		    $1->psc_curid.db_cur_name);
		return(E_DB_ERROR);
	    }
	}

	if (cb->pss_defqry == PSQ_DEFCURS)
	{
	    /* repeat cursors must be opened FOR READONLY */
	    if (!$3)
	    {
		i4	    err_code;
		
		(VOID) psf_error(E_PS0404_REP_CURS_NOT_FOR_RDONLY, 0L,
		    PSF_USERERR, &err_code, &psq_cb->psq_error, 1,
		    psf_trmwhite(DB_MAXNAME, $1->psc_curid.db_cur_name),
		    $1->psc_curid.db_cur_name);
	        return(E_DB_ERROR);
	    }

	    /*
	    ** if processing definition of a sharable repeat cursor, we need to
	    ** determine whether there is already a QP for this cursor or define
	    ** a new QP otherwise;
	    ** NOTE that we should not try to invoke psl_repeat_qry_id() before
	    ** calling psl_crsopen() because the former may deallocate query
	    ** tree needed by the latter
	    */
	    if ($Yqp_shareable)
	    {
		status = psl_repeat_qry_id(psq_cb, cb, &$1->psc_curid, $2,
		    $Yshr_qryinfo);

		if (DB_FAILURE_MACRO(status))
		{
		    return(status);
		}
	    }

	    if (psq_cb->psq_mode == PSQ_QRYDEFED)
	    {
		/*
		** we found an existing QP for this shareable repeat cursor -
		** overwrite BE QP id in the cursor block with that stored into
		** psq_cb->psq_cursid by psl_repeat_qry_id(); we do NOT need to
		** copy it into the query tree header (pst_cursid) because
		** psl_repeat_qry_id() has already deallocated it
		*/
		STRUCT_ASSIGN_MACRO(psq_cb->psq_cursid, $1->psc_blkid);
	    }
	}
    }
;

curop_ini:	    curop_ini_1
	    |	    curop_ini_2
;

curop_ini_1:	    OPEN QUERYID scrollopt CURSOR FOR
    {
	DB_STATUS              status;
	PSC_CURBLK	       *curblk;
	i4		       err_code;
	u_i4			l_id;
	char			tempstr[GCA_MAXNAME];
	u_i4			templen;
	u_i4		mode;

	psq_cb->psq_mode = PSQ_DEFCURS;

	/*
	** The cursor name must be translated here
	*/
	l_id = sizeof($2->db_cur_name);
	templen = sizeof(tempstr);
	mode = *cb->pss_dbxlate | CUI_ID_STRIP;
	status = cui_idxlate((u_char *) $2->db_cur_name, &l_id,
			     (u_char *)tempstr, &templen, mode,
			     (u_i4 *) NULL, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    /*@FIX_ME@ Customize message with line number? */
	    (VOID) psf_error(psq_cb->psq_error.err_code, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(ERx("Cursor name"))-1,
		ERx("Cursor name"),
		l_id, $2->db_cur_name);
	    return (E_DB_ERROR);
	}
	(VOID)MEmove(templen, (PTR)tempstr, ' ',
		     sizeof($2->db_cur_name),$2->db_cur_name);

	/* This is not a repeat cursor */
	cb->pss_defqry = 0;

	/* look for cursor by its FE id. It should not exist. */
	status = psq_crffind(cb, $2, &curblk, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	if (curblk != (PSC_CURBLK *) NULL)
	{
	    (VOID) psf_error(2201L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(DB_MAXNAME, $2->db_cur_name), $2->db_cur_name);
	    return (E_DB_ERROR);
	}

	/* Create cursor control block */
	status = psq_crcreate(cb, $2, psq_cb->psq_mode, &curblk,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Hand cursor id back to caller */
	STRUCT_ASSIGN_MACRO(curblk->psc_blkid, psq_cb->psq_cursid);

	$$ = curblk;
    }
;

curop_ini_2:	DEFQRY OPEN CURSOR QUERYID scrollopt FOR
    {
	DB_STATUS              status;
	PSC_CURBLK	       *curblk;
	i4		       err_code;
	u_i4			l_id;
	char			tempstr[GCA_MAXNAME];
	u_i4			templen;
	u_i4		mode;

	{
	    i4	val1 = 0, val2 = 0;

	    /* repeat cursors only available if user set trace point ps151 */
	    if (!ult_check_macro(&cb->pss_trace, 23, &val1, &val2))
	    {
	        psl_yerror(3, cb, psq_cb);
		return(E_DB_ERROR);
	    }
	}

	psq_cb->psq_mode = PSQ_DEFCURS;

	/* This is a repeat cursor */
	cb->pss_defqry = PSQ_DEFCURS;

	/*
	** The cursor name must be translated here
	*/
	l_id = sizeof($4->db_cur_name);
	templen = sizeof(tempstr);
	mode = *cb->pss_dbxlate | CUI_ID_STRIP;
	status = cui_idxlate((u_char *) $4->db_cur_name, &l_id,
			     (u_char *)tempstr, &templen, mode,
			     (u_i4 *) NULL, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    /*@FIX_ME@ Customize message with line number? */
	    (VOID) psf_error(psq_cb->psq_error.err_code, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 3,
		sizeof(ERx("Cursor name"))-1,
		ERx("Cursor name"),
		l_id, $4->db_cur_name);
	    return (E_DB_ERROR);
	}

	(VOID)MEmove(templen, (PTR)tempstr, ' ',
		     sizeof($4->db_cur_name), $4->db_cur_name);

	/* look for cursor by its FE id. */
	status = psq_crffind(cb, $4, &curblk, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/*
	** it is possible to find an existing cursor block describing a repeat
	** cursor if we were asked to reparse a cursor definition; it's quite
	** acceptable unless the cursor is opened
	*/
	if (curblk != (PSC_CURBLK *) NULL && curblk->psc_open)
	{
	    (VOID) psf_error(2210L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(DB_MAXNAME, $4->db_cur_name), $4->db_cur_name);
	    return (E_DB_ERROR);
	}

	/* Create cursor control block */
	status = psq_crcreate(cb, $4, psq_cb->psq_mode, &curblk,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Hand cursor id back to caller */
	STRUCT_ASSIGN_MACRO(curblk->psc_blkid, psq_cb->psq_cursid);

	/* remember to check for illegal VLUPs */
	$Ycheck_for_vlups = TRUE;
	
	$$ = curblk;
    }
;

scrollopt:	/* nuffin */
	    |	keyset_opt SCROLL
    {
	cb->pss_stmt_flags |= PSS_SCROLL;
	if ($1)
	    cb->pss_stmt_flags |= PSS_KEYSET;
    }
;

keyset_opt:	/* nuffin */
    {
	$$ = 0;
    }
	    | nonkeyword
    {
	/* It's either "keyset" or it's an error. */
	if (STcompare($1, "keyset") != 0)
	    psl_yerror(3, cb, psq_cb);
	$$ = 1;
    }
;

for_rdonly:	    FORREADONLY
    {
	$$ = TRUE;
    }
	    |	    /* empty */
    {
	$$ = FALSE;
    }
;

cursor_open_dsql:	curop_ini_dsql for_rdonly using_list
    {
	DB_STATUS		status;
	i4			i, err_code;
	PST_PROCEDURE		*pnode;
	register PST_QTREE	*tree;
	PST_RNGENTRY		*rtptr;

	/*
	** Substitute values from using list, if present.
	*/
	if ($3 == FALSE)
	{
	    if ($Ydsql_maxparm >= 0)
	    {	/* error if no parms */
		(VOID) psf_error(2300L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1,
		    sizeof(cb->pss_lineno), &cb->pss_lineno);		    
		return (E_DB_ERROR);
	    }
	}
	else 
	{
	    if (cb->pss_highparm != $Ydsql_maxparm)
	    {	/* error if not enough parms */
		(VOID) psf_error(2301L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1,
		    sizeof(cb->pss_lineno), &cb->pss_lineno);
		return (E_DB_ERROR);
	    }
	}

	pnode = (PST_PROCEDURE *) cb->pss_object; /* get ptr to procedure node */
	tree = pnode->pst_stmts->pst_specific.pst_tree;

	/* Loop over range table, looking for derived tables or common
	** query expressions that may also contain dynamic parameters. */
	for (i = 0; i < tree->pst_rngvar_count; i++)
	{
	    rtptr = tree->pst_rangetab[i];
	    if (rtptr && (rtptr->pst_rgtype == PST_DRTREE ||
			rtptr->pst_rgtype == PST_WETREE))
	    {
		status = pst_prmsub(psq_cb, cb, rtptr->pst_rgroot, 
							$Ydsql_plist);
		if (DB_FAILURE_MACRO(status))
		    return(status);
	    }
	}

	status = pst_prmsub(psq_cb, cb, tree->pst_qtree, $Ydsql_plist);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	/*
	** We only need to resolve unions that contained parameters at this
	** point.  Other unions should have already been resolved.
	*/
	if ((tree->pst_qtree->pst_sym.pst_value.pst_s_root.pst_union.pst_next
		!= (PST_QNODE *) NULL)
	    && (cb->pss_highparm != -1)
	   )
	{
	    status = pst_union_resolve(cb, tree->pst_qtree, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}

	psq_cb->psq_mode = PSQ_DEFCURS;
	psq_cb->psq_pnode = (PTR)pnode;

	status = psl_crsopen(cb, psq_cb, $1, tree, $2,
	    $Yupdcollst, $Ynonupdt, $Yjoin_id);

	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}
	/*
	** At this point we are done with parm substitution, if any.
	*/
	tree->pst_numparm = 0;
    }
;

curop_ini_dsql:	    curop_ini_1 generic_ident
    {
	PST_PROCEDURE	    *pnode;
	PST_QTREE	    *tree;
	DB_STATUS	    status;
	i4		    i;
	PSS_RNGTAB	    *rngvar;
	i4		    err_code;
	bool		    use_view;
	i4		    rng_count;

	/*
	** Obtain the prototype query tree from QSF and duplicate the tree.
	*/
	status = pst_execute(psq_cb, cb, $2, &pnode, &$Ydsql_maxparm,
	    (PTR *) &$Ydsql_plist, &$Ynonupdt, &$Yupdcollst);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	tree = pnode->pst_stmts->pst_specific.pst_tree;

	if (cb->pss_viewrng.pss_maxrng > 0)
	{
		use_view = TRUE;
		rng_count = cb->pss_viewrng.pss_maxrng;
	}
	else
	{
		use_view = FALSE;
		rng_count = tree->pst_rngvar_count;
	}

	/* QRYMOD execution requires entries in the range table.
	** This has to be done, otherwise integrities and permissions
	** for the cursor are likely to be screwed up (qrymod code
	** relies heavily on the parser range var. table.
	** We no longer need to look at PST_NUMVARS entries - pst_rngvar_count
	** tells us how many entries there are
	*/
	for (i = 0; i < rng_count; i++)
	{
	    if (tree->pst_rangetab[i] == (PST_RNGENTRY *) NULL ||
		tree->pst_rangetab[i]->pst_rgtype == PST_UNUSED)
	    {
		/*
		** this should never happen since we have not run psy_view()
		** over this tree yet
		*/
		(VOID) psf_error(E_PS0C04_BAD_TREE, 0L, PSF_INTERR,
		    &err_code, &psq_cb->psq_error, 0);
		return(E_DB_ERROR);
	    }

	    /*
	    ** Range variable name "!" means don't look for and
	    ** try to replace a range variable of the same name.
	    */

	    /*
	    ** Process derived tables and with elements separately.
	    */
	    if (tree->pst_rangetab[i]->pst_rgtype == PST_DRTREE ||
		tree->pst_rangetab[i]->pst_rgtype == PST_WETREE)
		status = pst_sdent(&cb->pss_auxrng, -1, "!", cb,
		    &rngvar, tree->pst_rangetab[i]->pst_rgroot,
		    tree->pst_rangetab[i]->pst_rgtype, 
		    &psq_cb->psq_error);
	    else if (use_view)
	    	status = pst_rgent(cb, &cb->pss_auxrng, -1, "!", PST_SHWID, 
		    (DB_TAB_NAME*) NULL, (DB_TAB_OWN*) NULL,
		    &cb->pss_viewrng.pss_rngtab[i].pss_tabid, FALSE, 
		    &rngvar, psq_cb->psq_mode, &psq_cb->psq_error);
	    else
	    	status = pst_rgent(cb, &cb->pss_auxrng, -1, "!", PST_SHWID, 
		    (DB_TAB_NAME*) NULL, (DB_TAB_OWN*) NULL,
		    &tree->pst_rangetab[i]->pst_rngvar, FALSE, 
		    &rngvar, psq_cb->psq_mode, &psq_cb->psq_error);

	    if (DB_FAILURE_MACRO(status))
	    {
		if (psq_cb->psq_error.err_code == E_PS0903_TAB_NOTFOUND)
		{
		    (VOID) psf_error(E_US1265_QEP_INVALID, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 1,
			STlength($2), $2);
		}
		else
		{
		    (VOID) psf_error(E_PS0E03_RGENT_ERR, psq_cb->psq_error.err_code,
			PSF_INTERR, &err_code, &psq_cb->psq_error, 0);
		}
		return (status);
	    }

	    /* If we haven't assign the pss_viewrng structure yet set it up */
	    if (use_view == FALSE)
	    {
		STRUCT_ASSIGN_MACRO(*rngvar,cb->pss_viewrng.pss_rngtab[i]);
	    	if (rngvar->pss_tabdesc->tbl_status_mask & DMT_VIEW)
                   cb->pss_viewrng.pss_maxrng = tree->pst_rngvar_count;
	    }
		
	    /* Reconstruct cb->pss_resrng */
	    if (i == tree->pst_restab.pst_resvno)
	    {
		cb->pss_resrng = rngvar;
	    }

	    /*
	    ** reconstruct the range variable name; this is required since we
	    ** may end up copying it into the PST_RNGENTRY structure, and "!"
	    ** will not do as a correlation name
	    */
	    MEcopy((PTR) &tree->pst_rangetab[i]->pst_corr_name,
		DB_MAXNAME, (PTR) rngvar->pss_rgname);

	    /*
	    ** copy inner and outer join maps into the new range table
	    ** entry
	    */
	    STRUCT_ASSIGN_MACRO(tree->pst_rangetab[i]->pst_inner_rel,
	        rngvar->pss_inner_rel);
	    STRUCT_ASSIGN_MACRO(tree->pst_rangetab[i]->pst_outer_rel,
	        rngvar->pss_outer_rel);
	}

	/* Restore query mode to `open cursor' */
	psq_cb->psq_mode = PSQ_DEFCURS;

	/* reconstruct $Yjoin_id from tree->pst_numjoins */
	$Yjoin_id = tree->pst_numjoins;

	$$ = $1;
    }
;

using_list:	    USING const_list
    {
	$$ = TRUE;
    }
	    |	    /* empty */
    {
	$$ = FALSE;
    }
;


const_list:	    dsql_data
	    |	    const_list COMMA dsql_data
;

dsql_data:	    QDATA
    {
	++cb->pss_highparm;
	if ($Yin_target_clause)
	   ++cb->pss_targparm;
	if (cb->pss_highparm <= $Ydsql_maxparm)
	{
	    *($Ydsql_plist + cb->pss_highparm) = $1;
	}
    }
;

define_query:	    defqry_ini repeat_query
    {
	i4	    err_code;
	DB_STATUS   status;

	if ((psq_cb->psq_mode == PSQ_REPCURS) ||
	    (psq_cb->psq_mode == PSQ_DELCURS))
	{
	    (VOID) psf_error(2216L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psq_cb->psq_mode = PSQ_DEFQRY;

	/*
	** For shared QEP's we need to define or translate
	** the FE object id.
	*/
	if ($Yqp_shareable)
	{
	    status = psl_repeat_qry_id(psq_cb, cb, &$Yfe_cursor_id, $2,
		$Yshr_qryinfo);

	    if (DB_FAILURE_MACRO(status))
	    {
		return(status);
	    }
	}
    }
;

defqry_ini:	    DEFQRY QUERYID IS 
    {
	psq_cb->psq_mode = PSQ_DEFQRY;
	cb->pss_defqry = PSQ_DEFQRY;

	/* For shared QEP's save the original FE id. */
	STRUCT_ASSIGN_MACRO(*($2), $Yfe_cursor_id);

	/* 
	** Hand cursor id back to caller. PSF fills in a part of cursor id.
	** The part consists of two i4's. The only requirement here is that
	** they be unique. So we use pss_sessid which is always unique and
	** a counter (pss_crsid) within each session. We used TMnow before
	** but it turns out that the granularity of the system clock is not
	** good enough to make the timestamp unique.
	*/
	STRUCT_ASSIGN_MACRO(*($2), psq_cb->psq_cursid);
	psq_cb->psq_cursid.db_cursor_id[0] = (i4) cb->pss_psessid;
	psq_cb->psq_cursid.db_cursor_id[1] = (i4) ++cb->pss_crsid;
    }
;

repeat_query:	    delete
    {
	$$ = $1;
    }
	    |	    insert
    {
	$$ = $1;
    }
	    |
    {
	$Ycheck_for_vlups = TRUE;
    }
		    query
    {
	$$ = $2;
    }
	    |	    update
    {
	$$ = $1;
    }
;

/*
** The DELETE statement now returns a tree for the cursor version too - in 
** support of Dynamic SQL.
*/
delete:		    delstmnt from_item where_cur
    {
	PST_QNODE              *tidnode;
	PST_VAR_NODE	       tidvar;
	PST_QNODE	       *rsdmnode;
	PST_RSDM_NODE	       resdom;
	PST_QNODE	       *rootnode;
	PST_RT_NODE	       root;
	PST_QTREE	       *tree;
	DB_STATUS	       status;
	i4		       err_code;
	i4                qrymod_resp_mask;
	PSC_CURBLK	       *cursor;
	PST_PROCEDURE          *pnode;
	i4		       tbl_stat_mask;
	i4		       tbl_2_stat_mask;
	i4		       hdr_mask;

	if (psq_cb->psq_mode == PSQ_DELETE)
	{
	    if (~cb->pss_distrib & DB_3_DDB_SESS)
	    {
		hdr_mask = 0;

		/* Set up a var. node representing the tid.
		** pst_adresdom should not be used here because it relies on
		** cb->pss_rsdmno, which may be incorrect now due to the fact
		** that subselects in the where clause reset it every time a new
		** target list is started.
		*/
		tidvar.pst_vno = $2->pss_rgno;
		tidvar.pst_atno.db_att_id = 0;	    /* tid is always column 0 */

		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		    (PST_QNODE *) NULL, PST_VAR, (char *) &tidvar,
		    sizeof(tidvar), DB_TID8_TYPE, (i2) 0, (i4) DB_TID8_LENGTH,
		    (DB_ANYTYPE *) NULL,
		    &tidnode, &psq_cb->psq_error, (i4) 0);
		if (status != E_DB_OK)
		{
		    return (status);	    /* non-zero return means error */
		}

		/* Set up a resdom result domain representing a tid. */
		resdom.pst_rsno = 0;
		cb->pss_rsdmno++; /* Count resdoms */
		resdom.pst_ntargno = (i4) 0;
		resdom.pst_ttargtype = (i4) PST_ATTNO;
		resdom.pst_rsupdt = FALSE;
		resdom.pst_rsflags = 0; /* no PST_RS_PRINT */
	        resdom.pst_dmuflags = 0;

		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		    tidnode, PST_RESDOM, (PTR) &resdom, sizeof(resdom),
		    DB_TID8_TYPE, (i2) 0, (i4) DB_TID8_LENGTH, 
		    (DB_ANYTYPE *) NULL, &rsdmnode,
		    &psq_cb->psq_error, (i4) 0);
		if (status != E_DB_OK)
		{
		    return (status);	/* non-zero return means error */
		}
	    }
	    else
	    {
		rsdmnode = (PST_QNODE *) NULL;
		hdr_mask = PST_1INSERT_TID;
	    }

	    /* Make the root node */
	    root.pst_rtuser = TRUE;
	    root.pst_union.pst_next  = 0;
	    root.pst_dups   = PST_ALLDUPS;
	    MEcopy((char *)&$Yflists[cb->pss_qualdepth], sizeof(PST_J_MASK),
				(char *)&$Yfrom_list);
	    root.pst_tvrc   = BTcount((char *) &$Yfrom_list, 
				      BITS_IN($Yfrom_list));
	    MEcopy((char *)&$Yfrom_list, sizeof(PST_J_MASK),
						(char *)&root.pst_tvrm);

	    status = pst_node(cb, &cb->pss_ostream, rsdmnode, $3, PST_ROOT,
		(PTR) &root, sizeof(PST_RT_NODE), DB_NODT, (i2) 0, (i4) 0,
		(DB_ANYTYPE *) NULL, &rootnode, &psq_cb->psq_error, (i4) 0);
	    if (status != E_DB_OK)
	    {
		return (status);	/* non-zero return means error */
	    }

	    /* Remember the result variable */
	    cb->pss_resrng = $2;

	    /* For repeat queries we must determine if the query is shareable.
	    ** We already know that this is an SQL query, so the only criterion
	    ** to be checked out is whether all relations/views are DBA owned or
	    ** are catalogs.
	    */
	    if (cb->pss_defqry == PSQ_DEFQRY)
	    {
		status = psl_shareable(psq_cb, cb,&$Yqp_shareable,
			&$Yshr_qryinfo);
		if (status != E_DB_OK)
		{
		    return (status);
		}
	    }

	    /* Apply qrymod algorithm (views, permits, integrities) */
	    status = psy_qrymod(rootnode, cb, psq_cb, &$Yjoin_id,
	    	&qrymod_resp_mask);
	    if (status != E_DB_OK)
		return (status);

	    tbl_stat_mask = cb->pss_resrng->pss_tabdesc->tbl_status_mask;
	    tbl_2_stat_mask = cb->pss_resrng->pss_tabdesc->tbl_2_status_mask;

	    /* Make sure base table is updateable;
	    ** In case of an index or a non-extended catalog
	    ** catalog update privilege must be on.
	    ** In case of security catalog session must have security 
	    ** privilege active.
	    ** Bug 34079, since 6.0 you were never supposed to be 
            ** able to update a secondary index.  Fixed it so 
            ** the same error is returned whether you have update 
            ** syscat or not (jennifer)
	    **
	    ** if PSS_REPAIR_SYSCAT and PSS_CATUPD are set in cb->pss_ses_flag,
	    ** allow DELETE on indexes which are non-extended catalogs
	    */
            if (tbl_2_stat_mask & DMT_READONLY)
            {
                (VOID) psf_error(E_US14E6_5350_READONLY_TBL_ERR, 0L,
                           PSF_USERERR, &err_code, &psq_cb->psq_error, 0);
                return(E_DB_ERROR);
            }
	    else if (tbl_stat_mask & DMT_IDX)
	    {
		if (!(   tbl_stat_mask & DMT_CATALOG
		      && ~tbl_stat_mask & DMT_EXTENDED_CAT
		      && cb->pss_ses_flag & PSS_CATUPD
		      && cb->pss_ses_flag & PSS_REPAIR_SYSCAT
		     )
		   )
		{
		    _VOID_ psf_error(2106L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1,
			psf_trmwhite(sizeof(DB_TAB_NAME),
			    (char *) &cb->pss_resrng->pss_tabname),
			&cb->pss_resrng->pss_tabname);
		    return(E_DB_ERROR);
		}
	    }
	    else if (   ((tbl_stat_mask & DMT_CATALOG ||
			 tbl_2_stat_mask & DMT_TEXTENSION)
		     && ~tbl_stat_mask & DMT_EXTENDED_CAT
		     && !(cb->pss_ses_flag & PSS_CATUPD)) 
		     ||
		     ((tbl_stat_mask & DMT_SECURE) &&
        	       !(cb->pss_ustat & DU_USECURITY)))
	    {
		i4 local_status;
		DB_ERROR	    e_error;

		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    local_status = psy_secaudit(FALSE, cb,
			    (char *)&cb->pss_resrng->pss_tabname,
			    &cb->pss_resrng->pss_tabdesc->tbl_owner,
			    sizeof(DB_TAB_NAME), 
			    SXF_E_TABLE,
			    I_SX2020_PROT_REJECT, 
			    SXF_A_FAIL|SXF_A_DELETE, 
			    &e_error);

		    if (local_status > status)
			status = local_status;
		}

		/* process security_alarms */
		local_status = psy_do_alarm_fail(cb, 
				cb->pss_resrng, PSQ_DELETE, &e_error);
		if (local_status > status)
		    status = local_status;

		_VOID_ psf_error(2107L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 2,
		    sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(sizeof(DB_TAB_NAME),
			(char *) &cb->pss_resrng->pss_tabname),
		    &cb->pss_resrng->pss_tabname);
		return (E_DB_ERROR);
	    }
	}
	else	/* DELETE CURSOR */
	{
	    cursor = (PSC_CURBLK *)$3;

	    /* We must compare names of objects and of object owners. */
	    if (MEcmp((PTR) &(cursor->psc_tabnm),
		      (PTR) &($2->pss_tabname), sizeof(DB_TAB_NAME)) ||
		MEcmp((PTR) &(cursor->psc_ownnm),
		      (PTR) &($2->pss_ownname), sizeof(DB_OWN_NAME)))
	    {
		(VOID) psf_error(2227L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 4,
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &cursor->psc_tabnm),
		    &cursor->psc_tabnm,
		    psf_trmwhite(sizeof(DB_OWN_NAME), 
			(char *) &cursor->psc_ownnm),
		    &cursor->psc_ownnm,
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &$2->pss_tabname),
		    &$2->pss_tabname,
		    psf_trmwhite(sizeof(DB_OWN_NAME), 
			(char *) &$2->pss_ownname),
		    &$2->pss_ownname);
		return(E_DB_ERROR);
	    }

	    /* Make the root node */
	    root.pst_tvrc = 0;
	    root.pst_lvrc = 0;
	    MEfill(sizeof(PST_J_MASK), 0, (char *)&root.pst_tvrm);
	    MEfill(sizeof(PST_J_MASK), 0, (char *)&root.pst_lvrm);
	    MEfill(sizeof(PST_J_MASK), 0, (char *)&root.pst_rvrm);
	    root.pst_mask1 = 0;
	    root.pst_qlang = DB_SQL;
	    root.pst_rtuser = TRUE;
	    root.pst_union.pst_next  = NULL;
	    root.pst_dups = PST_ALLDUPS;
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL,
		(PST_QNODE *)NULL, PST_ROOT, (PTR)&root, sizeof(PST_RT_NODE),
		DB_NODT, (i2)0, (i4)0, (DB_ANYTYPE *)NULL, &rootnode,
		&psq_cb->psq_error, (i4) 0);
	    if (status != E_DB_OK)
		return (status);

	    /* Remember the result variable */
	    cb->pss_resrng = $2;

	    /* Apply qrymod (currently only rules for DELETE cursor) */
	    status = psy_rules(cb, psq_cb->psq_mode, rootnode,
			       &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	}

	cb->pss_qualdepth--;

	/* Make the header */
	status = pst_header(cb, psq_cb, PST_UNSPECIFIED, (PST_QNODE *)NULL,
			    rootnode, &tree, &pnode,
			    hdr_mask | (($Yisdbp) ? 0: PST_0FULL_HEADER),
			    &$Yxlated_qry);
	if (status != E_DB_OK)
	    return (status);

	/* set pst_numjoins.  $Yjoin_id contains the highest join id */
	tree->pst_numjoins = $Yjoin_id;

	/* Fix the root in QSF */
	if (pnode != (PST_PROCEDURE *)NULL)
	{
	    status = psf_mroot(cb, &cb->pss_ostream, (PTR)pnode,
			       &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	}

	$$ = tree;
    }
;

delstmnt:          DELETE FROM
    {
	DB_STATUS              status;

	/* Set query mode */
	psq_cb->psq_mode = PSQ_DELETE;

	/* Open memory stream for allocating query tree */
	if ($Yisdbp == FALSE)
	{
	    if ((status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
		&psq_cb->psq_error)) != E_DB_OK)
	    {
		return (status);    /* non-zero return means error */
	    }
	}
	else
	{
	    /*
	    ** To indicate that in 'i= :i' in a subselect the first
	    ** "i" must not be processed as a local var (bug 8269).
	    */
	    $Ydbpinfo->pss_flags |= PSS_1SUB_SEEN;
	}

	MEfill(sizeof(PST_J_MASK), 0, (char *)&$Yflists[++cb->pss_qualdepth]);

	/* Start off with no columns */
	cb->pss_rsdmno = 0;
    }
;

drop_tvis:	     drop
    {
	PSY_CB		*psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;
	if (psy_cb->psy_numtabs == 0)
	{
	    /*
	    **  If there are no tables specified we just want to return.
	    **  Error messages should have already been displayed.
	    **  It is not possible for the user to type in DROP and get
	    **  to this production; he would first get a syntax error.
	    **  Upon return to SCF the sequencer will examine the return
	    **	code (E_DB_ERROR), then evaluate err_code, which in this
	    **  case will be set to indicate user error and just return
	    **  to the front end without any complaints, and that is what
	    **  we want.
	    */
	    psq_cb->psq_error.err_code = E_PS0001_USER_ERROR;
	    return (E_DB_ERROR);
	}
    }
;

drop:   	    drop_stmnt drop_obj_list
	    |	    drop_syn drop_syn_list
;

drop_stmnt:	    drop_prefix
    {
	PSY_CB		       *psy_cb;
	DB_STATUS	       status;

	if ($Yupobjtype < REMOVE_OBJ)
	{
	    psq_cb->psq_mode = PSQ_DESTROY;
	}
	else
	{
            /*
            ** schang: change from psq_remove to psq_reg_remove
            ** this change may cause problem in STAR.  Consult with
            ** Barbara if trouble occurs
            */
	    psq_cb->psq_mode = PSQ_REG_REMOVE;
	}

	/* Create a PSY_CB to do the destruction of tables and views */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	if (cb->pss_distrib & DB_3_DDB_SESS /* && $Yupobjtype < DROP_LINK */)
	{
	    /* q_next will be used to point to the first element of the queue */
	    psy_cb->psy_tblq.q_next = (PSF_QUEUE *) NULL;

	    /* q_prev will be used to point to the last element of the queue */
	    psy_cb->psy_tblq.q_prev = (PSF_QUEUE *) NULL;
	}

	if ($Yupobjtype == REMOVE_PROCEDURE)
	{
	    /* set flag so that psy_kview will destroy QP */
	    psy_cb->psy_flags |= PSY_REMOVE_PROC;
	}
    }
;

drop_prefix:	    DROP
    {
	/* initialize object type var */
	$Yupobjtype = 0L;
    }
	    |	    DROP TABLE
    {
	/* set object type var */
	$Yupobjtype = DROP_BASETABLE;
    }
	    |	    DROPVIEW
    {
	/* set object type var */
	$Yupobjtype = DROP_VIEW;
    }
	    |	    DROP INDEX
    {
	i4	    err_code;

	/* "DROP INDEX" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(5208L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error,0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	/* set object type var */
	$Yupobjtype = DROP_INDEX;
    }
	    |	    DROPLINK

    {
	/* DROP LINK is allowed ONLY in distributed */
	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	    err_code;

	    (VOID) psf_error(2086L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 1,sizeof("DROP LINK") - 1,
			     "DROP LINK");
	    return (E_DB_ERROR);
	}

	/* set object type var */
	$Yupobjtype = DROP_LINK;
    }
	    |	    REMOVE
    {
	/* set object type var */
	$Yupobjtype = REMOVE_OBJ;
    }
	    |	    REMOVE TABLE
    {
	/* set object type var */
	$Yupobjtype = REMOVE_TBL;
    }
	    |	    REMOVE VIEW
    {
	/* REMOVE VIEW is allowed ONLY in distributed */
	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	    err_code;

	    (VOID) psf_error(2086L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 1,STlength("REMOVE VIEW"),
			     "REMOVE VIEW");
	    return (E_DB_ERROR);
	}

	/* set object type var */
	$Yupobjtype = REMOVE_VIEW;
    }
	    |	    REMOVE INDEX
    {
	i4	    err_code;

	/* set object type var */
	$Yupobjtype = REMOVE_INDEX;
	
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    /* Note that in this release it is not allowed in STAR */
	    (VOID) psf_error(5208L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error,0);
	    return(E_DB_ERROR);
	}
    }
	    |	    REMOVE PROCEDURE
    {
	/* REMOVE PROCEDURE is allowed ONLY in distributed */
	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	    err_code;

	    (VOID) psf_error(2086L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 1,STlength("REMOVE PROCEDURE"),
			     "REMOVE PROCEDURE");
	    return (E_DB_ERROR);
	}

	/* set object type var */
	$Yupobjtype = REMOVE_PROCEDURE;
    }
;

drop_syn:	    DROPSYNONYM
    {
	i4                err_code;
	DB_STATUS	       status;

	/* "DROP SYNONYM" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("DROP SYNONYM")-1, "DROP SYNONYM");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	psq_cb->psq_mode = PSQ_DSYNONYM;

	if ((status = psy_qminit(cb, psq_cb, &cb->pss_ostream)) != E_DB_OK)
	    return(status);
    }
;

drop_obj_list:      drop_obj
          |	    drop_obj_list COMMA drop_obj
;

drop_syn_list:	    drop_syn_item
	     |	    drop_syn_list COMMA drop_syn_item
;

drop_syn_item:	    obj_spec
    {
	PSS_RNGTAB		*resrange;
	i4			err_code;
	DB_STATUS		status;
	i4			rngvar_info;

	/*
	** First we need to determine if the name specified by the user
	** refers to a synonym owned by this user
	*/
	if ($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp(cb->pss_user.db_own_name, 
		  $1->pss_owner.db_own_name, sizeof(DB_OWN_NAME)))
	{
	    (VOID) psf_error(E_PS042E_DROPSYN_NOT_OBJ_OWNER, 0L,
		PSF_USERERR, &err_code, &psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &$1->pss_owner),
		&$1->pss_owner);
	}
	else
	{
	    /* only search for objects owned by the current user */
	    status = psl0_orngent(&cb->pss_auxrng, -1, "", &cb->pss_user,
		&$1->pss_obj_name, cb, TRUE, &resrange, psq_cb->psq_mode,
		&psq_cb->psq_error, &rngvar_info, 0);

	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);
	    }

	    /* current user doesn't own an object with this name */
	    if (resrange == (PSS_RNGTAB *) NULL)
	    {
		(VOID) psf_error(2753L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 2,
		    sizeof("DROP SYNONYM") - 1, "DROP SYNONYM",
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &$1->pss_obj_name),
		    &$1->pss_obj_name);
	    }
	    else if (~rngvar_info & PSS_BY_SYNONYM)
	    {
		/* object is not a synonym */

		char	    *obj_type, *op;
		i4	    mask;
		i4	    obj_len, op_len;

		mask = resrange->pss_tabdesc->tbl_status_mask;
		if (mask & DMT_VIEW)
		{
		    obj_type = "view";
		    obj_len  = sizeof("view") - 1;
		    op       = "DROP [VIEW]";
		    op_len   = sizeof("DROP [VIEW]") - 1;
		}
		else if (mask & DMT_IDX)
		{
		    obj_type = "index";
		    obj_len  = sizeof("index") - 1;
		    op       = "DROP [INDEX]";
		    op_len   = sizeof("DROP [INDEX]") - 1;
		}
		else
		{
		    obj_type = "table";
		    obj_len  = sizeof("table") - 1;
		    op       = "DROP [TABLE]";
		    op_len   = sizeof("DROP [TABLE]") - 1;
		}

		(VOID) psf_error(E_PS0457_DROPSYN_NOT_SYN, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 3,
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &$1->pss_obj_name),
		    &$1->pss_obj_name, 
		    obj_len, obj_type, 
		    op_len, op);
	    }
	    else
	    {
		PSY_CB	*psy_cb = (PSY_CB *) cb->pss_object;
		i4	mask = resrange->pss_tabdesc->tbl_status_mask;

		/* Check for too many tables to fit into control block */
		if (psy_cb->psy_numtabs == PSY_MAXTABS)
		{
		    (VOID) psf_error(2754L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 0);
		    return (E_DB_ERROR);
		}

		/* Put synonym name into PSY_CB */
		STRUCT_ASSIGN_MACRO($1->pss_obj_name,
				    psy_cb->psy_tabname[psy_cb->psy_numtabs]);

		/*
		** store id of the object whose synonym is being dropped so that
		** we can change its timestamp (if it is not a view) or that of
		** an underlying base table (if it is a view)
		*/
		STRUCT_ASSIGN_MACRO(resrange->pss_tabid,
				    psy_cb->psy_tables[psy_cb->psy_numtabs]);

		/*
		** if dropping a synonym which was created for a view, set a
		** flag for psy_drop_synonym()
		*/
		psy_cb->psy_obj_mask[psy_cb->psy_numtabs++] = (mask & DMT_VIEW)
								? PSY_IS_VIEW
								: 0;
	    }
	}
    }
;

drop_obj:	    obj_spec
    {
	DD_OBJ_DESC		*obj_desc;
	DD_OBJ_TYPE		ldb_obj_type;
	PSS_RNGTAB		*resrange;
	i4			err_code;
	DB_STATUS		status;
	i4			rngvar_info;
	char			*cmnd;
	i4			cmnd_len;
	i4			op_code;

	/* Set up parameters for various error messages */
	if ($Yupobjtype <= DROP_LINK)
	{
	    cmnd = "DROP";
	    cmnd_len = 4;
	}
	else if ($Yupobjtype == REMOVE_PROCEDURE)
	{
	    cmnd = "REMOVE PROCEDURE";
	    cmnd_len = 16;
	}
	else
	{
	    cmnd = "REMOVE";
	    cmnd_len = 6;
	}

	/* First try to obtain table description */
	{
	    i4		lookup_mask = 0;

	    if (cb->pss_distrib & DB_3_DDB_SESS)
	    {
		/*
		** RDF flags to distinguish between drop and remove;
		** also (if user has system catalog update privilege)
		** to let RDF know that local object owner may be
		** different from current user
		*/
		lookup_mask = (($Yupobjtype >= DROP_LINK) ?
				PST_CHECK_EXIST | PST_REMOVE : PST_DTBL);
		if (lookup_mask & PST_DTBL && cb->pss_ses_flag & PSS_CATUPD)
		    lookup_mask |= PST_IS_CATALOG;
	    }

	    if ($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    {	
		status = psl0_orngent(&cb->pss_auxrng, -1, "", &$1->pss_owner,
		    &$1->pss_obj_name, cb, TRUE, &resrange, psq_cb->psq_mode,
		    &psq_cb->psq_error, &rngvar_info, lookup_mask);
	    }
	    else
	    {
		i4	tbls_to_lookup;
		char	*ch1, *ch2;

		if (~cb->pss_distrib & DB_3_DDB_SESS)
		{
		    tbls_to_lookup = PSS_USRTBL | PSS_DBATBL | PSS_INGTBL;
		    
		    /* One may drop an index on a session temp table */
		    if ( $Yupobjtype == DROP_INDEX ||
			cb->pss_ses_flag & PSS_GTT_SYNTAX_SHORTCUT )
			tbls_to_lookup |= PSS_SESTBL;
		}
		else
		{
		    ch1 = $1->pss_obj_name.db_tab_name;
		    ch2 = ch1 + CMbytecnt(ch1);

		    /* If table name starts with "ii" and user has system
		    ** catalog update privilege check table as an "INGRES"
		    ** table only.
		    */

		    if (  !CMcmpnocase(ch1, &SystemCatPrefix[0]) &&
			  !CMcmpnocase(ch2, &SystemCatPrefix[1]) &&
			  cb->pss_ses_flag & PSS_CATUPD
			)
		    {
			tbls_to_lookup = PSS_INGTBL;
		    }
		    else
		    {
			tbls_to_lookup = PSS_USRTBL;
		    }
		}
		status = psl0_rngent(&cb->pss_auxrng, -1, "",
		    &$1->pss_obj_name, cb, TRUE, &resrange, psq_cb->psq_mode,
		    &psq_cb->psq_error, tbls_to_lookup, &rngvar_info,
		    lookup_mask);
	    }
	    
	    if (DB_FAILURE_MACRO(status))
	    {
		if (~cb->pss_distrib & DB_3_DDB_SESS)
		    return (status);
		if (    psq_cb->psq_error.err_code != E_PS0916_USER_NOT_OWNER
		    &&	psq_cb->psq_error.err_code != E_PS0919_BAD_CATALOG_ENTRY
		    &&	psq_cb->psq_error.err_code != E_PS091A_CANNOT_CONNECT)
		{
		    return (status);
		}
	    }

	    if (resrange == (PSS_RNGTAB *) NULL)
	    {
		if (DB_FAILURE_MACRO(status))	/* Star */
		{
		    (VOID) psf_error(psq_cb->psq_error.err_code, 0L,
			PSF_USERERR, &err_code, &psq_cb->psq_error, 1,
			psf_trmwhite(sizeof(DB_TAB_NAME),
				(char *) &$1->pss_obj_name),
				&$1->pss_obj_name);
		}
		else if ($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
		{
		    (VOID) psf_error(2764L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 3, cmnd_len, cmnd,
			psf_trmwhite(sizeof(DB_TAB_NAME),
			    (char *) &$1->pss_obj_name),
			&$1->pss_obj_name,
			psf_trmwhite(sizeof(DB_OWN_NAME),
			    (char *) &$1->pss_owner),
			&$1->pss_owner);
		}
		else
		{
		    (VOID) psf_error(2753L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 2, cmnd_len, cmnd,
			psf_trmwhite(sizeof(DB_TAB_NAME), 
			    (char *) &$1->pss_obj_name),
			&$1->pss_obj_name);
		}
	    }
	    /*
	    ** DROP synonym_name will be disallowed
	    */
	    else if (rngvar_info & PSS_BY_SYNONYM && $Yupobjtype == 0)
	    {
		(VOID) psf_error(E_PS0452_CANT_DROP_SYN, 0L,
		    PSF_USERERR, &err_code, &psq_cb->psq_error, 1, 
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &$1->pss_obj_name),
		    &$1->pss_obj_name);

		resrange = (PSS_RNGTAB *) NULL;
	    }
	    /*								    
	    ** Object is not a catalog (i.e. it is a table) AND
	    ** it is not owned by the user AND
	    ** is not a DGTT, AND
	    ** (the user is neither a DBA nor $ingres OR
	    ** dba_drop_all flag is not set OR
	    ** object name was not explicitly qualified OR
	    ** user used a synonym).
	    */
	    else if (~resrange->pss_tabdesc->tbl_status_mask & DMT_CATALOG
		     &&
		     MEcmp((PTR) &resrange->pss_ownname, 
			    (PTR) &cb->pss_user, sizeof(DB_OWN_NAME))
		     && 
		     MEcmp((PTR) &resrange->pss_ownname,
			    (PTR) &cb->pss_sess_owner,
			    sizeof(DB_OWN_NAME))
		     &&
		     (~$1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
			||
		      !(cb->pss_ses_flag & PSS_DBA_DROP_ALL)
			||
		      rngvar_info & PSS_BY_SYNONYM
		        ||
		      (MEcmp((PTR) &cb->pss_user, (PTR) &cb->pss_dba.db_tab_own,
			    sizeof(DB_OWN_NAME))
			    &&
		      MEcmp((PTR) &cb->pss_user, (PTR) cb->pss_cat_owner,
			    sizeof(DB_OWN_NAME)))
		     )
		    )
	    {
		if ( $1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
		     Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{ 
		    /*
		    ** Only audit if fully qualified object name used
		    */
		    /* Must audit DROP Failure. */
		    DB_STATUS	local_status;
		    DB_ERROR	e_error;
		    i4	mask = resrange->pss_tabdesc->tbl_status_mask;
		    i4	msg_id;
		    i4		auditevent;
		    i4	accessmask = SXF_A_FAIL;

		    if (mask & DMT_VIEW)
		    {
		    	auditevent = SXF_E_VIEW;
		    	msg_id     = I_SX2015_VIEW_DROP;
		    	accessmask |= SXF_A_DROP;
		    }
		    else if (mask & DMT_IDX)
		    {
		    	auditevent = SXF_E_TABLE;
		    	msg_id     = I_SX2010_INDEX_DROP;
                    	accessmask |= SXF_A_INDEX;
		    }
		    else
		    {
		    	auditevent = SXF_E_TABLE;
		    	msg_id     = I_SX2025_TABLE_DROP;
		    	accessmask |= SXF_A_DROP;
		    }
	            local_status = psy_secaudit(FALSE, cb,
	    		(char *)&resrange->pss_tabdesc->tbl_name,
			&resrange->pss_tabdesc->tbl_owner,
	    		sizeof(DB_TAB_NAME), auditevent,
	      		msg_id, accessmask,
	      		&e_error);
		}
		/*
		** let user know if name supplied by the user was resolved to a
		** synonym
		*/
		if (rngvar_info & PSS_BY_SYNONYM)
		{
		    char	*op;
		    i4		len;

		    switch($Yupobjtype)
		    {
			case DROP_BASETABLE:
			    op = "DROP TABLE";
			    len = sizeof("DROP TABLE") - 1;
			    break;
			case DROP_INDEX:
			    op = "DROP INDEX";
			    len = sizeof("DROP INDEX") - 1;
			    break;
			case DROP_VIEW:
			    op = "DROP VIEW";
			    len = sizeof("DROP VIEW") - 1;
			    break;
			case REMOVE_TBL:
			    op = "REMOVE TABLE";
			    len = sizeof("REMOVE TABLE") - 1;
			    break;
			case REMOVE_OBJ:
			    op = "REMOVE";
			    len = sizeof("REMOVE") -1;
			    break;
			default:
			    /*
			    ** E_PS1004_BAD_OBJ_TYPE:
			    ** Invalid type '%0d' detected when '%1c'
			    */
			    (VOID) psf_error(E_PS1004_BAD_OBJ_TYPE, 
				0L, PSF_INTERR, &err_code,
				&psq_cb->psq_error, 2,
				sizeof($Yupobjtype), &$Yupobjtype,
				sizeof("SYNONYM DROP/REMOVE") - 1,
				"SYNONYM DROP/REMOVE");
					
			    /* Should never get here */
			    break;
		    }

		    psl_syn_info_msg(cb, resrange, $1, rngvar_info,
			len, op, &psq_cb->psq_error);
		}

		if (   $1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA 
		    && ~rngvar_info & PSS_BY_SYNONYM)
		{
		    /*
		    ** this error msg will be printed only if the user qualified
		    ** table name with its owner's name + and it was not a
		    ** synonym
		    */
		    (VOID) psf_error(2765L, 0L, PSF_USERERR,&err_code, 
			&psq_cb->psq_error, 3, cmnd_len, cmnd,
			psf_trmwhite(sizeof(DB_TAB_NAME),
			    (char *) &resrange->pss_tabname),
			&resrange->pss_tabname,
			psf_trmwhite(sizeof(DB_OWN_NAME),
			    (char *) &resrange->pss_ownname),
			&resrange->pss_ownname);
		}
		else
		{
		    (VOID) psf_error(2753L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 2, cmnd_len, cmnd,
			psf_trmwhite(sizeof(DB_TAB_NAME),
			    (char *) &resrange->pss_tabname),
			&resrange->pss_tabname);
		}
		resrange = (PSS_RNGTAB *) NULL;
	    }
	}

	/*
	** If we passed the above checks, do some some more consistency
	** checking, and, if everything computes, add table to the list of
	** objects to be dropped
	*/
	if (resrange != (PSS_RNGTAB *) NULL)
	{
	    PSY_CB	    *psy_cb;
	    i4	    mask, err_num = 0L;
	    i4         mask2;
	    char	    *tab_name, *op;
	    i4		    len;
	    
	    status = E_DB_OK;		    /* being optimistic */
		
	    cb->pss_resrng = resrange;
	    tab_name = resrange->pss_tabname.db_tab_name;
	    mask = resrange->pss_tabdesc->tbl_status_mask;
	    mask2 = resrange->pss_tabdesc->tbl_2_status_mask;

	    psy_cb = (PSY_CB *) cb->pss_object;

	    if (cb->pss_distrib & DB_3_DDB_SESS)
	    {
		/* distributed only checks handled later */
		err_num = 0;
	    }
	    /* Make sure we have the right type of object */
	    else if ($Yupobjtype == DROP_BASETABLE)
	    {
		if (mask & DMT_VIEW || mask & DMT_IDX)
		{
		    err_num = 2750L;
		}
	    }
	    else if ($Yupobjtype == DROP_VIEW)
	    {
		if (~mask & DMT_VIEW)
		{
		    err_num = 2751L;
		}
	    }
	    else if ($Yupobjtype == DROP_INDEX)
	    {
		if (~mask & DMT_IDX)
		{
		    err_num = 2752L;
		}
	    }
	    else if ($Yupobjtype == REMOVE_TBL) 
	    {
		if (~mask & DMT_GATEWAY)
		{
			/* E_US2233_8755 REMOVE [TABLE]: object '%0c' is not a gateway object*/
			err_num=8755L;
		}
	    }
	    else if ($Yupobjtype == REMOVE_OBJ)
	    {
		if (~mask & DMT_GATEWAY)
		{
			/* E_US2233_8755 REMOVE [TABLE]: object '%0c' is not a gateway object*/
			err_num=8755L;
		}
	    }

	    /* make sure object is user-droppable
	    ** (but don't change error number if already found an error)
	    */
	    if ((resrange->pss_tabdesc->tbl_2_status_mask & DMT_NOT_DROPPABLE)
		&& (err_num == 0L))
	    {
		err_num = E_US18AB_6315_NOT_DROPPABLE;
	    }

	    if ((resrange->pss_tabdesc->tbl_2_status_mask & DMT_READONLY)
		&& (err_num == 0L))
	    {
		err_num = E_US14E8_5352_DROP_READONLY;
	    }  

	    if (err_num != 0L)
	    {
		/* find out which command this is, for error text
		 */
		switch ($Yupobjtype)
		{
		case DROP_BASETABLE:
		    op = "DROP TABLE";
		    len = sizeof("DROP TABLE") - 1;
		    break;
		case DROP_VIEW:
		    op = "DROP VIEW";
		    len = sizeof("DROP VIEW") - 1;
		    break;
		case DROP_INDEX:
		    op = "DROP INDEX";
		    len = sizeof("DROP INDEX") - 1;
		    break;
		case REMOVE_TBL:
		    op="REMOVE TABLE";
		    len = sizeof("REMOVE TABLE") - 1;
		    break;
		case REMOVE_OBJ:
		    op="REMOVE";
		    len = sizeof("REMOVE") - 1;
		    break;
		default:
		    op = "";
		    len = 0;
		}
		
		/*
		** let user know if name supplied by the user was resolved
		** to a synonym
		*/
		if (rngvar_info & PSS_BY_SYNONYM)
		{
		    psl_syn_info_msg(cb, resrange, $1, rngvar_info,
			len, op, &psq_cb->psq_error);
		}

		if ((err_num == E_US18AB_6315_NOT_DROPPABLE) 
				||
		    (err_num == E_US14E8_5352_DROP_READONLY) )
		{
		    (VOID) psf_error(err_num, 0L, PSF_USERERR,
				&err_code, &psq_cb->psq_error, 2,
				len, op, 
				psf_trmwhite(sizeof(DB_TAB_NAME), tab_name),
				tab_name);
		}
		else
		{
		    (VOID) psf_error(err_num, 0L, PSF_USERERR, &err_code,
				&psq_cb->psq_error, 1,
				psf_trmwhite(sizeof(DB_TAB_NAME), tab_name),
				tab_name);
		}
		status = E_DB_ERROR;
	    }
	    /*
	    ** If object is a catalog, one may drop it if one has a
	    ** catalog update privilege AND it is not a CORE catalog.
	    ** For distributed, mask will not be set to DMT_CATALOG.
	    **
	    ** 13-jan-93 (andre)
	    **	    if running UPGRADEDB and possess CATUPD, allow destruction
	    **	    of one core catalog - IIDEVICES
	    */
	    else if (   (mask & DMT_CATALOG || mask2 & DMT_TEXTENSION)
		     && (   !(cb->pss_ses_flag & PSS_CATUPD)
			 || (   mask & DMT_CONCURRENCY
			     && (   resrange->pss_tabid.db_tab_base !=
					DM_B_DEVICE_TAB_ID
				 || resrange->pss_tabid.db_tab_index !=
					DM_I_DEVICE_TAB_ID
				 || ~cb->pss_ses_flag & PSS_RUNNING_UPGRADEDB
				)
			    )
			)
		    )
	    {
		/* Must audit DROP Failure. */
		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    DB_STATUS       local_status;
		    DB_ERROR	e_error;
		    i4		msg_id;
		    i4		auditevent;
		    i4		accessmask = SXF_A_FAIL | SXF_A_DROP;

		    if ($Yupobjtype == DROP_VIEW)
		    {
			auditevent = SXF_E_VIEW;
			msg_id     = I_SX2015_VIEW_DROP;
		    }
		    else
		    {
			if ($Yupobjtype == DROP_INDEX)
			{
			    msg_id = I_SX2010_INDEX_DROP;
			    accessmask |= SXF_A_INDEX;
			}
			else
			    msg_id = I_SX2025_TABLE_DROP;
			auditevent = SXF_E_TABLE;
		    }
		    local_status = psy_secaudit(FALSE, cb,
			    tab_name, &cb->pss_user,
			    sizeof(DB_TAB_NAME), auditevent,
			    msg_id, accessmask,
			    &e_error);
		}

		/*
		** let user know if name supplied by the user was resolved
		** to a synonym
		*/
		if (rngvar_info & PSS_BY_SYNONYM)
		{
		    switch($Yupobjtype)
		    {
			case DROP_BASETABLE:
			    op = "DROP TABLE";
			    len = sizeof("DROP TABLE") - 1;
			    break;
			case DROP_INDEX:
			    op = "DROP INDEX";
			    len = sizeof("DROP INDEX") - 1;
			    break;
			case DROP_VIEW:
			    op = "DROP VIEW";
			    len = sizeof("DROP VIEW") - 1;
			    break;
		    }

		    psl_syn_info_msg(cb, resrange, $1, rngvar_info,
			len, op, &psq_cb->psq_error);
		}

		(VOID) psf_error(5103L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 2, sizeof ("DROP") - 1, "DROP",
		    psf_trmwhite(sizeof(DB_TAB_NAME), tab_name), tab_name);
		status = E_DB_ERROR;
	    }

	    else if (cb->pss_distrib & DB_3_DDB_SESS)
	    {
		/*
		** Gather information on local object for QEF; also
		** do some error checking regarding local object.
		*/

		DD_OBJ_TYPE		ddb_obj_type;

		obj_desc = resrange->pss_rdrinfo->rdr_obj_desc;

		ddb_obj_type = obj_desc->dd_o6_objtype;
		ldb_obj_type = obj_desc->dd_o9_tab_info.dd_t3_tab_type;

		/* Make sure we have the right type of object */

		if ((psq_cb->psq_error.err_code != E_PS0000_OK) &&
		    (psq_cb->psq_error.err_code != E_PS0001_USER_ERROR))
		{
		    /*
		    ** Some errors mean only that we wouldn't be able to DROP
		    ** the LDB object, but we will still drop the DDB object
		    */
		    psq_cb->psq_error.err_code = E_PS0000_OK;
		    op_code = (i4) QED_DLINK;
		}
		else
		{
		    switch ($Yupobjtype)
		    {
			case 0L:
			{
			    if (ddb_obj_type == DD_1OBJ_LINK)
			    {
				/*
				** Cannot DROP an object that is a LINK,
				** includes registered table, view and procedure
				*/
                                (VOID) psf_error(2759L, 0L, PSF_USERERR,
                                    &err_code, &psq_cb->psq_error, 2, 
				    4, "DROP",
                                    psf_trmwhite(sizeof(DB_TAB_NAME),
                                    tab_name), tab_name);
                                status = E_DB_ERROR;
			    }
			    else if (ddb_obj_type == DD_3OBJ_VIEW)
			    {
				op_code = (i4) QEU_DVIEW;
			    }
			    else if (ddb_obj_type == DD_2OBJ_TABLE)
			    {
				op_code = (i4) DMU_DESTROY_TABLE;
			    }
			    else 
			    {
				/*
				** Can not DROP an object if the underlying LDB
				** object is of type INDEX
				*/
				(VOID) psf_error(5211L, 0L, PSF_USERERR,
				    &err_code, &psq_cb->psq_error, 2,
		    		    psf_trmwhite(sizeof(DB_TAB_NAME),
				    tab_name), tab_name, cmnd_len, cmnd);
				status = E_DB_ERROR;
			    }

			    break;
			}
			/*
			** STAR object HAS to have been created using
			** CREATE TABLE. 
			*/
			case DROP_BASETABLE:
			{
                            if (ddb_obj_type == DD_1OBJ_LINK)
                            {
                                /*
                                ** Cannot DROP an object that is a LINK
                                */
                                (VOID) psf_error(2759L, 0L, PSF_USERERR,
                                    &err_code, &psq_cb->psq_error, 2,
                                    10, "DROP TABLE",
                                    psf_trmwhite(sizeof(DB_TAB_NAME),
                                    tab_name), tab_name);
                                status = E_DB_ERROR;
                            }
			    else if (ddb_obj_type == DD_2OBJ_TABLE)
			    {
				op_code = (i4) DMU_DESTROY_TABLE;
			    }
			    else
			    {
				char    *type = (ddb_obj_type == DD_3OBJ_VIEW)
								    ? "VIEW"
								    : "INDEX";

				(VOID) psf_error(2755L, 0L, PSF_USERERR,
				    &err_code, &psq_cb->psq_error, 3,5, "TABLE",
		    		    psf_trmwhite(sizeof(DB_TAB_NAME),
				    tab_name), tab_name, STlength(type), type);

				status = E_DB_ERROR;
			    }

			    break;
			}

			case DROP_VIEW:
			{
                            if (ddb_obj_type == DD_1OBJ_LINK)
                            {
                                /*
                                ** Cannot DROP an object that is a LINK
                                */
                                (VOID) psf_error(2759L, 0L, PSF_USERERR,
                                    &err_code, &psq_cb->psq_error, 2,
                                    9, "DROP VIEW",
                                    psf_trmwhite(sizeof(DB_TAB_NAME),
                                    tab_name), tab_name);
                                status = E_DB_ERROR;
                            }
			    else if (ddb_obj_type == DD_3OBJ_VIEW)
			    {
				op_code = (i4) QEU_DVIEW;
			    }
			    else
			    {
				char    *type = (ddb_obj_type == DD_2OBJ_TABLE)
								      ? "TABLE"
								      : "INDEX";

				(VOID) psf_error(2755L, 0L, PSF_USERERR,
				    &err_code, &psq_cb->psq_error, 3,4, "VIEW",
		    		    psf_trmwhite(sizeof(DB_TAB_NAME),
				    tab_name), tab_name, STlength(type), type);

				status = E_DB_ERROR;
			    }

			    break;
			}

			case DROP_INDEX:
			{
                            if (ddb_obj_type == DD_1OBJ_LINK)
                            {
                                /*
                                ** Cannot DROP an object that is a LINK
                                */
                                (VOID) psf_error(2759L, 0L, PSF_USERERR,
                                    &err_code, &psq_cb->psq_error, 2,
                                    10, "DROP INDEX",
                                    psf_trmwhite(sizeof(DB_TAB_NAME),
                                    tab_name), tab_name);
                                status = E_DB_ERROR;
                            }
			    else if (ddb_obj_type == DD_4OBJ_INDEX)
			    {
				op_code = (i4) DMU_DESTROY_TABLE;
			    }
			    else
			    {
				char    *type = (ddb_obj_type == DD_3OBJ_VIEW)
								      ? "VIEW"
								      : "TABLE";

				(VOID) psf_error(2755L, 0L, PSF_USERERR,
				    &err_code, &psq_cb->psq_error, 3,5, "INDEX",
		    		    psf_trmwhite(sizeof(DB_TAB_NAME),
				    tab_name), tab_name, STlength(type), type);

				status = E_DB_ERROR;
			    }

			    break;
			}

			case DROP_LINK:
			case REMOVE_OBJ:
			case REMOVE_TBL:
			case REMOVE_VIEW:
			case REMOVE_INDEX:
			case REMOVE_PROCEDURE:
			{
			    /*
			    ** remove can now be used on all objects, not just
			    ** those created using REGISTER/CREATE LINK, but we
			    ** still cannot REMOVE an object created via CREATE
			    ** VIEW
			    */
			    if (ddb_obj_type == DD_3OBJ_VIEW)
			    {
				(VOID) psf_error(2758L, 0L, PSF_USERERR,
				    &err_code, &psq_cb->psq_error, 1,
		    		    psf_trmwhite(sizeof(DB_TAB_NAME),
				    tab_name), tab_name);

				status = E_DB_ERROR;
			    }
			    else
			    {
				char	*type;
				char	*rmv_word;
				
				if (ldb_obj_type == DD_2OBJ_TABLE)
				    type = "TABLE";
				else if (ldb_obj_type == DD_3OBJ_VIEW)
				    type = "VIEW";
				else if (ldb_obj_type == DD_4OBJ_INDEX)
				    type = "INDEX";
				else if (ldb_obj_type == DD_5OBJ_REG_PROC)
				    type = "PROCEDURE";
 			   	else type = "UNKNOWN";

				/*
				** first check if there is a conflict between
				** object type as specified by the user and the
				** actual object type
				*/

				if (($Yupobjtype == DROP_LINK ||
					 $Yupobjtype == REMOVE_OBJ)
				    && (ldb_obj_type == DD_5OBJ_REG_PROC))
				{
				    status = E_DB_ERROR;
				    rmv_word = "";
				}
				else if (($Yupobjtype == REMOVE_TBL) &&
				    (ldb_obj_type != DD_2OBJ_TABLE))
				{
				    status = E_DB_ERROR;
				    rmv_word = "TABLE";
				}
				else if (($Yupobjtype == REMOVE_VIEW) &&
					 (ldb_obj_type != DD_3OBJ_VIEW))
				{
				    status = E_DB_ERROR;
				    rmv_word = "VIEW";
				}
				else if (($Yupobjtype == REMOVE_INDEX) &&
					 (ldb_obj_type != DD_4OBJ_INDEX))
				{
				    status = E_DB_ERROR;
				    rmv_word = "INDEX";
				}
				else if (($Yupobjtype == REMOVE_PROCEDURE) &&
					 (ldb_obj_type != DD_5OBJ_REG_PROC))
				{
				    status = E_DB_ERROR;
				    rmv_word = "PROCEDURE";
				}
				else 
				{
				    op_code = (i4) QED_DLINK;
				}

				/*
				** if user specified incorrect type, report
				** error; otherwise check if the user tried to
				** use DROP LINK or REMOVE to remove an index,
				** and if so, report an error
				*/
				if (status == E_DB_ERROR)
				{
				    if (ldb_obj_type == DD_5OBJ_REG_PROC)
				    {
					(VOID) psf_error(E_PS1204_RMV_WRONGTYPE, 
					    0L, PSF_USERERR,
					    &err_code, &psq_cb->psq_error,2,
					    STlength(rmv_word), rmv_word,
					    psf_trmwhite(sizeof(DB_TAB_NAME),
				            tab_name), tab_name);
				    }
				    else
				    {
				        (VOID) psf_error(2757L, 0L, PSF_USERERR,
					    &err_code, &psq_cb->psq_error,3,
					    STlength(rmv_word), rmv_word,
					    psf_trmwhite(sizeof(DB_TAB_NAME),
				            tab_name), tab_name,
					    STlength(type),type);
				    }
				}
				else if (ldb_obj_type == DD_4OBJ_INDEX &&
				         $Yupobjtype != REMOVE_INDEX)
				{
				    if ($Yupobjtype == REMOVE_OBJ)
				    {
					rmv_word = "REMOVE";
				    }
				    else    /* must be DROP LINK */
				    {
					rmv_word = "DROP LINK";
				    }

				    (VOID) psf_error(5211L, 0L, PSF_USERERR,
					&err_code, &psq_cb->psq_error,2,
					psf_trmwhite(sizeof(DB_TAB_NAME),
				        tab_name), tab_name, STlength(rmv_word),
					rmv_word);

				    status = E_DB_ERROR;
				}
			    }

			    break;
			}
		    }
		}	/* else if there were no errors from pst_rgent */
	    }

	    if (status == E_DB_OK)
	    {
		/* Check for too many tables to fit into control block */
		if (psy_cb->psy_numtabs == PSY_MAXTABS)
		{
		    (VOID) psf_error(2754L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 0);
		    return (E_DB_ERROR);
		}

		/* Put it in the control block, along with the table name */
		if (~cb->pss_distrib & DB_3_DDB_SESS)
		{
		    STRUCT_ASSIGN_MACRO(resrange->pss_tabid,
				    psy_cb->psy_tables[psy_cb->psy_numtabs]);
		    STRUCT_ASSIGN_MACRO(resrange->pss_tabname,
				    psy_cb->psy_tabname[psy_cb->psy_numtabs]);

		    if (resrange->pss_tabdesc->tbl_temporary)
		    {
			/* if dropping a temp table, set a flag for psy_kview */
			psy_cb->psy_obj_mask[psy_cb->psy_numtabs++]
							= PSY_IS_TMPTBL;
		    }
		    else if (mask & DMT_VIEW)
		    {
			/* if dropping a view, set a flag for psy_kview() */
			psy_cb->psy_obj_mask[psy_cb->psy_numtabs++]
							= PSY_IS_VIEW; 
		    }
		    else
		    {
			psy_cb->psy_obj_mask[psy_cb->psy_numtabs++] = 0;
		    }
		}
		else	/* distributed */
		{
		    psy_cb->psy_numbs[psy_cb->psy_numtabs] = op_code;

		    if ($Yupobjtype == REMOVE_PROCEDURE)
		    {
			/* psy_kregproc needs procedure name to remove QP */
		    	STRUCT_ASSIGN_MACRO(resrange->pss_tabname,
				    psy_cb->psy_tabname[psy_cb->psy_numtabs]);
		    }

		    STRUCT_ASSIGN_MACRO(obj_desc->dd_o3_objid,
			psy_cb->psy_tables[psy_cb->psy_numtabs++]);

		    /*
		    ** If dropping a STAR object where the underlying LDB
		    ** object is a TABLE or an INDEX, we need to provide some
		    ** additional info for QEF in psy_kview().
		    */

		    if (op_code == DMU_DESTROY_TABLE)
		    {
			PSS_LTBL_INFO	    *ltbl_info;		    
			PSS_LTBL_INFO	    **last =
				    (PSS_LTBL_INFO **) &psy_cb->psy_tblq.q_prev;

			status = psf_malloc(cb, &cb->pss_ostream,
				sizeof(PSS_LTBL_INFO), (PTR *) &ltbl_info,
				&psq_cb->psq_error);

			if (status != E_DB_OK)
			{
			    return (status);
			}

			/* store LDB table name */
			MEcopy((PTR) obj_desc->dd_o9_tab_info.dd_t1_tab_name,
			       sizeof(DD_NAME),
			       (PTR) ltbl_info->pss_tbl_name);

			/* store LDB object type; will be TABLE, VIEW or INDEX */
			if (ldb_obj_type == DD_2OBJ_TABLE)
			{
			    ltbl_info->pss_obj_type = PSS_LTBL_IS_BASETABLE;
			}
			else if (ldb_obj_type == DD_3OBJ_VIEW)
			{
			    ltbl_info->pss_obj_type = PSS_LTBL_IS_VIEW;
			}
			else
			{
			    ltbl_info->pss_obj_type = PSS_LTBL_IS_INDEX;
			}

			/* Flag whether or not table name should be delimited */
			if (resrange->pss_rdrinfo->rdr_obj_desc->dd_o9_tab_info.
				dd_t9_ldb_p->dd_i2_ldb_plus.dd_p3_ldb_caps.
				dd_c1_ldb_caps & DD_8CAP_DELIMITED_IDS)
			{
			    ltbl_info->pss_delim_tbl = 1;
			}
			else
			{
			    ltbl_info->pss_delim_tbl = 0;
			}
			STRUCT_ASSIGN_MACRO(
			    obj_desc->dd_o9_tab_info.dd_t9_ldb_p->dd_i1_ldb_desc,
			    ltbl_info->pss_ldb_desc); 

			if (*last == (PSS_LTBL_INFO *) NULL)
			{
			    *last = ltbl_info;
			    psy_cb->psy_tblq.q_next = (PSF_QUEUE *) ltbl_info;
			}
			else
			{
			    (*last)->pss_next = ltbl_info;
			    *last = ltbl_info;
			}
		    }    /* dropping a table */
		}    /* distributed */
	    }    /* status == OK */
	}    /* store the object ID for QEF */
    }
;

dropinteg:	    dropintegstmnt obj_spec dropipspec
    {
	PSY_CB		    *psy_cb;
	DB_STATUS	    status;
	i4		    rngvar_info;
	PSS_RNGTAB	    *resrange;
	i4		    err_code;
	i4		    mask;
	i4		    mask2;

	/* Find table id */

	if ($2->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, "", &$2->pss_owner,
			&$2->pss_obj_name, cb, FALSE, &resrange,
			psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, -1, "", &$2->pss_obj_name, cb,
		FALSE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
		&rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    $2->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (status != E_DB_OK)
	    return (status);

	mask = resrange->pss_tabdesc->tbl_status_mask;
	mask2 = resrange->pss_tabdesc->tbl_2_status_mask;

	if (mask & DMT_CATALOG || mask2 & DMT_TEXTENSION)
	{
	    /* If not an extended catalog and no catalog update
	    ** permission - error.
	    */
	    if (~mask & DMT_EXTENDED_CAT && !(cb->pss_ses_flag & PSS_CATUPD) )
	    {
		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    DB_STATUS	local_status;
		    DB_ERROR	e_error;
		    /*
		    ** Audit failure to drop integrity
		    */
		    local_status = psy_secaudit( FALSE, cb,
			    resrange->pss_tabname.db_tab_name, 
			    &resrange->pss_ownname,
			    sizeof(resrange->pss_tabname), SXF_E_TABLE,
			    I_SX2036_INTEGRITY_DROP, SXF_A_FAIL | SXF_A_CONTROL,
			    &e_error);
		}

		/*
		** let user know if name supplied by the user was resolved to a
		** synonym
		*/
		if (rngvar_info & PSS_BY_SYNONYM)
		{
		    psl_syn_info_msg(cb, resrange, $2, rngvar_info,
			sizeof("DROP INTEGRITY")-1, "DROP INTEGRITY",
			&psq_cb->psq_error);
		}

		(VOID) psf_error(5103L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 2, 
		    sizeof ("DROP INTEGRITY") - 1, "DROP INTEGRITY", 
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &resrange->pss_tabname), 
		    &resrange->pss_tabname);
		return (E_DB_ERROR);
	    }
	}
	else if (MEcmp((PTR) &resrange->pss_ownname, 
	    (PTR) &cb->pss_user, sizeof(DB_OWN_NAME)))
	{
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_STATUS	local_status;
		DB_ERROR	e_error;
		/*
		** Audit failure to drop integrity
		*/
		local_status = psy_secaudit( FALSE, cb,
		    resrange->pss_tabname.db_tab_name, &resrange->pss_ownname,
		    sizeof(resrange->pss_tabname), SXF_E_TABLE,
		    I_SX2036_INTEGRITY_DROP, SXF_A_FAIL | SXF_A_CONTROL,
		    &e_error);
	    }

	    /*
	    ** let user know if name supplied by the user was resolved to a
	    ** synonym
	    */
	    if (rngvar_info & PSS_BY_SYNONYM)
	    {
		psl_syn_info_msg(cb, resrange, $2, rngvar_info,
		    sizeof("DROP INTEGRITY")-1, "DROP INTEGRITY",
		    &psq_cb->psq_error);
	    }

	    (VOID) psf_error(E_PS0424_ILLEGAL_TBL_REF, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 3,
		sizeof("DROP INTEGRITY") - 1, "DROP INTEGRITY",
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &resrange->pss_tabname),
		&resrange->pss_tabname,
		psf_trmwhite(sizeof(DB_OWN_NAME), 
		    (char *) &resrange->pss_ownname),
		&resrange->pss_ownname);
	    return (E_DB_ERROR);
	}

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Put it in the control block, along with the table name */
	STRUCT_ASSIGN_MACRO(resrange->pss_tabid,
			    psy_cb->psy_tables[psy_cb->psy_numtabs]);
	STRUCT_ASSIGN_MACRO($2->pss_obj_name,
			    psy_cb->psy_tabname[psy_cb->psy_numtabs++]);
    }
;

dropintegstmnt:    DROPINTEG ON
     {
	i4                err_code;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_DSTINTEG;

	/* "drop integrity" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(5206L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate a PSY_CB for drop integrity */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);
    }
;


dropperm:             droppermstmnt ON obj_spec dropipspec
    {
	PSY_CB                 *psy_cb;

	DB_STATUS	    status;
	PSS_RNGTAB	    *resrange;
	i4		    err_code;
	i4		    mask;
	i4		    mask2;
	DB_STATUS	    local_status;
	char		    obj_name[sizeof(DB_TAB_NAME) + sizeof(DB_OWN_NAME)];
	char		    *op = (psq_cb->psq_mode == PSQ_DSTPERM)
					? "DROP PERMIT"
					: "DROP SECURITY_ALARM";
	i4		    len = (psq_cb->psq_mode == PSQ_DSTPERM)
					? sizeof("DROP PERMIT") - 1
					: sizeof("DROP SECURITY_ALARM") - 1;
	i4		    rngvar_info;


	/******************************************************************
	** NOTE * NOTE * NOTE * NOTE * NOTE * NOTE * NOTE * NOTE * NOTE *
	*******************************************************************
	**
	** The DROP SECURITY_ALARM statement is also recognized thru these
	** productions.  Semantic checks to ensure statement consistency
	** is performed in this production.  When extending DROP PERMIT,
	** be sure to preserve the integrity of DROP SECURITY_ALARM.
	**
	******************************************************************/
	
	/* Find table id */

	if ($3->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, "", &$3->pss_owner,
			&$3->pss_obj_name, cb, FALSE, &resrange,
			psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, -1, "", &$3->pss_obj_name, cb,
		FALSE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
		&rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    $3->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (status != E_DB_OK)
	    return (status);

	mask = resrange->pss_tabdesc->tbl_status_mask;
	mask2 = resrange->pss_tabdesc->tbl_2_status_mask;

	MEcopy(resrange->pss_tabdesc->tbl_name.db_tab_name, 
	       sizeof(DB_TAB_NAME), obj_name);
	MEcopy(resrange->pss_tabdesc->tbl_owner.db_own_name, 
	       sizeof(DB_OWN_NAME), obj_name + sizeof(DB_TAB_NAME));

	/*
	** One no longer has to be a DBA or $INGRES in order to
	** DROP PERMIT/SECURITY_ALARM on tables other than catalogues.
	*/
	
	if (!psy_permit_ok(mask, cb, &resrange->pss_ownname))
	{
	    /* audit DROP PERMIT/SECURITY ALARM */
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_ERROR		e_error;

		local_status = psy_secaudit(FALSE, cb,
			    (char *)&resrange->pss_tabdesc->tbl_name,
			    &resrange->pss_tabdesc->tbl_owner,
			    sizeof(DB_TAB_NAME), SXF_E_TABLE,
			    I_SX2018_PROT_TAB_DROP,
			    SXF_A_FAIL | SXF_A_CONTROL,
			    &e_error);
	    }
	    /*
	    ** let user know if name supplied by the user was resolved to a
	    ** synonym
	    */
	    if (rngvar_info & PSS_BY_SYNONYM)
	    {
		psl_syn_info_msg(cb, resrange, $3, rngvar_info,
		    len, op, &psq_cb->psq_error);
	    }

	    if (   (mask & DMT_CATALOG || mask2 & DMT_TEXTENSION)
		&& ~mask & DMT_EXTENDED_CAT)
	    {
		/*
		** tried to DROP PERMIT/SECURITY_ALARM on system catalog
		** w/o catalog update privilege
		*/

		(VOID) psf_error(5103L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 2, 
		    len, op,
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &resrange->pss_tabname),
		    &resrange->pss_tabname);
	    }
	    else if (   $3->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA 
		     && ~rngvar_info & PSS_BY_SYNONYM)
	    {
		/*
		** this error msg will be printed only if the user qualified
		** table name with its owner's name + and it was not a synonym
		*/
		(VOID) psf_error(E_PS0424_ILLEGAL_TBL_REF, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 3, 
		    len, op,
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &resrange->pss_tabname),
		    &resrange->pss_tabname,
		    psf_trmwhite(sizeof(DB_OWN_NAME), 
			(char *) &resrange->pss_ownname),
		    &resrange->pss_ownname);
	    }
	    else
	    {
		(VOID) psf_error(2753L, 0L, PSF_USERERR,&err_code, 
		    &psq_cb->psq_error, 2, 
		    len, op,
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &resrange->pss_tabname),
		    &resrange->pss_tabname);
	    }

	    return(E_DB_ERROR);
	}

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Put id in the control block, along with the table name */
	STRUCT_ASSIGN_MACRO(resrange->pss_tabid,
			    psy_cb->psy_tables[psy_cb->psy_numtabs]);
	STRUCT_ASSIGN_MACRO(resrange->pss_tabname,
			    psy_cb->psy_tabname[psy_cb->psy_numtabs++]);
    }
        |             droppermstmnt ON PROCEDURE
    {
	PSY_CB	    *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** indicate to PSYKPERM that a permit on a database procedure is
	** being dropped
	*/
	psy_cb->psy_grant = PSY_PDROP;
    }
		      obj_spec dropipspec
    {
	DB_STATUS	        status;
	DB_TAB_NAME	        dbpname;
	i4			err_code;
	i4			dbpshow_flags;
	DB_OWN_NAME		*dbp_owner;

	/* If name was qualified, it'd better be the same as the user */
	if ($5->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp((PTR) &$5->pss_owner, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME)))
	{
	    /*
	    ** Audit failure to drop permit on database procedure
	    */
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_ERROR	e_error;

		(VOID) psy_secaudit(FALSE, cb, (char *) &$5->pss_obj_name,
		    (DB_OWN_NAME *)&$5->pss_owner, sizeof($5->pss_obj_name),
		    SXF_E_PROCEDURE, I_SX2019_PROT_DBP_DROP,
		    SXF_A_FAIL | SXF_A_CONTROL, &e_error);
	    }
		
	    (VOID) psf_error(E_PS0425_ILLEGAL_DBP_REF, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 3,
		sizeof("DROP PERMIT") - 1, "DROP PERMIT",
		psf_trmwhite(sizeof(DB_TAB_NAME), (char *) &$5->pss_obj_name),
		&$5->pss_obj_name,
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &$5->pss_owner),
		&$5->pss_owner);
	    return(E_DB_ERROR);
	}

	/* Find dbp id for this dbp name */
 	STmove($5->pss_orig_obj_name, ' ', sizeof(DB_TAB_NAME),
	    (char *) &dbpname);
	    
	dbp_owner = (DB_OWN_NAME *) NULL;

	status = pst_dbpshow(cb, (DB_DBP_NAME *) &dbpname, &$Ydbpinfo,
	    dbp_owner, (DB_TAB_ID *) NULL, PSS_USRDBP, psq_cb, &dbpshow_flags);
	if (DB_FAILURE_MACRO(status))
        {
	    /*
	    ** if pst_dbpshow() returned error, some internal error happened,
	    ** nothing that need be audited
	    */
	    return(status);
	}
	else if (dbpshow_flags & PSS_MISSING_DBPROC)
	{
	    return(E_DB_ERROR);
	}
	else
        {
	    PSY_CB	    *psy_cb = (PSY_CB *) cb->pss_object;

	    /*
	    ** Copy procedure id and procedure name to table entry.
	    */
	    STRUCT_ASSIGN_MACRO($Ydbpinfo->pss_ptuple.db_procid,
				psy_cb->psy_tables[psy_cb->psy_numtabs]);
	    STRUCT_ASSIGN_MACRO(dbpname,
				psy_cb->psy_tabname[psy_cb->psy_numtabs++]);
	}
    }
        |           droppermstmnt ON nonkeyword
    {
	PSY_CB	    *psy_cb;
	
	if (CMcmpcase($3, "d") || STcompare($3, "dbevent"))
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}

	psy_cb = (PSY_CB *) cb->pss_object;
	
	/* indicate to PSYKPERM that a permit on an dbevent is being dropped */
	psy_cb->psy_grant = PSY_EVDROP;
    }
		    obj_spec dropipspec
    {
	PSY_CB		*psy_cb;
	i4		err_code;
	DB_TAB_NAME	*nameplace;
	DB_TAB_ID	*idplace;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* If name was qualified, it'd better be the same as the user */
	if ($5->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp((PTR) &$5->pss_owner, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME)))
	{
	    /*
	    ** Audit failure to drop permit on dbevent
	    */
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_ERROR	e_error;

		(VOID) psy_secaudit(FALSE, cb, (char *) &$5->pss_obj_name,
		    (DB_OWN_NAME *)&$5->pss_owner, sizeof($5->pss_obj_name),
		    SXF_E_EVENT, I_SX2031_PROT_EV_DROP, 
		    SXF_A_FAIL | SXF_A_CONTROL, &e_error);
	    }

	    (VOID) psf_error(E_PS0426_ILLEGAL_EVENT_REF, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 3,
		sizeof("DROP PERMIT") - 1, "DROP PERMIT",
		psf_trmwhite(sizeof(DB_TAB_NAME), (char *) &$5->pss_obj_name),
		&$5->pss_obj_name,
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &$5->pss_owner),
		&$5->pss_owner);
	    return(E_DB_ERROR);
	}

	/* Figure out where dbevent name and id go */
	idplace = &psy_cb->psy_tables[psy_cb->psy_numtabs];
	nameplace = &psy_cb->psy_tabname[psy_cb->psy_numtabs++];

	/* Get DUMMY table id - use iievent until later looked up in QEU */
	idplace->db_tab_base = DM_B_EVENT_TAB_ID;
	idplace->db_tab_index = DM_I_EVENT_TAB_ID;

 	STmove($5->pss_orig_obj_name, ' ', sizeof(DB_TAB_NAME),
	    (char *) nameplace);
    }
;

droppermstmnt:	    DROPPERM
    {
	i4                err_code;
	PSY_CB		       *psy_cb;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_DSTPERM;

	/* "drop permit is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(5207L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate a PSY_CB for drop permit */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** indicate to PSYKPERM	what kind of object is being dropped - initially
	** assume that dropping permit on a table
	*/
	psy_cb->psy_grant = PSY_TDROP;
    }
;

/*
** If "all" is specified, the number of numbers should be set to 0.
** This is done when the first part of the stmt is parsed.
*/
dropipspec:		dropiplist
	    |		ALL
;

dropiplist:		dropipint
		|	dropiplist COMMA dropipint
;

dropipint:		intconst_p
    {
	PSY_CB		       *psy_cb;
	i4		       err_code;

	psy_cb = (PSY_CB *) cb->pss_object;

	if (++psy_cb->psy_numnms > PSY_MAXTABS)
	{
	    (VOID) psf_error(2754L, 0L, PSF_USERERR, &err_code, 
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	psy_cb->psy_numbs[psy_cb->psy_numnms - 1] = $1;
    }
;

drop_dbproc:	    ddbp_drpkwd obj_spec 
    {
	DB_STATUS	status;
	DB_DBP_NAME	dbpname;
	i4		err_code;
	i4		dbpshow_flags;
	PSY_CB		*psy_cb;

	/* If name was qualified, it'd better be the same as the user */
	if ($2->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp((PTR) &$2->pss_owner, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME)))
	{
	    /*
	    ** Audit failure to drop a database procedure
	    */
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_ERROR	e_error;

		(VOID) psy_secaudit(FALSE, cb, (char *) &$2->pss_obj_name,
		    (DB_OWN_NAME *)&$2->pss_owner, sizeof($2->pss_obj_name),
		    SXF_E_PROCEDURE, I_SX2013_DBPROC_DROP,
		    SXF_A_FAIL | SXF_A_DROP, &e_error);
	    }

	    (VOID) psf_error(E_PS0425_ILLEGAL_DBP_REF, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 3,
		sizeof("DROP PROCEDURE") - 1, "DROP PROCEDURE",
		psf_trmwhite(sizeof(DB_TAB_NAME), (char *) &$2->pss_obj_name),
		&$2->pss_obj_name,
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &$2->pss_owner),
		&$2->pss_owner);
	    return(E_DB_ERROR);
	}

	STmove($2->pss_orig_obj_name, ' ', 
	       sizeof(DB_DBP_NAME), dbpname.db_dbp_name);

	/* Open the stream now because dbpinfo will be allocated from it. */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* dbproc is expected to exist */
	status = pst_dbpshow(cb, &dbpname, &$Ydbpinfo, (DB_OWN_NAME *) NULL,
	    (DB_TAB_ID *) NULL, PSS_USRDBP, psq_cb, &dbpshow_flags);
	if (DB_FAILURE_MACRO(status))
	{
	    /*
	    ** pst_dbpshow() will return error if some internal error takes
	    ** place - need not audit
	    */
	    return (status);
	}
	else if (dbpshow_flags & PSS_MISSING_DBPROC)
	{
	    /* Procedure not found */
	    return (E_DB_ERROR);
	}

	/* make sure object is user-droppable;
	** don't allow users to drop internal procedures
	*/
	if ($Ydbpinfo->pss_ptuple.db_mask[0] & DBP_NOT_DROPPABLE)
	{
	    psf_error(E_US18AB_6315_NOT_DROPPABLE, 0L, PSF_USERERR,
		      &err_code, &psq_cb->psq_error, 2,
		      sizeof(ERx("DROP PROCEDURE"))-1, ERx("DROP PROCEDURE"),
		      psf_trmwhite(DB_MAXNAME, dbpname.db_dbp_name),
		      dbpname.db_dbp_name);
	    return(E_DB_ERROR);
	}

	/* Create the PSY_CB for the DROP PROCEDURE */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Fill in the procedure name to be destroyed. */
	(VOID) MEcopy(dbpname.db_dbp_name, sizeof(DB_DBP_NAME),   
		      psy_cb->psy_tabname[0].db_tab_name);
        /* Fill in a procedure id */
	STRUCT_ASSIGN_MACRO($Ydbpinfo->pss_ptuple.db_procid,
			    psy_cb->psy_tables[0]);
    }
;

ddbp_drpkwd:	    DROP PROCEDURE
    {
        /* "DROP PROCEDURE" is not allowed in distributed yet */
        if (cb->pss_distrib & DB_3_DDB_SESS)
        {
	    i4         err_code;

            (VOID) psf_error(5118L, 0L, PSF_USERERR, &err_code,
               	&psq_cb->psq_error, 1, 
		sizeof("DROP PROCEDURE") - 1, "DROP PROCEDURE");
            return (E_DB_ERROR);
        }

	psq_cb->psq_mode = PSQ_DRODBP;
    }
;

/*
** Yacc rule:  drop_rule	- Drop a rule
**
** Statement Syntax:
**	DROP RULE rule_name
**
** Return State:
**	PSY_CB.psy_rule	      = Rule tuple with rule name constructed
*/
drop_rule:		drl_kwd obj_spec
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	/* "drop rule" is not allowed in Star */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    _VOID_ psf_error(E_US18A0_6304_RULE_STAR, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* If name was qualified, it'd better be the same as the user */
	if ($2->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp((PTR) &$2->pss_owner, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME)))
	{
	    /*
	    ** Audit failure to drop a rule
	    */
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_ERROR	e_error;

		(VOID) psy_secaudit(FALSE, cb, (char *)&$2->pss_obj_name,
		    (DB_OWN_NAME *)&$2->pss_owner, sizeof($2->pss_obj_name),
		    SXF_E_RULE, I_SX2038_RULE_DROP, 
		    SXF_A_FAIL | SXF_A_DROP, &e_error);
	    }

	    (VOID) psf_error(E_PS0420_DROPOBJ_NOT_OBJ_OWNER, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof("DROP RULE") - 1, "DROP RULE",
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &$2->pss_owner),
		&$2->pss_owner);
	    return(E_DB_ERROR);
	}

	/* Allocate the PSY_CB for the DROP RULE statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *)cb->pss_object;

	/* Initialize rule tuple */
	MEfill(sizeof(psy_cb->psy_tuple.psy_rule), '\0',
	       (PTR)&psy_cb->psy_tuple.psy_rule);
	STmove($2->pss_orig_obj_name, ' ', sizeof(DB_NAME),
	       (char *)&psy_cb->psy_tuple.psy_rule.dbr_name);
    }
;
drl_kwd:	    	DROPRULE
    {
	psq_cb->psq_mode = PSQ_DSTRULE;
    }
;

etransact:	    ENDXACT
    {
	QEF_RCB                *qef_rcb;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_ENDTRANS;

	/* Allocate the QEF control block for 'end transaction' */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;

	/* destroy all dynamic SQL statement prototypes */
	status = pst_commit_dsql(psq_cb, cb);
	if (status != E_DB_OK)
	    return (status);
    }
;

/*
** Yacc rule:  execute_dbproc	- Execute a procedure.  This Yacc rule is
**				  shared with the CREATE RULE statement.
**
** Statement Syntax:
**	[result_variable =] 
**	    EXECUTE PROCEDURE | CALLPROC procedure_name
**	    [(parameter_name = value {, parameter_name = value})];
**
**	    value :==
**		constant, USER, NULL.
**
** Return State:
**	PST_CP_TYPE statement with procedure/owner name.
**	Result_variable clause is handled inside DBP's - cdbp_stmt.
**
*/
execute_dbproc:	exdbp_kword exdbp_name exdbp_arguments
    {
	PST_STATEMENT	*stmt_cp;	/* CALLPROC statement */
	PST_CPROCSTMT	*cps;	
	DB_STATUS	status;

        if (psq_cb->psq_mode == PSQ_DDEXECPROC)
	{
	    /* 
	    ** Add the rest of the execute procedure statement.
	    */
	    status = psq_x_add(cb, $Yscanbuf_ptr, &cb->pss_ostream,
                $Yxlated_qry.pss_buf_size, &$Yxlated_qry.pss_q_list,
                (i4) ((char *) cb->pss_endbuf - (char *) $Yscanbuf_ptr),
                " ", " ", (char *) NULL, &psq_cb->psq_error);
            if (DB_FAILURE_MACRO(status))
		return (status);

            status = psf_mroot(cb, &cb->pss_ostream,
                        (PTR) $Yxlated_qry.pss_q_list.pss_head, 
			&psq_cb->psq_error);
            if (DB_FAILURE_MACRO(status))
            	return (status);

	    $$ = NULL;
	    break;		/* done for distributed case */
        }
	
	/*
	** Allocate CALLPROC statement and fill.  If this is not inside a
	** DBP then package the whole thing as a statement in a procedure and
	** ship.  If this is in a procedure then just build the statement.
	**
	** Note that this statement may have a result variable attached to it
	** later (when nested in a DBP).
	*/

	/*
	** Allocate CALLPROC statement node and initialize fields
	** NOTE: we do not use psl_init_dbp_stmt() here since we do not want
	**       this statement node linked into the statement list (especially
	**	 if we are not parsing a dbproc, in which case there is no list
	**	 to speak of); if this is a statement in a database procedure,
	**	 it will be linked in later.
	*/
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_STATEMENT),
			    (PTR *)&stmt_cp, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	MEfill(sizeof(PST_STATEMENT), (u_char) 0, (PTR) stmt_cp);

	stmt_cp->pst_mode = PSQ_CALLPROC;
	stmt_cp->pst_type = PST_CP_TYPE;
#ifdef xDEBUG
	stmt_cp->pst_lineno = cb->pss_lineno;
#endif
	stmt_cp->pst_lineno = cb->pss_stmtno;
	cps = &stmt_cp->pst_specific.pst_callproc;
	cps->pst_pmask = PST_CPUSER;
	cps->pst_rulename.db_name[0] = EOS;

	cps->pst_procname.qso_n_id.db_cursor_id[0] =
	    cps->pst_procname.qso_n_id.db_cursor_id[1] = 0;

	MEcopy((PTR)&$2->pss_ptuple.db_dbpname, DB_MAXNAME,
	       (PTR)cps->pst_procname.qso_n_id.db_cur_name);
	STRUCT_ASSIGN_MACRO($2->pss_ptuple.db_owner,
			    cps->pst_procname.qso_n_own);
	cps->pst_procname.qso_n_dbid = cb->pss_udbid;

	/* Are there arguments? */
	if ((cps->pst_arglist = $3) != (PST_QNODE *) NULL)
	    cps->pst_argcnt = $3->pst_sym.pst_value.pst_s_rsdm.pst_rsno;
	else
	    cps->pst_argcnt = 0;

	if ($Yisdbp) 		/* Return statement to be patched later */
	{
	    /*
	    ** if this statement is not reachable, do not attach it to the
	    ** list of statements used by OPF (to save the cost of
	    ** optimizing it)
	    */
	    if ($Ydbpinfo->pss_unreachable_stmt_lvl == 0)
	    {
		if ($Ydbpinfo->pss_link != (PST_STATEMENT *) NULL)
		{
		    $Ydbpinfo->pss_link->pst_link = stmt_cp;
		}

		$Ydbpinfo->pss_link = stmt_cp;
	    }

	    $Ydbpinfo->pss_last_stmt = stmt_cp;
	    $Ydbpinfo->pss_patch = &stmt_cp->pst_next;

	    $$ = stmt_cp;
	}
	else			/* Not a DBP */
	{
	    PST_PROCEDURE   *prnode;	/* Procedure node to create */

	    /* Create procedure (for OPC) and attach the CALLPROC statement */
	    status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_PROCEDURE),
				(PTR *)&prnode, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);

	    prnode->pst_mode = 0;
	    prnode->pst_vsn = PST_CUR_VSN;
	    prnode->pst_isdbp = FALSE;
	    prnode->pst_flags = 0;
	    prnode->pst_stmts = stmt_cp;
	    prnode->pst_parms = (PST_DECVAR *)NULL;
	    MEfill(sizeof(prnode->pst_dbpid), (u_char)0,
		   (PTR)&prnode->pst_dbpid);
	    status = psf_mroot(cb, &cb->pss_ostream, (PTR)prnode,
			       &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	    $$ = NULL;		/* Unused outside of DBP */
	}
    }
;

exdbp_kword:	exdbp_xkword
    {
	DB_STATUS	status;

        if (cb->pss_distrib & DB_3_DDB_SESS)
        {
            psq_cb->psq_mode = PSQ_DDEXECPROC;

            /* Open QSF memory stream for the EXECUTE PROCEDURE text */
            status = psf_mopen(cb, QSO_QTEXT_OBJ, &cb->pss_ostream, 
			&psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	    break;		/* bypass the rest of the parsing */
        }

	psq_cb->psq_mode = PSQ_CALLPROC;

	/* Open memory stream for allocating objects */
	if ($Yisdbp == FALSE)
	{
	    if ((status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
				    &psq_cb->psq_error)) != E_DB_OK)
		return (status);
	}
    }
;
exdbp_xkword:	EXECUTE PROCEDURE
    |		CALLPROC
;

exdbp_name:	obj_spec
    {
	DB_STATUS	status;
	DB_DBP_NAME	dbpname;
	PSS_DBPINFO	*dbp;
	i4		err_code;

        if (psq_cb->psq_mode == PSQ_DDEXECPROC)
        {
	    PSS_RNGTAB	    	*resrange;
	    i4		    	rngvar_info;
	    i4		    	lookup_mask;
	    DD_OBJ_DESC         *obj_desc;
	    DD_2LDB_TAB_INFO    *ldb_tab_info;

	    lookup_mask = PST_REGPROC;

	    if ($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    {
                status = psl0_orngent(&cb->pss_auxrng, -1, 
		    $1->pss_orig_obj_name, &$1->pss_owner, &$1->pss_obj_name, 
		    cb, TRUE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error, 
		    &rngvar_info, lookup_mask);
	    }
	    else
	    {
                status = psl0_rngent(&cb->pss_auxrng, -1, 
		    $1->pss_orig_obj_name, &$1->pss_obj_name, 
		    cb, TRUE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
		    (PSS_USRTBL | PSS_DBATBL | PSS_INGTBL),
                    &rngvar_info, lookup_mask);
	    }

	    if (DB_FAILURE_MACRO(status))
	    {
   		return (status);
	    }
	    else if (resrange == (PSS_RNGTAB *) NULL)
	    {
                /*
                ** If reg proc wasn't found, report it to user here.
                */
	        if ($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
		{
                    (VOID) psf_error(2764L, 0L, PSF_USERERR, &err_code,
                    &psq_cb->psq_error, 3, 17, "EXECUTE PROCEDURE",
                    psf_trmwhite(sizeof(DB_TAB_NAME),
		    	(char *) &$1->pss_obj_name), 
		    &$1->pss_obj_name,
                    psf_trmwhite(sizeof(DB_OWN_NAME),
		    	(char *) &$1->pss_owner), 
		    &$1->pss_owner);
		}
		else
		{
                    (VOID) psf_error(2753L, 0L, PSF_USERERR, &err_code,
                    &psq_cb->psq_error, 2, 17, "EXECUTE PROCEDURE",
                    psf_trmwhite(sizeof(DB_TAB_NAME),
		    	(char *) &$1->pss_obj_name), 
		    &$1->pss_obj_name);
		}

                return (E_DB_ERROR);
	    }
	    else
	    {
		/* translate registered name and built query text in buffer */
		obj_desc = resrange->pss_rdrinfo->rdr_obj_desc;
		ldb_tab_info = &obj_desc->dd_o9_tab_info;

        	status = psq_x_add(cb, "", &cb->pss_ostream, 
			$Yxlated_qry.pss_buf_size, &$Yxlated_qry.pss_q_list, 
			-1, (char *)NULL, (char *)NULL, 
			"execute immediate execute procedure ", 
		        &psq_cb->psq_error);

        	if (DB_FAILURE_MACRO(status))
            	    return(status);

		/* 
		** Although qmode != PSQ_COPY, the rules for owners and
		** delimiters are the same.
		*/
        	status = psq_prt_tabname(cb, &$Yxlated_qry, &cb->pss_ostream, 
			resrange, PSQ_COPY, &psq_cb->psq_error);

        	if (DB_FAILURE_MACRO(status))
        	    return(status);

        	/* remember table site */
        	STRUCT_ASSIGN_MACRO(ldb_tab_info->dd_t9_ldb_p->dd_i1_ldb_desc,
                        *(psq_cb->psq_ldbdesc));
    	    }

    	    cb->pss_resrng = resrange;

	    /*
	    ** Set buffer pointer; later we'll copy from here till
	    ** the end of the input text to the QSF QTEXT object.
	    */
            if ($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
                $Yscanbuf_ptr = (PTR) cb->pss_nxtchar;
            else
                $Yscanbuf_ptr = (PTR) cb->pss_prvtok;   /* already looked ahead */
	    $$ = NULL;
	    break;		/* done for distributed case */
	}

	/* normalize dbproc name */
	MEmove(sizeof(DB_TAB_NAME), (PTR) &$1->pss_obj_name, ' ',
	       sizeof(dbpname), (PTR) &dbpname);

	/*
	** IF
	** - we are creating a dbproc AND
	** - dbproc name specified by the user is the same as that of the one
	**   being defined AND
	**	EITHER
	**	- dbproc name was explicitly qualified AND
	**	- owner name as specified by the user is the same as that of the
	**	  user
	**	OR
	**	- procedure name was NOT explicitly qualified
	**
	** this is a recursive call, and we don't need to look up a procedure
	**
	** Otherwise, call pst_dbpshow()
	*/

	if ((dbp = $Ydbpinfo) == NULL
	    || !$Yisdbp
	    || MEcmp((PTR)&dbpname, (PTR)&dbp->pss_ptuple.db_dbpname,
		     sizeof(dbpname))
	    || ($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	        MEcmp((PTR) &$1->pss_owner, (PTR) &cb->pss_user,
		      sizeof($1->pss_owner))))
	{
	    i4		    dbp_mask;
	    DB_OWN_NAME	    *dbp_owner;
	    i4		    dbpshow_flags;

	    if ($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    {
		dbp_owner = &$1->pss_owner;
		dbp_mask = PSS_DBP_PERM_AND_AUDIT | PSS_DBP_BY_OWNER;
	    }
	    else
	    {
		dbp_owner = (DB_OWN_NAME *) NULL;
		dbp_mask = PSS_DBP_PERM_AND_AUDIT |
		    PSS_USRDBP | PSS_DBADBP | PSS_INGDBP;
	    }

	    status = pst_dbpshow(cb, &dbpname, &dbp, dbp_owner,
		(DB_TAB_ID *) NULL, dbp_mask, psq_cb, &dbpshow_flags);

	    if (DB_FAILURE_MACRO(status))
		return (status);
	    else if (dbpshow_flags & (PSS_MISSING_DBPROC | PSS_INSUF_DBP_PRIVS))
	    {
		/*
		**    dbproc does not exist
		** or the current user may not execute it
		** or we are reparsing a dbproc in order to determine if it is
		** grantable and the user does not posess EXECUTE WGO on this
		** dbproc
		*/
		return (E_DB_ERROR);
	    }

	    /*
	    ** dbp has names set from pst_dbpshow 
	    */

	    /* check if user is trying to execute a
	    ** system-generated procedure from the command line
	    **
	    ** Note that it is OK to have system-generated rule or dbproc fire a
	    **      system-generated dbproc
	    */
	    if (	/* system generated dbproc */
		   dbp->pss_ptuple.db_mask[0] & DBP_SYSTEM_GENERATED
		   
			/* not fired by a system-generated rule */
		&& !(   psq_cb->psq_mode == PSQ_RULE
		     && psq_cb->psq_info != (PST_INFO *) NULL
		     && psq_cb->psq_info->pst_execflags & PST_SYSTEM_GENERATED)
		     
			/* not fired by system-generated dbproc */
		&& !($Yisdbp && cb->pss_dbp_flags & PSS_SYSTEM_GENERATED)
	       )
	    {

		if ((cb->pss_ses_flag & PSS_RUNNING_UPGRADEDB) == 0)
		{
		    (void) psf_error(E_PS049E_CANT_EXEC_SYSGEN_PROC, 
				 0L, PSF_USERERR,
				 &err_code, &psq_cb->psq_error, 1,
				 psf_trmwhite(DB_MAXNAME,
				       dbp->pss_ptuple.db_dbpname.db_dbp_name),
				 dbp->pss_ptuple.db_dbpname.db_dbp_name);
		    return(E_DB_ERROR);
		}
	    }

	    /* if emitting query text, and the schema/owner name has not been
	    ** specified, add the procedure's schema name to the query
	    */
	    if (   (cb->pss_stmt_flags & PSS_TXTEMIT) 
		&& (~$1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA))
	    {
		status = psl_prepend_schemaname(cb->pss_tchain, 
		    $1->pss_orig_obj_name, 
		    (u_char *) dbp->pss_ptuple.db_owner.db_own_name,
		    &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return (status);
	    }

	    /* dbp has names set from pst_dbpshow */
	}
	else
	{
	    /* this is a recursive procedure call;
	    ** if emitting query text, must be creating procedure
	    ** and that means this EXEC PROC must be owned by current user;
	    ** so
	    ** if emitting query text, and the schema/owner name has not been
	    ** specified, add the current schema name to the query
	    */
	    if (   (cb->pss_stmt_flags & PSS_TXTEMIT) 
		&& (~$1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA))
	    {
		status = psl_prepend_schemaname(cb->pss_tchain, 
		    $1->pss_orig_obj_name, (u_char *) cb->pss_user.db_own_name,
		    &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return (status);
	    }
	}
	    
	$$ = dbp;
    }
;

exdbp_arguments:	/* No arguments */
    {
	$$ = NULL;
    }
	|		LPAREN exdbp_arg_list RPAREN
    {
	$$ = $2;
    }
;

exdbp_arg_list:	exdbp_arg
    {
	DB_STATUS	    status;
	PST_QNODE	    *treenode;

        if (psq_cb->psq_mode == PSQ_DDEXECPROC)
        {
	    /* execution of regproc; by pass parsing */
	    $$ = NULL;
	    break;
	}

	/* First node - create the tail PST_TREE node */
	status = pst_node(cb, &cb->pss_ostream,
			  (PST_QNODE *)NULL, (PST_QNODE *)NULL,
			  PST_TREE, (PTR)NULL, 0,
			  DB_NODT, (i2) 0, (i4)0, (DB_ANYTYPE *)NULL,
			  &treenode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	    return (status);

	/* Keep track of parameter number */
	$1->pst_sym.pst_value.pst_s_rsdm.pst_rsno = 1;
	$1->pst_sym.pst_value.pst_s_rsdm.pst_ntargno = 1;

	$1->pst_left = treenode;
	$$ = $1;
    }
	|		exdbp_arg_list COMMA exdbp_arg
    {
        if (psq_cb->psq_mode == PSQ_DDEXECPROC)
        {
	    /* execution of regproc; by pass parsing */
	    $$ = NULL;
	    break;
	}

	/* Make sure there is only one temptab proc param */
	if ($1->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype 
		== PST_TTAB_DBPARM ||
	    $3->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype
		== PST_TTAB_DBPARM)
	{	/* uh, oh! */
	    i4                err_code;
	    (VOID) psf_error(E_US0989_2441_TTAB_PARM, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	/* Bump current parameter number */
	$3->pst_sym.pst_value.pst_s_rsdm.pst_rsno =
	    $1->pst_sym.pst_value.pst_s_rsdm.pst_rsno + 1;
	$3->pst_sym.pst_value.pst_s_rsdm.pst_ntargno =
	    $1->pst_sym.pst_value.pst_s_rsdm.pst_ntargno + 1;

	$3->pst_left = $1;
	$$ = $3;
    }
;
exdbp_arg:		generic_ident EQUAL SESSION PERIOD generic_ident
    {
	/* First option is the temp table parameter ("parm = session.table") */
	DB_STATUS	    status;
	PST_QNODE	    *argnode;
	PST_QNODE	    *ttabnode = (PST_QNODE *)NULL;
	PST_TAB_NODE	    tabnode;

        if (psq_cb->psq_mode == PSQ_DDEXECPROC)
        {
	    /* execution of regproc; by pass parsing */
	    $$ = NULL;
	    break;
	}

	/* Turn temp table name into a TAB node, to be hung from 
	** procparm RESDOM. */
	STRUCT_ASSIGN_MACRO(cb->pss_sess_owner, tabnode.pst_owner);
	STmove($5, ' ', sizeof(DB_TAB_NAME), (char *)&tabnode.pst_tabname);
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL,
	    (PST_QNODE *)NULL, PST_TAB, (char *)&tabnode, sizeof(tabnode),
	    DB_NODT, (i2)0, (i4)0, (DB_ANYTYPE *)NULL, &ttabnode,
	    &psq_cb->psq_error, (i4)0);
	if (status != E_DB_OK)
	    return(status);

	status = psl_dbproc_param(psq_cb, cb, $1, ttabnode, FALSE, &argnode);
	if (status != E_DB_OK)
	    return (status);
	argnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype = PST_TTAB_DBPARM;
	$$ = argnode;
    }
		|	generic_ident EQUAL exdbp_arg_val
    {
	DB_STATUS	    status;
	PST_QNODE	    *argnode;

        if (psq_cb->psq_mode == PSQ_DDEXECPROC)
        {
	    /* execution of regproc; by pass parsing */
	    $$ = NULL;
	    break;
	}

	status = psl_dbproc_param(psq_cb, cb, $1, $3, FALSE, &argnode);
	if (status != E_DB_OK)
	    return (status);
	$$ = argnode;
    }
		|	generic_ident EQUAL BYREF LPAREN cdbp_parmlvar RPAREN
    {
	DB_STATUS	    status;
	PST_QNODE	    *argnode;

        if (psq_cb->psq_mode == PSQ_DDEXECPROC)
        {
	    /* execution of regproc; by pass parsing */
	    $$ = NULL;
	    break;
	}

	status = psl_dbproc_param(psq_cb, cb, $1, $5, TRUE, &argnode);
	if (status != E_DB_OK)
	    return (status);
	$$ = argnode;
    }
		|	generic_ident EQUAL BYREF LPAREN cname RPAREN
    {
	DB_STATUS	    status;
	PST_QNODE	    *argnode;
	
	if (psq_cb->psq_mode == PSQ_DDEXECPROC)
        {
	    /* execution of regproc; by pass parsing */
	    $$ = NULL;
	    break;
	}

	status = psl_dbproc_param(psq_cb, cb, $1, $5, TRUE, &argnode);

	if (status != E_DB_OK)
	    return (status);
	$$ = argnode;
    }
;

exdbp_arg_val:		cdbp_rhs_asgn
;

execute_imdte:	    EXECUTE IMMEDIATE ex_imdte_stmts
	  |	    EXECUTE IMMEDIATE
    {
	i4		    err_code;

	(VOID) psf_error(2350L, 0L, PSF_USERERR, &err_code, &psq_cb->psq_error,
	    0);
	return (E_DB_ERROR);
    }
		    query
;

ex_imdte_stmts:	    abort
	  |	    alter_role
	  |	    alter_group
	  |	    alter_user
	  |	    alter_location
	  |	    alter_table
	  |	    alter_profile
	  |	    alter_sequence
          |	    btransact
	  |	    comment		/* EXECUTE IMMEDIATE COMMENT ON ... */
	  |	    commit
          |	    copy
	  |	    create_dbproc	/* IMMEDIATE create procedure */
	  |	    create_event	/* IMMEDIATE CREATE DBEVENT */
	  |	    create_role
	  |	    create_group
	  |	    create_index
	  |	    create_integrity
	  |	    create_link
	  |	    create_permit
	  |	    create_rule
	  |	    create_table
	  |	    create_user
	  |	    create_profile
	  |	    create_location
	  |	    create_schema
	  |	    create_secalm
	  |	    create_sequence
	  |	    create_synonym
	  |	    create_view
	  |	    delete
	  |	    dgtt_stmt
	  |	    drop_dbproc		/* IMMEDIATE drop procedure */
	  |	    drop_event		/* IMMEDIATE DROP DBEVENT */
	  |	    drop_role
	  |	    drop_group
	  |	    drop_tvis
	  |	    drop_schema
	  |	    dropinteg
	  |	    dropperm
	  |	    drop_rule
	  |	    drop_user
	  |	    drop_location
	  |	    drop_profile
	  |	    drop_secalm
	  |	    drop_sequence
	  |	    disable_secaud
	  |	    enable_secaud
	  |	    alter_secaud
	  |	    execute_dbproc	/* IMMEDIATE execute procedure */
	  |	    etransact
          |	    grant
          |	    insert
          |	    modify
	  |         reg_distr_idx
	  |         reg_distr_tv
	  |	    revoke
	  |	    rollback
	  |	    relocate
	  |	    reg_gateway_tab	/* REGISTER TABLE AS IMPORT */
	  |	    register_event	/* IMMEDIATE REGISTER DBEVENT */
	  |	    remove_event	/* IMMEDIATE REMOVE DBEVENT */
	  |	    raise_event		/* IMMEDIATE RAISE DBEVENT */
          |	    save
	  |	    savepoint
	  |	    setaggr
	  |	    setautocommit
	  |	    setcpufact
          |	    setdatefmt
	  |         setddl_concur
	  |	    setdecimal
	  |	    setflatten
	  |	    sethash
	  |	    setiotrace
	  |	    setjoinop
          |	    setjournal
          |	    setjtimeout
          |	    setlockmode
	  |	    setlocktrace
	  |	    setlogging
	  |	    setlogtrace
	  |	    setmnyfmt
	  |	    setmnyprec
	  |	    setmxio
	  |	    setmxrow
	  |	    setmxcpu
	  |	    setmxidle
	  |	    setmxconnect
	  |	    setmxpage
	  |	    setmxcost
	  |	    setojflatten
	  |	    setoptimizeonly
	  |	    setparallel
	  |	    setprintqry
	  |	    setprintrules
	  |	    setprintevents		/* IMMEDIATE SET PRINTEVENTS */
	  |	    setlogevents		/* IMMEDIATE SET LOGEVENTS */
	  |	    setqep
	  |	    setrandomseed
	  |	    setresstruct
	  |	    setretinto
	  |	    setrules
	  |	    setsession
	  |	    setstats
	  |	    settrace
          |         settransaction
	  |	    set_sess_auth_id
	  |	    setunicodesub
	  |	    setupdrowcnt	/* IMMEDIATE SET UPDATE_ROWCOUNT */
	  |	    setwork
	  |	    setrole		/* IMMEDIATE SET ROLE */
	  |	    update
;

/*
**  Note: DATABASE/CURRENT INSTALLATION will be handled in the second production
**
**  12-jun-91 (andre)
**	separate rules for grant ON
**	[TABLE]/PROCEDURE/DBEVENT/{DATABASE|CURRENT INSTALLATION}
*/
grant:		    grant_kwd tbl_priv_spec tbl_priv_obj_spec grant_auth_spec
		    grant_option
    {
/* GRANT ... ON [TABLE] ... [WITH GRANT OPTION] */

	DB_STATUS           status;
	PSY_CB		    *psy_cb = (PSY_CB *) cb->pss_object;
	PTR                 piece;
	i4		    err_code;
	u_char		    ident_placeholder[DB_MAX_DELIMID + 1];
	char		    text[512];
	i4		    textcnst, noncol = FALSE, curoff;
	bool		    updtcols, insrtcols, refcols;
	i4		    colprivs;
	char		    *str;
	i4		    str_len;

#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Special processing for CREATE SCHEMA
	    */
	    status = psl_cs05s_grant(cb, psq_cb, $Ystmtstart, $Ydeplist);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	    return(E_DB_OK);
	}

	/*
	** Set grantee type; default is USER 
	*/
	psy_cb->psy_gtype = ($4 == DBGR_DEFAULT) ? DBGR_USER : $4;

	/*
	** if WITH GRANT OPTION was specified, make sure that the grantee is of
	** type USER or PUBLIC (recall that PUBLIC could be specified as a user
	** authorization identifier) 
	*/
	if (   psy_cb->psy_opmap & DB_GRANT_OPTION
	    && psy_cb->psy_gtype != DBGR_USER)
	{
	    (VOID) psf_error(E_PS0550_GRANTEE_TYPE_FOR_WGO, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* remember if column-specific privileges were specified */
	colprivs = 0;

	if (updtcols  = psy_cb->psy_u_numcols != 0)
	    colprivs |= (i4) DB_REPLACE;
	    
	if (insrtcols = psy_cb->psy_i_numcols != 0)
	    colprivs |= (i4) DB_APPEND;
	    
	if (refcols   = psy_cb->psy_r_numcols != 0)
	    colprivs |= (i4) DB_REFERENCES;

	/*
	** The "grant" statement requires query text to be stored
	** in the iiqrytext relation. In general case there may be three
	** iiqrytext templates generated here. Later on, in psy_dgrant,
	** table and grantee names will be substituted.
	** The first template is produced for the version that
	** doesn't have columns. The version of grant with
	** UPDATE columns requires second template and if a list of columns 
	** associated with REFERENCES privilege is also unempty, we will build a
	** third template. The first template is always built and part of it is 
	** used for creation of the other templates. The first template will be 
	** stored only when there are table-wide privileges.
	*/

	/* fill in an identifier placeholder */
	MEfill(DB_MAX_DELIMID, '?', (PTR) ident_placeholder);
	ident_placeholder[DB_MAX_DELIMID] = EOS;
    
	status = psq_topen(&cb->pss_tchain, &cb->pss_memleft, 
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Text is a buffer where templates are built */
	text[0] = EOS;

	if (~psy_cb->psy_flags & PSY_ALL_PRIVS)	
	{
	    i4		tbl_wide_privs;

	    /* privilege list was specified */

	    /*
	    ** check whether table-wide privileges (i.e. SELECT, INSERT, DELETE,
	    ** UPDATE, or REFERENCES) are being granted;
	    ** we can tell that table-wide privileges were granted if the map of
	    ** privileges being granted contains privilege(s) besides those
	    ** found in colprivs (as in many other cases, for purposes of the
	    ** comparison DB_GRANT_OPTION is not treated as a privilege)
	    */
	    tbl_wide_privs = psy_cb->psy_opmap & ~(colprivs | DB_GRANT_OPTION);
	    if (tbl_wide_privs)
	    {
		/*
		** if a list of table-wide privileges was specified, we need a
		** placeholder for word GRANT followed by the longest of
		** privilege names of those which were specified.
		** If only one privilege (possibly WITH GRANT OPTION) is being
		** specified, we will insert it into the text now.
		*/
		noncol = TRUE;

		if (BTcount((char *) &tbl_wide_privs, BITS_IN(tbl_wide_privs))
			> 1)
		{
		    /* make placeholder big enough for REFERENCES */
		    str = "grant ??????????";
		}
		else if (tbl_wide_privs == DB_RETRIEVE)
		{
		    str = "grant select";
		}
		else if (tbl_wide_privs == DB_REPLACE)
		{
		    str = "grant update";
		}
		else if (tbl_wide_privs == DB_DELETE)
		{
		    str = "grant delete";
		}
		else if (tbl_wide_privs == DB_APPEND)
		{
		    str = "grant insert";
		}
		else if (tbl_wide_privs == DB_COPY_INTO)
		{
		    str = "grant copy_into";
		}
		else if (tbl_wide_privs == DB_COPY_FROM)
		{
		    str = "grant copy_from";
		}
		else
		{
		    str = "grant references";
		}

		STcat(text, str);
	    }
	}	/* privilege list was suppled */
	else
	{
	    noncol = TRUE;

	    /*
	    ** note that we will generate an IIPROTECT (and IIQRYTEXT) tuple to
	    ** represent each of privileges being granted even for ALL TO PUBLIC
	    ** permit
	    ** (make privilege name placeholder big enough to accomodate
	    ** REFERENCES)
	    */
	    STcat(text, "grant ??????????");
	}

	/*
	** For update/references columns we need to store the beginning of the
	** variable part of text so that the iiqrytext for UPDATE/REFERENCES 
	** permits may be easily generated.
	*/
	textcnst = STlength(text);

	if ($3 == 0)
	{
	    str = " on ";
	    str_len = sizeof(" on ") - 1;
	}
	else
	{
	    str = " on table ";
	    str_len = sizeof(" on table ") - 1;
	}
	
	STcat(text, str);
	
	/* Remember offset to the 'owner'.table name in the first template. */
	psy_cb->psy_noncol_obj_name_off = textcnst + str_len;
	
	/* Append the place holder for schema.table */
	STcat(text, (char *) ident_placeholder);
	STcat(text, ".");
	STcat(text, (char *) ident_placeholder);

	psl_grantee_type_to_str($4, &str, &str_len, FALSE);
	if (!str)
	{
	    /* this is very bad */
	    (VOID) psf_error(E_PS0002_INTERNAL_ERROR, 0L, PSF_INTERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	STcat(text, str);

	/* remember offset to the grantee name in the first template */
	psy_cb->psy_noncol_grantee_off = 
	      psy_cb->psy_noncol_obj_name_off 	/* begining of schema name */
	    + DB_MAX_DELIMID			/* schema name placeholder */
	    + CMbytecnt(".")			/* separator b/w schema and 
						** object name */
	    + DB_MAX_DELIMID                    /* object name placeholder */
	    + str_len;				/* TO <grantee type> */

	/* append the place holder for grantee name */
	STcat(text, (char *) ident_placeholder);

	if (psy_cb->psy_opmap & DB_GRANT_OPTION)
	{
	    STcat(text, " with grant option ");
	}

	/*
	** First template is ready now. It should be stored only
	** if non-column specific privileges have been defined.
	*/
	if (noncol)
	{
	    status = psq_tadd(cb->pss_tchain, (u_char *) text,
		STlength(text), &piece, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);

	    /* Determine size of the first iiqrytext */
	    status = psq_tqrylen(cb->pss_tchain, &psy_cb->psy_noncol_qlen);
	    if (status != E_DB_OK)
		return (status);
	}
	else
	{
	    psy_cb->psy_noncol_qlen = 0;
	}

	/*
	** Now emit iiqrytext for UPDATE [EXCLUDING] (cols) case, if necessary.
	*/
	if (updtcols)
	{
	    status = psl_bld_col_spec_grant_template(cb->pss_tchain, "update",
		(bool) ((psy_cb->psy_flags & PSY_EXCLUDE_UPDATE_COLUMNS) != 0),
		&psy_cb->psy_u_colq, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return(status);

	    /* Obtain the size of the current iiqrytext (1 & 2) */
	    status = psq_tqrylen(cb->pss_tchain, &curoff);
	    if (status != E_DB_OK)
		return (status);

	    /* compute the length of the second template built so far */
	    curoff -= psy_cb->psy_noncol_qlen;

	    /*
	    ** Compute offset to the beginning of the object name and grantee
	    ** name in the second template.
	    ** To do this we need to subtract from the table/grantee name offset
	    ** in the first template the length of
	    ** "GRANT <non-column privileges>" and add the length of the second
	    ** template text built so far (i.e. "GRANT UPDATE (...) ".)
	    */
	    psy_cb->psy_updt_obj_name_off =
		psy_cb->psy_noncol_obj_name_off - textcnst + curoff;
	    psy_cb->psy_updt_grantee_off =
		psy_cb->psy_noncol_grantee_off - textcnst + curoff;

	    /* copy the first template starting with ON [TABLE] */
	    status = psq_tadd(cb->pss_tchain, (u_char *) (text + textcnst),
		STlength(text + textcnst), &piece, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);

	    /* compute length of second template */

	    /* Obtain the size of the current iiqrytext (1 & 2) */
	    status = psq_tqrylen(cb->pss_tchain, &curoff);
	    if (status != E_DB_OK)
		return (status);

	    /* 
	    ** subtract length of first template to derive length of the second 
	    ** one
	    */
	    psy_cb->psy_updt_qlen = curoff - psy_cb->psy_noncol_qlen;
	}
	else
	{
	    psy_cb->psy_updt_qlen = 0;
	}

	/*
	** Now emit iiqrytext for REFERENCES [EXCLUDING] (cols) case, 
	** if necessary.
	*/
	if (refcols)
	{
	    status = psl_bld_col_spec_grant_template(cb->pss_tchain, 
		"references",
		(bool) ((psy_cb->psy_flags & PSY_EXCLUDE_REFERENCES_COLUMNS) 
			!= 0),
		&psy_cb->psy_r_colq, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return(status);

	    /* Obtain the size of the current iiqrytext (1 & 2 & 3) */
	    status = psq_tqrylen(cb->pss_tchain, &curoff);
	    if (status != E_DB_OK)
		return (status);

	    /* compute the length of the second template built so far */
	    curoff -= (psy_cb->psy_noncol_qlen + psy_cb->psy_updt_qlen);

	    /*
	    ** Compute offset to the beginning of the object name and grantee
	    ** name in the third template.
	    ** To do this we need to subtract from the table/grantee name offset
	    ** in the first template the length of
	    ** "GRANT <non-column privileges>" and add the length of the third
	    ** template text built so far (i.e. "GRANT REFERENCES (...) ".)
	    */
	    psy_cb->psy_ref_obj_name_off =
		psy_cb->psy_noncol_obj_name_off - textcnst + curoff;
	    psy_cb->psy_ref_grantee_off =
		psy_cb->psy_noncol_grantee_off - textcnst + curoff;

	    /* copy the first template starting with ON [TABLE] */
	    status = psq_tadd(cb->pss_tchain, (u_char *) (text + textcnst),
		STlength(text + textcnst), &piece, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);

	    /* compute length of third template */

	    /* Obtain the size of the current iiqrytext (1 & 2 & 3) */
	    status = psq_tqrylen(cb->pss_tchain, &curoff);
	    if (status != E_DB_OK)
		return (status);

	    /* 
	    ** subtract length of first two stored templates to derive length of
	    ** the third one
	    */
	    psy_cb->psy_ref_qlen =
		curoff - psy_cb->psy_noncol_qlen - psy_cb->psy_updt_qlen;
	}
	else
	{
	    psy_cb->psy_ref_qlen = 0;
	}

	/*
	** All needed templates are ready now. Put the iiqrytext in a contiguous
	** block in QSF.
	*/
	status = psq_tout(cb, (PSS_USRRANGE *) NULL, 
	    cb->pss_tchain, &cb->pss_tstream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/*
	** Copy the object id for the query text to the control block.
	*/
	STRUCT_ASSIGN_MACRO(cb->pss_tstream.psf_mstream, psy_cb->psy_qrytext);
	
	/* DONE GENERATING QUERY TEXT */

    }
	|	    grant_kwd dbproc_priv_spec dbproc_priv_obj_spec
		    grant_auth_spec grant_option
    {
/* GRANT ... ON PROCEDURE ... WITH GRANT OPTION */
	DB_STATUS           status;
	PSY_CB		    *psy_cb = (PSY_CB *) cb->pss_object;
	PTR                 piece;
	i4		    err_code;
	u_char              ident_placeholder[DB_MAX_DELIMID + 1];
	char		    text[512];
	char		    *str;
	i4		    str_len;

#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** GRANT ... ON PROCEDURE not allowed in CREATE SCHEMA
	    */
	    (VOID) psf_error(6656L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		(i4) sizeof("CREATE SCHEMA")-1, "CREATE SCHEMA",
		(i4) sizeof("GRANT ... ON PROCEDURE")-1,
				 "GRANT ... ON PROCEDURE");
	    return (E_DB_ERROR);	/* non-zero return means error */
	}
	    
	/*
	** Set grantee type; default is USER 
	*/
	psy_cb->psy_gtype = ($4 == DBGR_DEFAULT) ? DBGR_USER : $4;

	/*
	** if WITH GRANT OPTION was specified, make sure that the grantee is of
	** type USER or PUBLIC (recall that PUBLIC may be specified as one of
	** user authorization identifier(s))
	*/
	if (   psy_cb->psy_opmap & DB_GRANT_OPTION
	    && psy_cb->psy_gtype != DBGR_USER)
	{
	    (VOID) psf_error(E_PS0550_GRANTEE_TYPE_FOR_WGO, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** The "grant" statement requires query text to be stored
	** in the iiqrytext relation. A template will be generated here.
	** Later on, in psy_dgrant, dbproc and grantee names will be
	** substituted.
	*/

	/* fill in an identifier placeholder */
	MEfill(DB_MAX_DELIMID, '?', (PTR) ident_placeholder);
	ident_placeholder[DB_MAX_DELIMID] = EOS;

	status = psq_topen(&cb->pss_tchain, &cb->pss_memleft,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Text is a buffer where templates are built */
	text[0] = EOS;

	/* EXECUTE, ALL, or ALL PRIVILEGES mean the same thing: EXECUTE */
	STcat(text, "grant execute on procedure ");

	/* Remember offset to the dbproc name. */
	psy_cb->psy_noncol_obj_name_off = STlength(text);

	/* Append the place holder for schema.dbproc name */
	STcat(text, (char *) ident_placeholder);
	STcat(text, ".");
	STcat(text, (char *) ident_placeholder);

	psl_grantee_type_to_str($4, &str, &str_len, FALSE);
	if (!str)
	{
	    /* this is very bad */
	    (VOID) psf_error(E_PS0002_INTERNAL_ERROR, 0L, PSF_INTERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	STcat(text, str);

	/* remember offset to the grantee name in the template */
	psy_cb->psy_noncol_grantee_off = 
	      psy_cb->psy_noncol_obj_name_off 	/* begining of schema name */
	    + DB_MAX_DELIMID			/* schema name placeholder */
	    + CMbytecnt(".")			/* separator b/w schema and 
						** object name */
	    + DB_MAX_DELIMID                    /* object name placeholder */
	    + str_len;				/* TO <grantee type> */

	/* append the place holder for grantee name */
	STcat(text, (char *) ident_placeholder);

	if (psy_cb->psy_opmap & DB_GRANT_OPTION)
	{
	    STcat(text, " with grant option ");
	}

	/* The template is ready now. */
	status = psq_tadd(cb->pss_tchain, (u_char *) text, STlength(text),
	    &piece, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Determine size of the template */
	status = psq_tqrylen(cb->pss_tchain, &psy_cb->psy_noncol_qlen);
	if (status != E_DB_OK)
	    return (status);

	/*
	** Put the iiqrytext in a contiguous block in QSF.
	*/
	status = psq_tout(cb, (PSS_USRRANGE*) NULL, 
	    cb->pss_tchain, &cb->pss_tstream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/*
	** Copy the object id for the query text to the control block.
	*/
	STRUCT_ASSIGN_MACRO(cb->pss_tstream.psf_mstream, psy_cb->psy_qrytext);
	
	/* DONE GENERATING QUERY TEXT */

    }
	|	    grant_kwd seq_priv_spec seq_priv_obj_spec
		    grant_auth_spec grant_option
    {
/* GRANT ... ON SEQUENCE ... WITH GRANT OPTION */
	DB_STATUS           status;
	PSY_CB		    *psy_cb = (PSY_CB *) cb->pss_object;
	PTR                 piece;
	i4		    err_code;
	u_char              ident_placeholder[DB_MAX_DELIMID + 1];
	char		    text[512];
	char		    *str;
	i4		    str_len;

#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** GRANT ... ON SEQUENCE not allowed in CREATE SCHEMA
	    */
	    (void)psf_error(6656L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		(i4) sizeof("CREATE SCHEMA")-1, "CREATE SCHEMA",
		(i4) sizeof("GRANT ... ON SEQUENCE")-1,
				 "GRANT ... ON SEQUENCE");
	    return (E_DB_ERROR);	/* non-zero return means error */
	}
	    
	/*
	** Set grantee type; default is USER 
	*/
	psy_cb->psy_gtype = ($4 == DBGR_DEFAULT) ? DBGR_USER : $4;

	/*
	** if WITH GRANT OPTION was specified, make sure that the grantee is of
	** type USER or PUBLIC (recall that PUBLIC may be specified as one of
	** user authorization identifier(s))
	*/
	if (   psy_cb->psy_opmap & DB_GRANT_OPTION
	    && psy_cb->psy_gtype != DBGR_USER)
	{
	    (void)psf_error(E_PS0550_GRANTEE_TYPE_FOR_WGO, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** The "grant" statement requires query text to be stored
	** in the iiqrytext relation. A template will be generated here.
	** Later on, in psy_dgrant, sequence and grantee names will be
	** substituted.
	*/

	/* fill in an identifier placeholder */
	MEfill(DB_MAX_DELIMID, '?', (PTR) ident_placeholder);
	ident_placeholder[DB_MAX_DELIMID] = EOS;

	status = psq_topen(&cb->pss_tchain, &cb->pss_memleft,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Text is a buffer where templates are built */
	text[0] = EOS;

	/* NEXT, ALL, or ALL PRIVILEGES mean the same thing: NEXT */
	STcat(text, "grant next on sequence ");

	/* Remember offset to the sequence name. */
	psy_cb->psy_noncol_obj_name_off = STlength(text);

	/* Append the place holder for schema.sequence name */
	STcat(text, (char *) ident_placeholder);
	STcat(text, ".");
	STcat(text, (char *) ident_placeholder);

	psl_grantee_type_to_str($4, &str, &str_len, FALSE);
	if (!str)
	{
	    /* this is very bad */
	    (void)psf_error(E_PS0002_INTERNAL_ERROR, 0L, PSF_INTERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	STcat(text, str);

	/* remember offset to the grantee name in the template */
	psy_cb->psy_noncol_grantee_off = 
	      psy_cb->psy_noncol_obj_name_off 	/* begining of schema name */
	    + DB_MAX_DELIMID			/* schema name placeholder */
	    + CMbytecnt(".")			/* separator b/w schema and 
						** object name */
	    + DB_MAX_DELIMID                    /* object name placeholder */
	    + str_len;				/* TO <grantee type> */

	/* append the place holder for grantee name */
	STcat(text, (char *) ident_placeholder);

	if (psy_cb->psy_opmap & DB_GRANT_OPTION)
	{
	    STcat(text, " with grant option ");
	}

	/* The template is ready now. */
	status = psq_tadd(cb->pss_tchain, (u_char *) text, STlength(text),
	    &piece, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Determine size of the template */
	status = psq_tqrylen(cb->pss_tchain, &psy_cb->psy_noncol_qlen);
	if (status != E_DB_OK)
	    return (status);

	/*
	** Put the iiqrytext in a contiguous block in QSF.
	*/
	status = psq_tout(cb, (PSS_USRRANGE*) NULL, 
	    cb->pss_tchain, &cb->pss_tstream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/*
	** Copy the object id for the query text to the control block.
	*/
	STRUCT_ASSIGN_MACRO(cb->pss_tstream.psf_mstream, psy_cb->psy_qrytext);
	
	/* DONE GENERATING QUERY TEXT */

    }
	|	grant_kwd event_priv_spec event_priv_obj_spec
		grant_auth_spec grant_option
    {
/* GRANT ... ON DBEVENT ... WITH GRANT OPTION */
	DB_STATUS           status;
	PSY_CB		    *psy_cb = (PSY_CB *) cb->pss_object;
	PTR                 piece;
	i4		    err_code;
	u_char              ident_placeholder[DB_MAX_DELIMID + 1];
	char		    text[512];
	char		    *str;
	i4		    str_len;

#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** GRANT ... ON DBEVENT not allowed in CREATE SCHEMA
	    */
	    (VOID) psf_error(6656L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		(i4) sizeof("CREATE SCHEMA")-1, "CREATE SCHEMA",
		(i4) sizeof("GRANT ... ON DBEVENT")-1,
				 "GRANT ... ON DBEVENT");
	    return (E_DB_ERROR);	/* non-zero return means error */
	}
	    
	/*
	** Set grantee type; default is USER 
	*/
	psy_cb->psy_gtype = ($4 == DBGR_DEFAULT) ? DBGR_USER : $4;

	/*
	** if WITH GRANT OPTION was specified, make sure that the grantee is of
	** type USER or PUBLIC (recall that PUBLIC would be specified as one of
	** user authorization identifiers)
	*/
	if (   psy_cb->psy_opmap & DB_GRANT_OPTION
	    && psy_cb->psy_gtype != DBGR_USER)
	{
	    (VOID) psf_error(E_PS0550_GRANTEE_TYPE_FOR_WGO, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** The "grant" statement requires query text to be stored
	** in the iiqrytext relation. A template will be generated here.
	** Later on, in psy_dgrant, dbevent and grantee names will be
	** substituted.
	*/

	/* fill in an identifier placeholder */
	MEfill(DB_MAX_DELIMID, '?', (PTR) ident_placeholder);
	ident_placeholder[DB_MAX_DELIMID] = EOS;

	status = psq_topen(&cb->pss_tchain, &cb->pss_memleft, 
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Text is a buffer where templates are built */
	text[0] = EOS;

	/*
	** ALL [PRIVILEGES] will get translated into two tuples - for REGISTER
	** and RAISE; template will contain a placeholder for the longest of
	** them - REGISTER
	*/
	if (psy_cb->psy_opmap & DB_EVREGISTER && psy_cb->psy_opmap & DB_EVRAISE)
	{
	    /*
	    ** 2 permit tuples will be generated - template will contain a
	    ** placeholder for the longest privilege - REGISTER
	    */
	    str = "grant ???????? on dbevent ";
	}
	else if (psy_cb->psy_opmap & DB_EVREGISTER)
	{
	    str = "grant register on dbevent ";
	}
	else
	{
	    str = "grant raise on dbevent ";
	}

	STcat(text, str);

	/* Remember offset to the dbevent name. */
	psy_cb->psy_noncol_obj_name_off = STlength(text);

	/* Append the place holder for 'owner'.dbevent name. */
	STcat(text, (char *) ident_placeholder);
	STcat(text, ".");
	STcat(text, (char *) ident_placeholder);

	psl_grantee_type_to_str($4, &str, &str_len, FALSE);
	if (!str)
	{
	    /* this is very bad */
	    (VOID) psf_error(E_PS0002_INTERNAL_ERROR, 0L, PSF_INTERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	STcat(text, str);

	/* remember offset to the grantee name in the template */
	psy_cb->psy_noncol_grantee_off = 
	      psy_cb->psy_noncol_obj_name_off 	/* begining of schema name */
	    + DB_MAX_DELIMID			/* schema name placeholder */
	    + CMbytecnt(".")			/* separator b/w schema and 
						** object name */
	    + DB_MAX_DELIMID                    /* object name placeholder */
	    + str_len;				/* TO <grantee type> */

	/* append the place holder for grantee name */
	STcat(text, (char *) ident_placeholder);

	if (psy_cb->psy_opmap & DB_GRANT_OPTION)
	{
	    STcat(text, " with grant option ");
	}

	/*
	** The template is ready now. 
	*/
	status = psq_tadd(cb->pss_tchain, (u_char *) text,
	    STlength(text), &piece, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Determine size of the iiqrytext */
	status = psq_tqrylen(cb->pss_tchain, &psy_cb->psy_noncol_qlen);
	if (status != E_DB_OK)
	    return (status);

	/*
	** Put the iiqrytext in a contiguous block in QSF.
	*/
	status = psq_tout(cb, (PSS_USRRANGE*) NULL, 
	    cb->pss_tchain, &cb->pss_tstream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/*
	** Copy the object id for the query text to the control block.
	*/
	STRUCT_ASSIGN_MACRO(cb->pss_tstream.psf_mstream, psy_cb->psy_qrytext);
	
	/* DONE GENERATING QUERY TEXT */

    }
	|	grant_kwd db_priv_spec db_priv_obj_spec grant_auth_spec
    {
	i4	    err_code;
	PSY_CB	    *psy_cb = (PSY_CB *) cb->pss_object;

#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** GRANT ... ON DATABASE|INSTALLATION not allowed in CREATE SCHEMA
	    */
	    (VOID) psf_error(6656L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		(i4) sizeof("CREATE SCHEMA")-1, "CREATE SCHEMA",
		(i4) sizeof("GRANT ... ON DATABASE|INSTALLATION")-1,
				 "GRANT ... ON DATABASE|INSTALLATION");
	    return (E_DB_ERROR);	/* non-zero return means error */
	}
	    
	/* Translate ALL [PRIVILEGES] */
	if (psy_cb->psy_flags & PSY_ALL_PRIVS)
	{
	    psy_cb->psy_ctl_dbpriv = DBPR_C_ALLPRIVS;
	    psy_cb->psy_fl_dbpriv  = DBPR_F_ALLPRIVS;
	}

	/* Set grantee type; default is USER */
	psy_cb->psy_gtype = ($4 == DBGR_DEFAULT) ? DBGR_USER : $4;

	/* 
	** Set statement mode depending upon what privileges are granted:
	**	PSQ_GDBPRIV - One or more restricted privileges are granted
	**	PSQ_GOKPRIV - No restricted privileges are being granted
	*/

	if (   (psy_cb->psy_flags & PSY_GR_REV_ROLE)
	    && psy_cb->psy_gtype != DBGR_USER)
	{
	    (VOID) psf_error(9341, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	/* Set mode in the PSY_CB */
	if (psy_cb->psy_flags & PSY_GR_REV_ROLE)
	{
		psy_cb->psy_grant = PSY_RGRANT;
		psq_cb->psq_mode = PSQ_RGRANT;
	}
	else
	{
		psy_cb->psy_grant = PSY_DGRANT;
		psq_cb->psq_mode = (psy_cb->psy_ctl_dbpriv & DBPR_RESTRICTED)
								? PSQ_GDBPRIV
								: PSQ_GOKPRIV;
	}
    }
;
grant_option:	WITH GRANT OPTION
    {
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_GRANT_OPTION;
    }
	    |
;

grant_kwd:         GRANT
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

#ifdef	xDEBUG
	psl_debug();
#endif

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Special handling for CREATE SCHEMA
	    */
	    $Ysubmode = PSQ_GRANT;
	    $Ydeplist = (PST_OBJDEP *) NULL;
	    $Ystmtstart = (char *) cb->pss_prvgoval;
	    $Ycons_list = (PSS_CONS *) NULL;
	    return(E_DB_OK);
	}
	    
	psq_cb->psq_mode = PSQ_GRANT;

	/* "grant" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(2325L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the grant statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Default terminal name is "" */
	MEfill(sizeof(psy_cb->psy_terminal), ' ', (PTR) &psy_cb->psy_terminal);

	/* default user name is " " */
	MEfill(sizeof(psy_cb->psy_user), ' ', (PTR) &psy_cb->psy_user);
	
	/*
	** Default time is all day, starting at 00:00 and ending at 24:00,
	** given as minutes after 00:00.
	*/
	psy_cb->psy_timbgn = 0;
	psy_cb->psy_timend = 1440;

	/*
	** Default days are all week, starting with Sunday and ending with
	** Saturday.  Sunday = 0, Saturday = 6.
	*/
	psy_cb->psy_daybgn = 0;
	psy_cb->psy_dayend = 6;

	/*
	** next we will be processing the list of privileges, psl_sscan() will
	** accord special treatment to words REGISTER and RAISE (dbevent
	** privileges) only when processing the privilege specification of 
	** GRANT or REVOKE statements
	*/
	cb->pss_stmt_flags |= PSS_PARSING_PRIVS;

	if ((psq_cb->psq_info != (PST_INFO *) NULL) &&
            (psq_cb->psq_info->pst_execflags & PST_SCHEMA_MODE))
	    psy_cb->psy_flags |= PSY_SCHEMA_MODE;

	/* Initialize object queue */
	(VOID) QUinit((QUEUE *) &psy_cb->psy_objq); /* No objects */

    }
;
    
priv_noise:	    PRIVILEGES
	  |
;

tbl_priv_spec:	    tbl_priv_list
    {
	PSY_CB      *psy_cb = (PSY_CB *) cb->pss_object;

	/* granting/revoking privilege(s) on a Table */
	psy_cb->psy_grant = (psq_cb->psq_mode == PSQ_GRANT) ? PSY_TGRANT
							    : PSY_TREVOKE;
	/* defined ops are the same as allowed ops */
	psy_cb->psy_opctl = psy_cb->psy_opmap;

	/* finished parsing the privilege specification */
	cb->pss_stmt_flags &= ~PSS_PARSING_PRIVS;
    }
	     |	    ALL priv_noise
    {
	PSY_CB      *psy_cb = (PSY_CB *) cb->pss_object;
	
	/* granting/revoking privilege(s) on a Table */
	psy_cb->psy_grant = (psq_cb->psq_mode == PSQ_GRANT) ? PSY_TGRANT
							    : PSY_TREVOKE;

	/* finished parsing the privilege specification */
	cb->pss_stmt_flags &= ~PSS_PARSING_PRIVS;

	/*
	** defined ops are the same as allowed ops
	*/
	psy_cb->psy_opctl =
	    (psy_cb->psy_opmap |=
		DB_RETRIEVE | DB_APPEND | DB_REPLACE | DB_DELETE
		    | DB_REFERENCES | DB_COPY_INTO | DB_COPY_FROM);

	/*
	** remember that the user specified ALL [PRIVILEGES] and has not
	** specified all of the privileges explicitly
	*/
	psy_cb->psy_flags |= PSY_ALL_PRIVS;
    }
;

tbl_priv_list:	    tbl_priv
	     |	    tbl_priv_list COMMA tbl_priv
;

tbl_priv:	    SELECT
    {
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_RETRIEVE;
    }
	|	    DELETE
    {
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_DELETE;
    }
	|	    INSERT
    {
	/*
	** @FIX_ME@:
	**	when we start supporting INSERT(column_list), having processed 
	**	the grant_col_spec we will need to recompute 
	** 	psy_cb->psy_r_col_offset which depends on psy_cb->psy_i_numcols
	** @FIX_ME@
	*/
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_APPEND;
    }
	|	    UPDATE
    {
	$Ypriv = DB_REPLACE;
    }
		    grant_col_spec
    {
	PSY_CB		*psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_opmap |= DB_REPLACE;

	/*
	** recompute offset of the beginning of the attribute list
	** associated with INSERT and REFERENCES privileges
	** (attributes (if any) to which UPDATE will/won't apply
	** will be placed in the beginning of the list - offset 0)
	*/
	psy_cb->psy_u_col_offset = 0;
	psy_cb->psy_i_col_offset = psy_cb->psy_u_numcols;
	psy_cb->psy_r_col_offset =
	    psy_cb->psy_i_col_offset + psy_cb->psy_i_numcols;
    }
	|	    REFERENCES
    {
	$Ypriv = DB_REFERENCES;
    }
		    grant_col_spec
    {
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_REFERENCES;
    }
	| COPY_FROM
    {
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_COPY_FROM;
	((PSY_CB *) cb->pss_object)->psy_opctl |= DB_COPY_FROM;
    }
	| COPY_INTO
    {
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_COPY_INTO;
	((PSY_CB *) cb->pss_object)->psy_opctl |= DB_COPY_INTO;
    }
;

dbproc_priv_spec:   dbproc_priv_list
    {
	PSY_CB      *psy_cb = (PSY_CB *) cb->pss_object;

	/* granting/revoking privilege on a Procedure */
	psy_cb->psy_grant = (psq_cb->psq_mode == PSQ_GRANT) ? PSY_PGRANT
							    : PSY_PREVOKE;
	/* defined ops are the same as allowed ops */
	psy_cb->psy_opctl = psy_cb->psy_opmap;

	/* finished parsing the privilege specification */
	cb->pss_stmt_flags &= ~PSS_PARSING_PRIVS;
    }
		|   ALL priv_noise
    {
	PSY_CB      *psy_cb = (PSY_CB *) cb->pss_object;
	
	/* granting/revoking privilege on a Procedure */
	psy_cb->psy_grant = (psq_cb->psq_mode == PSQ_GRANT) ? PSY_PGRANT
							    : PSY_PREVOKE;

	/* finished parsing the privilege specification */
	cb->pss_stmt_flags &= ~PSS_PARSING_PRIVS;

	/*
	** defined ops are the same as allowed ops
	*/
	psy_cb->psy_opctl = (psy_cb->psy_opmap |= DB_EXECUTE);

	/*
	** remember that the user specified ALL [PRIVILEGES] and has not
	** specified all of the privileges explicitly
	*/
	psy_cb->psy_flags |= PSY_ALL_PRIVS;
    }
;

dbproc_priv_list:   dbproc_priv
		|   dbproc_priv_list COMMA dbproc_priv
;

dbproc_priv:	    EXECUTE
    {
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_EXECUTE;
    }
;

seq_priv_spec:   seq_priv_list
    {
	PSY_CB      *psy_cb = (PSY_CB *) cb->pss_object;

	/* granting/revoking privilege on a sequence */
	psy_cb->psy_grant = (psq_cb->psq_mode == PSQ_GRANT) ? PSY_SQGRANT
							    : PSY_SQREVOKE;
	/* defined ops are the same as allowed ops */
	psy_cb->psy_opctl = psy_cb->psy_opmap;

	/* finished parsing the privilege specification */
	cb->pss_stmt_flags &= ~PSS_PARSING_PRIVS;
    }
		|   ALL priv_noise
    {
	PSY_CB      *psy_cb = (PSY_CB *) cb->pss_object;
	
	/* granting/revoking privilege on a sequence */
	psy_cb->psy_grant = (psq_cb->psq_mode == PSQ_GRANT) ? PSY_SQGRANT
							    : PSY_SQREVOKE;

	/* finished parsing the privilege specification */
	cb->pss_stmt_flags &= ~PSS_PARSING_PRIVS;

	/*
	** defined ops are the same as allowed ops
	*/
	psy_cb->psy_opctl = (psy_cb->psy_opmap |= DB_NEXT);

	/*
	** remember that the user specified ALL [PRIVILEGES] and has not
	** specified all of the privileges explicitly
	*/
	psy_cb->psy_flags |= PSY_ALL_PRIVS;
    }
;

seq_priv_list:   seq_priv
		|   seq_priv_list COMMA seq_priv
;

seq_priv:	    NEXT
    {
	/* "next" privilege is same as "select", but avoids grammar ambiguity. */
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_NEXT;
    }
;

event_priv_spec:    event_priv_list
    {
	PSY_CB      *psy_cb = (PSY_CB *) cb->pss_object;

	/* Granting/revoking privilege(s) on a dbevent */
	psy_cb->psy_grant = (psq_cb->psq_mode == PSQ_GRANT) ? PSY_EVGRANT
							    : PSY_EVREVOKE;

	/* defined ops are the same as allowed ops */
	psy_cb->psy_opctl = psy_cb->psy_opmap;

	/* finished parsing the privilege specification */
	cb->pss_stmt_flags &= ~PSS_PARSING_PRIVS;
    }
	       |    ALL priv_noise
    {
	PSY_CB      *psy_cb = (PSY_CB *) cb->pss_object;
	
	/* Granting/revoking privilege(s) on a dbevent */
	psy_cb->psy_grant = (psq_cb->psq_mode == PSQ_GRANT) ? PSY_EVGRANT
							    : PSY_EVREVOKE;

	/* finished parsing the privilege specification */
	cb->pss_stmt_flags &= ~PSS_PARSING_PRIVS;

	/*
	** defined ops are the same as allowed ops
	*/
	psy_cb->psy_opctl = (psy_cb->psy_opmap |= DB_EVREGISTER | DB_EVRAISE);

	/*
	** remember that the user specified ALL [PRIVILEGES] and has not
	** specified all of the privileges explicitly
	*/
	psy_cb->psy_flags |= PSY_ALL_PRIVS;
    }
;

event_priv_list:    event_priv
	       |    event_priv_list COMMA event_priv
;

event_priv:	    REGISTER
    {
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_EVREGISTER;
    }
	  |	    RAISE
    {
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_EVRAISE;
    }
;

db_priv_spec:	    db_priv_list
    {
	/* finished parsing the privilege specification */
	cb->pss_stmt_flags &= ~PSS_PARSING_PRIVS;
    }
	    |	    ALL priv_noise
    {
	PSY_CB	    *psy_cb = (PSY_CB *) cb->pss_object;
	
	/* REVOKE GRANT OPTION FOR <database_privs> is not supported yet */
	if (   psq_cb->psq_mode == PSQ_REVOKE
	    && psy_cb->psy_opmap & DB_GRANT_OPTION)
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}

	/* finished parsing the privilege specification */
	cb->pss_stmt_flags &= ~PSS_PARSING_PRIVS;
	
	/*
	** remember that the user specified ALL [PRIVILEGES] and has not
	** specified all of the privileges explicitly
	*/
	psy_cb->psy_flags |= PSY_ALL_PRIVS;
    }
;

db_priv_list:	    db_priv
    {
	/* REVOKE GRANT OPTION FOR <database_privs> is not supported yet */
	if (   psq_cb->psq_mode == PSQ_REVOKE
	    && ((PSY_CB *) cb->pss_object)->psy_opmap & DB_GRANT_OPTION)
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}
    }
	    |	    db_priv_list COMMA db_priv
;
/*
** Note that using user_ident is a little over flexible here. We are parsing
** either:
**	GRANT dbprivilege [intconst] ...
** or
**	GRANT ["]rolename["] ...
**
** but don't know which yet. We use user_ident to allow either, then
** later on check if the input was appropriate. (both parts have to use
** user_ident consistently otherwise a reduce/reduce error can occur)
*/
db_priv:	    user_ident
    {
	PSY_CB	    *psy_cb = (PSY_CB *) cb->pss_object;
	DB_STATUS   status;

	status=psl_dp1_dbp_nonkeyword(cb, psy_cb, psq_cb, $1);
	if(status!=E_DB_OK)
		return status;
    }
	    |	    user_ident intconst_p
    {
	PSY_CB	    *psy_cb = (PSY_CB *) cb->pss_object;
	i4	    err_code;
	i4	    err_num = 0;

	if (psq_cb->psq_mode == PSQ_REVOKE)
	{
	    if ((STcasecmp($1, "QUERY_IO_LIMIT") == 0) ||
		(STcasecmp($1, "QUERY_ROW_LIMIT") == 0) ||
		(STcasecmp($1, "QUERY_CPU_LIMIT") == 0) ||
		(STcasecmp($1, "QUERY_PAGE_LIMIT") == 0) ||
		(STcasecmp($1, "QUERY_COST_LIMIT") == 0) ||
		(STcasecmp($1, "IDLE_TIME_LIMIT") == 0) ||
		(STcasecmp($1, "CONNECT_TIME_LIMIT") == 0) ||
		(STcasecmp($1, "SESSION_PRIORITY") == 0)
	       )
		err_num = 6286L;
	    else
		err_num = 6287L;
	}
	else if (STcasecmp($1, "QUERY_IO_LIMIT") == 0)
	{
	    if ((psy_cb->psy_ctl_dbpriv & DBPR_QDIO_LIMIT) &&
		(!(psy_cb->psy_fl_dbpriv & DBPR_QDIO_LIMIT) ||
		  (psy_cb->psy_qdio_limit != $2)))
		err_num = 6289L;
	    else
	    {
		psy_cb->psy_ctl_dbpriv |= DBPR_QDIO_LIMIT;
		psy_cb->psy_fl_dbpriv  |= DBPR_QDIO_LIMIT;
		psy_cb->psy_qdio_limit = $2;
	    }
	}
	else if (STcasecmp($1, "QUERY_ROW_LIMIT") == 0)
	{
	    if ((psy_cb->psy_ctl_dbpriv & DBPR_QROW_LIMIT) &&
		(!(psy_cb->psy_fl_dbpriv & DBPR_QROW_LIMIT) ||
		  (psy_cb->psy_qrow_limit != $2)))
		err_num = 6289L;
	    else
	    {
		psy_cb->psy_ctl_dbpriv |= DBPR_QROW_LIMIT;
		psy_cb->psy_fl_dbpriv  |= DBPR_QROW_LIMIT;
		psy_cb->psy_qrow_limit = $2;
	    }
	}
	else if (STcasecmp($1, "QUERY_CPU_LIMIT") == 0)
	{
	    if ((psy_cb->psy_ctl_dbpriv & DBPR_QCPU_LIMIT) &&
		(!(psy_cb->psy_fl_dbpriv & DBPR_QCPU_LIMIT) ||
		  (psy_cb->psy_qcpu_limit != $2)))
		err_num = 6289L;
	    else
	    {
		psy_cb->psy_ctl_dbpriv |= DBPR_QCPU_LIMIT;
		psy_cb->psy_fl_dbpriv  |= DBPR_QCPU_LIMIT;
		psy_cb->psy_qcpu_limit = $2;
	    }
	}
	else if (STcasecmp($1, "QUERY_PAGE_LIMIT") == 0)
	{
	    if ((psy_cb->psy_ctl_dbpriv & DBPR_QPAGE_LIMIT) &&
		(!(psy_cb->psy_fl_dbpriv & DBPR_QPAGE_LIMIT) ||
		  (psy_cb->psy_qpage_limit != $2)))
		err_num = 6289L;
	    else
	    {
		psy_cb->psy_ctl_dbpriv |= DBPR_QPAGE_LIMIT;
		psy_cb->psy_fl_dbpriv  |= DBPR_QPAGE_LIMIT;
		psy_cb->psy_qpage_limit = $2;
	    }
	}
	else if (STcasecmp($1, "IDLE_TIME_LIMIT") == 0)
	{
	    if ((psy_cb->psy_ctl_dbpriv & DBPR_IDLE_LIMIT) &&
		(!(psy_cb->psy_fl_dbpriv & DBPR_IDLE_LIMIT) ||
		  (psy_cb->psy_idle_limit != $2)))
		err_num = 6289L;
	    else
	    {
		psy_cb->psy_ctl_dbpriv |= DBPR_IDLE_LIMIT;
		psy_cb->psy_fl_dbpriv  |= DBPR_IDLE_LIMIT;
		psy_cb->psy_idle_limit = $2;
	    }
	}
	else if (STcasecmp($1, "CONNECT_TIME_LIMIT") == 0)
	{
	    if ((psy_cb->psy_ctl_dbpriv & DBPR_CONNECT_LIMIT) &&
		(!(psy_cb->psy_fl_dbpriv & DBPR_CONNECT_LIMIT) ||
		  (psy_cb->psy_connect_limit != $2)))
		err_num = 6289L;
	    else
	    {
		psy_cb->psy_ctl_dbpriv |= DBPR_CONNECT_LIMIT;
		psy_cb->psy_fl_dbpriv  |= DBPR_CONNECT_LIMIT;
		psy_cb->psy_connect_limit = $2;
	    }
	}
	else if (STcasecmp($1, "SESSION_PRIORITY") == 0)
	{
	    if ((psy_cb->psy_ctl_dbpriv & DBPR_PRIORITY_LIMIT) &&
		(!(psy_cb->psy_fl_dbpriv & DBPR_PRIORITY_LIMIT) ||
		  (psy_cb->psy_priority_limit != $2)))
		err_num = 6289L;
	    else
	    {
		psy_cb->psy_ctl_dbpriv |= DBPR_PRIORITY_LIMIT;
		psy_cb->psy_fl_dbpriv  |= DBPR_PRIORITY_LIMIT;
		psy_cb->psy_priority_limit = $2;
	    }
	}
	else if (STcasecmp($1, "QUERY_COST_LIMIT") == 0)
	{
	    if ((psy_cb->psy_ctl_dbpriv & DBPR_QCOST_LIMIT) &&
		(!(psy_cb->psy_fl_dbpriv & DBPR_QCOST_LIMIT) ||
		  (psy_cb->psy_qcost_limit != $2)))
		err_num = 6289L;
	    else
	    {
		psy_cb->psy_ctl_dbpriv |= DBPR_QCOST_LIMIT;
		psy_cb->psy_fl_dbpriv  |= DBPR_QCOST_LIMIT;
		psy_cb->psy_qcost_limit = $2;
	    }
	}
	else if ((STcasecmp($1, "CREATE_TABLE") == 0) ||
		 (STcasecmp($1, "CREATE_PROCEDURE") == 0) ||
		 (STcasecmp($1, "CREATE_SEQUENCE") == 0) ||
		 (STcasecmp($1, "LOCKMODE") == 0) ||
		 (STcasecmp($1, "ACCESS") == 0) ||
		 (STcasecmp($1, "UPDATE_SYSCAT") == 0) ||
		 (STcasecmp($1, "SELECT_SYSCAT") == 0) ||
		 (STcasecmp($1, "TABLE_STATISTICS") == 0) ||
		 (STcasecmp($1, "DB_ADMIN") == 0) ||
		 (STcasecmp($1, "NOCREATE_TABLE") == 0) ||
		 (STcasecmp($1, "NOCREATE_PROCEDURE") == 0) ||
		 (STcasecmp($1, "NOCREATE_SEQUENCE") == 0) ||
		 (STcasecmp($1, "NOLOCKMODE") == 0) ||
		 (STcasecmp($1, "NOACCESS") == 0) ||
		 (STcasecmp($1, "NOUPDATE_SYSCAT") == 0) ||
		 (STcasecmp($1, "NOSELECT_SYSCAT") == 0) ||
		 (STcasecmp($1, "NOTABLE_STATISTICS") == 0) ||
		 (STcasecmp($1, "NOCONNECT_TIME_LIMIT") == 0) ||
		 (STcasecmp($1, "NOSESSION_PRIORITY") == 0) ||
		 (STcasecmp($1, "NOIDLE_TIME_LIMIT") == 0) ||
		 (STcasecmp($1, "NODB_ADMIN") == 0) ||
		 (STcasecmp($1, "NOQUERY_IO_LIMIT") == 0) ||
		 (STcasecmp($1, "NOQUERY_ROW_LIMIT") == 0) ||
		 (STcasecmp($1, "NOQUERY_CPU_LIMIT") == 0) ||
		 (STcasecmp($1, "NOQUERY_PAGE_LIMIT") == 0) ||
		 (STcasecmp($1, "NOQUERY_COST_LIMIT") == 0)
		)
	    err_num = 6287L;
	else
	    err_num = 6288L;

	if (err_num != 0)
	{
	    (VOID) psf_error(err_num, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STtrmwhite($1), $1);
	    return (E_DB_ERROR);
	}
	/*
	** Mark this as a dbpriv
	*/
	psy_cb->psy_flags |= PSY_GR_REV_DBPRIV;
    }
;

db_priv_obj_spec:   ONCURRENT nonkeyword
    {
	PSY_CB          *psy_cb;
	i4	    err_code;
	/* must be ON CURRENT INSTALLATION */
    	psy_cb = (PSY_CB *) cb->pss_object;
	if (CMcmpcase($2, "i") || STcompare($2, "installation"))
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}
	if(psy_cb->psy_flags & PSY_GR_REV_ROLE)
	{
	    /*
	    ** Assume role name(s) are illegal database priv names
	    ** since the format is of a database grant
	    */
	    (VOID) psf_error(6288, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) 0, "");
	    return E_DB_ERROR;
	}
    }
	    |	    ONDATABASE db_loc_obj_list
	    {
		PSY_CB          *psy_cb;
		i4	    err_code;

		psy_cb = (PSY_CB *) cb->pss_object;
		if(psy_cb->psy_flags & PSY_GR_REV_ROLE)
		{
		    /*
		    ** Assume role name(s) are illegal database priv names
		    ** since the format is of a database grant
		    */
		    (VOID) psf_error(6288, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1, (i4) 0, "");
		    return E_DB_ERROR;
		}
	    }
	    | /* empty */
	    {
		PSY_CB          *psy_cb;
		/*
		** This clause is missing for ROLE grants, so
		** mark we are doing a role grant. Also check at this
		** point we have at least one role name
		*/
    		psy_cb = (PSY_CB *) cb->pss_object;
		if(!((psy_cb->psy_flags & PSY_GR_REV_ROLE) ||
		    psy_cb->psy_ctl_dbpriv & (DBPR_ALLPRIVS | DBPR_ALL)) ||
		    (psy_cb->psy_flags & PSY_GR_REV_DBPRIV))
		{
			psl_yerror(3, cb, psq_cb);
			return E_DB_ERROR;
		}
	    }
	    ;

db_loc_obj_list:	db_loc_obj
	    |		db_loc_obj_list COMMA db_loc_obj
;

db_loc_obj:		    generic_ident
    {
	PSY_CB          *psy_cb;
	PSY_TBL		*psy_tbl;
	DB_STATUS	status;
	bool		found = FALSE;
	DB_TAB_NAME	db_name;


	STmove($1, ' ', sizeof(DB_TAB_NAME), (char *) &db_name);

	/* database and location names must be in lowercase */
	if (*cb->pss_dbxlate & CUI_ID_REG_U)
	    CVlower(db_name.db_tab_name);
	
    	psy_cb = (PSY_CB *) cb->pss_object;

	/* Check if database is being specified for the first time. */
	for (psy_tbl = (PSY_TBL *) psy_cb->psy_tblq.q_next;
	     psy_tbl != (PSY_TBL *) &psy_cb->psy_tblq;
	     psy_tbl = (PSY_TBL *) psy_tbl->queue.q_next
	    )
	{
	    if (!MEcmp((PTR) &db_name, (PTR) &psy_tbl->psy_tabnm,
		       sizeof(psy_tbl->psy_tabnm)))
	    {
		found = TRUE;
		break;
	    }
	}

	if (!found)
	{
	    /* Allocate memory for an object entry */
	    status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSY_TBL),
		(PTR *) &psy_tbl, &psq_cb->psq_error);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }

	    /*
	    ** Copy database name to object entry.
	    */
	    STRUCT_ASSIGN_MACRO(db_name, psy_tbl->psy_tabnm);

	    /*
	    ** Attach element to the list.
	    */
	    (VOID) QUinsert((QUEUE *) psy_tbl, (QUEUE *) &psy_cb->psy_tblq);
	}
    }
;

tbl_priv_obj_spec:  ON tbl_priv_obj_list
    {
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** if privileges cannot be granted/revoked on any of specified objects,
	** we will simply return E_DB_ERROR since there is no reason to proceed 
	** on to psy_dgrant() or psy_revoke().
	*/
	if (psy_cb->psy_tblq.q_next == &psy_cb->psy_tblq)
	{
	    return(E_DB_ERROR);
	}

	$$ = 0;
    }
	    |	    ON TABLE tbl_priv_obj_list
    {
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** if privileges cannot be granted/revoked on any of specified objects,
	** we will simply return E_DB_ERROR since there is no reason to proceed 
	** on to psy_dgrant() or psy_revoke().
	*/
	if (psy_cb->psy_tblq.q_next == &psy_cb->psy_tblq)
	{
	    return(E_DB_ERROR);
	}

	$$ = 1;
    }
;

tbl_priv_obj_list:  tbl_priv_obj
	    |	    tbl_priv_obj_list COMMA tbl_priv_obj
;

tbl_priv_obj:	    obj_spec
    {
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;
	i4		err_code;
	PSY_TBL		*psy_tbl;
	DB_STATUS	status;
	bool		found = FALSE;
	PSS_RNGTAB	*resrange;
	i4		rngvar_info;
	bool		updtcols, insrtcols, refcols, colprivs;

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Capture object name for CREATE SCHEMA
	    */
	    return(psl_cs06s_obj_spec(cb, psq_cb, &($Ydeplist), $1,
				      (u_i4)0));
	}

	/*
	** remember whether one or more of UPDATE, INSERT, REFERENCES privilege
	** will or will not apply to a set of columns
	*/

	updtcols = psy_cb->psy_u_numcols != 0;
	insrtcols = psy_cb->psy_i_numcols != 0;
	refcols = psy_cb->psy_r_numcols != 0;

	colprivs = updtcols || insrtcols || refcols;

	if ($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl0_orngent(&cb->pss_auxrng, -1, $1->pss_orig_obj_name,
		&$1->pss_owner, &$1->pss_obj_name, cb, !colprivs, &resrange,
		psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info, 0);
	}
	else
	{
	    status = psl0_rngent(&cb->pss_auxrng, -1, $1->pss_orig_obj_name,
		&$1->pss_obj_name, cb, !colprivs, &resrange,
		psq_cb->psq_mode, &psq_cb->psq_error,
		PSS_USRTBL | PSS_DBATBL | PSS_INGTBL, &rngvar_info, 0);
	}

	if (status != E_DB_OK)
	{
	    return (status);
	}
	else if (resrange == (PSS_RNGTAB *) NULL)
	{
	    /* table doesn't exist */

	    /* 
	    ** if the user spevcified name of the schema, we will issue a vague
	    ** message saying that EITHER the table did not exist or the user
	    ** lacked required privileges on it; this way the user who possesses
	    ** no privileges on a table will not be able to find out about its
	    ** existence based on error messages.  If the schema name was not 
	    ** specified, we will continue issuing the old "table does not 
	    ** exist or is not owned by you" message
	    */

	    if ($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    {
		char        command[PSL_MAX_COMM_STRING];
		i4     length;

		psl_command_string(psq_cb->psq_mode, cb->pss_lang, command, 
		    &length);

		(VOID) psf_error(E_US088E_2190_INACCESSIBLE_TBL, 0L, 
		    PSF_USERERR,&err_code, &psq_cb->psq_error, 3,
		    length, command,
		    psf_trmwhite(sizeof($1->pss_owner), 
			(char *) &$1->pss_owner),
		    &$1->pss_owner,
		    psf_trmwhite(sizeof($1->pss_obj_name),
			(char *) &$1->pss_obj_name),
		    &$1->pss_obj_name);
	    }
	    else
	    {
	        (VOID) psf_error(2117L, 0L, PSF_USERERR,&err_code,
		    &psq_cb->psq_error, 1, STlength($1->pss_orig_obj_name),
		    $1->pss_orig_obj_name);
	    }

	    /*
	    ** if processing GRANT inside CREATE SCHEMA, non-existent table 
	    ** constitutes a Syntax Rule violation and will result in the 
	    ** CREATE SCHEMA being rolled back; 
	    ** otherwise, for the sake of backward compatibility, we will 
	    ** proceed to the next object name (if any) specified in the 
	    ** statement
	    */
	    if (   psq_cb->psq_mode == PSQ_GRANT 
		&& psy_cb->psy_flags & PSY_SCHEMA_MODE)
	    {
		return(E_DB_ERROR);
	    }
	}
	else
	{
	    i4	    mask;
	    
	    /* Check if table is specified for the first time */
	    for (psy_tbl = (PSY_TBL *) psy_cb->psy_tblq.q_next;
		 psy_tbl != (PSY_TBL *) &psy_cb->psy_tblq;
		 psy_tbl = (PSY_TBL *) psy_tbl->queue.q_next
		)
	    {
		/*
		** compare components of DB_TAB_ID rather than using more
		** expensive MEcmp()
		*/
		if (resrange->pss_tabid.db_tab_base ==
		    psy_tbl->psy_tabid.db_tab_base
		    &&
		    resrange->pss_tabid.db_tab_index ==
		    psy_tbl->psy_tabid.db_tab_index
		   )
		{
		    found = TRUE;

		    /*
		    ** if the same object is mentioned more than once by its 
		    ** name (as opposed to by synonym name) remember whether 
		    ** its schema and/or object name may be expressed as regular
		    ** identifiers
		    */
		    if (~rngvar_info & PSS_BY_SYNONYM)
		    {
			if (   ~psy_tbl->psy_mask & PSY_REGID_SCHEMA_NAME
			    && $1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
			    && $1->pss_schema_id_type == PSS_ID_REG
			   )
			{
			    psy_tbl->psy_mask |= PSY_REGID_SCHEMA_NAME;
			}

			if (   ~psy_tbl->psy_mask & PSY_REGID_OBJ_NAME
			    && $1->pss_obj_id_type == PSS_ID_REG)
			{
			    psy_tbl->psy_mask |= PSY_REGID_OBJ_NAME;
			}
		    }

		    break;
		}
	    }

	    if (!found)
	    {
		mask = resrange->pss_tabdesc->tbl_status_mask;

		if (mask & DMT_IDX)
		{
		    /*
		    ** let user know if name supplied by the user was
		    ** resolved to a synonym
		    */
		    if (rngvar_info & PSS_BY_SYNONYM)
		    {
			char        qry[PSL_MAX_COMM_STRING];
			i4     qry_len;

			psl_command_string(psq_cb->psq_mode, cb->pss_lang, 
			    qry, &qry_len);

			psl_syn_info_msg(cb, resrange, $1, rngvar_info,
			    (i4) qry_len, qry, &psq_cb->psq_error);
		    }

		    /* 
		    ** GRANT/REVOKE/CREATE SECURITY_ALARM on an index is not 
		    ** allowed 
		    */
		    (VOID) psf_error(2328L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1,
			psf_trmwhite(sizeof(DB_TAB_NAME),
			    (char *) &resrange->pss_tabname),
			&resrange->pss_tabname);

		    /*
		    ** if processing GRANT inside CREATE SCHEMA, violation of
		    ** a syntax rule will result in the whole statement being 
		    ** rolled back;
		    ** otherwise, for the sake of backward compatibility, we 
		    ** will proceed to the next object name (if any) specified 
		    ** in the statement
		    */
		    if (   psq_cb->psq_mode == PSQ_GRANT 
			&& psy_cb->psy_flags & PSY_SCHEMA_MODE)
		    {
			return(E_DB_ERROR);
		    }
		}
		else if (   mask & DMT_VIEW 
			 && (psy_cb->psy_opmap & DB_REFERENCES) 
			 && ~psy_cb->psy_flags & PSY_ALL_PRIVS
			)
		{
		    /* 
		    ** one may not explicitly GRANT/REVOKE REFERENCES on a view;
		    ** if ALL [PRIIVLEGES] was specified, code in 
		    ** psy_dgrant()/psy_revoke() will "know" to not try to 
		    ** GRANT/REVOKE REFERENCES on views
		    */
		    (VOID) psf_error(E_PS0470_REFERENCES_ON_VIEW, 0L, 
			PSF_USERERR, &err_code, &psq_cb->psq_error, 1,
			psf_trmwhite(sizeof(DB_TAB_NAME),
			    (char *) &resrange->pss_tabname),
			&resrange->pss_tabname);

		    /*
		    ** if processing GRANT inside CREATE SCHEMA, this error
		    ** will result in the whole statement being rolled back;
		    ** otherwise, for the sake of backward compatibility, we 
		    ** will proceed to the next object name (if any) specified 
		    ** in the statement
		    */
		    if (   psq_cb->psq_mode == PSQ_GRANT 
			&& psy_cb->psy_flags & PSY_SCHEMA_MODE)
		    {
			return(E_DB_ERROR);
		    }
		}
		else if (   mask & DMT_VIEW 
			 && (psy_cb->psy_opmap & (DB_COPY_INTO|DB_COPY_FROM)) 
			 && ~psy_cb->psy_flags & PSY_ALL_PRIVS
			)
		{
		    /* 
		    ** one may not explicitly GRANT/REVOKE COPY on a view;
		    ** if ALL [PRIIVLEGES] was specified, code in 
		    ** psy_dgrant()/psy_revoke() will "know" to not try to 
		    ** GRANT/REVOKE REFERENCES on views
		    */
		    (VOID) psf_error(E_PS04D0_GRANT_COPY_ON_VIEW, 0L, 
			PSF_USERERR, &err_code, &psq_cb->psq_error, 1,
			psf_trmwhite(sizeof(DB_TAB_NAME),
			    (char *) &resrange->pss_tabname),
			&resrange->pss_tabname);
		    /* do not return error; just a warning */
		}
		else
		{
		    /*
		    ** One no longer has to be a DBA or $INGRES in order to
		    ** GRANT or CREATE SECURITY_ALARM
		    */

		    /*
		    ** The following now applies to
		    ** GRANT and CREATE SECURITY_ALARM:
		    ** DBA can run the query against extended catalogs.
		    ** User may run the query against catalogs if he has a
		    ** catalog update privilege.
		    ** Any user may run the query against his table.
		    ** If !psy_permit_ok(), we definitely need to report an
		    ** error.
		    **
		    ** And one more change: we will no longer invoke
		    ** psy_permit_ok() when parsing GRANT/REVOKE.  A user may be
		    ** able to grant/revoke access to another user's object
		    ** providing he was given GRANT OPTION FOR/has previously
		    ** granted the same privileges on this object
		    */

		    if (psq_cb->psq_mode == PSQ_CALARM &&
			!psy_permit_ok(mask, cb, &resrange->pss_ownname))
		    {
			/*
			** Must audit CREATE SECURITY_ALARM failure.
			*/
			if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
			{
			    DB_STATUS       local_status;
			    DB_ERROR         e_error;

			    local_status = psy_secaudit(FALSE, cb,
				(char *)&resrange->pss_tabdesc->tbl_name,	
				&resrange->pss_tabdesc->tbl_owner,
				sizeof(DB_TAB_NAME), SXF_E_TABLE,
				I_SX202D_ALARM_CREATE, SXF_A_FAIL | SXF_A_CREATE,
				&e_error);
			}

			/*
			** let user know if name supplied by the user was
			** resolved to a synonym
			*/
			if (rngvar_info & PSS_BY_SYNONYM)
			{
			    psl_syn_info_msg(cb, resrange, $1, rngvar_info,
				sizeof("CREATE SECURITY_ALARM") - 1,
				"CREATE SECURITY_ALARM", &psq_cb->psq_error);
			}

			(VOID) psf_error(2327L, 0L, PSF_USERERR, &err_code,
			    &psq_cb->psq_error, 1,
			    psf_trmwhite(sizeof(DB_TAB_NAME),
				(char *) &resrange->pss_tabname),
			    &resrange->pss_tabname);
				
			return (E_DB_ERROR);
		    }

		    /* Allocate memory for a table entry */
		    status = psf_malloc(cb, &cb->pss_ostream,
			(i4) (sizeof(PSY_TBL) +
			    (psy_cb->psy_u_numcols + psy_cb->psy_i_numcols +
			      psy_cb->psy_r_numcols) * sizeof(i4)), 
			(PTR *) &psy_tbl, &psq_cb->psq_error);
		    if (status != E_DB_OK)
		    {
			return (status);
		    }

		    /*
		    ** Copy table id, table name, and owner name in table entry.
		    */
		    STRUCT_ASSIGN_MACRO(resrange->pss_tabid,
					psy_tbl->psy_tabid);
		    STRUCT_ASSIGN_MACRO(resrange->pss_tabname,
					psy_tbl->psy_tabnm);
		    STRUCT_ASSIGN_MACRO(resrange->pss_ownname,
					psy_tbl->psy_owner);

		    if (updtcols)	/* there are UPDATE cols */
		    {
			i4		    *attrid;
			DMT_ATT_ENTRY	    *attribute;
			register i4	    i;
			PSY_COL		    *psy_col;

			/*
			** Verify column existence, store attribute nos.
			*/
			for (psy_col = (PSY_COL *) psy_cb->psy_u_colq.q_next,
			     i = 0,
			     attrid = psy_tbl->psy_colatno +
				psy_cb->psy_u_col_offset;
				
			     i < psy_cb->psy_u_numcols;
			     
			     psy_col = (PSY_COL *) psy_col->queue.q_next,
			     i++,
			     attrid++
			    )
			{
			    /*
			    ** Store a attribute no. for each column.
			    */

			    /* Look up the attribute */
			    attribute = pst_coldesc(resrange,
				&psy_col->psy_colnm);

			    /*
			    ** Check for attribute not found;
			    ** user may not grant UPDATE on TID (attr 0)
			    */
			    if (attribute == (DMT_ATT_ENTRY *) NULL ||
				attribute->att_number == 0)
			    {
				(VOID) psf_error(2100L, 0L, PSF_USERERR,
				    &err_code, &psq_cb->psq_error, 4,
				    sizeof(cb->pss_lineno), &cb->pss_lineno,
				    psf_trmwhite(sizeof(DB_TAB_NAME),
					(char *) &resrange->pss_tabname),
				    &resrange->pss_tabname,
				    psf_trmwhite(sizeof(DB_OWN_NAME),
					(char *) &resrange->pss_ownname),
				    &resrange->pss_ownname,
				    psf_trmwhite(sizeof(DB_ATT_NAME),
					(char *) &psy_col->psy_colnm),
				    &psy_col->psy_colnm);
				return (E_DB_ERROR);
			    }

			    *attrid = attribute->att_number;	

			}	    /* for each column */

		    }	    /* there are update cols */

		    if (insrtcols)	/* there are INSERT columns */
		    {
			/*
			** start inserting attribute numbers starting at offset
			** psy_cb->psy_i_col_offset into psy_tbl->psy_colatno[]
			*/
		    }

		    if (refcols)	/* there are REFERENCES columns */
		    {
			i4		    *attrid;
			DMT_ATT_ENTRY	    *attribute;
			register i4	    i;
			PSY_COL		    *psy_col;

			/*
			** Verify column existence, store attribute nos.
			*/
			for (psy_col = (PSY_COL *) psy_cb->psy_r_colq.q_next,
			     i = 0,
			     attrid = psy_tbl->psy_colatno +
				psy_cb->psy_r_col_offset;
				
			     i < psy_cb->psy_r_numcols;
			     
			     psy_col = (PSY_COL *) psy_col->queue.q_next,
			     i++,
			     attrid++
			    )
			{
			    /*
			    ** Store a attribute no. for each column.
			    */

			    /* Look up the attribute */
			    attribute = pst_coldesc(resrange,
				&psy_col->psy_colnm);

			    /*
			    ** Check for attribute not found;
			    ** user may not grant REFERENCES on TID (attr 0)
			    */
			    if (attribute == (DMT_ATT_ENTRY *) NULL ||
				attribute->att_number == 0)
			    {
				(VOID) psf_error(2100L, 0L, PSF_USERERR,
				    &err_code, &psq_cb->psq_error, 4,
				    sizeof(cb->pss_lineno), &cb->pss_lineno,
				    psf_trmwhite(sizeof(DB_TAB_NAME),
					(char *) &resrange->pss_tabname),
				    &resrange->pss_tabname,
				    psf_trmwhite(sizeof(DB_OWN_NAME),
					(char *) &resrange->pss_ownname),
				    &resrange->pss_ownname,
				    psf_trmwhite(sizeof(DB_ATT_NAME),
					(char *) &psy_col->psy_colnm),
				    &psy_col->psy_colnm);
				return (E_DB_ERROR);
			    }

			    *attrid = attribute->att_number;	

			}	    /* for each column */

		    }

		    /* remember the object type */
		    psy_tbl->psy_mask = (mask & DMT_VIEW) ? PSY_OBJ_IS_VIEW
							  : PSY_OBJ_IS_TABLE;

		    /*
		    ** if the object was specified using its real name (as 
		    ** opposed to a name of a synonym defined for it), remember
		    ** whether the schema and/or object name may be expressed 
		    ** as regular identifiers
		    */
		    if (~rngvar_info & PSS_BY_SYNONYM)
		    {
			if (   $1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
			    && $1->pss_schema_id_type == PSS_ID_REG
			   )
			{
			    psy_tbl->psy_mask |= PSY_REGID_SCHEMA_NAME;
			}

			if ($1->pss_obj_id_type == PSS_ID_REG)
			{
			    psy_tbl->psy_mask |= PSY_REGID_OBJ_NAME;
			}
		    }

		    /*
		    ** Attach element to the list.
		    */
		    (VOID) QUinsert((QUEUE *) psy_tbl, 
			(QUEUE *) &psy_cb->psy_tblq);

		}	    /* table is not an index */
	    }	    /* if (!found) */
	}	/* resrange != NULL */
    }
;

dbproc_priv_obj_spec:    ONPROCEDURE dbproc_priv_obj_list
    {
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** if privileges cannot be granted/revoked on any of specified objects,
	** we will simply return E_DB_ERROR since there is no reason to proceed 
	** on to psy_dgrant() or psy_revoke().
	*/
	if (psy_cb->psy_tblq.q_next == &psy_cb->psy_tblq)
	{
	    return(E_DB_ERROR);
	}
    }
;

dbproc_priv_obj_list:	dbproc_priv_obj
	       |	dbproc_priv_obj_list COMMA dbproc_priv_obj
;

dbproc_priv_obj:	    obj_spec
    {
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;
	i4		err_code;
	PSY_TBL		*psy_tbl;
	DB_STATUS	status;
	bool		found = FALSE;
	i4		dbp_mask;
	i4		dbpshow_flags;
	DB_OWN_NAME	*dbp_owner;

	/*
	** NOTE: we no longer insist that only the owner of the dbproc can
	**	 grant privileges on it; in psy_dgrant() we will verify that
	**	 this user can grant the specified privilege
	*/

	if ($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    dbp_owner = &$1->pss_owner;
	    dbp_mask = PSS_DBP_BY_OWNER;
	}
	else
	{
	    dbp_owner = (DB_OWN_NAME *) NULL;
	    dbp_mask = PSS_USRDBP | PSS_DBADBP | PSS_INGDBP;
	}

	status = pst_dbpshow(cb, (DB_DBP_NAME *) &$1->pss_obj_name,
	    &$Ydbpinfo, dbp_owner, (DB_TAB_ID *) NULL, dbp_mask, psq_cb,
	    &dbpshow_flags);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	if (dbpshow_flags & PSS_MISSING_DBPROC)
	{
	    /* Procedure doesn't exist - do not return error; just a warning */
	}
	else
	{
	    /* don't allow users to grant/revoke on system-generated procedures
	     */
	    if ($Ydbpinfo->pss_ptuple.db_mask[0] & DBP_SYSTEM_GENERATED)
	    {
		psf_error(E_PS04A3_NO_GRANT, 0L, PSF_USERERR,
			  &err_code, &psq_cb->psq_error, 1,
			  psf_trmwhite(DB_MAXNAME,
			       $Ydbpinfo->pss_ptuple.db_dbpname.db_dbp_name),
			  $Ydbpinfo->pss_ptuple.db_dbpname.db_dbp_name);
		return(E_DB_ERROR);
	    }


	    /*
	    ** Check if dbproc is specified for the first time (compare proc ids
	    ** since it is cheaper than comparing dbproc names and owner names +
	    ** it will not fail if a user U enters something like
	    **	    "GRANT EXECUTE ON PROCEDURE Z.P, P to X"
	    ** if Z is the DBA or $ingres and U does not own a dbproc named P.
	    */
	    for (psy_tbl = (PSY_TBL *) psy_cb->psy_tblq.q_next;
		 psy_tbl != (PSY_TBL *) &psy_cb->psy_tblq;
		 psy_tbl = (PSY_TBL *) psy_tbl->queue.q_next
		)
	    {
		if (psy_tbl->psy_tabid.db_tab_base ==
		    $Ydbpinfo->pss_ptuple.db_procid.db_tab_base
		    &&
		    psy_tbl->psy_tabid.db_tab_index ==
		    $Ydbpinfo->pss_ptuple.db_procid.db_tab_index
		   )
		{
		    found = TRUE;

		    /*
		    ** if the same object is mentioned more than once, remember
		    ** whether its schema and/or object name may be expressed 
		    ** as regular identifiers
		    */
		    if (   ~psy_tbl->psy_mask & PSY_REGID_SCHEMA_NAME
		        && $1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
		        && $1->pss_schema_id_type == PSS_ID_REG
		       )
		    {
		        psy_tbl->psy_mask |= PSY_REGID_SCHEMA_NAME;
		    }

		    if (   ~psy_tbl->psy_mask & PSY_REGID_OBJ_NAME
		        && $1->pss_obj_id_type == PSS_ID_REG)
		    {
		        psy_tbl->psy_mask |= PSY_REGID_OBJ_NAME;
		    }

		    break;
		}
	    }

	    if (!found)
	    {
		/* Allocate memory for a table entry */
		status = psf_malloc(cb, &cb->pss_ostream,
		    (i4) sizeof(PSY_TBL), (PTR *) &psy_tbl,
		    &psq_cb->psq_error);
		if (status != E_DB_OK)
		{
		    return (status);
		}

		/*
		** Copy procedure id, procedure name, and owner name to
		** table entry.
		*/
		STRUCT_ASSIGN_MACRO($Ydbpinfo->pss_ptuple.db_procid,
				    psy_tbl->psy_tabid);
		STRUCT_ASSIGN_MACRO($1->pss_obj_name, psy_tbl->psy_tabnm);
		STRUCT_ASSIGN_MACRO($Ydbpinfo->pss_ptuple.db_owner,
				    psy_tbl->psy_owner);

		/* init psy_mask */
		psy_tbl->psy_mask = PSY_OBJ_IS_DBPROC;


		/*
		** remember whether the schema and/or object name may be 
		** expressed as regular identifiers
		*/
		if (   $1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
		    && $1->pss_schema_id_type == PSS_ID_REG
		   )
		{
		    psy_tbl->psy_mask |= PSY_REGID_SCHEMA_NAME;
		}

		if ($1->pss_obj_id_type == PSS_ID_REG)
		{
		    psy_tbl->psy_mask |= PSY_REGID_OBJ_NAME;
		}

		/*
		** Attach element to the list.
		*/
		(VOID) QUinsert((QUEUE *) psy_tbl, (QUEUE *) &psy_cb->psy_tblq);
	    }
	}	/* database procedure exists */
    }
;

seq_priv_obj_spec:    ONSEQUENCE seq_priv_obj_list
    {
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** if privileges cannot be granted/revoked on any of specified objects,
	** we will simply return E_DB_ERROR since there is no reason to proceed 
	** on to psy_dgrant() or psy_revoke().
	*/
	if (psy_cb->psy_tblq.q_next == &psy_cb->psy_tblq)
	{
	    return(E_DB_ERROR);
	}
    }
;

seq_priv_obj_list:	seq_priv_obj
	       |	seq_priv_obj_list COMMA seq_priv_obj
;

seq_priv_obj:	    obj_spec
    {
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;
	PSY_TBL		*psy_tbl;
	DB_STATUS	status;
	i4		nopriv = 0;
	i4		gseq_flags;
	i4		seq_mask = 0;
	DB_IISEQUENCE	seqtup;

	seq_mask |= (($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    ? PSS_SEQ_BY_OWNER
	    : PSS_USRSEQ | PSS_DBASEQ | PSS_INGSEQ);

	/* If name wasn't qualified, fill in default user name. */
	if (!($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA))
	    STmove((PTR)&cb->pss_user, ' ', sizeof(DB_OWN_NAME),
	       (PTR)&$1->pss_owner);
	/* Find the sequence first. */
	status = psy_gsequence(cb, &$1->pss_owner, (DB_NAME *)&$1->pss_obj_name, 
		seq_mask, NULL, &seqtup, &gseq_flags, (i4 *)NULL, 
		psq_cb->psq_mode, FALSE, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	else if (gseq_flags & PSS_MISSING_SEQUENCE)
	{
	    /* sequence doesn't exist - do not return error; just a warning */
	}
	else
	{
	    DB_TAB_ID	*seq_id = &seqtup.dbs_uniqueid;
	    bool	found = FALSE;

	    /* see if sequence is specified for the first time */
	    for (psy_tbl = (PSY_TBL *) psy_cb->psy_tblq.q_next;
		 psy_tbl != (PSY_TBL *) &psy_cb->psy_tblq;
		 psy_tbl = (PSY_TBL *) psy_tbl->queue.q_next
		)
	    {
		/*
		** compare sequence ids since it is cheaper than MEcmp'ing
		** sequence names and owner names;
		*/
		if (   psy_tbl->psy_tabid.db_tab_base == seq_id->db_tab_base
		    && psy_tbl->psy_tabid.db_tab_index == seq_id->db_tab_index)
		{
		    found = TRUE;

		    /*
		    ** if the same object is mentioned more than once, remember
		    ** whether its schema and/or object name may be expressed 
		    ** as regular identifiers
		    */
		    if (   ~psy_tbl->psy_mask & PSY_REGID_SCHEMA_NAME
		        && $1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
		        && $1->pss_schema_id_type == PSS_ID_REG
		       )
		    {
		        psy_tbl->psy_mask |= PSY_REGID_SCHEMA_NAME;
		    }

		    if (   ~psy_tbl->psy_mask & PSY_REGID_OBJ_NAME
		        && $1->pss_obj_id_type == PSS_ID_REG)
		    {
		        psy_tbl->psy_mask |= PSY_REGID_OBJ_NAME;
		    }

		    break;
		}
	    }

	    if (!found)
	    {
		/* Allocate memory for a sequence entry */
		status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSY_TBL),
		    (PTR *) &psy_tbl, &psq_cb->psq_error);
		if (status != E_DB_OK)
		    return (status);

		psy_tbl->psy_tabid.db_tab_base = seq_id->db_tab_base;
		psy_tbl->psy_tabid.db_tab_index = seq_id->db_tab_index;

		/* Save sequence name */
		STRUCT_ASSIGN_MACRO($1->pss_obj_name, psy_tbl->psy_tabnm);

		/* save sequence owner name */
		STRUCT_ASSIGN_MACRO(seqtup.dbs_owner, psy_tbl->psy_owner);

		/* init psy_mask */
		psy_tbl->psy_mask = 0;

		/*
		** remember whether the schema and/or object name may be 
		** expressed as regular identifiers
		*/
		if (   $1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
		    && $1->pss_schema_id_type == PSS_ID_REG
		   )
		{
		    psy_tbl->psy_mask |= PSY_REGID_SCHEMA_NAME;
		}

		if ($1->pss_obj_id_type == PSS_ID_REG)
		{
		    psy_tbl->psy_mask |= PSY_REGID_OBJ_NAME;
		}


		/* Attach element to the list */
		(void)QUinsert((QUEUE *)psy_tbl, (QUEUE *) &psy_cb->psy_tblq);
	    }
	}
    }
;

event_priv_obj_spec:	ONEVENT event_priv_obj_list
    {
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** if privileges cannot be granted/revoked on any of specified objects,
	** we will simply return E_DB_ERROR since there is no reason to proceed 
	** on to psy_dgrant() or psy_revoke().
	*/
	if (psy_cb->psy_tblq.q_next == &psy_cb->psy_tblq)
	{
	    return(E_DB_ERROR);
	}
    }
;

event_priv_obj_list:	    event_priv_obj
	      |		    event_priv_obj_list COMMA event_priv_obj
;

event_priv_obj:	    obj_spec
    {
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;
	PSY_TBL		*psy_tbl;
	DB_STATUS	status;
	i4		ev_mask = 0;
	i4		gevent_flags;
	PSS_EVINFO	ev_info;
	i4		nopriv = 0;

	ev_mask |= (($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    ? PSS_EV_BY_OWNER
	    : PSS_USREVENT | PSS_DBAEVENT | PSS_INGEVENT);

	/*
	** at this point we will not be checking permissions - only look up the
	** dbevent
	*/
	status = psy_gevent(cb, &$1->pss_owner, &$1->pss_obj_name,
	    (DB_TAB_ID *) NULL, ev_mask, &ev_info, &gevent_flags, &nopriv,
	    psq_cb->psq_mode, (i4) FALSE, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return (status);
	else if (gevent_flags & PSS_MISSING_EVENT)
	{
	    /* dbevent doesn't exist - do not return error; just a warning */
	}
	else
	{
	    DB_TAB_ID	*ev_id = &ev_info.pss_ev_id;
	    bool	found = FALSE;

	    /* see if dbevent is specified for the first time */
	    for (psy_tbl = (PSY_TBL *) psy_cb->psy_tblq.q_next;
		 psy_tbl != (PSY_TBL *) &psy_cb->psy_tblq;
		 psy_tbl = (PSY_TBL *) psy_tbl->queue.q_next
		)
	    {
		/*
		** compare dbevent ids since it is cheaper than MEcmp'ing
		** dbevent names and dbevent owner names;
		*/
		if (   psy_tbl->psy_tabid.db_tab_base == ev_id->db_tab_base
		    && psy_tbl->psy_tabid.db_tab_index == ev_id->db_tab_index)
		{
		    found = TRUE;

		    /*
		    ** if the same object is mentioned more than once, remember
		    ** whether its schema and/or object name may be expressed 
		    ** as regular identifiers
		    */
		    if (   ~psy_tbl->psy_mask & PSY_REGID_SCHEMA_NAME
		        && $1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
		        && $1->pss_schema_id_type == PSS_ID_REG
		       )
		    {
		        psy_tbl->psy_mask |= PSY_REGID_SCHEMA_NAME;
		    }

		    if (   ~psy_tbl->psy_mask & PSY_REGID_OBJ_NAME
		        && $1->pss_obj_id_type == PSS_ID_REG)
		    {
		        psy_tbl->psy_mask |= PSY_REGID_OBJ_NAME;
		    }

		    break;
		}
	    }

	    if (!found)
	    {
		/* Allocate memory for an dbevent entry */
		status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSY_TBL),
		    (PTR *) &psy_tbl, &psq_cb->psq_error);
		if (status != E_DB_OK)
		    return (status);

		psy_tbl->psy_tabid.db_tab_base = ev_id->db_tab_base;
		psy_tbl->psy_tabid.db_tab_index = ev_id->db_tab_index;

		/* Save dbevent name */
		STRUCT_ASSIGN_MACRO($1->pss_obj_name, psy_tbl->psy_tabnm);

		/* save dbevent owner name */
		STRUCT_ASSIGN_MACRO(ev_info.pss_alert_name.dba_owner,
				    psy_tbl->psy_owner);

		/* init psy_mask */
		psy_tbl->psy_mask = 0;

		/*
		** remember whether the schema and/or object name may be 
		** expressed as regular identifiers
		*/
		if (   $1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
		    && $1->pss_schema_id_type == PSS_ID_REG
		   )
		{
		    psy_tbl->psy_mask |= PSY_REGID_SCHEMA_NAME;
		}

		if ($1->pss_obj_id_type == PSS_ID_REG)
		{
		    psy_tbl->psy_mask |= PSY_REGID_OBJ_NAME;
		}


		/* Attach element to the list */
		(VOID) QUinsert((QUEUE *)psy_tbl, (QUEUE *) &psy_cb->psy_tblq);
	    }
	}
    }
;

grant_col_spec:     LPAREN grant_col_list RPAREN
    {
	PSY_CB	    *psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** if before processing this grant_col_list, the column queue for this
	** privilege consisted of names of columns to which the privilege did
	** not apply, it is possible that this list became empty as a result of
	** processing this grant_col_list; if so, we will reset the
	** PSY_EXCLUDE_<privilege>_COLUMN bit to indicate that the column queue
	** no longer contains any "excluded" columns
	*/
	if ($Ypriv == (i4) DB_REPLACE)
	{
	    if (   !psy_cb->psy_u_numcols
		&& psy_cb->psy_flags & PSY_EXCLUDE_UPDATE_COLUMNS)
	    {
		psy_cb->psy_flags &= ~PSY_EXCLUDE_UPDATE_COLUMNS;
	    }
	}
	else if ($Ypriv == (i4) DB_REFERENCES)
	{
	    if (   !psy_cb->psy_r_numcols
		&& psy_cb->psy_flags & PSY_EXCLUDE_REFERENCES_COLUMNS)
	    {
		psy_cb->psy_flags &= ~PSY_EXCLUDE_REFERENCES_COLUMNS;
	    }
	}
    }
	    |	    EXCLUDING
    {
	PSY_CB      *psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** remember that we will be processing a list of columns to which a
	** privilege (specified by $Ypriv) will NOT apply
	*/
	$Yqry_mask |= PSS_EXCLUDE_COLUMNS;

	/* initialize the "excluded column" queue header */
	QUinit((QUEUE *) &$Yexcluded_colq);

	/*
	** column list associated with the specified (in $Ypriv) privilege) will
	** be reinitialized - reset count of columns in the list to 0 here
	*/
	if ($Ypriv == (i4) DB_REPLACE)
	{
  	    psy_cb->psy_u_numcols = 0; 
	}
	else if ($Ypriv == DB_REFERENCES || 
		 $Ypriv == DB_COPY_INTO ||
		 $Ypriv == DB_COPY_FROM )
	{
	    psy_cb->psy_r_numcols = 0;
	}
    }
		    LPAREN grant_col_list RPAREN
    {
	PSY_CB      *psy_cb = (PSY_CB *) cb->pss_object;
	
	/* finished processing a list of excluded columns */
	$Yqry_mask &= ~PSS_EXCLUDE_COLUMNS;

	/*
	** "excluded column" queue built during processing of the
	** grant_col_list represents the set of columns to which the privilege
	** should not apply - overwrite the appropriate column queue with
	** contents of "excluded column" queue;
	**
	** if "excluded column" queue is empty, reset the
        ** PSY_EXCLUDE_<privilege>_COLUMNS bit to indicate that the user is
        ** granting table wide <privilege> and make the appropriate column queue
	** empty;
        ** otherwise set PSY_EXCLUDE_<privilege>_COLUMNS bit to indicate that
        ** the queue consists of names of columns to which privilege should not
        ** apply and overwrite the column queue with contents of "excluded
        ** column" queue
	*/

	if ($Ypriv == (i4) DB_REPLACE)
	{
	    if (!psy_cb->psy_u_numcols)
	    {
		psy_cb->psy_flags &= ~PSY_EXCLUDE_UPDATE_COLUMNS;
		QUinit((QUEUE *) &psy_cb->psy_u_colq);
	    }
	    else
	    {
		STRUCT_ASSIGN_MACRO($Yexcluded_colq, psy_cb->psy_u_colq);

		/* reset pointers which were pointing at $Yexcluded_colq */
		psy_cb->psy_u_colq.q_next->q_prev =
		    psy_cb->psy_u_colq.q_prev->q_next = &psy_cb->psy_u_colq;

		psy_cb->psy_flags |= PSY_EXCLUDE_UPDATE_COLUMNS;
	    }
	}
	else if ($Ypriv == DB_REFERENCES  ||
		 $Ypriv == DB_COPY_INTO ||
		 $Ypriv == DB_COPY_FROM )
	{
	    if (!psy_cb->psy_r_numcols)
	    {
		psy_cb->psy_flags &= ~PSY_EXCLUDE_REFERENCES_COLUMNS;
		QUinit((QUEUE *) &psy_cb->psy_r_colq);
	    }
	    else
	    {
		STRUCT_ASSIGN_MACRO($Yexcluded_colq, psy_cb->psy_r_colq);

		/* reset pointers which were pointing at $Yexcluded_colq */
		psy_cb->psy_r_colq.q_next->q_prev =
		    psy_cb->psy_r_colq.q_prev->q_next = &psy_cb->psy_r_colq;

		psy_cb->psy_flags |= PSY_EXCLUDE_REFERENCES_COLUMNS;
	    }
	}
    }
	    |	    /* empty (i.e., no columns) */
    {
	PSY_CB	    *psy_cb = (PSY_CB *) cb->pss_object;

	/*
	** if prior to specifying privilege P, user specified
	** P [EXCLUDING] (<column list>), clear the column list as P overrides
	** P [EXCLUDING] (<column list>)
	*/
	if ($Ypriv == (i4) DB_REPLACE && psy_cb->psy_u_numcols > 0)
	{
	    psy_cb->psy_flags &= ~PSY_EXCLUDE_UPDATE_COLUMNS;
	    QUinit((QUEUE *) &psy_cb->psy_u_colq);
	    psy_cb->psy_u_numcols = 0;
	}
	else if ($Ypriv == DB_REFERENCES && psy_cb->psy_r_numcols > 0)
	{
	    psy_cb->psy_flags &= ~PSY_EXCLUDE_REFERENCES_COLUMNS;
	    QUinit((QUEUE *) &psy_cb->psy_r_colq);
	    psy_cb->psy_r_numcols = 0;
	}
    }
;

grant_col_list:		
    {
	PSY_CB		*psy_cb = (PSY_CB *) cb->pss_object;

	/* save address of the queue header for the privilege being processed */
	if ($Ypriv == DB_REPLACE)
	{
	    $Ypriv_colq = &psy_cb->psy_u_colq;
	}
	else if ($Ypriv == DB_REFERENCES)
	{
	    $Ypriv_colq = &psy_cb->psy_r_colq;
	}
	else
	{
	    /* this should never happen */
	    return(E_DB_ERROR);
	}
    }
			grant_col
	    |		grant_col_list COMMA grant_col
;

grant_col:          col_spec
    {
	PSY_CB		    *psy_cb = (PSY_CB *) cb->pss_object;
	PSY_COL		    *psy_col;
	i4		    err_code;
	bool		    found = FALSE;
	DB_STATUS	    status;
	DB_ATT_NAME	    colname;
	PSF_QUEUE	    *colq = $Ypriv_colq;
	bool		    cur_list_including;
	i4		    *col_cnt;

	{
	    /* 
	    ** determine whether the existing list contains column to which 
	    ** privilege will apply + remember address of the counter keeping 
	    ** track of the number of column in the list being constructed
	    */

	    i4		excl_mask;

	    if ($Ypriv == (i4) DB_REPLACE)
	    {
		excl_mask = PSY_EXCLUDE_UPDATE_COLUMNS;
		col_cnt = &psy_cb->psy_u_numcols;
	    }
	    else if ($Ypriv == (i4) DB_REFERENCES)
	    {
		excl_mask = PSY_EXCLUDE_REFERENCES_COLUMNS;
		col_cnt = &psy_cb->psy_r_numcols;
	    }

	    cur_list_including = (psy_cb->psy_flags & excl_mask) == 0;
	}

	/*
	** if the privilege bit corresponding to the privilege being processed
	** is not set (i.e. this privilege has not been speciifed before in this
	** statement), or the column queue associated with this privilege is not
	** empty (i.e. it contains a list of columns to which the privilege
	** should or should not apply), process this column name; otherwise
	** simply discard it as a table-wide privilege overrides any
	** specifications of columns to which a privilege should [not] apply
	*/
	if (~psy_cb->psy_opmap & $Ypriv || colq->q_next != colq)
	{
	    STmove($1, ' ', sizeof(DB_ATT_NAME), (char *) &colname);

	    /*
	    ** at this point four different scenarios are possible:
	    ** 
	    **   (1) user is specifying a list of columns to which a privilege
	    **       should not apply and the existing column queue contains
	    **	     names of columns to which that privilege should apply (or
	    **	     is empty);
	    **
	    **       we will compute a set difference of the names specified by
	    **	     the user and names contained in the existing list - the
	    **	     resulting set (if any) will represent names of columns to
	    **	     which privilege should not apply
	    **
	    **   (2) user is specifying a list of columns to which a privilege
	    **       should not apply and the existing column queue contains
	    **	     names of columns to which that privilege should not apply
	    **
	    **       we will compute conjunction (AND) of the names specified by
	    **	     the user and names contained in the existing list - the
	    **	     resulting set (if any) will represent names of columns to
	    **	     which privilege should not apply
	    **
	    **   (3) user is specifying a list of columns to which a privilege
	    **       should apply and the existing column queue contains names
	    **	     of columns to which that privilege should apply (or is
	    **	     empty);
	    **
	    **	     we will compute disjunction (OR) of the names specified by
	    **	     the user and names contained in the existing list - the
	    **	     resulting set will represent names of columns to which
	    **	     privilege should apply
	    **	 
	    **   (4) user is specifying a list of columns to which a privilege
	    **       should apply and the existing column queue contains names
	    **	     of columns to which that privilege should not apply
	    **
	    **	     we will compute a set difference of the names contained in
	    **	     the existing list and the names specified by the user - the
	    **	     resulting set (if any) will represent names of columns to
	    **	     which privilege should not apply
	    */

	    if ($Yqry_mask & PSS_EXCLUDE_COLUMNS)
	    {
		if (cur_list_including)
		{
		    /* case (1) */

		    /*
		    ** first check whether this column appears in the column 
		    ** list consisting of names of columns to which the 
		    ** privilege in $Ypriv will apply
		    */
		    for (psy_col = (PSY_COL *) colq->q_next;
			 psy_col != (PSY_COL *) colq;
			 psy_col = (PSY_COL *) psy_col->queue.q_next
			)
		    {
			if (!MEcmp((PTR) &colname, (PTR) &psy_col->psy_colnm,
			         sizeof(psy_col->psy_colnm)))
			{
			    found = TRUE;
			    break;
			}
		    }

		    /*
		    ** if the user has previously specified that the privilege
		    ** should apply to a column C and now specifies that the
		    ** privilege should apply to the table except for the column
		    ** C (and possibly other columns), privilege will continue
		    ** to apply to C; otherwise we will add the column to the
		    ** "excluded column" queue unless it has been added before
		    */

		    if (!found)
		    {
			for (psy_col = (PSY_COL *) $Yexcluded_colq.q_next;
			     psy_col != (PSY_COL *) &$Yexcluded_colq;
			     psy_col = (PSY_COL *) psy_col->queue.q_next
			    )
			{
			    if (!MEcmp((PTR) &colname,
				     (PTR) &psy_col->psy_colnm,
				     sizeof(psy_col->psy_colnm)))
			    {
				found = TRUE;

				/*
				** if the same column was specified more than 
				** once and was not consistently specified using
				** either a regular or a delimited identifier, 
				** we want to ensure that it is represented by 
				** a regular identifier in the final text
				*/
				if (   ~psy_col->psy_col_flags & 
					   PSY_REGID_COLSPEC
				    && $Yid_type == PSS_ID_REG
				   )
				{
				    psy_col->psy_col_flags |=
					PSY_REGID_COLSPEC;
				}

				break;
			    }
			}

			if (!found)
			{
			    /*
			    ** column has not been added before; will add it to
			    ** the "excluded column" queue unless the queue
			    ** already contains DB_MAX_COLS elements
			    */
			    if (*col_cnt == DB_MAX_COLS)
			    {
				(VOID) psf_error(2113L, 0L, PSF_USERERR,
				    &err_code, &psq_cb->psq_error, 1,
				    sizeof(cb->pss_lineno), &cb->pss_lineno);
				return (E_DB_ERROR);
			    }

			    /* Allocate memory for a column entry */
			    status = psf_malloc(cb, &cb->pss_ostream,
				(i4) sizeof(PSY_COL), (PTR *) &psy_col,
				&psq_cb->psq_error);
			    if (status != E_DB_OK)
			    {
				return (status);
			    }

			    /*
			    ** Copy update column name to column entry.
			    */
			    STRUCT_ASSIGN_MACRO(colname, psy_col->psy_colnm);

			    psy_col->psy_col_flags = 0;

			    /*
			    ** remember whether the column name was specified 
			    ** using a regular or a delimited identifier
			    */
			    if ($Yid_type == PSS_ID_REG)
			    {
				psy_col->psy_col_flags |= PSY_REGID_COLSPEC;
			    }

			    /*
			    ** Attach element to the "excluded column" list.
			    */
			    (VOID) QUinsert((QUEUE *) psy_col,
				(QUEUE *) &$Yexcluded_colq);
				
			    /*
			    ** increment number of elements in the new list of
			    ** columns to which privilege will not apply
			    */
			    ++*col_cnt;
			}
		    }
		}
		else
		{
		    /* case (2) */

		    for (psy_col = (PSY_COL *) colq->q_next;
			 psy_col != (PSY_COL *) colq;
			 psy_col = (PSY_COL *) psy_col->queue.q_next
			)
		    {
			if (!MEcmp((PTR) &colname, (PTR) &psy_col->psy_colnm,
			         sizeof(psy_col->psy_colnm)))
			{
			    /*
			    ** column appears both in the existing column list
			    ** containing names of columns to which privilege
			    ** will not apply and in the new list supplied by
			    ** the user - thus the privilege will continue to
			    ** NOT apply to this column; move it from the
			    ** current column list into the "excluded column"
			    ** list unless the queue already contains 
			    ** DB_MAX_COLS elements
			    */
			    if (*col_cnt == DB_MAX_COLS)
			    {
				(VOID) psf_error(2113L, 0L, PSF_USERERR,
				    &err_code, &psq_cb->psq_error, 1,
				    sizeof(cb->pss_lineno), &cb->pss_lineno);
				return (E_DB_ERROR);
			    }

			    /*
			    ** if the same column was specified more than 
			    ** once and was not consistently specified using
			    ** either a regular or a delimited identifier, 
			    ** we want to ensure that it is represented by 
			    ** a regular identifier in the final text
			    */
			    if (   ~psy_col->psy_col_flags & PSY_REGID_COLSPEC
				&& $Yid_type == PSS_ID_REG
			       )
			    {
			        psy_col->psy_col_flags |= PSY_REGID_COLSPEC;
			    }

			    (VOID) QUinsert(QUremove((QUEUE *) psy_col),
				(QUEUE *) &$Yexcluded_colq);

			    /*
			    ** increment number of elements in the new list of
			    ** columns to which privilege will not apply
			    */
			    ++*col_cnt;

			    break;
			}
		    }
		}
	    }
	    else if (cur_list_including)
	    {
		/* case (3) */

		/*
		** Check if column specified for the first time.
		*/
		for (psy_col = (PSY_COL *) colq->q_next;
		     psy_col != (PSY_COL *) colq;
		     psy_col = (PSY_COL *) psy_col->queue.q_next
		    )
		{
		    if (!MEcmp((PTR) &colname, (PTR) &psy_col->psy_colnm,
			    sizeof(psy_col->psy_colnm)))
		    {
			found = TRUE;
			/*
			** if the same column was specified more than 
			** once and was not consistently specified using
			** either a regular or a delimited identifier, 
			** we want to ensure that it is represented by 
			** a regular identifier in the final text
			*/
			if (   ~psy_col->psy_col_flags & PSY_REGID_COLSPEC
			    && $Yid_type == PSS_ID_REG
			   )
			{
			    psy_col->psy_col_flags |= PSY_REGID_COLSPEC;
			}

			break;
		    }
		}

		/*
		** Store only if not found. No need to keep duplicates.
		*/
		if (!found)
		{
		    /* make sure the list is not longer than DB_MAX_COLS */
		    if (*col_cnt == DB_MAX_COLS)
		    {
			(VOID) psf_error(2113L, 0L, PSF_USERERR, &err_code,
			    &psq_cb->psq_error, 1, sizeof(cb->pss_lineno),
			    &cb->pss_lineno);
			return (E_DB_ERROR);
		    }

		    /* Allocate memory for a column entry */
		    status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSY_COL),
			(PTR *) &psy_col, &psq_cb->psq_error);
		    if (status != E_DB_OK)
		    {
			return (status);
		    }

		    /*
		    ** Copy column name to column entry.
		    */
		    STRUCT_ASSIGN_MACRO(colname, psy_col->psy_colnm);

		    psy_col->psy_col_flags = 0;

		    /*
		    ** remember whether the column name was specified 
		    ** using a regular or a delimited identifier
		    */
		    if ($Yid_type == PSS_ID_REG)
		    {
			psy_col->psy_col_flags |= PSY_REGID_COLSPEC;
		    }

		    /*
		    ** Attach element to the list.
		    */
		    (VOID) QUinsert((QUEUE *) psy_col, (QUEUE *) colq);

		    /* increment number of elements in the list */
		    ++*col_cnt;
		}
	    }
	    else
	    {
		/* case (4) */

		for (psy_col = (PSY_COL *) colq->q_next;
		     psy_col != (PSY_COL *) colq;
		     psy_col = (PSY_COL *) psy_col->queue.q_next
		    )
		{
		    if (!MEcmp((PTR) &colname, (PTR) &psy_col->psy_colnm,
			     sizeof(psy_col->psy_colnm)))
		    {
			/*
			** column appears both in the existing column list
			** containing names of columns to which privilege
			** will not apply and in the new list of columns to
			** which privilege will apply - thus the privilege will
			** apply to this column; remove it from the current
			** column list
			*/
			(VOID) QUremove((QUEUE *) psy_col);

			/*
			** decrement number of elements in the list of columns
			** to which privilege will not apply
			*/
			--*col_cnt;
			break;
		    }
		}
	    }
	}
    }
;

grant_auth_spec:        TO user_auth_list
    {
	$$ = DBGR_DEFAULT;
    }
	    |		TOUSER user_auth_list
    {
	$$ = DBGR_USER;
    }
	    |		TOGROUP group_role_auth_list
    {
	$$ = DBGR_GROUP;
    }
	    |		TOROLE group_role_auth_list
    {
	$$ = DBGR_APLID;
    }
;

user_auth_list:		user_auth
	      |		user_auth_list COMMA user_auth
;

user_auth:		user_ident
    {
	DB_STATUS		    status;

	status = psl_add_grantee(cb, $1, $Yid_type, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    }
	|		PUBLIC
    {
	PSY_CB		*psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_flags |= PSY_PUBLIC;
    }
;

group_role_auth_list:	group_role_auth
		    |	group_role_auth_list COMMA group_role_auth
;

group_role_auth:	auth_ident
    {
	DB_STATUS		    status;

	status = psl_add_grantee(cb, $1, $Yid_type, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    }
;

/*
** Production return specification:
**				  		  $4
** 			                   	3 = database
**			             		4 = current installation
**			                   	
**
**  grant_option_for is used here to avoid shift_reduce conflict.  Without
**  grant_option_for YACC will will shift on GRANT ^ ALL assuming that ALL
**  refers to database privileges which will not be necessarily correct
*/
revoke:	            rev_kwd grant_option_for db_priv_spec db_priv_obj_spec
		    rev_auth_spec
    {
	/* REVOKE <db_privileges>|role [ON <db_object_spec>] FROM <auth_spec> */
	
	PSY_CB		    *psy_cb = (PSY_CB *) cb->pss_object;
	i4                err_code;


	/* Set grantee type; default to USER */
	psy_cb->psy_gtype = ($5 == DBGR_DEFAULT) ? DBGR_USER : $5;

	/* Translate ALL [PRIVILEGES] */
	if (psy_cb->psy_flags & PSY_ALL_PRIVS)
	{
	    psy_cb->psy_ctl_dbpriv = DBPR_ALLPRIVS | DBPR_ALL;
	}

	if (   (psy_cb->psy_flags & PSY_GR_REV_ROLE)
	    && psy_cb->psy_gtype != DBGR_USER)
	{
	    (VOID) psf_error(9344, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* Set mode in the PSY_CB */
	if (psy_cb->psy_flags & PSY_GR_REV_ROLE)
	{
		psy_cb->psy_grant = PSY_RREVOKE;
		psq_cb->psq_mode = PSQ_RREVOKE;
	}
	else
	{
		psy_cb->psy_grant = PSY_DREVOKE;
		psq_cb->psq_mode = (psy_cb->psy_ctl_dbpriv & DBPR_RESTRICTED)
								? PSQ_RDBPRIV
								: PSQ_ROKPRIV;
	}
    }
	|	    rev_kwd grant_option_for tbl_priv_spec tbl_priv_obj_spec
		    rev_auth_spec drop_behaviour
    {
	/*
	** REVOKE [GRANT OPTION FOR] <tbl priv>(s) ON <tbl spec>
	**     FROM <grantee>(s)
	*/
	
	PSY_CB		    *psy_cb = (PSY_CB *) cb->pss_object;

	/* Set grantee type; default to USER */
	psy_cb->psy_gtype = ($5 == DBGR_DEFAULT) ? DBGR_USER : $5;

	if ($6 == CASCADING_DESTRUCTION)
	    psy_cb->psy_flags |= PSY_DROP_CASCADE;
    }
	|	    rev_kwd grant_option_for dbproc_priv_spec
		    dbproc_priv_obj_spec rev_auth_spec drop_behaviour
    {
	/*
	** REVOKE [GRANT OPTION FOR] <dbproc priv>(s) ON <dbproc spec>
	**     FROM <grantee>(s)
	*/

	PSY_CB		    *psy_cb = (PSY_CB *) cb->pss_object;

	/* Set grantee type; default to USER */
	psy_cb->psy_gtype = ($5 == DBGR_DEFAULT) ? DBGR_USER : $5;

	if ($6 == CASCADING_DESTRUCTION)
	    psy_cb->psy_flags |= PSY_DROP_CASCADE;
    }
	|	    rev_kwd grant_option_for seq_priv_spec
		    seq_priv_obj_spec rev_auth_spec drop_behaviour
    {
	/*
	** REVOKE [GRANT OPTION FOR] <seq priv>(s) ON <seq spec>
	**     FROM <grantee>(s)
	*/

	PSY_CB		    *psy_cb = (PSY_CB *) cb->pss_object;

	/* Set grantee type; default to USER */
	psy_cb->psy_gtype = ($5 == DBGR_DEFAULT) ? DBGR_USER : $5;

	if ($6 == CASCADING_DESTRUCTION)
	    psy_cb->psy_flags |= PSY_DROP_CASCADE;
    }
	|           rev_kwd grant_option_for event_priv_spec event_priv_obj_spec
		    rev_auth_spec drop_behaviour
    {
	/*
	** REVOKE [GRANT OPTION FOR] <dbevent priv>(s) ON <dbevent spec>
	**     FROM <grantee>(s)
	*/

	PSY_CB		    *psy_cb = (PSY_CB *) cb->pss_object;

	/* Set grantee type; default to USER */
	psy_cb->psy_gtype = ($5 == DBGR_DEFAULT) ? DBGR_USER : $5;

	if ($6 == CASCADING_DESTRUCTION)
	    psy_cb->psy_flags |= PSY_DROP_CASCADE;
    }
;

grant_option_for:	GRANT OPTION FOR
    {
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_GRANT_OPTION;
    }
	    |
;

rev_kwd:	    REVOKE
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_REVOKE;

	/* "revoke" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6290L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the revoke statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Default terminal name is "" */
	MEfill(sizeof(psy_cb->psy_terminal), ' ', (PTR) &psy_cb->psy_terminal);

	/* default user name is " " */
	MEfill(sizeof(psy_cb->psy_user), ' ', (PTR) &psy_cb->psy_user);
	
	/*
	** Default time is all day, starting at 00:00 and ending at 24:00,
	** given as minutes after 00:00.
	*/
	psy_cb->psy_timbgn = 0;
	psy_cb->psy_timend = 1440;

	/*
	** Default days are all week, starting with Sunday and ending with
	** Saturday.  Sunday = 0, Saturday = 6.
	*/
	psy_cb->psy_daybgn = 0;
	psy_cb->psy_dayend = 6;

	/*
	** next we will be processing the list of privileges, psl_sscan() will
	** accord special treatment to words REGISTER and RAISE (dbevent
	** privileges) only when processing the privilege specification of 
	** GRANT or REVOKE statements
	*/
	cb->pss_stmt_flags |= PSS_PARSING_PRIVS;
	/* Initialize object queue */
	(VOID) QUinit((QUEUE *) &psy_cb->psy_objq); /* No objects */
    }
;

rev_auth_spec:		FROM user_role_auth_list
    {
	$$ = $2;
    }
	    |		FROM USER user_auth_list
    {
	$$ = DBGR_USER;
    }
	    |		FROM GROUP group_role_auth_list
    {
	$$ = DBGR_GROUP;
    }
;

user_role_auth_list:	generic_ident group_role_auth_list
    {
	/* This is either a "role" qualified list, or a syntax error. */
	if (STcompare($1, "role") == 0)
	{
	    $$ = DBGR_APLID;
	}
	else
	{
	    (void) psl_sx_error(2728L, cb, psq_cb);
	    return(E_DB_ERROR);
	}
    }
	    |		user_auth_list
    {
	$$ = DBGR_DEFAULT;
    }
;

drop_behaviour:	    CASCADE
    {
	$$ = CASCADING_DESTRUCTION;
    }
	      |	    RESTRICT
    {
	$$ = RESTRICTED_DESTRUCTION;
    }
;

/*
** create_secalm, create a security alarm:
**
** 	CREATE SECURITY_ALARM [name] ON object_spec
**	[IF alm_cond_spec]
**	[WHEN alm_priv_spec]
**	BY alm_auth_spec
**	[RAISE DBEVENT eventspec [eventtext]
**
** Returns:
**	PSY_CB.psy_alarm      = Alarm tuple constructed
**	      .psy_tabname[0] = Object name (if table/database-type alarm)
**	      .psy_qrytext    = Text of statement
*/
create_secalm:	    crt_alm_kwd crt_alm_name alm_obj_spec alm_cond_spec 
		    alm_priv_spec alm_auth_spec alm_event_spec
    {
	DB_STATUS           status;
	PSY_CB		    *psy_cb = (PSY_CB *) cb->pss_object;
	status=psl_al1_create_alarm(cb, psy_cb, psq_cb, $6, $3);
	if(status!=E_DB_OK)
		return status;
    }
;

crt_alm_kwd:         CRTSECALM
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_CALARM;

	/* "create security_alarm" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CREATE SECURITY_ALARM")-1,
		"CREATE SECURITY_ALARM");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	/* Allocate the PSY_CB for the create security_alarm statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;
	psy_cb->psy_opctl   = DB_ALARM;  /* Indicate security alarm */
	psy_cb->psy_opmap   = DB_ALARM;  /* Indicate security alarm */

	/* Reset alarm tuple */
	MEfill(sizeof(psy_cb->psy_tuple.psy_alarm), 0, 
	    (PTR) &psy_cb->psy_tuple.psy_alarm);

	MEfill(sizeof(psy_cb->psy_tuple.psy_alarm.dba_alarmname), ' ', 
	    (PTR) &psy_cb->psy_tuple.psy_alarm.dba_alarmname);

	MEfill(sizeof(psy_cb->psy_tuple.psy_alarm.dba_objname), ' ', 
	    (PTR) &psy_cb->psy_tuple.psy_alarm.dba_objname);

	MEfill(sizeof(psy_cb->psy_tuple.psy_alarm.dba_reserve), ' ', 
	    (PTR) &psy_cb->psy_tuple.psy_alarm.dba_reserve);

	/* default user name is " " */
	MEfill(sizeof(psy_cb->psy_user), ' ', (PTR) &psy_cb->psy_user);
	
	/* event information */
	MEfill(sizeof(psy_cb->psy_tuple.psy_alarm.dba_eventtext),' ',
		(PTR)&psy_cb->psy_tuple.psy_alarm.dba_eventtext);

	psy_cb->psy_alflag = PSY_CALARM;	/* CREATE SECURITY_ALARM */
    }
;
crt_alm_name:		generic_ident
    {
	i4		err_code;

	/* test alarm name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT($1, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	STmove($1, ' ', sizeof(DB_NAME),
	      (char *)&((PSY_CB *)cb->pss_object)->psy_tuple.psy_alarm.dba_alarmname);
    }
    |
    /* Empty */
    ;
/*
** alm_obj_spec:
**	ON table | TABLE table | DATABASE database | CURRENT INSTALLATION
*/
alm_obj_spec:   ONCURRENT nonkeyword
	    {
		DB_STATUS status;
		PSY_CB	  *psy_cb;
		psy_cb = (PSY_CB *) cb->pss_object;
		/* must be ON CURRENT INSTALLATION */
		if (STcasecmp($2, "installation"))
		{
		    psl_yerror(3, cb, psq_cb);
		    return(E_DB_ERROR);
		}
		status=psl_al3_db_obj_spec(cb, psy_cb, psq_cb, NULL, FALSE);
		if(status!=E_DB_OK)
			return status;
		$$=DBOB_DATABASE;
	    }
    |	    ONDATABASE generic_ident
	    {
		DB_STATUS status;
		PSY_CB	  *psy_cb;
		psy_cb = (PSY_CB *) cb->pss_object;
		status=psl_al3_db_obj_spec(cb, psy_cb, psq_cb, $2, 
						TRUE);
		if(status!=E_DB_OK)
			return status;

		$$ = DBOB_DATABASE;
	    }
    |	   ON obj_spec
	    {
		PSY_CB		       *psy_cb;
		DB_STATUS status;
		psy_cb = (PSY_CB *) cb->pss_object;
		status=psl_al2_tbl_obj_spec(cb, psy_cb, psq_cb, $2);
		if(status!=E_DB_OK)
			return status;
		/* Default to table */
		$$=DBOB_TABLE;
	
	    }
    |	    ON TABLE obj_spec
	    {
		PSY_CB		       *psy_cb;
		DB_STATUS status;
		psy_cb = (PSY_CB *) cb->pss_object;
		status=psl_al2_tbl_obj_spec(cb, psy_cb, psq_cb, $3);
		if(status!=E_DB_OK)
			return status;
		$$ = DBOB_TABLE;
	    }
;
alm_cond_spec:	    IF	alm_cond_list
    {
	$$ = 0;
    }
		|
    {
	PSY_CB                 *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;
	psy_cb->psy_alflag |= (PSY_ALMSUCCESS | PSY_ALMFAILURE);
	psy_cb->psy_opmap  |= (DB_ALMSUCCESS  | DB_ALMFAILURE);
	psy_cb->psy_opctl  |= (DB_ALMSUCCESS  | DB_ALMFAILURE);

	$$ = 1;
    }
;

alm_cond_list:	    alm_cond COMMA alm_cond_list
		|   alm_cond
;

alm_cond:	    nonkeyword
    {
	PSY_CB		*psy_cb = (PSY_CB *) cb->pss_object;
	i4		err_code;

	if (STcasecmp($1, "SUCCESS") == 0)
	{
	    psy_cb->psy_alflag |= PSY_ALMSUCCESS;
	    psy_cb->psy_opmap  |= DB_ALMSUCCESS;
	    psy_cb->psy_opctl  |= DB_ALMSUCCESS;
	}
	else if (STcasecmp($1, "FAILURE") == 0)
	{
	    psy_cb->psy_alflag |= PSY_ALMFAILURE;
	    psy_cb->psy_opmap  |= DB_ALMFAILURE;
	    psy_cb->psy_opctl  |= DB_ALMFAILURE;
	}
	else
	{
	    /* Invalid condition specified */
	    (VOID) psf_error(6384, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1, STtrmwhite($1), $1);
	    return (E_DB_ERROR);
	}
    }
;

alm_priv_list:	    alm_priv
	     |	    alm_priv_list COMMA alm_priv
;

alm_priv:	    SELECT
    {
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_RETRIEVE;
    }
	|	    DELETE
    {
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_DELETE;
    }
	|	    INSERT
    {
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_APPEND;
    }
	|	    UPDATE
    {
	((PSY_CB *) cb->pss_object)->psy_opmap |= DB_REPLACE;
    }
	|	nonkeyword
    {
	/*
	** CONNECT | DISCONNECT
	*/
	if(!STcasecmp($1,"connect"))
		((PSY_CB *) cb->pss_object)->psy_opmap |= DB_CONNECT;
	else if(!STcasecmp($1,"disconnect"))
		((PSY_CB *) cb->pss_object)->psy_opmap |= DB_DISCONNECT;
	else
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}
    }
;

alm_priv_spec:	    WHEN alm_priv_list
    {
	PSY_CB      *psy_cb = (PSY_CB *) cb->pss_object;

	/* defined ops are the same as allowed ops */
	psy_cb->psy_opctl = psy_cb->psy_opmap;

	$$ = 0;
    }
	|
    {
	/* Empty */
	$$=0;
     }
;

alm_auth_spec:		BY user_role_auth_list
    {
	if ($2 == DBGR_DEFAULT)
	{
	    PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;
	    /*
	    **      Check if production used PUBLIC, set accordingly
	    */
	    if( psy_cb->psy_flags& PSY_PUBLIC)
		$$ = DBGR_PUBLIC;
	    else
		$$ = DBGR_USER;
	}
	else $$ = $2;
    }
	    |   	BY GROUP group_role_auth_list
    {
	$$ = DBGR_GROUP;
    }
	    |		BY USER user_auth_list
    {
	$$ = DBGR_USER;
    }
	    |
    {
	$$ = DBGR_DEFAULT;
    }
;
alm_event_spec: RAISEEVENT obj_spec alm_ev_text 
	{
	    /*
	    ** Save event name/owner
	    */
	    PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;
	    DB_STATUS	status;
	    i4		ret_flags;
	    PSS_EVINFO	ev_info;
	    i4		stmt_type;
	    i4		priv_to_check;
	    i4		ev_mask;
	    i4		err_code;

	    stmt_type = PST_EVRAISE_TYPE;
	    priv_to_check = (i4) DB_EVRAISE;
	    /*
	    ** If user specified a schema then tell psy_gevent to 
	    ** check that, otherwise lookup in regular namespace
	    */
	    if($2->pss_objspec_flags&PSS_OBJSPEC_EXPL_SCHEMA)
		ev_mask = ( PSS_EV_BY_OWNER );
	    else
	        ev_mask = ( PSS_USREVENT | PSS_DBAEVENT | PSS_INGEVENT);

	    /*
	    ** Look up the event, making sure we can access it
	    */
	    status = psy_gevent(cb, &$2->pss_owner, &$2->pss_obj_name,
	       (DB_TAB_ID*)0, ev_mask, &ev_info, &ret_flags, &priv_to_check,
	       psq_cb->psq_mode, (i4) FALSE, &psq_cb->psq_error);

	    if (DB_FAILURE_MACRO(status))
	    	return (status);
	    else if (ret_flags & (PSS_MISSING_EVENT | PSS_INSUF_EV_PRIVS))
	    {
	        /*
	        **    dbevent does not exist
	        ** or the current user lacks a required privilege on it
	        */
	        return(E_DB_ERROR);
	     }

	     /*
	     ** copy event id structure into the alarm structure
	     ** Note this effectively resolves the dbevent early 
	     */
	     STRUCT_ASSIGN_MACRO(ev_info.pss_ev_id, 
			psy_cb->psy_tuple.psy_alarm.dba_eventid);

	     psy_cb->psy_tuple.psy_alarm.dba_flags|=DBA_DBEVENT; 

	}
	|
	/* Empty */

alm_ev_text: SCONST
	{
	    PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;
	    /*
	    ** Save optional event text  (note: this silently
	    ** truncates very long text currently)
	    */
	    STmove(sconvert($1),' ',sizeof(psy_cb->psy_tuple.psy_alarm.dba_eventtext),
				psy_cb->psy_tuple.psy_alarm.dba_eventtext);

	    psy_cb->psy_tuple.psy_alarm.dba_flags|=DBA_DBEVTEXT; 
	}
	|
	/* Empty */

/*
** drop_secalm: handles the DROP SECURITY_ALARM statement
**
**	DROP SECURITY_ALARM ON 
**		[TABLE] table|DATABASE dbname | CURRENT INSTALLATION
**		num | name | ALL
*/
drop_secalm:  drop_secalkw alm_obj_spec drop_secalspeclist
	{
	    DB_STATUS status;
	    PSY_CB   *psy_cb = (PSY_CB *) cb->pss_object;
	    status=psl_al4_drop_alarm(cb, psy_cb, psq_cb, $2);
	    if(status!=E_DB_OK)
		return status;
	}
;

drop_secalkw: DROPSECALM
    {
	i4                err_code;
	PSY_CB		       *psy_cb;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_KALARM;

	/* "drop security_alarm" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("DROP SECURITY_ALARM")-1,
		"DROP SECURITY_ALARM");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate a PSY_CB for drop security_alarm */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_alflag = PSY_KALARM;	/* DROP SECURITY_ALARM */
	(VOID) QUinit((QUEUE *) &psy_cb->psy_objq); /* No objects */
	psy_cb->psy_numnms=0;
	MEfill(sizeof(psy_cb->psy_tuple.psy_alarm), 0, 
	    (PTR) &psy_cb->psy_tuple.psy_alarm);
    }
;
drop_secalspeclist: drop_secallist 
		  | ALL
;

drop_secallist: drop_secallist COMMA drop_secalspec
		| drop_secalspec
		;

drop_secalspec: generic_ident
	{
	    PSY_OBJ *psy_obj;
	    PSY_CB  *psy_cb;
	    DB_STATUS status;
	    /*
	    ** Build list of identifiers in psy_objq
	    */
	    psy_cb = (PSY_CB *) cb->pss_object;

	    /* Allocate memory for an object entry */
	    status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSY_OBJ), 
		(PTR *) &psy_obj, &psq_cb->psq_error);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }
	    (VOID) QUinsert((QUEUE *)psy_obj, (QUEUE *) &psy_cb->psy_objq);

	    STmove($1, ' ', sizeof(DB_NAME), (char *) &psy_obj->psy_objnm);
	}
	| dropipint
	;
/*
** alter_secaud - ALTER SECURITY_AUDIT
*/
alter_secaud:	alt_secaud_kwd alt_secaud_word alt_secaud_with
	{ DB_STATUS status;

	  status=psl_as3_alter_secaud(psq_cb, cb);
	  if(DB_FAILURE_MACRO(status))
		return status;
	}

alt_secaud_kwd:	ALTSECAUDIT
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_ALTAUDIT;

	/* "alter security_audit" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("ALTER SECURITY_AUDIT")-1,
		"ALTER SECURITY_AUDIT");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the alter security_audit statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to ALTER SECURITY_AUDIT */
	psy_cb->psy_auflag  = PSY_ALTAUDIT;
    }

alt_secaud_word: RESTART
    {
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;
	psy_cb->psy_auflag |= PSY_AURESTART;
    }
	|	nonkeyword
    {
	PSY_CB		       *psy_cb;
	DB_STATUS	       status;

	psy_cb = (PSY_CB *) cb->pss_object;
	status=psl_as1_nonkeyword(psy_cb, psq_cb, $1);

	if(DB_FAILURE_MACRO(status))
		return status;
    }
	| /* empty */
;
alt_secaud_with:  WITH alt_secaud_withlist
	| /* empty */

alt_secaud_withlist: alt_secaud_withentry
	| alt_secaud_withentry COMMA alt_secaud_withlist

alt_secaud_withentry: nonkeyword EQUAL strconst
	{
	PSY_CB		       *psy_cb;
	DB_STATUS	       status;

	psy_cb = (PSY_CB *) cb->pss_object;
	status=psl_as2_with_nonkw_eq_sconst(psy_cb, psq_cb, cb, $1, $3);

	if(DB_FAILURE_MACRO(status))
		return status;
	}

enable_secaud:	    en_secaud_kwd sec_aud_spec
;

en_secaud_kwd:	    ENSECAUDIT
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_ENAUDIT;

	/* "enable security_audit" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("ENABLE SECURITY_AUDIT")-1,
		"ENABLE SECURITY_AUDIT");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the enable security_audit statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to ENABLE SECURITY_AUDIT */
	psy_cb->psy_auflag  = PSY_ENAUDIT;
	psy_cb->psy_autype  = 0;
    }
;

disable_secaud:	    dis_secaud_kwd sec_aud_spec
;

dis_secaud_kwd:	    DISECAUDIT
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_DISAUDIT;

	/* "disable security_audit" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("DISABLE SECURITY_AUDIT")-1,
		"DISABLE SECURITY_AUDIT");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the disable security_audit statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to DISABLE SECURITY_AUDIT */
	psy_cb->psy_auflag  = PSY_DISAUDIT;
	psy_cb->psy_autype  = 0;
    }
;

sec_aud_spec:	    sec_aud_ltok LPAREN sec_aud_lvl RPAREN
		|   sec_aud_type
    {
	DB_STATUS   local_status;
	DB_ERROR    e_error;
	PSY_CB	    *psy_cb;
	i4	    error;
	i4     msg_id;

	psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_autype = (i4)$1;

        /* Make sure user is authorized */

        if (cb->pss_ustat & DU_UALTER_AUDIT)
	    return(E_DB_OK);

	/* User not authorized */

	/*
	** Audit the failure to ENABLE/DISABLE SECURITY AUDITing
	*/
	if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	{
	    /*
	    ** Pick out the text of message, depending on if the SECURITY_AUDIT
	    ** profile was ENABLEd/DISABLEd, and the profile element that was
	    ** modified.
	    */
	    if (psq_cb->psq_mode == PSQ_ENAUDIT)
		switch($1)
		{
		    case(DU_SALL):
			msg_id = I_SX2502_ENAB_AUDIT_ALL;
			break;
		    case(DU_SVIEW):
			msg_id = I_SX2506_ENAB_AUDIT_VIEW;
			break;
		    case(DU_SDATABASE):
			msg_id = I_SX2508_ENAB_AUDIT_DATABASE;
			break;
		    case(DU_SUSER):
			msg_id = I_SX250A_ENAB_AUDIT_USER;
			break;
		    case(DU_SPROCEDURE):
			msg_id = I_SX250C_ENAB_AUDIT_PROCEDURE;
			break;
		    case(DU_SSECURITY):
			msg_id = I_SX250E_ENAB_AUDIT_SECURITY;
			break;
		    case(DU_SALARM):
			msg_id = I_SX2510_ENAB_AUDIT_ALARM;
			break;
		    case(DU_SALERT):
			msg_id = I_SX2512_ENAB_AUDIT_DBEVENT;
			break;
		    case(DU_SRULE):
			msg_id = I_SX2514_ENAB_AUDIT_RULE;
			break;
		    case(DU_SLOCATION):
			msg_id = I_SX2516_ENAB_AUDIT_LOCATION;
			break;
		    case(DU_SRESOURCE):
			msg_id = I_SX2519_ENAB_AUDIT_RESOURCE;
			break;
		    case(DU_SQRYTEXT):
			msg_id = I_SX251B_ENAB_AUDIT_QRYTEXT;
			break;
		    default:
			msg_id = I_SX2501_CHANGE_AUDIT_PROFILE;
			break;
		}
	    else
	    {
		switch($1)
		{
		    case(DU_SALL):
			msg_id = I_SX2503_DISB_AUDIT_ALL;
			break;
		    case(DU_STABLE):
			msg_id = I_SX2505_DISB_AUDIT_TABLE;
			break;
		    case(DU_SVIEW):
			msg_id = I_SX2507_DISB_AUDIT_VIEW;
			break;
		    case(DU_SDATABASE):
			msg_id = I_SX2509_DISB_AUDIT_DATABASE;
			break;
		    case(DU_SUSER):
			msg_id = I_SX250B_DISB_AUDIT_USER;
			break;
		    case(DU_SPROCEDURE):
			msg_id = I_SX250D_DISB_AUDIT_PROCEDURE;
			break;
		    case(DU_SSECURITY):
			msg_id = I_SX250F_DISB_AUDIT_SECURITY;
			break;
		    case(DU_SALARM):
			msg_id = I_SX2511_DISB_AUDIT_ALARM;
			break;
		    case(DU_SALERT):
			msg_id = I_SX2513_DISB_AUDIT_DBEVENT;
			break;
		    case(DU_SRULE):
			msg_id = I_SX2515_DISB_AUDIT_RULE;
			break;
		    case(DU_SLOCATION):
			msg_id = I_SX2517_DISB_AUDIT_LOCATION;
			break;
		    case(DU_SRESOURCE):
			msg_id = I_SX251A_DISB_AUDIT_RESOURCE;
			break;
		    case(DU_SQRYTEXT):
			msg_id = I_SX251C_DISB_AUDIT_QRYTEXT;
			break;
		    default:
			msg_id = I_SX2501_CHANGE_AUDIT_PROFILE;
			break;
		}
	    }
	    local_status = psy_secaudit(FALSE, cb,
			    ERx("SECURITY_AUDIT"), (DB_OWN_NAME *)NULL,
			    sizeof(ERx("SECURITY_AUDIT")), SXF_E_SECURITY,
			    msg_id, SXF_A_FAIL | SXF_A_ALTER,
			    &e_error);
	}

        error = E_US18D3_6355_NOT_AUTH;

        (VOID) psf_error(E_US18D3_6355_NOT_AUTH, 0L,
                         PSF_USERERR, &error, &psq_cb->psq_error, 1,
                         sizeof("ENABLE/DISABLE SECURITY_AUDIT")-1,
                         "ENABLE/DISABLE SECURITY_AUDIT");

	return(E_DB_ERROR);
    }
;

sec_aud_type:	    ALL
    {
	$$ = DU_SALL;
    }
		|   TABLE
    {
	$$ = DU_STABLE;
    }
		|   USER
    {
	$$ = DU_SUSER;
    }
		|   VIEW
    {
	$$ = DU_SVIEW;
    }
                |   PROCEDURE
    {
        $$ = DU_SPROCEDURE;
    }
		|   ROW
    {	
	$$ = DU_SRECORD;
    }
		|   nonkeyword
    {
	i4	    err_code;
	PSY_CB	    *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if (STcasecmp($1, "DATABASE") == 0)
	    $$ = DU_SDATABASE;

	else if (STcasecmp($1, "ROLE") == 0)
	    $$ = DU_SAPPLICATION;

	else if (STcasecmp($1, "LOCATION") == 0)
	    $$ = DU_SLOCATION;

	else if (STcasecmp($1, "SECURITY") == 0)
	    $$ = DU_SSECURITY;

	else if (STcasecmp($1, "ALARM") == 0)
	    $$ = DU_SALARM;

	else if (STcasecmp($1, "RULE") == 0)
	    $$ = DU_SRULE;

	else if (STcasecmp($1, "DBEVENT") == 0)
	    $$ = DU_SALERT;

	else if (STcasecmp($1, "RESOURCE") == 0)
	    $$ = DU_SRESOURCE;

	else if (STcasecmp($1, "QUERY_TEXT") == 0)
	    $$ = DU_SQRYTEXT;

	else if (STcasecmp($1, "LEVEL") == 0)
	{
	    /* Level omitted */
	    (VOID) psf_error(6371, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	else
	{
	    	if(psq_cb->psq_mode == PSQ_ENAUDIT)
			{
			(VOID) psf_error(3833, 0L, PSF_USERERR, &err_code,
				&psq_cb->psq_error, 2, 
				(i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
				(i4) STtrmwhite($1), $1);
			}
			else 
			{
			(VOID) psf_error(3834, 0L, PSF_USERERR, &err_code,
				&psq_cb->psq_error, 2, 
				(i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
				(i4) STtrmwhite($1), $1);
			}
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    }


sec_aud_ltok:	    nonkeyword
    {
	i4	    err_code;
	PSY_CB	    *psy_cb = (PSY_CB *) cb->pss_object;

	if (STcasecmp($1, "LEVEL") == 0)
	{
	    psy_cb->psy_autype  = DU_SLVL;
	    return (E_DB_OK);
	}

	/* Invalid audit type */
	if(psq_cb->psq_mode == PSQ_ENAUDIT)
	{
	(VOID) psf_error(3833, 0L, PSF_USERERR, &err_code,
	    &psq_cb->psq_error, 2, 
	    (i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
	    (i4) STtrmwhite($1), $1);
	}
	else 
	{
	(VOID) psf_error(3834, 0L, PSF_USERERR, &err_code,
	    &psq_cb->psq_error, 2, 
	    (i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
	    (i4) STtrmwhite($1), $1);
	}
	return (E_DB_ERROR);    /* non-zero return means error */
    }
;

sec_aud_lvl:	    name_or_sconst
    {
	PSY_CB	    *psy_cb;
	char	    *str = $1;
	i4	    error;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;

        /* Make sure user is authorized */

        if (!(cb->pss_ustat & DU_UALTER_AUDIT))
	{
	    /* User not authorized  - create security audit record */
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		status = psy_secaudit(FALSE, cb,
			    ERx("SECURITY_AUDIT"), (DB_OWN_NAME *)NULL,
			    sizeof(ERx("SECURITY_AUDIT")), SXF_E_SECURITY,
			    I_SX2501_CHANGE_AUDIT_PROFILE, 
			    SXF_A_FAIL | SXF_A_ALTER,
			    &psq_cb->psq_error);
	    }

	    error = E_US18D3_6355_NOT_AUTH;
	    (VOID) psf_error(E_US18D3_6355_NOT_AUTH, 0L,
                         PSF_USERERR, &error, &psq_cb->psq_error, 1,
                         sizeof("ENABLE/DISABLE SECURITY_AUDIT")-1,
                         "ENABLE/DISABLE SECURITY_AUDIT");

	    return(E_DB_ERROR);
	}
    }
;
/*
** CREATE/ALTER/DROP PROFILE
** 
** These are parsed essentially the same as CREATE/ALTER/DROP USER except
** the query mode is different
*/
create_profile:	    crt_pro_kwd auth_user usr_with_spec
    {
	PSY_CB	    *psy_cb;
	PSY_USR	    *psy_usr;
	/* test profilename for reserved name
	 */
	psy_cb  = (PSY_CB *) cb->pss_object;
	psy_usr = (PSY_USR *) psy_cb->psy_usrq.q_next;
	
	/* test user name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT(psy_usr->psy_usrnm.db_own_name, 
				  cb, psq_cb, TRUE))
	    return(E_DB_ERROR);
    }

;
crt_pro_kwd:	    CRTPROFILE
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_CPROFILE;

	/* "create profile" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CREATE PROFILE")-1, "CREATE PROFILE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the create profile statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to CREATE PROFILE */
	psy_cb->psy_usflag  = PSY_CPROFILE;
	psy_cb->psy_usprivs = 0;
	psy_cb->psy_usdefprivs = 0;
	psy_cb->psy_ussecaudit = 0;
	MEfill(sizeof(psy_cb->psy_usgroup), ' ', (PTR) &psy_cb->psy_usgroup);
	MEfill(sizeof(psy_cb->psy_apass), ' ', (PTR) &psy_cb->psy_apass);
    }
;
alter_profile:	    alt_pro_start usr_adp_spec usr_with_spec
;

alt_pro_start:	    ALTPROFILE 
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_APROFILE;

	/* "alter profile" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("ALTER PROFILE")-1, "ALTER PROFILE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the alter user statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to ALTER PROFILE */
	psy_cb->psy_usflag  = PSY_APROFILE;
	psy_cb->psy_usprivs = 0;
	psy_cb->psy_usdefprivs = 0;
	psy_cb->psy_ussecaudit = 0;
	MEfill(sizeof(psy_cb->psy_usgroup), ' ', (PTR) &psy_cb->psy_usgroup);
	MEfill(sizeof(psy_cb->psy_apass), ' ', (PTR) &psy_cb->psy_apass);
	MEfill(sizeof(psy_cb->psy_bpass), ' ', (PTR) &psy_cb->psy_bpass);
    } 
    auth_user

   | ALTER  DEFAULT nonkeyword
    { 
	/*
	** ALTER DEFAULT PROFILE is transformed into an ALTER operation
	** on the default profile, named "all-spaces"
	*/
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;
	PSY_USR	    		*psy_usr;

	psq_cb->psq_mode = PSQ_APROFILE;

	if(STcasecmp($3,"profile")!=0)
	{
	    (VOID) psf_error(6353L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		sizeof("ALTER PROFILE")-1,
		"ALTER PROFILE",
		(i4) STtrmwhite($3), $3);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* "alter profile" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("ALTER PROFILE")-1, "ALTER PROFILE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the alter user statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to ALTER PROFILE */
	psy_cb->psy_usflag  = PSY_APROFILE;
	psy_cb->psy_usprivs = 0;
	psy_cb->psy_usdefprivs = 0;
	psy_cb->psy_ussecaudit = 0;
	MEfill(sizeof(psy_cb->psy_usgroup), ' ', (PTR) &psy_cb->psy_usgroup);
	MEfill(sizeof(psy_cb->psy_apass), ' ', (PTR) &psy_cb->psy_apass);
	MEfill(sizeof(psy_cb->psy_bpass), ' ', (PTR) &psy_cb->psy_bpass);



	/* Allocate memory for a user entry */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSY_USR), 
		(PTR *) &psy_usr, &psq_cb->psq_error);
	if (status != E_DB_OK)
	{
		return (status);
	}

	 /*
	 ** Copy user name to user entry.
	 */
	STmove("", ' ', sizeof(DB_OWN_NAME), (char *) &psy_usr->psy_usrnm);

	/*
	** Attach element to the list.
	*/
	(VOID) QUinsert((QUEUE *) psy_usr, (QUEUE *)&psy_cb->psy_usrq);

	psy_cb->psy_usflag |= PSY_USRNAME;
    }
;
drop_profile:	    drp_pro_kwd auth_user drp_pro_term
;

drp_pro_kwd:	    DROPPROFILE
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_DPROFILE;

	/* "drop profile" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("DROP PROFILE")-1, "DROP PROFILE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the drop profile statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to DROP PROFILE */
	psy_cb->psy_usflag  = PSY_DPROFILE;
    }
;

drp_pro_term: /* nothing */
	| RESTRICT 
	| CASCADE 
		{PSY_CB *psy_cb;

		psy_cb = (PSY_CB *) cb->pss_object;

		psy_cb->psy_usflag  |= PSY_USRCASCADE;
		}

/*
** CREATE/ALTER/DROP USER statements
**
** Most of these productions are used for CREATE/ALTER PROFILE as well
*/
create_user:	    crt_usr_kwd auth_user usr_with_spec
    {
	PSY_CB	    *psy_cb;
	PSY_USR	    *psy_usr;
	/* test username for reserved name
	 */
	psy_cb  = (PSY_CB *) cb->pss_object;
	psy_usr = (PSY_USR *) psy_cb->psy_usrq.q_next;
	
	/* test user name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT(psy_usr->psy_usrnm.db_own_name, 
				  cb, psq_cb, TRUE))
	    return(E_DB_ERROR);
    }

;

crt_usr_kwd:	    CRTUSER
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_CUSER;

	/* "create user" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CREATE USER")-1, "CREATE USER");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the create user statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to CREATE USER */
	psy_cb->psy_usflag  = PSY_CUSER;
	psy_cb->psy_usprivs = 0;
	psy_cb->psy_usdefprivs = 0;
	psy_cb->psy_ussecaudit = 0;
	MEfill(sizeof(psy_cb->psy_usprofile), ' ', (PTR) &psy_cb->psy_usprofile);
	MEfill(sizeof(psy_cb->psy_usgroup), ' ', (PTR) &psy_cb->psy_usgroup);
	MEfill(sizeof(psy_cb->psy_apass), ' ', (PTR) &psy_cb->psy_apass);
    }
;

alter_user:	    alt_usr_kwd auth_user usr_adp_spec usr_with_spec
;

alt_usr_kwd:	    ALTUSER
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_AUSER;

	/* "alter user" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("ALTER USER")-1, "ALTER USER");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the alter user statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to ALTER USER */
	psy_cb->psy_usflag  = PSY_AUSER;
	psy_cb->psy_usprivs = 0;
	psy_cb->psy_usdefprivs = 0;
	psy_cb->psy_ussecaudit = 0;
	MEfill(sizeof(psy_cb->psy_usgroup), ' ', (PTR) &psy_cb->psy_usgroup);
	MEfill(sizeof(psy_cb->psy_apass), ' ', (PTR) &psy_cb->psy_apass);
	MEfill(sizeof(psy_cb->psy_bpass), ' ', (PTR) &psy_cb->psy_bpass);
	MEfill(sizeof(psy_cb->psy_usprofile), ' ', (PTR) &psy_cb->psy_usprofile);
    }
;

usr_adp_spec:    ADD PRIVILEGES LPAREN usr_priv_list RPAREN
	     {
		PSY_CB	    *psy_cb;
		DB_STATUS   status;

		psy_cb = (PSY_CB *) cb->pss_object;
/*
		TRdisplay ( "usr_adp_spec: ADD P L list R - calling psl_us5_usr_priv_def\n" ) ;
*/
		status=psl_us5_usr_priv_def(psy_cb,psq_cb, cb, PSY_USRAPRIVS, $4);
		if(DB_FAILURE_MACRO(status))
			return status;
	      }
	| DROP PRIVILEGES LPAREN usr_priv_list RPAREN
	     {
		PSY_CB	    *psy_cb;
		DB_STATUS   status;

		psy_cb = (PSY_CB *) cb->pss_object;
/*
		TRdisplay ( "usr_adp_spec : DROP P L list R - calling psl_us5_usr_priv_def\n" ) ;
*/
		status=psl_us5_usr_priv_def(psy_cb,psq_cb, cb, PSY_USRDPRIVS, $4);
		if(DB_FAILURE_MACRO(status))
			return status;
	      }
	| /* Nothing */
; /*b66257*/

usr_with_spec:	    WITH usr_with_list
		| /* nothing */
;

usr_with_list:	    usr_with COMMA usr_with_list
		|   usr_with
;

usr_with:	    GROUP EQUAL auth_ident
    {
	PSY_CB	    *psy_cb;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;
/*
	TRdisplay ( "usr_with : GROUP EQUAL auth_ident - calling psl_us2_with\n" ) ;
*/
	status=psl_us2_with_nonkw_eq_nmsconst(psy_cb,psq_cb, cb, "group", $3);
	if(DB_FAILURE_MACRO(status))
			return status;
    }
    |   PRIVILEGES EQUAL LPAREN usr_priv_list RPAREN
     {
	PSY_CB	    *psy_cb;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;
/*
	TRdisplay ( "usr_with : ADD P L list R - calling psl_us5_usr_priv_def\n" ) ;
*/
	status=psl_us5_usr_priv_def(psy_cb,psq_cb, cb, PSY_USRPRIVS, $4);
	if(DB_FAILURE_MACRO(status))
		return status;
      }
    |   nonkeyword EQUAL LPAREN usr_priv_list RPAREN
     {
	PSY_CB	    *psy_cb;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;
	status=psl_us4_usr_priv_or_nonkw(psy_cb,psq_cb, cb, $1, $4);
	if(DB_FAILURE_MACRO(status))
		return status;
      }
    |   nonkeyword EQUAL sconst_ident /* ident or sconst */
    {
	PSY_CB	    *psy_cb;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;
/*
	TRdisplay ( "usr_with : nonkeyword EQUAL sconst_ident - calling psl_us2_with\n" ) ;
*/
	status=psl_us2_with_nonkw_eq_nmsconst(psy_cb,psq_cb, cb, $1, $3);
	if(DB_FAILURE_MACRO(status))
			return status;
    }
    |   nonkeyword EQUAL HEXCONST
    {
	PSY_CB	    *psy_cb;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;
	status=psl_us2_with_nonkw_eq_hexconst(psy_cb, psq_cb, cb, $1,
	    $3->db_t_count, (char *)$3->db_t_text);
	if(DB_FAILURE_MACRO(status))
			return status;
    }
    |   nonkeyword EQUAL ALL
    {
	PSY_CB	    *psy_cb;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;
/*
	TRdisplay ( "usr_with : nonkeyword EQUAL ALL - calling psl_us2_with\n" ) ;
*/
	status=psl_us2_with_nonkw_eq_nmsconst(psy_cb,psq_cb, cb, $1, "ALL");
	if(DB_FAILURE_MACRO(status))
			return status;
    }
    |   nonkeyword
    {
	PSY_CB	    *psy_cb;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;
	status=psl_us1_with_nonkeyword(psy_cb, psq_cb, cb, $1);
	if(DB_FAILURE_MACRO(status))
		return status;
    }
;

usr_priv_list:	    usr_priv COMMA usr_priv_list
			{ $$= ($1|$3);}
		|   usr_priv
			{ $$= $1;}
;

usr_priv:	    nonkeyword
    {
	PSY_CB	    *psy_cb;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;
/*
	TRdisplay ( "usr_priv : nonkeyword - calling psl_us3_usrpriv\n" ) ;
*/
	status=psl_us3_usrpriv(psy_cb, psq_cb, $1, &$$);
	if(DB_FAILURE_MACRO(status))
		return status;
    }
    | ALL
    {
	PSY_CB	    *psy_cb;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;
/*
	TRdisplay ( "usr_priv : nonkeyword ALL - calling psl_us3_usrpriv\n" ) ;
*/
	status=psl_us3_usrpriv(psy_cb, psq_cb, "all", &$$);
	if(DB_FAILURE_MACRO(status))
		return status;
    }
;

drop_user:	    drp_usr_kwd auth_user
;

drp_usr_kwd:	    DROPUSER
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_KUSER;

	/* "drop user" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("DROP USER")-1, "DROP USER");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the drop user statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to DROP USER */
	psy_cb->psy_usflag  = PSY_KUSER;
    }
;

create_location:    crt_loc_kwd db_loc_obj loc_with_spec 
    {
	i4	    err_code;
	PSY_CB	    *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Ensure AREA was specified */
	if (!(psy_cb->psy_loflag & PSY_LOCAREA))
	{
	    (VOID) psf_error(6360L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Usage is ALL if usage clause was not specified */
	if (!(psy_cb->psy_loflag & PSY_LOCUSAGE))
	{
	    psy_cb->psy_lousage = DU_ALL_LOCS;
	    psy_cb->psy_loflag |= PSY_LOCUSAGE;
	}

	/* RAW percent can only be specified with usage=database */
	if ( psy_cb->psy_loc_rawpct && psy_cb->psy_lousage != DU_DBS_LOC )
	{
	    (VOID) psf_error(E_US18DE_6366_INVALID_RAW_USAGE, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    }
;

crt_loc_kwd:	    CRTLOC
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_CLOC;

	/* "create location" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CREATE LOCATION")-1, "CREATE LOCATION");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the create location statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);
	    
	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to CREATE LOCATION */
	psy_cb->psy_loflag  = PSY_CLOC;
	psy_cb->psy_lousage = 0;
	psy_cb->psy_loc_rawpct = 0;
    }
;

alter_location:	    alt_loc_kwd db_loc_obj loc_with_spec
    {
	i4	    err_code;
	PSY_CB	    *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Ensure AREA was *not* specified */
	if (psy_cb->psy_loflag & PSY_LOCAREA)
	{
	    (VOID) psf_error(6361L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    }
;

alt_loc_kwd:	    ALTLOC
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_ALOC;

	/* "alter location" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("ALTER LOCATION")-1, "ALTER LOCATION");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the alter location statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to ALTER LOCATION */
	psy_cb->psy_loflag  = PSY_ALOC;
	psy_cb->psy_lousage = 0;
    }
;

loc_with_spec:	    WITH loc_with_list
;

loc_with_list:	    loc_with COMMA loc_with_list
		|   loc_with
;

loc_with:	    loc_use_tok LPAREN loc_use_list RPAREN
		|   loc_rawpct_tok loc_rawpct
		|   loc_area_tok loc_area
		|   loc_nouse_tok
;

loc_area_tok:	    nonkeyword EQUAL
    {
	PSY_CB	    *psy_cb;
	i4                err_code;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Ensure word is AREA */

	if (STcasecmp($1, "AREA") != 0)
	{
	    (VOID) psf_error(6353L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		(i4) sizeof("CREATE/ALTER LOCATION")-1, "CREATE/ALTER LOCATION",
		(i4) STtrmwhite($1), $1);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Ensure AREA was not previously specified */
	if (psy_cb->psy_loflag & PSY_LOCAREA)
	{
	    (VOID) psf_error(6351L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		(i4) sizeof("CREATE/ALTER LOCATION")-1, "CREATE/ALTER LOCATION",
		(i4) sizeof("AREA")-1, "AREA");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Indicate AREA was specified */
	psy_cb->psy_loflag |= PSY_LOCAREA;
    }
;

loc_use_tok:	    nonkeyword EQUAL
    {
	PSY_CB	    *psy_cb;
	i4	    err_code;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Ensure first word is USAGE */
	if (STcasecmp($1, "USAGE") != 0)
	{
	    (VOID) psf_error(6353L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		(i4) sizeof("CREATE/ALTER LOCATION")-1, "CREATE/ALTER LOCATION",
		(i4) STtrmwhite($1), $1);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Ensure USAGE was not previously specified */
	if (psy_cb->psy_loflag & PSY_LOCUSAGE)
	{
	    (VOID) psf_error(6351L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		(i4) sizeof("CREATE/ALTER LOCATION")-1, "CREATE/ALTER LOCATION",
		(i4) sizeof("[NO]USAGE")-1, "[NO]USAGE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Indicate USAGE was specified */
	psy_cb->psy_loflag |= PSY_LOCUSAGE;
    }
;

loc_nouse_tok:	    nonkeyword 
    {
	PSY_CB	    *psy_cb;
	i4	    err_code;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Ensure first word is NOUSAGE */
	if (STcasecmp($1, "NOUSAGE") != 0)
	{
	    (VOID) psf_error(6353L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		(i4) sizeof("CREATE/ALTER LOCATION")-1, "CREATE/ALTER LOCATION",
		(i4) STtrmwhite($1), $1);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Ensure USAGE was not previously specified */
	if (psy_cb->psy_loflag & PSY_LOCUSAGE)
	{
	    (VOID) psf_error(6351L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		(i4) sizeof("CREATE/ALTER LOCATION")-1, "CREATE/ALTER LOCATION",
		(i4) sizeof("[NO]USAGE")-1, "[NO]USAGE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Indicate USAGE was specified */
	psy_cb->psy_loflag |= PSY_LOCUSAGE;
    }
;

loc_area:	    name_or_sconst
    {
	PSY_CB	    *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	STmove($1, ' ', sizeof(DB_AREANAME),
	       (char *) &psy_cb->psy_area);
    }
;

loc_use_list:	    loc_use COMMA loc_use_list
		|   loc_use
;

loc_use:	    loc_use_type
    {
	i4	    err_code;
	PSY_CB	    *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if (psy_cb->psy_loflag & PSY_LOCUSED)	/* ALL/NONE prev specified */
	{
	    /* Inconsistent use of ALL or NONE -- other usages specified  */
	    (VOID) psf_error(6363L, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	if (($1 == 0) ||	    		/* NONE specified */
	    ($1 == DU_ALL_LOCS))		/* ALL  specified */
	{
	    if (psy_cb->psy_lousage)		/* Other prev specified */
	    {
		/* Inconsistent use of ALL or NONE -- other usages specified  */
		(VOID) psf_error(6363L, 0L, PSF_USERERR,
				 &err_code, &psq_cb->psq_error, 0);
		return (E_DB_ERROR);    /* non-zero return means error */
	    }
	    psy_cb->psy_loflag |= PSY_LOCUSED;	/* No more usages allowed */
	}

	psy_cb->psy_lousage |= $1;		/* Indicate usage */
    }
;

loc_use_type:	    ALL
    {
	$$ = DU_ALL_LOCS;
    }
		|   WORK
    {
	$$ = DU_WORK_LOC;
    }
		|   nonkeyword
    {
	i4	    err_code;
	PSY_CB	    *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if (STcasecmp($1, "DATABASE") == 0)
	    $$ = DU_DBS_LOC;

	else if (STcasecmp($1, "JOURNAL") == 0)
	    $$ = DU_JNLS_LOC;

	else if (STcasecmp($1, "CHECKPOINT") == 0)
	    $$ = DU_CKPS_LOC;

	else if (STcasecmp($1, "DUMP") == 0)
	    $$ = DU_DMPS_LOC;

	else
	{
	    /* Unknown usage specified */
	    (VOID) psf_error(6362L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		(i4) STtrmwhite($1), $1);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    }
;

loc_rawpct_tok:	    	RAWPCT EQUAL 
    {
	PSY_CB	    *psy_cb;
	i4	    err_code;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Ensure RAWPCT was not previously specified */
	if (psy_cb->psy_loc_rawpct)
	{
	    (VOID) psf_error(6351L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		(i4) sizeof("CREATE LOCATION")-1, "CREATE LOCATION",
		(i4) sizeof("RAWPCT")-1, "RAWPCT");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    }
;

loc_rawpct:		loc_rawpct_type
    {
	PSY_CB	    *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;
	psy_cb->psy_loc_rawpct = $1;
    }
;

loc_rawpct_type:	intconst_p
    {
	PSY_CB	    *psy_cb;
	i4	    err_code;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Must be between 0 and 100 */
	if ( $1 < 0 || $1 > 100 )
	{
	    /* Bad value for rawpct specified */
	    (VOID) psf_error(6365L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	$$ = $1;
    }
;


drop_location:	    drp_loc_kwd db_loc_obj
;

drp_loc_kwd:	    DROPLOC
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_KLOC;

	/* "drop location" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("DROP LOCATION")-1, "DROP LOCATION");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the drop location statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set stuff specific to DROP LOCATION */
	psy_cb->psy_loflag  = PSY_KLOC;
	psy_cb->psy_lousage = 0;
    }
;

create_group:	    crt_grp_kwd auth_obj_list crt_grp_spec
;

crt_grp_kwd:	    CRTGROUP
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_CGROUP;

	/* "create group" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6274L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the create group statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);
	    
	psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_grpflag = PSY_CGROUP;

	/* we are about to process the new object name */
	cb->pss_stmt_flags |= PSS_NEW_OBJ_NAME;
    }
;

crt_grp_spec:	    WITH crt_grp_ukwd EQUAL LPAREN auth_user_list RPAREN
		|
;

crt_grp_ukwd:	    nonkeyword
    {
	PSY_CB	    *psy_cb;
	i4	    err_code;

	/* we are done processing the new object name */
	cb->pss_stmt_flags &= ~PSS_NEW_OBJ_NAME;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Ensure "USERS" was specified */

	if (STcasecmp($1, "USERS"))
	{
	    (VOID) psf_error(6270L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STtrmwhite($1), $1);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    }
;

alter_group:	    alt_grp_kwd auth_obj_list alt_grp_spec
;

alt_grp_kwd:	    ALTGROUP
    {
	i4                err_code;
	DB_STATUS	       status;

	/*
	** Set statement mode to ALTER GROUP ... ADD;
	** just in case of parser error before EOS.
	** Reset to correct statement mode later,
	** when we determine what kind of ALTER we have.
	*/
	psq_cb->psq_mode = PSQ_AGROUP;

	/* "alter group" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6275L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the create group statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);
    }
;

alt_grp_spec:	    ADD  alt_grp_ukwd LPAREN auth_user_list RPAREN
    {
	PSY_CB	    *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;
	psq_cb->psq_mode = PSQ_AGROUP;
	psy_cb->psy_grpflag = PSY_AGROUP;
    }
		|   DROP alt_grp_ukwd LPAREN auth_user_list RPAREN
    {
	PSY_CB	    *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;
	psq_cb->psq_mode = PSQ_DGROUP;
	psy_cb->psy_grpflag = PSY_DGROUP;
    }
		|   DROP ALL
    {
	PSY_CB	    *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;
	psq_cb->psq_mode = PSQ_DGROUP;
	psy_cb->psy_grpflag = PSY_DGROUP;
    }
;

alt_grp_ukwd:	    nonkeyword
    {
	PSY_CB	    *psy_cb;
	i4	    err_code;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Ensure "USERS" was specified */

	if (STcasecmp($1, "users"))
	{
	    (VOID) psf_error(6271L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STtrmwhite($1), $1);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    }
;

drop_group:	    drp_grp_kwd auth_obj_list
;

drp_grp_kwd:	    DROPGROUP
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_KGROUP;

	/* "drop group" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6276L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the create group statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_grpflag = PSY_KGROUP;
    }
;

create_role:	    crt_role_kwd auth_obj_list usr_with_spec
;

crt_role_kwd:	    CRTROLE
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_CAPLID;

	/* "create role" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6277L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the create appication_id statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_aplflag = PSY_CAPLID;

	/* we are about to process new object names */
	cb->pss_stmt_flags |= PSS_NEW_OBJ_NAME;

	(VOID)MEfill(sizeof(DB_OWN_NAME), (u_char)' ', (PTR)&psy_cb->psy_apass);
	psy_cb->psy_usprivs = 0;
	psy_cb->psy_usdefprivs = 0;
	psy_cb->psy_ussecaudit = 0;

    }
;


alter_role:	    alt_role_kwd auth_obj_list usr_adp_spec usr_with_spec
;

alt_role_kwd:	    ALTROLE
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_AAPLID;

	/* "alter role" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6278L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the create appication_id statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_aplflag = PSY_AAPLID;
	(VOID)MEfill(sizeof(DB_OWN_NAME), (u_char)' ', (PTR)&psy_cb->psy_apass);
	psy_cb->psy_usprivs = 0;
	psy_cb->psy_usdefprivs = 0;
	psy_cb->psy_ussecaudit = 0;
    }
;

drop_role:	    drp_role_kwd auth_obj_list
;

drp_role_kwd:	    DROPROLE
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_KAPLID;

	/* "drop role" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6279L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the create group statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_aplflag = PSY_KAPLID;
    }
;

auth_user_list:	    auth_user
		|   auth_user_list COMMA auth_user
;

auth_user:	    user_ident
    {
	PSY_CB	    *psy_cb;
	PSY_USR	    *psy_usr;
	bool	    found = FALSE;
	DB_STATUS   status;
	DB_OWN_NAME username;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Normalize the user name */
	STmove($1, ' ', sizeof(DB_OWN_NAME), (char *) &username);

	/*
	** Check if user specified for the first time.
	*/
	for (psy_usr = (PSY_USR *) psy_cb->psy_usrq.q_next;
	     psy_usr != (PSY_USR *) &psy_cb->psy_usrq;
	     psy_usr = (PSY_USR *) psy_usr->queue.q_next
	    )
	{
	    if (MEcmp((PTR) &username, (PTR) &psy_usr->psy_usrnm,
		sizeof(psy_usr->psy_usrnm)) == 0
	       )
	    {
		found = TRUE;
		break;
	    }
	}

	/*
	** Store only if not found. No need to keep duplicates.
	*/
	if (found == FALSE)
	{
	    /* Allocate memory for a user entry */
	    status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSY_USR), 
		(PTR *) &psy_usr, &psq_cb->psq_error);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }

	    /*
	    ** Copy user name to user entry.
	    */
	    STmove($1, ' ', sizeof(DB_OWN_NAME), (char *) &psy_usr->psy_usrnm);

	    /*
	    ** Attach element to the list.
	    */
	    (VOID) QUinsert((QUEUE *) psy_usr, (QUEUE *) &psy_cb->psy_usrq);

	    psy_cb->psy_usflag |= PSY_USRNAME;
	}
    }
;

auth_obj_list:	    auth_obj
		|   auth_obj_list COMMA auth_obj
;

auth_obj:	    auth_ident
    {
	PSY_CB	    *psy_cb;
	PSY_TBL	    *psy_tbl;
	bool	    found = FALSE;
	DB_STATUS   status;
	DB_OWN_NAME objname;

	/* test username for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT($1, cb, psq_cb, FALSE))
	    return(E_DB_ERROR);
	    
	psy_cb = (PSY_CB *) cb->pss_object;

	/* Normalize the object name */
	STmove($1, ' ', sizeof(DB_OWN_NAME), (char *) &objname);

	/*
	** Check if object specified for the first time.
	*/
	for (psy_tbl  = (PSY_TBL *) psy_cb->psy_tblq.q_next;
	     psy_tbl != (PSY_TBL *)&psy_cb->psy_tblq;
	     psy_tbl  = (PSY_TBL *) psy_tbl->queue.q_next
	    )
	{
	    if (MEcmp((PTR) &objname, (PTR) &psy_tbl->psy_tabnm,
		sizeof(psy_tbl->psy_tabnm)) == 0
	       )
	    {
		found = TRUE;
		break;
	    }
	}

	/*
	** Store only if not found. No need to keep duplicates.
	*/
	if (found == FALSE)
	{
	    /* Allocate memory for a user entry */
	    status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSY_TBL), 
		(PTR *) &psy_tbl, &psq_cb->psq_error);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }

	    /*
	    ** Copy object name to table entry.
	    */
	    STmove($1, ' ', sizeof(DB_OWN_NAME), (char *) &psy_tbl->psy_tabnm);

	    /*
	    ** Attach element to the list.
	    */
	    (VOID) QUinsert((QUEUE *) psy_tbl, (QUEUE *) &psy_cb->psy_tblq);
	}
    }
;


/*
** CREATE/ALTER/DROP SEQUENCE statements
**
*/
create_sequence:	crt_seq_kwd obj_spec seq_opt_list
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;
	DB_IISEQUENCE	       *seqp;

	/* test event name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT($2->pss_orig_obj_name, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	/* If name was qualified, it'd better be the same as the user */
	if ($2->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp((PTR) &$2->pss_owner, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME)))
	{
	    (void)psf_error(E_PS0421_CRTOBJ_NOT_OBJ_OWNER, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof("CREATE SEQUENCE") - 1, "CREATE SEQUENCE",
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &$2->pss_owner),
		&$2->pss_owner);
	    return(E_DB_ERROR);
	}

        status = psy_ckdbpr(psq_cb, (u_i4)DBPR_SEQ_CREATE);
        if (status)
        {
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_ERROR	e_error;
		DB_STATUS	local_status;
		DB_NAME		seqname;
		/*
		** Audit failure to create sequence
		*/
		STmove($2->pss_orig_obj_name, ' ', 
		    sizeof(DB_NAME), seqname.db_name);
		local_status = psy_secaudit(FALSE, cb,
		    (char *)&seqname, &cb->pss_user,
		    sizeof(DB_TAB_NAME), SXF_E_PROCEDURE,
		    I_SX2045_SEQUENCE_CREATE, SXF_A_FAIL | SXF_A_CREATE,
		    &e_error);
	    }

            (void)psf_error(6321L, 0L, PSF_USERERR,
                                 &err_code, &psq_cb->psq_error, 0);
            return(status);
        }

	psy_cb = (PSY_CB *) cb->pss_object;

	seqp = &psy_cb->psy_tuple.psy_sequence;

	STmove($2->pss_orig_obj_name, ' ', sizeof(DB_NAME),
	       (char *)&seqp->dbs_name);

	status = psl_csequence(cb, &psq_cb->psq_error);	/* set default parms 
						** and verify them all */
	if (status != E_DB_OK)
	    return(status);
    }
;

crt_seq_kwd:	    CRTSEQ
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_CSEQUENCE;

	/* "create sequence" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (void)psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CREATE SEQUENCE")-1, "CREATE SEQUENCE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the create sequence statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set control block and tuple fields to defaults and initial values */
	psy_cb->psy_istree = FALSE;   		
	MEfill(sizeof(psy_cb->psy_tuple.psy_sequence), NULLCHAR,
	       (PTR)&psy_cb->psy_tuple.psy_sequence);
	psy_cb->psy_seqflag |= PSY_CSEQ;
	psy_cb->psy_tuple.psy_sequence.dbs_cache = 20;
					/* default cache value */
    }
;

seq_opt_list:	seq_opt_list1
		|    /* empty */
;

seq_opt_list1:	seq_opt
		|    seq_opt_list1 seq_opt
;

seq_opt:	AS seq_type
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		*psy_cb;

	if (psq_cb->psq_mode != PSQ_CSEQUENCE)
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}

	/* Verify that the type is either int4 or dec with no scale or
	** precision > 31 digits - the 31 digit limitation is likely 
	** just temporary (Ingres supports 39 for decimal), hence the use
	** of an explicit constant. */
	if (($2->db_datatype == DB_INT_TYPE && $2->db_length != 4) ||
		($2->db_datatype == DB_DEC_TYPE &&
			(DB_S_DECODE_MACRO($2->db_prec) != 0 ||
			 DB_P_DECODE_MACRO($2->db_prec) > 31)) ||
	    ($2->db_datatype != DB_INT_TYPE && $2->db_datatype != DB_DEC_TYPE))
	{
	    (void)psf_error(6318L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	
	psy_cb = (PSY_CB *) cb->pss_object;

	/* Assign datatype, length, precision. */
	psy_cb->psy_tuple.psy_sequence.dbs_type = $2->db_datatype;
	psy_cb->psy_tuple.psy_sequence.dbs_length = $2->db_length;
	psy_cb->psy_tuple.psy_sequence.dbs_prec = 
				DB_P_DECODE_MACRO($2->db_prec);
	if ($2->db_datatype == DB_DEC_TYPE)
	    psy_cb->psy_seqflag |= PSY_DECTYPE;
				/* and note declared decimal type */

    }
		|    START WITH sign_op number
    {
	DB_STATUS	       status;
	
	status = psl_seq_parmcheck(cb, psq_cb, $4, DBS_START,
	    ($3 == ADI_MINUS_OP));
	if (status != E_DB_OK)
	    return(status);

    }
		|    RESTART WITH sign_op number
    {
	DB_STATUS	       status;
	
	status = psl_seq_parmcheck(cb, psq_cb, $4, DBS_RESTART,
	    ($3 == ADI_MINUS_OP));
	if (status != E_DB_OK)
	    return(status);

    }
		|   INCREMENT BY sign_op number
    {
	DB_STATUS	       status;
	
	status = psl_seq_parmcheck(cb, psq_cb, $4, DBS_INCR,
	    ($3 == ADI_MINUS_OP));
	if (status != E_DB_OK)
	    return(status);

    }
	
		|   MAXVALUE sign_op number
    {
	DB_STATUS	       status;
	
	status = psl_seq_parmcheck(cb, psq_cb, $3, DBS_MAXVAL,
	    ($2 == ADI_MINUS_OP));
	if (status != E_DB_OK)
	    return(status);

    }
	
		|   MINVALUE sign_op number
    {
	DB_STATUS	       status;
	
	status = psl_seq_parmcheck(cb, psq_cb, $3, DBS_MINVAL,
	    ($2 == ADI_MINUS_OP));
	if (status != E_DB_OK)
	    return(status);

    }
	
		|   CACHE number
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		*psy_cb;
	i4		cacheval;
	
	psy_cb = (PSY_CB *) cb->pss_object;

	/* FIXME disallow i8 cache value for now */
	if ($2->db_datatype != DB_INT_TYPE || $2->db_length == 8)
	{
	    /* Cache value must be integer. */
	    (void)psf_error(6316L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CACHE")-1, "CACHE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	if (psy_cb->psy_tuple.psy_sequence.dbs_flag & DBS_NOCACHE)
	{
	    /* Inconsistent options - CACHE and NOCACHE. */
	    (void)psf_error(6317L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CACHE/NOCACHE")-1, "CACHE/NOCACHE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	switch ($2->db_length) {
	  case 1:
	    cacheval = *(i1 *)$2->db_data;
	    break;
	  case 2:
	    cacheval = *(i2 *)$2->db_data;
	    break;
	  case 4:
	    cacheval = *(i4 *)$2->db_data;
	    break;
	}

	if (cacheval <= 0)
	{
	    /* Cache value must be positive integer constant. */
	    (void)psf_error(6316L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CACHE")-1, "CACHE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	psy_cb->psy_tuple.psy_sequence.dbs_cache = cacheval;
	psy_cb->psy_tuple.psy_sequence.dbs_flag |= DBS_CACHE;

    }
		|   CYCLE
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		*psy_cb;
	
	psy_cb = (PSY_CB *) cb->pss_object;

	if (psy_cb->psy_tuple.psy_sequence.dbs_flag & DBS_NOCYCLE)
	{
	    /* Inconsistent options - CYCLE and NOCYCLE. */
	    (void)psf_error(6317L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CYCLE/NOCYCLE")-1, "CYCLE/NOCYCLE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	psy_cb->psy_tuple.psy_sequence.dbs_flag |= DBS_CYCLE;
    }
		|   ORDER
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		*psy_cb;
	
	psy_cb = (PSY_CB *) cb->pss_object;

	if (psy_cb->psy_tuple.psy_sequence.dbs_flag & DBS_NOORDER)
	{
	    /* Inconsistent options - ORDER and NOORDER. */
	    (void)psf_error(6317L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("ORDER/NOORDER")-1, "ORDER/NOORDER");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	psy_cb->psy_tuple.psy_sequence.dbs_flag |= DBS_ORDER;
    }
		|   NOMAX
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		*psy_cb;
	
	psy_cb = (PSY_CB *) cb->pss_object;

	if (psy_cb->psy_tuple.psy_sequence.dbs_flag & DBS_MAXVAL)
	{
	    /* Inconsistent options - MAXVALUE and NOMAXVALUE. */
	    (void)psf_error(6317L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("MAXVALUE/NOMAXVALUE")-1, "MAXVALUE/NOMAXVALUE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	psy_cb->psy_tuple.psy_sequence.dbs_flag |= DBS_NOMAXVAL;
    }
		|   NOMIN
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		*psy_cb;
	
	psy_cb = (PSY_CB *) cb->pss_object;

	if (psy_cb->psy_tuple.psy_sequence.dbs_flag & DBS_MINVAL)
	{
	    /* Inconsistent options - MINVALUE and NOMINVALUE. */
	    (void)psf_error(6317L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("MINVALUE/NOMINVALUE")-1, "MINVALUE/NOMINVALUE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	psy_cb->psy_tuple.psy_sequence.dbs_flag |= DBS_NOMINVAL;
    }
		|   NOCACHE
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		*psy_cb;
	
	psy_cb = (PSY_CB *) cb->pss_object;

	if (psy_cb->psy_tuple.psy_sequence.dbs_flag & DBS_CACHE)
	{
	    /* Inconsistent options - CACHE and NOCACHE. */
	    (void)psf_error(6317L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CACHE/NOCACHE")-1, "CACHE/NOCACHE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	psy_cb->psy_tuple.psy_sequence.dbs_flag |= DBS_NOCACHE;
	psy_cb->psy_tuple.psy_sequence.dbs_cache = 0;
    }
		|   NOCYCLE
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		*psy_cb;
	
	psy_cb = (PSY_CB *) cb->pss_object;

	if (psy_cb->psy_tuple.psy_sequence.dbs_flag & DBS_CYCLE)
	{
	    /* Inconsistent options - CYCLE and NOCYCLE. */
	    (void)psf_error(6317L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("CYCLE/NOCYCLE")-1, "CYCLE/NOCYCLE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	psy_cb->psy_tuple.psy_sequence.dbs_flag |= DBS_NOCYCLE;
    }
		|   NOORDER
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		*psy_cb;
	
	psy_cb = (PSY_CB *) cb->pss_object;

	if (psy_cb->psy_tuple.psy_sequence.dbs_flag & DBS_ORDER)
	{
	    /* Inconsistent options - ORDER and NOORDER. */
	    (void)psf_error(6317L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("ORDER/NOORDER")-1, "ORDER/NOORDER");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	psy_cb->psy_tuple.psy_sequence.dbs_flag |= DBS_NOORDER;
    }
;

seq_type:	    tname
    {
	ADF_CB		*adf_scb = (ADF_CB*) cb->pss_adfcb;
	i4                err_code;
	DB_STATUS	status;
	
	status = adi_encode_colspec(adf_scb, $1, 0, NULL, 0, &$Ydb_pdata);
	if (status != E_DB_OK) 
	{
	    /* Bad datatype definition */
	    (VOID) psf_error(6323, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1, STtrmwhite($1), $1);
	    return (E_DB_ERROR);
	}

	$$ = &$Ydb_pdata;
    }
		|    tname LPAREN intconst_e seq_type_scale RPAREN
    {
	ADF_CB		*adf_scb = (ADF_CB*) cb->pss_adfcb;
	i4                err_code;
	DB_STATUS	status;
	i4		len = $3;

	status = adi_encode_colspec(adf_scb, $1, 1, &len, 0, &$Ydb_pdata);
	if (status != E_DB_OK) 
	{
	    /* Bad datatype definition */
	    (VOID) psf_error(6323, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1, STtrmwhite($1), $1);
	    return (E_DB_ERROR);
	}

	$$ = &$Ydb_pdata;
    }
;

/* Scale part must be zero, but allow create seq as dec (10,0) *sigh* */
seq_type_scale:	/* empty */
	|	COMMA intconst_e
    {
	if ($2 != 0)
	{
	    i4 err_code;
	    (VOID) psf_error(6318, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
    }
;

alter_sequence:	    alt_seq_kwd obj_spec seq_opt_list
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;
	DB_IISEQUENCE		oldseq;
	i4			seq_mask = 0;
	i4			gseq_flags;

	/* test event name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT($2->pss_orig_obj_name, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	/* If name was qualified, it'd better be the same as the user */
	if ($2->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp((PTR) &$2->pss_owner, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME)))
	{
	    (void)psf_error(E_PS0427_ALTOBJ_NOT_OBJ_OWNER, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof("ALTER SEQUENCE") - 1, "ALTER SEQUENCE",
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &$2->pss_owner),
		&$2->pss_owner);
	    return(E_DB_ERROR);
	}

        status = psy_ckdbpr(psq_cb, (u_i4)DBPR_SEQ_CREATE);
        if (status)
        {
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_ERROR	e_error;
		DB_STATUS	local_status;
		DB_NAME		seqname;
		/*
		** Audit failure to create sequence
		*/
		STmove($2->pss_orig_obj_name, ' ', 
		    sizeof(DB_NAME), seqname.db_name);
		local_status = psy_secaudit(FALSE, cb,
		    (char *)&seqname, &cb->pss_user,
		    sizeof(DB_TAB_NAME), SXF_E_PROCEDURE,
		    I_SX2046_SEQUENCE_ALTER, SXF_A_FAIL | SXF_A_ALTER,
		    &e_error);
	    }

            (void)psf_error(6321L, 0L, PSF_USERERR,
                                 &err_code, &psq_cb->psq_error, 0);
            return(status);
        }

	psy_cb = (PSY_CB *) cb->pss_object;

	seq_mask |= (($2->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    ? PSS_SEQ_BY_OWNER
	    : PSS_USRSEQ | PSS_DBASEQ | PSS_INGSEQ);

	STmove($2->pss_orig_obj_name, ' ', sizeof(DB_NAME),
	       (char *)&psy_cb->psy_tuple.psy_sequence.dbs_name);
	STmove((PTR)&cb->pss_user, ' ', sizeof(DB_OWN_NAME),
	       (char *)&psy_cb->psy_tuple.psy_sequence.dbs_owner);

	/* Find the old sequence first. */
	status = psy_gsequence(cb, &psy_cb->psy_tuple.psy_sequence.dbs_owner, 
		&psy_cb->psy_tuple.psy_sequence.dbs_name, seq_mask, NULL, &oldseq,
		&gseq_flags, (i4 *)NULL, psq_cb->psq_mode, FALSE, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
	else if (gseq_flags & (PSS_MISSING_SEQUENCE | PSS_INSUF_SEQ_PRIVS))
	{
	    /*
	    **    sequence does not exist
	    ** or the current user lacks a required privilege on it
	    */
	    return(E_DB_ERROR);
	}

	/* Then merge sequence tuples and perform validation. */
	status = psl_asequence(cb, &oldseq, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

    }
;

alt_seq_kwd:	    ALTSEQ
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_ASEQUENCE;

	/* "alter sequence" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (void)psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("ALTER SEQUENCE")-1, "ALTER SEQUENCE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the alter sequence statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set control block and tuple fields to defaults and initial values */
	psy_cb->psy_istree = FALSE;   		
	MEfill(sizeof(psy_cb->psy_tuple.psy_sequence), NULLCHAR,
	       (PTR)&psy_cb->psy_tuple.psy_sequence);
	psy_cb->psy_seqflag |= PSY_ASEQ;

    }
;
 
drop_sequence:	    drp_seq_kwd obj_spec drp_seq_behaviour
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;
	DB_IISEQUENCE		oldseq;
	i4			seq_mask = 0;
	i4			gseq_flags;

	/* test event name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT($2->pss_orig_obj_name, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	/* If name was qualified, it'd better be the same as the user */
	if ($2->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
	    MEcmp((PTR) &$2->pss_owner, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME)))
	{
	    (void)psf_error(E_PS0420_DROPOBJ_NOT_OBJ_OWNER, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof("DROP SEQUENCE") - 1, "DROP SEQUENCE",
		psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &$2->pss_owner),
		&$2->pss_owner);
	    return(E_DB_ERROR);
	}

        status = psy_ckdbpr(psq_cb, (u_i4)DBPR_SEQ_CREATE);
        if (status)
        {
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_ERROR	e_error;
		DB_STATUS	local_status;
		DB_NAME		seqname;
		STmove($2->pss_orig_obj_name, ' ', 
		    sizeof(DB_NAME), seqname.db_name);
		/*
		** Audit failure to drop sequence
		*/
		local_status = psy_secaudit(FALSE, cb,
		    (char *)&seqname, &cb->pss_user,
		    sizeof(DB_TAB_NAME), SXF_E_PROCEDURE,
		    I_SX2047_SEQUENCE_DROP, SXF_A_FAIL | SXF_A_DROP,
		    &e_error);
	    }

            (void)psf_error(6321L, 0L, PSF_USERERR,
                                 &err_code, &psq_cb->psq_error, 0);
            return(status);
        }

	psy_cb = (PSY_CB *) cb->pss_object;

	seq_mask |= (($2->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    ? PSS_SEQ_BY_OWNER
	    : PSS_USRSEQ | PSS_DBASEQ | PSS_INGSEQ);

	STmove($2->pss_orig_obj_name, ' ', sizeof(DB_NAME),
	       (char *)&psy_cb->psy_tuple.psy_sequence.dbs_name);
	STmove((PTR)&cb->pss_user, ' ', sizeof(DB_OWN_NAME),
	       (char *)&psy_cb->psy_tuple.psy_sequence.dbs_owner);

	/* Find the old sequence first. */
	status = psy_gsequence(cb, &psy_cb->psy_tuple.psy_sequence.dbs_owner, 
		&psy_cb->psy_tuple.psy_sequence.dbs_name, seq_mask, NULL, &oldseq,
		&gseq_flags, (i4 *)NULL, psq_cb->psq_mode, FALSE, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
	else if (gseq_flags & (PSS_MISSING_SEQUENCE | PSS_INSUF_SEQ_PRIVS))
	{
	    /*
	    **    sequence does not exist
	    ** or the current user lacks a required privilege on it
	    */
	    return(E_DB_ERROR);
	}
	STRUCT_ASSIGN_MACRO(oldseq.dbs_uniqueid, 
			psy_cb->psy_tuple.psy_sequence.dbs_uniqueid);
					/* copy internal ID */
    }
;

drp_seq_kwd:	    DROPSEQ
    {
	i4                err_code;
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_DSEQUENCE;

	/* "drop sequence" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (void)psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("DROP SEQUENCE")-1, "DROP SEQUENCE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the create group statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set control block and tuple fields to defaults and initial values */
	psy_cb->psy_istree = FALSE;   		
	MEfill(sizeof(psy_cb->psy_tuple.psy_sequence), NULLCHAR,
	       (PTR)&psy_cb->psy_tuple.psy_sequence);
	psy_cb->psy_seqflag |= PSY_DSEQ;

    }
;

drp_seq_behaviour:	/* empty */
	|	drop_behaviour	/* just syntax for now */
;

free_locator:	FREELOCATOR locator_list
    {
	i4	i;

	psq_cb->psq_mode = PSQ_FREELOCATOR;
	
	/* Set remaining locators to -1. */
	for (i = $Yloc_count; i < 10; i++)
	    psq_cb->psq_locator[i].db_datatype = DB_NODT;
    }
;

locator_list:	locator_elem
	|	locator_list COMMA locator_elem
;

locator_elem:	QDATA
    {

	if ($1->db_datatype != DB_LCLOC_TYPE && 
	    $1->db_datatype != DB_LNLOC_TYPE &&
	    $1->db_datatype != DB_LBLOC_TYPE)
	{
	    /* Bad data type for locator. */
	}

	STRUCT_ASSIGN_MACRO(*($1), psq_cb->psq_locator[$Yloc_count++]);

    }
;

insert:             insertkwd intname incolspec invalspec
    {
	PST_QNODE		*node;
	PST_QNODE		*qlend;
	PST_RT_NODE		root;
	PST_QTREE		*tree;
	i4			err_code;
	DB_STATUS		status;

	/* Check if column and value list are of the same length */
	for (node = $Yresdmhd; node->pst_sym.pst_type != PST_TREE;
	     node = node->pst_left
	    )
	{
	    /* NOTE: if $4 is NULL, this was "insert ... default values"
	    ** and there are no rhs' to the resdoms. */
	    if ($4 != NULL && node->pst_right == (PST_QNODE *) NULL)
	    {
		/* # of values does not match # of cols */
		(VOID) psf_error(2775L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	    }
	}

	if ($4 == NULL)
	    $4 = node;			/* address the PST_TREE */

	/* create QLEND node */

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		(PST_QNODE *) NULL, PST_QLEND, (PTR) NULL, 0, DB_NODT, (i2) 0,
		(i4) 0, (DB_ANYTYPE *) NULL, &qlend, &psq_cb->psq_error,
		(i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);	/* non-zero return means error */
	}

	root.pst_rtuser = TRUE;
	root.pst_union.pst_next  = 0;
	root.pst_dups   = PST_DNTCAREDUPS;
	root.pst_tvrc   = 0;
	MEfill(sizeof(PST_J_MASK), 0, (char *)&root.pst_tvrm);
	status = pst_node(cb, &cb->pss_ostream, $4, qlend, PST_ROOT, 
	        (PTR) &root, sizeof(root), DB_NODT, (i2) 0, (i4) 0,
		(DB_ANYTYPE *) NULL, &node, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);	/* non-zero return means error */
	}

	status = psl_do_insert(cb, psq_cb, node, &$Yqp_shareable, &tree,
	   $Yisdbp, $Yjoin_id, &$Yxlated_qry, &$Yshr_qryinfo);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	$$ = tree;
    }
	    |	    insertkwd intname incolspec query_expr
    {
	PST_QNODE		*node, *ssnode;
	PST_QTREE		*tree = 0;
	i4			err_code;
	DB_DT_ID		datatype, adatatype;
	DB_DT_ID		ssdatatype, assdtype;
	ADI_DT_BITMASK		typeset;
	DB_STATUS		status;

	/* restore mode that was changed for subselect processing */
	psq_cb->psq_mode = PSQ_APPEND;

	/*
	** First we have to determine whether number of resdoms 
	** and columns is equal.
	*/
	for (node = $3, ssnode = $4->pst_left;
	     (node->pst_sym.pst_type == PST_RESDOM &&
	      ssnode->pst_sym.pst_type == PST_RESDOM);
	     node = node->pst_left, ssnode = ssnode->pst_left)
	{
	    /* While we're here, check for illegal use of VLUPs. 
	    ** They're not allowed in the select list of the 
	    ** "insert ... select". This fixes a problem in which the
	    ** select had an aggregate, but it appears to work without
	    ** aggregates. So even though it's a bit sloppy, we only
	    ** exclude repeated insert ... select for aggregate selects. */
	    if (ssnode->pst_sym.pst_dataval.db_length == ADE_LEN_UNKNOWN
		&& cb->pss_stmt_flags & PSS_AGINTREE)
	    {
		/*
		** We are in the outermost subselect.
		** If db_length of PST_RESDOM node is ADE_LEN_UNKNOWN,
		** we must be dealing with illegal usage of VLUPs.
		*/
		(VOID) psf_error(2218L, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 0);
		return(E_DB_ERROR);
	    }
	}

	/*
	** Once we run out of RESDOMs, we'd better be looking at TREEs in both
	** lists
	*/
	if (node->pst_sym.pst_type != PST_TREE ||
	    ssnode->pst_sym.pst_type != PST_TREE)
	{
	    /* numbers of columns and resdoms are not equal */
	    (VOID) psf_error(2776L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** By now we know that we have equal number of RESDOMs in both lists,
	** and that both lists are terminated with PST_TREE
        */

	for (node = $3, ssnode = $4->pst_left;
	     node->pst_sym.pst_type != PST_TREE;
	     node = node->pst_left, ssnode = ssnode->pst_left)
	{
	    /* update RESDOM in subselect with info from 'incolspec' RESDOM. */

	    /* copy domain name */
	    MEcopy((char *) node->pst_sym.pst_value.pst_s_rsdm.pst_rsname,
		    sizeof(DB_ATT_NAME),
		    (char *) ssnode->pst_sym.pst_value.pst_s_rsdm.pst_rsname);

	    /* copy attribute number */
	    ssnode->pst_sym.pst_value.pst_s_rsdm.pst_rsno =
		node->pst_sym.pst_value.pst_s_rsdm.pst_rsno;

	    /* reinitialize target number (to be equal to resdom number). */
	    ssnode->pst_sym.pst_value.pst_s_rsdm.pst_ntargno =
		node->pst_sym.pst_value.pst_s_rsdm.pst_rsno;

	    /*
	    ** Fix datatype if necessary.
	    */
	    ssdatatype = ssnode->pst_sym.pst_dataval.db_datatype;
	    datatype = node->pst_sym.pst_dataval.db_datatype;
	    /*
	    ** We pretty much ignore nullability in the coercion business.
	    */
	    assdtype = abs(ssdatatype);
	    adatatype = abs(datatype);

        /*
        ** Fix for B64341 - if this is a prepare, we may not yet
        ** know the assdtype (it may be 0, indicating a '?' place
        ** marker. In this case, don't error, just allow the copy
        ** of the result colum to the resdom. (added assdtype != 0)
        */
		
	    if ((adatatype != assdtype) && (assdtype != 0))
	    {
		if ((status = adi_tycoerce((ADF_CB *)cb->pss_adfcb, 
					   assdtype, &typeset))
		    || !BTtest((i4) ADI_DT_MAP_MACRO(adatatype),
			    (char*) &typeset))
		{
		    /* error 2913 - incompatible type coercion */
		    ADI_DT_NAME	    right_name;
		    ADI_DT_NAME	    res_name;
	    
		    /* Get the names of the left & right operands, if any */
		    STmove("<none>", ' ', sizeof (ADI_DT_NAME),
					 (char *) &right_name);
		    STmove("<none>", ' ', sizeof (ADI_DT_NAME), 
					 (char *) &res_name);

		    status = adi_tyname((ADF_CB *)cb->pss_adfcb, 
					ssdatatype, &right_name);
		    status = adi_tyname((ADF_CB *)cb->pss_adfcb, 
					datatype, &res_name);

		    /* Now report the error */
		    (VOID) psf_error(2913, 0L, PSF_USERERR, &err_code,
				&psq_cb->psq_error, 3,
				sizeof(cb->pss_lineno), &cb->pss_lineno, 
				psf_trmwhite(sizeof(ADI_DT_NAME), 
				    (char *) &right_name), 
				&right_name, 
				psf_trmwhite(sizeof (ADI_DT_NAME), 
				    (char *) &res_name),
				&res_name);
		    return (E_DB_ERROR);
		}
	    }

	    /*
	    ** Fix a long-standing bug: RESDOM must contain attributes of the
	    ** result column, not of the target list element.
	    ** Bug 115638: only modify the resdom nodes if this is not a UNION
	    ** query
	    */
	    if ($4->pst_sym.pst_value.pst_s_root.pst_union.pst_next == NULL)
		STRUCT_ASSIGN_MACRO(node->pst_sym.pst_dataval,
					    ssnode->pst_sym.pst_dataval);
	}

	/*
	** Convert the root node of the subselect into the root node
	** for the query.
	*/
	$4->pst_sym.pst_type = PST_ROOT;
	$4->pst_sym.pst_value.pst_s_root.pst_rtuser = TRUE;

	status = psl_do_insert(cb, psq_cb, $4, &$Yqp_shareable, &tree, $Yisdbp,
			       $Yjoin_id, &$Yxlated_qry, &$Yshr_qryinfo);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
	if (tree)
	tree->pst_firstn = $Yfirst_n;
	if ($Yfirst_n > 0 && cb->pss_distrib & DB_3_DDB_SESS)
	{
	    /* No "select first n ..." allowed in Star queries. */
	    (VOID) psf_error(E_PS091F_STAR_NO_FIRSTN, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return(E_DB_ERROR);
	}

	$$ = tree;
    }
;

insertkwd:         INSERT INTO
    {
	DB_STATUS              status;

	psq_cb->psq_mode = PSQ_APPEND;
	if ($Yisdbp == FALSE)
	{
	    if ((status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
		&psq_cb->psq_error)) != E_DB_OK)
	    {
		return (status);	    /* non-zero return means error */
	    }
	}
	else
	{
	    /*
	    ** To indicate that in 'i= :i' in a subselect the first
	    ** "i" must not be processed as a local var (bug 8269).
	    */
	    $Ydbpinfo->pss_flags |= PSS_1SUB_SEEN;
	}
    }
;

intname:	    obj_spec
    {
	DB_STATUS           status;
	PSS_RNGTAB	    *resrange;
	i4		    rngvar_info;

	if ($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, "", &$1->pss_owner,
			&$1->pss_obj_name, cb, FALSE, &resrange,
			psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, -1, "", &$1->pss_obj_name, cb,
		FALSE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
		&rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    $1->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** In case of DB procedures table name needs to be qualified
	** by the owner name. 
	** But don't qualify name if it's a set-input parameter.
	*/
	if ($Yisdbp 
	    && (cb->pss_stmt_flags & PSS_TXTEMIT) 
	    && ~$1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
	    && (resrange->pss_rgtype != PST_SETINPUT))
	{
	    u_char 	    *owner;

	    if (rngvar_info & PSS_BY_SYNONYM)
	    {
		/*
		** special care must be exercised when dealing with synonyms:
		** if the object referenced by the user was a synonym, name of
		** its owner must be determined by consulting rngvar_info.
		*/
		if (rngvar_info & PSS_USR_OBJ)
		{
		    owner = (u_char *) &cb->pss_user;
		}
		else if (rngvar_info & PSS_DBA_OBJ)
		{
		    owner = (u_char *) &cb->pss_dba;
		}
		else if (rngvar_info & PSS_SYS_OBJ)
		{
		    owner = (u_char *) cb->pss_cat_owner;
		}
		else	    /* user name was explicitly specified */
		{
		    owner = (u_char *) &$1->pss_owner;
		}
	    }
	    else
	    {
		owner = (u_char *) &resrange->pss_ownname;
	    }

	    status = psl_prepend_schemaname(cb->pss_tchain, 
					    $1->pss_orig_obj_name, 
					    owner, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);

	}  /* end if ($Yisdbp && PSS_TXTEMIT) */

	cb->pss_resrng = resrange;
    }
;

incolspec:	    LPAREN incollist RPAREN
    {
	DB_STATUS           status;
	register PST_QNODE  *node;

	/* Find the leftmost node in the tree */
	for (node = $2; node->pst_left != (PST_QNODE *) NULL; )
	{
	    node = node->pst_left;
	}

	/* Allocate the PST_TREE node */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		(PST_QNODE *) NULL, PST_TREE, (PTR) NULL, 0, DB_NODT, (i2) 0,
		(i4) 0, (DB_ANYTYPE *) NULL, &node->pst_left,
		&psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = $Yresdmhd = $2;
    }
	    |
    {
	DMT_ATT_ENTRY	    **attribute;
	PST_QNODE	    *rsdmnode = (PST_QNODE *) NULL;
	DB_STATUS	    status;
	PSS_RNGTAB	    *rngtabp;
	i4		    i;
	register PST_QNODE  *node;

	rngtabp = (PSS_RNGTAB *) cb->pss_resrng;

	/* Start at first attribute */
	for (i = 0, attribute = rngtabp->pss_attdesc + 1;
	     i < rngtabp->pss_tabdesc->tbl_attr_count;
	     i++, attribute++)
	{
	    if ((*attribute)->att_flags & DMT_F_HIDDEN)
		continue;

	    /* Create the result domain node with null right child */
	    status = pst_adresdom((char *) &(*attribute)->att_name, rsdmnode,
		(PST_QNODE *) NULL, cb, psq_cb, &rsdmnode);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}

	$Yresdmhd = rsdmnode;

	/* Find the leftmost node in the tree */
	for (node = rsdmnode; node->pst_left != (PST_QNODE *) NULL; )
	{
	    node = node->pst_left;
	}

	/* Allocate the PST_TREE node */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_TREE, (PTR) NULL, 0, DB_NODT, (i2) 0,
	    (i4) 0, (DB_ANYTYPE *) NULL, &node->pst_left, &psq_cb->psq_error,
	    (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = rsdmnode;
    }
;

incollist:	    incol
    {
	$$ = $1;
    }
	    |	    incollist COMMA incol
    {
	PST_QNODE   *node;
	i4	    err_code;
	char	    *rsname;

	/* Check for duplicate names */
	rsname = $3->pst_sym.pst_value.pst_s_rsdm.pst_rsname;
	for (node = $1; node != (PST_QNODE *) NULL;
	     node = node->pst_left
	    )
	{
	    if (!MEcmp((char *) rsname,
		(char *) node->pst_sym.pst_value.pst_s_rsdm.pst_rsname,
		DB_MAXNAME)
	       )
	    {
		(VOID) psf_error(2774L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1,
		    psf_trmwhite(DB_MAXNAME, rsname), rsname);
		return (E_DB_ERROR);
	    }
	}

	/*
	** Attach bulk of target list to leftmost node of new element.
	*/
	$$ = pst_tlprpnd($1, $3);
    }
;

incol:		    col_spec
    {
	PSS_RNGTAB	       *rngtabp;
	DMT_ATT_ENTRY          *attribute;
	DB_ATT_NAME	       atname;
	i4		       err_code;
	DB_STATUS	       status;
	PST_QNODE	       *resdomnode;

	rngtabp = cb->pss_resrng;

	/* Normalize the attribute name */
	STmove($1, ' ', sizeof(DB_ATT_NAME), (char *) &atname);

	/* Look up the attribute */
	attribute = pst_coldesc(rngtabp, &atname);

	/* Check for attribute not found */
	if (attribute == (DMT_ATT_ENTRY *) NULL)
	{
	    (VOID) psf_error(2100L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 4,
		(i4) sizeof(cb->pss_lineno), &cb->pss_lineno, 
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &rngtabp->pss_tabname),
		&rngtabp->pss_tabname,
		psf_trmwhite(sizeof(DB_OWN_NAME), 
		    (char *) &rngtabp->pss_ownname),
		&rngtabp->pss_ownname,
		(i4) STtrmwhite($1), $1);
	    return (E_DB_ERROR);
	}
		
	status = pst_adresdom((char *) &atname, (PST_QNODE *) NULL, 
	    (PST_QNODE *) NULL, cb, psq_cb, &resdomnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$$ = resdomnode;
    }
;

invalspec:	DEFAULT VALUES
    {
	$$ = NULL;		/* no RESDOM structure - all defaults */
    }
	|	values LPAREN invallist RPAREN
    {
	$$ = $Yresdmhd;
    }
;

values:		    VALUES
    {
	$Yaggr_allowed &= ~(PSS_AGG_ALLOWED | PSS_STMT_AGG_ALLOWED);
	$Ycheck_for_vlups = FALSE;
    }
;

invallist:	    invallst
    {
	/* This is not necessary, but for the sake of completeness. */
	$Yaggr_allowed |= (PSS_AGG_ALLOWED | PSS_STMT_AGG_ALLOWED);
    }
;

invallst:	    inexpr
	    |	    invallst COMMA inexpr
;

inexpr:		    select_expr
    {
	DB_STATUS	status;
	PST_QNODE	*node;
	bool		found;
	DB_DT_ID	datatype, adatatype;
	DB_DT_ID	db_right, adb_right;
	ADI_DT_BITMASK	typeset;
	i4		err_code;

	/*
	** Check whether it is a constant or expression thereof.
	** No VAR nodes must be present.
	*/
	status = chkcnst($1);
	if (status != E_DB_OK)
	{   /* not a constant expression */
	    (VOID) psf_error(2778L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** Walk down the RESDOM tree to find the last node
	** that has a null right node.
	*/
	node = $Yresdmhd;
	found = FALSE;
	for ( ; node->pst_sym.pst_type != PST_TREE; node = node->pst_left)
	{
	    if (((node->pst_left->pst_sym.pst_type == PST_TREE) ||
		 (node->pst_left->pst_right != (PST_QNODE *)NULL))
		&& (node->pst_right == (PST_QNODE *)NULL)	    )
	    {
		found = TRUE;
		break;
	    }
	}

	if (found == FALSE)
	{
	    /* # of values does not match # of cols */
	    i4	errcode = 2775;

	    if (psq_cb->psq_mode == PSQ_RETROW)
		errcode = 2446;
	    (VOID) psf_error(errcode, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* attach the 'select_expr' subtree to the found RESDOM node */
	node->pst_right = $1;

	/*
	** Fix datatype if necessary.
	** (this code comes from pst_node procedure)
	*/
	/* Skip type checking if preparing a dynamic SQL with parm nodes */

	if ((cb->pss_defqry != PSQ_PREPARE) || (cb->pss_highparm == -1))
	{
	    db_right = $1->pst_sym.pst_dataval.db_datatype;
	    datatype = node->pst_sym.pst_dataval.db_datatype;
	    /*
	    ** We pretty much ignore nullability in the coercion business.
	    */
	    adb_right = abs(db_right);
	    adatatype = abs(datatype);
	    if (adatatype != adb_right)
	    {
		/* Check coercibility - pst_convlit() tries to convert
		** between string & numeric literals so user can be sloppy. */
		if ((status = adi_tycoerce((ADF_CB *)cb->pss_adfcb, 
					   adb_right, &typeset)
		    || !BTtest((i4) ADI_DT_MAP_MACRO(adatatype), (char*) &typeset))
		    && !pst_convlit(cb, &cb->pss_ostream, 
				&node->pst_sym.pst_dataval, $1))
		{
		    /* error 2913 - incompatible type coercion */
		    ADI_DT_NAME	    right_name;
		    ADI_DT_NAME	    res_name;
		
		    /* Get the names of the left & right operands, if any */
		    STmove("<none>", ' ', sizeof (ADI_DT_NAME),
			 (char *) &right_name);
		    STmove("<none>", ' ', sizeof (ADI_DT_NAME), 
			(char *) &res_name);

		    status = adi_tyname((ADF_CB *)cb->pss_adfcb, 
					db_right, &right_name);
		    status = adi_tyname((ADF_CB *)cb->pss_adfcb, 
					datatype, &res_name);

		    /* Now report the error */
		    (VOID) psf_error(2913, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 3, 
			sizeof(cb->pss_lineno),&cb->pss_lineno, 
			psf_trmwhite(sizeof(ADI_DT_NAME), (char *) &right_name),
			&right_name,
			psf_trmwhite(sizeof(ADI_DT_NAME), (char *) &res_name), 
			&res_name);
		    return (E_DB_ERROR);
		}
	    }
	}
    }
	    |	    NULLWORD
    {
	DB_STATUS	status;
	PST_QNODE	*node, *newnode;
	PST_CNST_NODE	pst_cnst_node;
	DB_DT_ID	datatype;
	bool		found;
	i2		dataprec;
	i4		datalen;
	i4		err_code;
	/*
	** Walk down the RESDOM tree to find the last node
	** that has a null right node.
	*/
	node = $Yresdmhd;
	found = FALSE;
	for ( ; node->pst_sym.pst_type != PST_TREE; node = node->pst_left)
	{
	    if (((node->pst_left->pst_sym.pst_type == PST_TREE) ||
		 (node->pst_left->pst_right != (PST_QNODE *)NULL))
		&& (node->pst_right == (PST_QNODE *)NULL)	    )
	    {
		found = TRUE;
		break;
	    }
	}

	if (found == FALSE)
	{
	    /* # of values does not match # of cols */
	    (VOID) psf_error(2775L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	dataprec = node->pst_sym.pst_dataval.db_prec;
	datalen = node->pst_sym.pst_dataval.db_length;
	datatype = node->pst_sym.pst_dataval.db_datatype;
	if (datatype > 0)
	{
	    /* nonnullable data type */
	    (VOID) psf_error(2777L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(DB_MAXNAME,
		    node->pst_sym.pst_value.pst_s_rsdm.pst_rsname),
		node->pst_sym.pst_value.pst_s_rsdm.pst_rsname);
	    return (E_DB_ERROR);
	}

        if (abs(datatype) == DB_VCH_TYPE)
        {
        datalen = sizeof(DB_VCH_TYPE)+1;
        }
	/* following added for b67293 070395 newca01 as a test !!!   */
	if ((cb->pss_distrib & DB_3_DDB_SESS) && 
	    (abs(datatype) == DB_LVCH_TYPE)) 
	{ 
	  	datatype = - DB_VCH_TYPE; 
		datalen = 23;
	}
	/*
	** Create a constant node for the NULL value.
	*/
	pst_cnst_node.pst_tparmtype = PST_USER;
	pst_cnst_node.pst_parm_no = 0;
	pst_cnst_node.pst_pmspec = PST_PMNOTUSED;
	pst_cnst_node.pst_cqlang = DB_SQL;
	pst_cnst_node.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &pst_cnst_node,
	    sizeof (PST_CNST_NODE), datatype, dataprec, datalen,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}
	/* Allocate space and set to 0's. */
	status = psf_malloc(cb, &cb->pss_ostream, datalen,
		(PTR *) &newnode->pst_sym.pst_dataval.db_data, 
		&psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}
	MEfill(datalen, 0, (PTR)newnode->pst_sym.pst_dataval.db_data);

	status = adc_getempty ((ADF_CB *)cb->pss_adfcb, 
			       &newnode->pst_sym.pst_dataval);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/* attach the newnode to the found RESDOM node */
	newnode->pst_sym.pst_len += datalen;	/* add NULL const to length */
	node->pst_right = newnode;
    }
	    |	    DEFAULT
    {
	DB_STATUS	status;
	PST_QNODE	*node, *prevnode;
	bool		found;
	i4		err_code;
	/*
	** Walk down the RESDOM tree to find the last node
	** that has a null right node.
	*/
	node = $Yresdmhd;
	found = FALSE;
	for (prevnode = NULL; node->pst_sym.pst_type != PST_TREE; 
				prevnode = node, node = node->pst_left)
	{
	    if (((node->pst_left->pst_sym.pst_type == PST_TREE) ||
		 (node->pst_left->pst_right != (PST_QNODE *)NULL))
		&& (node->pst_right == (PST_QNODE *)NULL)	    )
	    {
		found = TRUE;
		break;
	    }
	}

	if (found == FALSE)
	{
	    /* # of values does not match # of cols */
	    (VOID) psf_error(2775L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* Just drop the corresponding resdom node. */
	if (prevnode == NULL)
	    $Yresdmhd = node->pst_left;
	else prevnode->pst_left = node->pst_left;
    }
;

modify:		modstmnt modtable modnoise modstorage modkeys mod_with_or_where
    {
	DB_STATUS		    status;

	status = psl_md1_modify(cb, yyvarsp, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

modstmnt:          MODIFY
    {
	DB_STATUS		status;

	status = psl_md2_modstmnt(cb, psq_cb, yyvarsp);

	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* In case we have modify pmast PARTITION ... */
	cb->pss_yacc->yy_partalt_kwds = TRUE;
    }
;

/* production continues after initial action... */
modtable:	    obj_spec
    {
	DB_STATUS		status;

	status = psl_md8_modtable(cb, $1, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
		modpartition
;

/* Thanks to the TO being optional (!!! ??? !!!), partition has to be
** a keyword or we can't figure it out.  So we'll parse the start of
** this under the alternate-keywords aegis.  ("TO" is a keyword in the
** alternate set, of course, or this wouldn't work out.)
*/
modpartition:	/* nothing */
    {
	cb->pss_yacc->yy_partalt_kwds = FALSE;
    }
	|	PARTITION logpartlist
    {
	DB_STATUS	status;

	cb->pss_yacc->yy_partalt_kwds = FALSE;
	status = psl_md_modpart(cb, psq_cb, yyvarsp);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
;

logpartlist:	logpartname
	|	logpartlist PERIOD logpartname
;

logpartname:	generic_ident
    {
	DB_STATUS	status;

	status = psl_md_logpartname(cb, psq_cb, yyvarsp, $1);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
;

/* Why the devil is this optional?  Not that I am quite brave enough
** to change it... (schka24).
*/
modnoise:	TO
    |
;

modstorage:         modstorname
          |	    modstorname UNIQUE modscope
    {
	DB_STATUS		status;

	status = psl_md3_modstorage(cb,
				    yyvarsp, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

modscope:	/* Nuffin' */
	|	nonkeyword EQUAL twith_nkw_kwd
    {
	DB_STATUS		status;

	/* ****FIXME what about unique_scope = row? !!! */
	if (STcompare($1, "unique_scope") || 
		(STcompare($3, "statement") && (STcompare($3, "row"))))
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}
	status = psl_md4_modstorname(cb, "unique_scope", yyvarsp, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

modstorname:	    nonkeyword
    {
	DB_STATUS		status;

	status = psl_md4_modstorname(cb, $1, yyvarsp, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	RELOCATE
    {
	DB_STATUS		status;

	status = psl_md4_modstorname(cb, "relocate", yyvarsp, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	nonkeyword EQUAL twith_nkw_kwd
    {
	DB_STATUS		status;

	/* ****FIXME what about unique_scope = row? !!! */
	if (STcompare($1, "unique_scope") || 
		(STcompare($3, "statement") && (STcompare($3, "row"))))
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}
	status = psl_md4_modstorname(cb, "unique_scope", yyvarsp, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	twith_num	
;

modkeys:           ON modrptkey
	  |
    {
	DB_STATUS		status;

	status = psl_md5_modkeys(cb, yyvarsp, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

modrptkey:          modbasekey
          |	    modrptkey COMMA modbasekey
;

modbasekey:         modkeyname
          |	    modkeyname m_asc_desc
    {
	DB_STATUS		    status;

	status = psl_md6_modbasekey(cb, (i4) ($2 == PSS_ASCENDING),
	    $Yis_heapsort, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

m_asc_desc:	    ASC
    {
	$$ = PSS_ASCENDING;
    }
	    |	    nonkeyword
    {
	if (STcompare($1, "desc"))
	{
	    i4	    err_code;

	    /*
	    ** NOTE: this production is curently used only by MODIFY.
	    ** Should you change it, make sure that the correct message gets
	    ** displayed.
	    ** (andre 4/26/90)
	    */
	    (VOID) psf_error(2511L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, STlength($1), $1);
	    return (E_DB_ERROR);
	}

	$$ = PSS_DESCENDING;
    }
;

modkeyname:	    col_spec
    {
	DB_STATUS		status;

	status = psl_md7_modkeyname(cb, $1, yyvarsp, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

/* MODIFY needs a separate WITH-clause introducer, because it also allows
** the (obsolete?  deprecated) form WHERE clause...
*/
mod_with_or_where:	WITH tblwithlist
		|	WHERE tblwithlist
		|
;

prepare:	prepare_kwrd generic_ident FROM prepare_stmt_list
    {
	DB_STATUS   status;

	/* Extract information from PSQ_CB and PSS_SESBLK.
	** Save it in the prototype header */

	status = pst_prepare(psq_cb, cb, $2, $Ynonupdt, $Yupdcollst);
	psq_cb->psq_mode = PSQ_PREPARE;

	if (status != E_DB_OK)
    	    return(status);
    }
	 |	
		prepare_kwrd generic_ident INTO NAME using_names 
    					   FROM prepare_stmt_list
    {
	DB_STATUS   status;

	/* Extract information from PSQ_CB and PSS_SESBLK.
	** Save it in the prototype header */

	status = pst_prepare(psq_cb, cb, $2, $Ynonupdt, $Yupdcollst);
	psq_cb->psq_mode = PSQ_INPREPARE;

	if (status != E_DB_OK)
	    return (status);

	/* Return query descriptor in SQLDA */

	if ((status = pst_describe(psq_cb, cb, $2)) != E_DB_OK)
	    return (status);
    }
;


prepare_kwrd:	PREPARE
    {
	/* Indicate processing a PREPARE statement */

	cb->pss_defqry = PSQ_PREPARE;
    }
;

prepare_stmt_list:  alter_role
	  |	    alter_group
	  |	    alter_user
	  |	    alter_location
	  |	    alter_table
	  |	    alter_profile
	  |	    comment
	  |	    commit
	  |	    copy
	  |	    create_event	/* PREPARE CREATE DBEVENT */
	  |	    create_role
	  |	    create_group
	  |	    create_integrity
	  |	    create_permit
	  |	    create_rule
	  |	    create_table
	  |	    create_location
	  |	    create_view
	  |	    create_index
	  |	    create_secalm
	  |	    create_profile
	  |	    create_synonym
	  |	    delete
	  |	    dgtt_stmt
	  |	    drop_event		/* PREPARE DROP DBEVENT */
	  |	    drop_role
	  |	    drop_group
	  |	    drop_tvis
	  |	    drop_schema
	  |	    dropinteg
	  |	    dropperm
	  |	    drop_rule
	  |	    drop_user
	  |	    drop_location
	  |	    drop_profile
	  |	    drop_secalm
	  |	    disable_secaud
	  |	    enable_secaud
	  |	    alter_secaud
	  |	    grant
          |	    insert
          |	    modify
	  |	    query
	  |         reg_gateway_idx
	  |         reg_gateway_tab
	  |	    relocate
	  |	    revoke
	  |	    rollback
	  |	    register_event	/* PREPARE REGISTER DBEVENT */
	  |	    remove_event	/* PREPARE REMOVE DBEVENT */
	  |	    raise_event		/* PREPARE RAISE DBEVENT */
	  |	    save
	  |	    savepoint
	  |	    set_sess_auth_id
	  |	    update
;

execute:	    exe_stmnt using_list
    {
	i4	    i, err_code;
	DB_STATUS   status;
	PST_QTREE   *tree = (PST_QTREE *) NULL;
	PST_RNGENTRY	*rtptr;

	if ($1 != (PST_PROCEDURE *) NULL)
	{
	    if (psq_cb->psq_mode == PSQ_VIEW)
	    {
		/*
		** view tree for CREATE VIEW statement is found in
		** PST_CREATE_VIEW.pst_view_tree
		*/
		tree =
		    $1->pst_stmts->pst_specific.pst_create_view.pst_view_tree;
	    }
	    else
	    {
		tree = $1->pst_stmts->pst_specific.pst_tree;
	    }
	}

	if ($2 == FALSE)
	{
	    if ($Ydsql_maxparm >= 0)
	    {	/* error if no parms */
		(VOID) psf_error(2300L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1,
		    sizeof(cb->pss_lineno), &cb->pss_lineno);
		return (E_DB_ERROR);
	    }
	}
	else
	{
	    if (cb->pss_highparm != $Ydsql_maxparm)
	    {	/* error if not enough parms */
		(VOID) psf_error(2301L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1,
		    sizeof(cb->pss_lineno), &cb->pss_lineno);
		return (E_DB_ERROR);
	    }
	    /*
	    ** If there is a tree, start from the right child of the root node,
	    ** substitute all constant nodes with values from user's parameter
	    ** list.
	    */

	    if (tree != (PST_QTREE *) NULL)
	    {
		/* Must also loop over range table, looking for derived tables 
		** or common query expressions that may also contain dynamic 
		** parameters. */
		for (i = 0; i < tree->pst_rngvar_count; i++)
		{
		    rtptr = tree->pst_rangetab[i];
		    if (rtptr && (rtptr->pst_rgtype == PST_DRTREE ||
			rtptr->pst_rgtype == PST_WETREE))
		    {
			status = pst_prmsub(psq_cb, cb, rtptr->pst_rgroot, 
							$Ydsql_plist);
			if (DB_FAILURE_MACRO(status))
			    return(status);
		    }
		}

		status = pst_prmsub(psq_cb, cb, tree->pst_qtree,
		    $Ydsql_plist);
		if (DB_FAILURE_MACRO(status))
		    return (status);
	    }
	    else if (psq_cb->psq_mode == PSQ_SET_SESS_AUTH_ID)
	    {
		DB_TEXT_STRING  *str;
		u_i4		len, save_len, id_len = DB_MAXNAME;
		i4		leading_blanks;
		char		*c;
		DB_DT_ID	totype;
		
		/*
		** if the prepared statement was SET SESSION AUTHORIZATION, we
		** need to store the supplied value in PSQ_CB
		*/

		/*
		** if the input datatype was nullable, so must be the output
		** datatype
		*/

		totype = ((*$Ydsql_plist)->db_datatype < 0) ? -DB_LTXT_TYPE
							    : DB_LTXT_TYPE;
							   
		status = qdata_cvt(cb, psq_cb, *$Ydsql_plist, totype,
		    (PTR *) &str);
		if (DB_FAILURE_MACRO(status))
		{
		    return(status);
		}

		/*
		** according to SQL92, we need to strip off leading and trailing
		** blanks from the contents of the string constant and only then
		** may we verify that the remainder represents a valid
		** identifier
		*/

		c = (char *) str->db_t_text;

		len = psf_trmwhite((u_i4) str->db_t_count, c);

		for (leading_blanks = 0;
		     CMspace(c);
		     leading_blanks++, CMnext(c))
		;

		/*
		** we are saving length of the string to be passed to
		** cui_idxlate() so that we can ensure that the entire string
		** was "consumed" by it
		*/
		save_len = len -= leading_blanks;

		status = cui_idxlate((u_char *) c, &len,
		    (u_char *) &psq_cb->psq_user, &id_len,
		    (u_i4) *cb->pss_dbxlate,
		    (u_i4 *) NULL, &psq_cb->psq_error);

		if (save_len != len || DB_FAILURE_MACRO(status))
		{
		    psf_error(E_PS0359_NOT_A_VALID_AUTH_ID, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 1,
			(i4) save_len, (PTR) c);

		    return(E_DB_ERROR);
		}

		/* fill the rest of psq_cb->psq_user with blanks */
		if (id_len < DB_MAXNAME)
		{
		    MEfill(DB_MAXNAME - id_len, (u_char) ' ',
			(PTR) ((char *) &psq_cb->psq_user + id_len));
		}
	    }
	}

	/* At this point we are done with parm substitution, if any.
	** If there is a query tree, indicate this in the header.
	*/
	if (tree != (PST_QTREE *) NULL)
	{
	    tree->pst_numparm = 0;
	}
    }
;

exe_stmnt:	    EXECUTE generic_ident
    {
	PST_PROCEDURE   *pnode;
	DB_STATUS	status;

	psq_cb->psq_mode = PSQ_EXECQRY;

	status = pst_execute(psq_cb, cb, $2, &pnode, &$Ydsql_maxparm,
	    (PTR *) &$Ydsql_plist, &$Ynonupdt, &$Yupdcollst);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$$ = pnode;
    }
;

describe:	    DESCRIBE generic_ident using_names
    {
	DB_STATUS   status;

	psq_cb->psq_mode = PSQ_DESCRIBE;
	if ((status = pst_describe(psq_cb, cb, $2)) != E_DB_OK)
	    return (status);
    }
;

using_names:	    USING nonkeyword
    {
	i4	    err_code;

	if (STcompare($2, "names") != 0)
	{
	    (VOID) psf_error(2303L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, STtrmwhite($2), $2);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    }
	|
    {
    }
;


describe_input:	DESCINPUT generic_ident
    {
	DB_STATUS   status;

	psq_cb->psq_mode = PSQ_DESCINPUT;
	if ((status = pst_descinput(psq_cb, cb, $2)) != E_DB_OK)
	    return (status);
    }
;


query:		query_with query_expr query_clause query_hint_with
    /* If (when) the SQL standard "with" clause is supported in Ingres,
    ** the above rule will become: query_with query_expr query_clause and 
    ** the $1 and $2 variables will become $2 and $3, respectively. */
    {
	DB_STATUS	    status;
	PST_QTREE	    *tree;
	i4		    updtmode;
	i4		    err_code;
	PST_PROCEDURE	    *pnode;
	PST_QNODE	    *res, *ss, *s1;

	/* For the database procedure case */
	if ($Yisdbp == TRUE)
	{
	    /* Reset some flags */
	    $Ydbpinfo->pss_flags &= ~PSS_1SUB_SEEN; /*
						    ** Haven't seen the first
						    ** query term yet
						    */
	    $Ydbpinfo->pss_flags &= ~PSS_LVAR_SEEN; /* No local vars seen yet */

	    /* Now that we have processed the query_clause let's update
	    ** the target list if INTO clause present.
	    */
	    if ($Ydbpinfo->pss_into_clause != (PST_QNODE *) NULL)
	    {
		$2->pst_left = $Ydbpinfo->pss_into_clause;
		$Ydbpinfo->pss_into_clause = (PST_QNODE *) NULL;
	    }

	    /* Ensure that builtins are WRITE PROTECTED;
	    ** they are READONLY by definition.
	    ** (builtins in question are iirowcount and iierrornumber) 
	    */
	    for (res = $2->pst_left;
		 res->pst_sym.pst_type == PST_RESDOM;
		 res = res->pst_left
		)
	    {
		    i4	    tno;

		    tno =  res->pst_sym.pst_value.pst_s_rsdm.pst_ntargno;
		    if ((tno == PST_RCNT || tno == PST_ERNO) &&
			res->pst_sym.pst_value.pst_s_rsdm.pst_rsflags&PST_RS_PRINT)
		    {
			(VOID) psf_error(2434L, 0L, PSF_USERERR,
			    &err_code, &psq_cb->psq_error, 1,
			    sizeof(cb->pss_lineno), &cb->pss_lineno);
			return (E_DB_ERROR);
		    }
	    }

	    /* Make sure that all UNIONed subselects have target lists
	    ** refer to same local vars and in the same sequence as the
	    ** first subselect.
	    */
	    for (ss = $2->pst_sym.pst_value.pst_s_root.pst_union.pst_next; ss; 
		    ss = ss->pst_sym.pst_value.pst_s_root.pst_union.pst_next)
	    {	    
		for (res = ss->pst_left, s1 = $2->pst_left;
		     res->pst_sym.pst_type == PST_RESDOM;
		     res = res->pst_left, s1 = s1->pst_left
		    )
		{
		    res->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype =
			s1->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype;
		    res->pst_sym.pst_value.pst_s_rsdm.pst_ntargno =
			s1->pst_sym.pst_value.pst_s_rsdm.pst_ntargno;
		}
	    }

	    /* Finally, to assure UNION selects in procedures compile 
	    ** to proper RESDOM lists, resolve 'em all. */
	    if ($2->pst_sym.pst_value.pst_s_root.pst_union.pst_next
				!= (PST_QNODE *) NULL)
	    {
		status = pst_union_resolve(cb, $2, &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return(status);
	    }
	}

	/* 
	** All root nodes in the tree will have set the `pst_rtuser' flag to
	** FALSE to indicate that they are not the ROOT of the tree. Now is the
	** time to mark the topmost ROOT node. In any case (unions included)
	** there will be one and only one such root node per tree.
	*/
	$2->pst_sym.pst_value.pst_s_root.pst_rtuser = TRUE;

	if ($3 != 0)
	{
	    /* no sortlist was provided */
	    $Ysort_list = (PST_QNODE *) NULL;
	}

	/*
	** Store the FOR clause info.
	*/
	if ($3 == 1)
	{
	    updtmode = PST_DEFER;
	}
	else if ($3 == 2)
	{
	    updtmode = PST_DIRECT;
	}
	else
	{
	    updtmode = PST_READONLY;
	}

	/*
	** Initialize result variable info in the session control block
	** for open cursor statement and prepare statement. The idea is
	** to identify range variables defined at the outermost scope
	** (qualdepth == 1). To a certain extent we follow algorithm
	** used in the `order_column' production.
	*/
	if (psq_cb->psq_mode == PSQ_DEFCURS || cb->pss_defqry == PSQ_PREPARE)
	{
	    i4		    scope = MAXI1 + 1;
	    PSS_RNGTAB	    *rngvar;
	    i4		    i;
	    bool	    found = FALSE;

	    /* Check each variable */
	    for (i = 0; i < PST_NUMVARS; i++)
	    {
		rngvar = &cb->pss_auxrng.pss_rngtab[i];
		/* skip unused entries */
		if (!rngvar->pss_used || rngvar->pss_rgno < 0)
		    continue;
		/* must be at our scope */
		if (rngvar->pss_rgparent == scope)
		{
		    found = TRUE;
		    break;
		}
	    }

	    if (found)
	    {
		cb->pss_resrng = rngvar;

		/*
		** if the user has not specified FOR UPDATE or ORDER BY, at this
		** point we do not know the mode for the query: if the <query
		** expression> is updatable and its underlying table is also
		** updatable, then it will be DIRECT or DEFERRED UPDATE;
		** otherwise, it will be left marked READONLY.
		** 
		** If a user has specified FOR UPDATE without specifying <column
		** name list>, we will know the mode of the query but the list
		** of columns will still be empty.
		** 
		** In both cases if the query itself appears updatable, we will
		** build a RESDOM list representing all attributes of the table
		** or view
		*/
		if (   (   $3 == -1	    /* empty clause */
					    /* or FOR UPDATE w/o <col list> */
			|| cb->pss_stmt_flags & PSS_IMPL_COL_LIST_IN_DECL_CURS)
		    && !$Ynonupdt   /* query looks updatable so far */
		   )
		{
		    PST_RSDM_NODE       resdom;
		    DMT_ATT_ENTRY      **attribute;

		    /*
		    ** if FOR UPDATE has not been specified, reset updtmode to
		    ** PST_UNSPECIFIED.  This will serve as an indicator that a
		    ** user may be allowed to UPDATE through the cursor
		    ** provifing the cursor's underlying table is updatable
		    */
		    if ($3 == -1)
		    {
			updtmode = PST_UNSPECIFIED;
		    }

		    /* Start at first attribute */
		    for (i = 0, attribute = rngvar->pss_attdesc + 1;
			 i < rngvar->pss_tabdesc->tbl_attr_count;
			 i++, attribute++)
		    {
			if ((*attribute)->att_flags & DMT_F_HIDDEN)
			    continue;

			MEcopy((PTR) (*attribute)->att_name.db_att_name,
			    DB_MAXNAME,
			    (PTR) resdom.pst_rsname);

			resdom.pst_rsno = (i4) 1;
			resdom.pst_ntargno = (i4) 0;
			resdom.pst_ttargtype = (i4) PST_USER;
			resdom.pst_rsupdt = (i4) FALSE;
			resdom.pst_rsflags = PST_RS_PRINT;
	                resdom.pst_dmuflags = 0;
			status = pst_node(cb, &cb->pss_ostream, $Yupdcollst,
			    (PST_QNODE *) NULL, PST_RESDOM, (char *) &resdom,
			    sizeof(PST_RSDM_NODE), DB_NODT, (i2) 0, (i4) 0,
			    (DB_ANYTYPE *) NULL, &$Yupdcollst,
			    &psq_cb->psq_error, (i4) 0);
			if (status != E_DB_OK)
			{
			    return (status);
			}
		    }
		}
	    }

	    if ($Yupdcollst != (PST_QNODE *) NULL)
	    {
		/* FOR UPDATE clause must have been specified.
		** We need to validate column names. We will also
		** generate VAR nodes and connect them to resdom nodes.
		** This mini target-list will be connected to the main one
		** so that qrymod executed from within cursor_open tells us
		** what attribute numbers in the underlying base relation(s)
		** these update columns map to; we need these att. nos.
		** for proper initialization of psc_iupdmap and consequently
		** pst_updmap in the tree header passed to OPF.
		*/
		DMT_ATT_ENTRY	*coldesc;
		PST_QNODE	*rsdm, *newnode;
		char		*name;
		DB_DATA_VALUE	*dv;
		PST_VAR_NODE	varnode;

		for (rsdm = $Yupdcollst;
		     rsdm && rsdm->pst_sym.pst_type == PST_RESDOM;
		     rsdm = rsdm->pst_left
		    )
		{
		    name = rsdm->pst_sym.pst_value.pst_s_rsdm.pst_rsname;

		    /* Get the column description */
		    coldesc = pst_coldesc(cb->pss_resrng, 
			(DB_ATT_NAME *) name);

		    if (coldesc == (DMT_ATT_ENTRY *) NULL)
		    {
			(VOID) psf_error(2102L, 0L, PSF_USERERR, &err_code,
			    &psq_cb->psq_error, 2,
			    (i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
			    (i4) psf_trmwhite(DB_MAXNAME, name), name);
			return (E_DB_ERROR);
		    }

		    dv = &rsdm->pst_sym.pst_dataval;

		    dv->db_data =   (PTR) NULL;
		    dv->db_length = coldesc->att_width;
		    dv->db_datatype = coldesc->att_type;
		    dv->db_prec = coldesc->att_prec;
		    dv->db_collID = coldesc->att_collID;

		    /* Set up var node. */
		    varnode.pst_vno = cb->pss_resrng->pss_rgno;
		    varnode.pst_atno.db_att_id = coldesc->att_number;

		    /* Create the node */
		    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			(PST_QNODE *) NULL, PST_VAR, (char *) &varnode,
			sizeof(varnode), (DB_DT_ID) coldesc->att_type,
			(i2) coldesc->att_prec, (i4) coldesc->att_width,
			(DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error,
			(i4) 0);
		    if (DB_FAILURE_MACRO(status))
			return (status);

		    rsdm->pst_right = newnode;
		    newnode->pst_sym.pst_dataval.db_collID = dv->db_collID;
		}
	    }
	}

	/* For repeat queries we must determine if the query is shareable.
	** We already know that this is an SQL query, so the only criterion
	** to be checked out is whether all relations/views are DBA owned or
	** are catalogs.
	*/
	if (cb->pss_defqry == PSQ_DEFQRY || cb->pss_defqry == PSQ_DEFCURS)
	{
	    status = psl_shareable(psq_cb, cb, &$Yqp_shareable, &$Yshr_qryinfo);
	    if (status != E_DB_OK)
		return (status);
	}

	/*
	** Apply the qrymod algorithm (views, permits, and integrities).
	** If this is an OPEN CURSOR statement we cannot run querymod yet,
	** even though we know what columns have been spec'd in FOR UPDATE
	** clause, if any, because FOR READONLY may have been spec'd and we
	** have not seen it yet. Same applies to PREPARE case. Execution
	** of qrymod at this steg may result in erronous behaviour of psyview
	** because cb->pss_resrng has been defined.
	*/
	if (psq_cb->psq_mode != PSQ_DEFCURS && cb->pss_defqry != PSQ_PREPARE)
	{
	    i4	    qrymod_resp_mask;

	    status = psy_qrymod($2, cb, psq_cb, &$Yjoin_id, &qrymod_resp_mask);
	    if (status != E_DB_OK)
		return (status);
	}

	/*
	** In case of FOR UPDATE clause  we need to check whether the stmnt
	** is updateble. However, for cursors this check is not performed here
	** because FOR READONLY may have been spec'd and we have not seen it
	** yet. Same applies to PREPARE SELECT statements.
	*/
	if (psq_cb->psq_mode != PSQ_DEFCURS && updtmode != PST_READONLY &&
	    cb->pss_defqry != PSQ_PREPARE)
	{
	    /*
	    ** Make sure the query has only one range variable at the outermost
	    ** scope. The idea is to identify range variables defined at the
	    ** outermost scope (qualdepth == 1). To a certain extent we follow
	    ** algorithm used in the `order_column' production.
	    */
	    i4		    scope = MAXI1 + 1;
	    PSS_RNGTAB	    *rngvar;
	    i4		    i, varcount = 0;

	    /* Check each variable */
	    for (i = 0, rngvar = cb->pss_auxrng.pss_rngtab;
		 i < PST_NUMVARS;
		 i++, rngvar++)
	    {
		
		if (rngvar->pss_used &&	    /* skip unused entries */
		    rngvar->pss_rgno >= 0 
		    &&
		    rngvar->pss_rgparent == scope   /* must be at our scope */
		   )
		{
		    if (++varcount > 1)
		    {
			/* this SELECT is non-updatable */
			(VOID) psf_error(2925L, 0L, PSF_USERERR,
			    &err_code, &psq_cb->psq_error, 0);
			return (E_DB_ERROR);
		    }
		}
	    }
	}

        /* Make and fill in the query tree header */
	status = pst_header(cb, psq_cb, updtmode, $Ysort_list, $2,
	    &tree, &pnode, ($Yisdbp) ? 0 : PST_0FULL_HEADER, &$Yxlated_qry);
    	if (status != E_DB_OK)
        {
	    return (status);
        }

	/* set pst_numjoins.  $Yjoin_id contains the highest join id */
	tree->pst_numjoins = $Yjoin_id;
	/* Fill in "first n" value. */
	tree->pst_firstn = $Yfirst_n;
	if ($Yfirst_n > 0 && cb->pss_distrib & DB_3_DDB_SESS)
	{
	    /* No "select first n ..." allowed in Star queries. */
	    (VOID) psf_error(E_PS091F_STAR_NO_FIRSTN, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return(E_DB_ERROR);
	}

	/* Make sure the statement header gets updated later for cursor.*/
	if (psq_cb->psq_mode != PSQ_DEFCURS && cb->pss_defqry != PSQ_PREPARE)
	{
	    psq_cb->psq_pnode = (PTR) NULL;
	}
	else
	    psq_cb->psq_pnode = (PTR) pnode;

	/* Fix the root in QSF */
	if (pnode != (PST_PROCEDURE *) NULL)
	{
	    status = psf_mroot(cb, &cb->pss_ostream, (PTR) pnode, &psq_cb->psq_error);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }
	}

        $$ = tree;
    }
;

/* The following rules aren't currently reduced because the SQL standard 
** "WITH" clause isn't yet supported. This isn't to be copnfused with the
** WITH clause that adds hints to a query. */
query_with:	/* nuttin' here */
	|	WITH query_with_list
;

query_with_list:	with_list_element
	|	query_with_list COMMA with_list_element
;

with_list_element:	tbl_spec dcollist AS LPAREN
    {
	DB_STATUS	status;

	$Ysave_pss_rsdmno = cb->pss_rsdmno;
	status = psl_push_yyvars(psq_cb, cb, yyvarspp);
	if (DB_FAILURE_MACRO(status))
		return(status);
	yyvarsp = *yyvarspp;
    }
		query_expr RPAREN
    {
	PST_J_MASK	*mask;
	DB_STATUS	status;
	PSS_RNGTAB	*resrange;

	/* Add with list element to range table. Note scope is 
	** pss_qualdepth+1, because the "subselect" production decrements
	** it before we can add with list element to the range table. */
	status = psl_drngent(&cb->pss_auxrng, cb->pss_qualdepth+1,
		$1, cb, &resrange, $6, PST_WETREE, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return (status);

	cb->pss_ses_flag |= PSS_WITHELEM_INQ;	/* note WITH clause in qry */

	/* And now restore the outer yyvarsp, since recursion is done. 
	**
	** This is done ahead of the dcol_list analysis, since the dcol_list
	** (if any) was built before we pushed the previous YYVARS ptr. */
	
	$Yprev_yyvarsp->join_id = $Yjoin_id;	/* join_id persists */

	if ($Ynonupdt)
	{
	    /* Propagate non-updateability to containing query. */
	    $Yprev_yyvarsp->nonupdt = TRUE;
	    $Yprev_yyvarsp->nonupdt_reason |= $Ynonupdt_reason;
	}

	yyvarsp = *yyvarspp = $Yprev_yyvarsp;
	cb->pss_rsdmno = $Ysave_pss_rsdmno;	/* restore */

	/* If there was an override column list, check here that the 
	** count is right, and replace the column names. */
	if ($Ydcol_list.queue.q_next != (QUEUE *)&$Ydcol_list)
	{
	    PSY_COL	*psy_col;
	    i4		i, err_code;

	    for (i = 1, psy_col = (PSY_COL *)$Ydcol_list.queue.q_prev;
		i <= resrange->pss_tabdesc->tbl_attr_count && 
				psy_col != (PSY_COL *)&$Ydcol_list;
		i++, psy_col = (PSY_COL *)psy_col->queue.q_prev)
	    {
		MEcopy((char *)psy_col->psy_colnm.db_att_name, 
		    sizeof(DB_ATT_NAME), 
		    (char *)resrange->pss_attdesc[i]->att_name.db_att_name);
	    }

	    if (resrange->pss_tabdesc->tbl_attr_count >= i ||
		psy_col != (PSY_COL *)&$Ydcol_list)
	    {
		/* Count of override column names is incorrect - error. */
		(VOID) psf_error(2157L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2,
		    sizeof(cb->pss_lineno), &cb->pss_lineno,
		    sizeof(DB_TAB_NAME),
		    resrange->pss_rgname);
		return (E_DB_ERROR);
	    }
	}

	/*
	** Correlation name was explicitly specified, set a bit in
	** resrange->pss_var_mask
	*/
	resrange->pss_var_mask |= PSS_EXPLICIT_CORR_NAME;

	BTset(resrange->pss_rgno, (char*) &$Yflists[cb->pss_qualdepth]);

        if (cb->pss_qualdepth == 1)
        {
            if (BTcount((char *)&$Yflists[cb->pss_qualdepth], PST_NUMVARS) > 1)
            {
                /*
                ** FROM-list in the outermost subselect involves more than one
                ** relation - query will not be updateable
                */
                $Ynonupdt = TRUE;
                $Ynonupdt_reason |= PSS_MULT_VAR_IN_OUTERMOST_SUBSEL;
            }
            else if (psq_cb->psq_mode == PSQ_VIEW && !$Ynonupdt)
            {
                /*
                ** remember address of the range variable representing the new
                ** view's simply underlying table
                */
                $Yunderlying_rel = resrange;
            }
        }

	/*
	** save the address for future dereferencing.  Now, given range number,
	** I will get the pointer to a range variable without having to scan the
	** entire table
	*/
	$Yrng_vars[resrange->pss_rgno] = resrange;

	/*
	** productions such as integtbl may need to know thr value of
	** rngvar_info
	*/
	$Yrngvar_info = PSS_USR_OBJ;
	
	/* Allocate PST_J_MASK to define this table to rest of parse. */
        status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_J_MASK),
	         (PTR *) &mask, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}
	MEfill(sizeof(PST_J_MASK), '\0', (PTR)mask);
	BTset(resrange->pss_rgno, (char *) mask);

	/*
	** we keep track of the tables in the FROM list to make sure that there
	** are no correlated queries appearing in the join_search condition of
	** the FROM list which involve tables from the same FROM list
	*/
	BTor(PST_NUMVARS, (char *)mask, (char *)&$Yjoin_tbls);
    }
;

query_clause:	    order_clause
    {
	$$ = 0;
    }
	    |	    /* empty */
    {
	/*
	** Indicate lack of sortlist or FOR UPDATE clause
	*/
	$$ = -1;
    }
	    |	    cur_updmode UPDATE OF newcollist
    {
	/* updcollst point to the root of RESDOM tree with
	** names of columns named in the FOR UPDATE clause.
	*/
	$Yupdcollst = $4;

	/* FOR UPDATE + SCROLL = KEYSET */
	if (cb->pss_stmt_flags & PSS_SCROLL)
	{
	    if ($1 == 1)
	    {
		i4	err_code;
		/* Explicitly declared DEFERRED KEYSET cur not supported. */
		(VOID) psf_error(2230L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1,
		    sizeof(cb->pss_lineno), &cb->pss_lineno);
		return (E_DB_ERROR);
	    }

	    cb->pss_stmt_flags |= PSS_KEYSET;
	    $$ = 2;			/* KEYSET ==> DIRECT */
	}
	else $$ = $1;
    }
	    |	    cur_updmode UPDATE
    {
	/* FOR UPDATE + SCROLL = KEYSET */
	if (cb->pss_stmt_flags & PSS_SCROLL)
	{
	    if ($1 == 1)
	    {
		i4	err_code;
		/* Explicitly declared DEFERRED KEYSET cur not supported. */
		(VOID) psf_error(2230L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1,
		    sizeof(cb->pss_lineno), &cb->pss_lineno);
		return (E_DB_ERROR);
	    }

	    cb->pss_stmt_flags |= PSS_KEYSET;
	    $$ = 2;			/* KEYSET ==> DIRECT */
	}
	else $$ = $1;

	/*
	** remember that FOR [DIRECT|DEFERRED] UPDATE without <column name list>
	** has been specified.
	*/

	cb->pss_stmt_flags |= PSS_IMPL_COL_LIST_IN_DECL_CURS;
	$Yupdcollst = (PST_QNODE *) NULL;

    }
;

cur_updmode:	    DEFERUPD
    {
	$$ = 1;
    }
	    |	    DIRECTUPD
    {
	$$ = 2;
    }
	    |	    FOR
    {
	extern PSF_SERVBLK	*Psf_srvblk;
	
	/*
	** Ordinarilym DEFERRED UPDATE  is the default.  However, at server
	** startup we could be told that the default mode of an updatable cursor
	** is DIRECT, in which case we must act as if DIRECT was specified
	*/
	$$ = (Psf_srvblk->psf_flags & PSF_DEFAULT_DIRECT_CURSOR) ? 2 : 1;

	if (cb->pss_stmt_flags & PSS_SCROLL)
	    $$ = 2;			/* scrollable trumps deferred */
    }
;

order_clause:	    ORDER BY
    {
	/* Same trick is used as with group by to save range table scope
	** around order by analysis. */
	$Yordby_qd = cb->pss_qualdepth;
	cb->pss_qualdepth += (MAXI1 + 1);
	$Yin_orderby = TRUE;
	psq_cb->psq_ret_flag |= PSQ_PARSING_ORDER_BY;	/* needed for FIRST */
    }
	order_item_list
    {
	/*
	** Mark this SELECT stmnt as non-updatable
	** Note that ORDER BY can only occur in the outermost SUBSELECT, if at
	** all.
	*/
	$Ynonupdt = TRUE;
	$Ynonupdt_reason |= PSS_ORDER_BY_IN_OUTERMOST_SUBSEL;
	$Yin_orderby = FALSE;
	psq_cb->psq_ret_flag &= ~PSQ_PARSING_ORDER_BY;	/* needed for FIRST */
	cb->pss_qualdepth = $Yordby_qd;
    }
;

query_hint_with:	/* Nothing or ... */
	|	WITH query_hint_list
;

query_hint_list:	query_hint_element
	|	query_hint_list COMMA query_hint_element
;

query_hint_element:	nonkeyword
    {
	i4	err_code;
	bool	conflict = FALSE;

	if (STcompare($1, "flatten") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_NOFLATTEN)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_FLATTEN;
	}
	else if (STcompare($1, "noflatten") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_FLATTEN)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_NOFLATTEN;
	}
	else if (STcompare($1, "ojflatten") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_NOOJFLATTEN)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_OJFLATTEN;
	}
	else if (STcompare($1, "noojflatten") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_OJFLATTEN)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_NOOJFLATTEN;
	}
	else if (STcompare($1, "greedy") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_NOGREEDY)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_GREEDY;
	}
	else if (STcompare($1, "nogreedy") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_GREEDY)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_NOGREEDY;
	}
	else if (STcompare($1, "hash") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_NOHASH)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_HASH;
	}
	else if (STcompare($1, "nohash") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_HASH)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_NOHASH;
	}
	else if (STcompare($1, "keyj") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_NOKEYJ)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_KEYJ;
	}
	else if (STcompare($1, "nokeyj") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_KEYJ)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_NOKEYJ;
	}
	else if (STcompare($1, "parallel") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_NOPARALLEL)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_PARALLEL;
	}
	else if (STcompare($1, "noparallel") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_PARALLEL)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_NOPARALLEL;
	}
	else if (STcompare($1, "qep") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_NOQEP)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_QEP;
	}
	else if (STcompare($1, "noqep") == 0)
	{
	    if (cb->pss_hint_mask & PST_HINT_QEP)
		conflict = TRUE;
	    else cb->pss_hint_mask |= PST_HINT_NOQEP;
	}
	else
	{
	    (VOID) psf_error(5989L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		sizeof(cb->pss_lineno), &cb->pss_lineno);
	    return (E_DB_ERROR);
	}

	if (conflict)
	{
	    (VOID) psf_error(5990L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		sizeof(cb->pss_lineno), &cb->pss_lineno);
	    return (E_DB_ERROR);
	}
    }
/* This rule is cut short to disable hints in 2006u1. A dummy rule is
   inserted to soak up remaining alternatives. */
;
hintdummy:	ORDER
    {
	/* Forces the FROM clause order on the join tree. */
	cb->pss_hint_mask |= PST_HINT_ORDER;
    }
    |
	|	INDEX LPAREN generic_ident COMMA generic_ident RPAREN
    {
	PSS_HINTENT	*hintp;

	/* Forces the use of a specific index to access a base table. */
	if (cb->pss_hintcount < PST_NUMVARS)
	{
	    hintp = &cb->pss_tabhint[cb->pss_hintcount++];
	    hintp->pss_hintcode = PST_THINT_INDEX;
	    STmove($3, ' ', sizeof(DB_TAB_NAME), 
				(char *)&hintp->pss_tabname1.db_tab_name);
	    STmove($5, ' ', sizeof(DB_TAB_NAME), 
				(char *)&hintp->pss_tabname2.db_tab_name);
	}
    }
	|	nonkeyword LPAREN generic_ident COMMA generic_ident RPAREN
    {
	PSS_HINTENT	*hintp;

	/* Forces specific join techniques on a pair of tables. Address
	** next hint table entry, copy the table names and look for the 
	** keyword. */
	if (cb->pss_hintcount < PST_NUMVARS)
	{
	    hintp = &cb->pss_tabhint[cb->pss_hintcount++];
	    STmove($3, ' ', sizeof(DB_TAB_NAME), 
				(char *)&hintp->pss_tabname1.db_tab_name);
	    STmove($5, ' ', sizeof(DB_TAB_NAME), 
				(char *)&hintp->pss_tabname2.db_tab_name);
	    if (STcompare($1, "fsmj") == 0)
		hintp->pss_hintcode = PST_THINT_FSMJ;
	    else if (STcompare($1, "hashj") == 0)
		hintp->pss_hintcode = PST_THINT_HASHJ;
	    else if (STcompare($1, "keyj") == 0)
		hintp->pss_hintcode = PST_THINT_KEYJ;
	    else if (STcompare($1, "psmj") == 0)
		hintp->pss_hintcode = PST_THINT_PSMJ;
	    else cb->pss_hintcount--;
	}
    }
;

query_expr:	    query_expr_1
    {
	PST_QNODE   *ss, *res, *thead;
	i4	    err_code;
	bool	    first = TRUE;

	/* Update target list in the session ctrl block for
	** ORDER BY clause processing.
	*/
	cb->pss_tlist = $1->pst_left;

	/* If in DB procedure, check all target lists to make sure that
	** the leftmost query term references only local vars and
	** target lists of other terms do not reference local vars.
	** If the INTO clause has been used, for the first subselect
	** check the target list corresponding to the clause rather
	** than the target list.
	*/
	if ($Yisdbp == TRUE)
	{
	    /* For every query term */
	    for (ss = $1; ss != (PST_QNODE *) NULL;
		 ss = ss->pst_sym.pst_value.pst_s_root.pst_union.pst_next
		)
	    {
		thead = ss->pst_left;

		if (first && $Ydbpinfo->pss_into_clause != (PST_QNODE *) NULL)
		{
		    thead = $Ydbpinfo->pss_into_clause;
		}

		/* Check the target list */
		for (res = thead;
		     res != (PST_QNODE *) NULL;
		     res = res->pst_left)
		{
		    /* See if end of the target list. */
		    if (res->pst_sym.pst_type == PST_TREE)
			break;

		    if (first && 
			res->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype
			    != PST_LOCALVARNO &&
			!(cb->pss_stmt_flags & PSS_PARSING_INSERT_SUBSEL)
		       )
		    {
			/* Illegal resdom found */
			(VOID) psf_error(2412L, 0L, PSF_USERERR,
			    &err_code, &psq_cb->psq_error, 2,
			    sizeof(cb->pss_lineno), &cb->pss_lineno,
			    psf_trmwhite(DB_MAXNAME,
				res->pst_sym.pst_value.pst_s_rsdm.pst_rsname),
			    res->pst_sym.pst_value.pst_s_rsdm.pst_rsname);
			return (E_DB_ERROR);
		    }

		    if (!first &&
			res->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype
			    == PST_LOCALVARNO
			)
		    {
			/* Illegal resdom found */
			(VOID) psf_error(2430L, 0L, PSF_USERERR,
			    &err_code, &psq_cb->psq_error, 2,
			    sizeof(cb->pss_lineno), &cb->pss_lineno,
			    psf_trmwhite(DB_MAXNAME,
				res->pst_sym.pst_value.pst_s_rsdm.pst_rsname),
			    res->pst_sym.pst_value.pst_s_rsdm.pst_rsname);
			return (E_DB_ERROR);
		    }
		}

		if (first)
		{
		    first = FALSE;
		}
	    }
	}
    }
;
    
query_expr_1:	    query_term
    {
	/* For the INTO clause processing remember
	** that we have already seen the first subselect.
	*/
	if ($Yisdbp == TRUE)
	{
	    $Ydbpinfo->pss_flags |= PSS_1SUB_SEEN;
	}

	$$ = $1;
    }
	|	    query_expr_1 union query_term
    {
	DB_STATUS	status;
	PST_QNODE	*ss;
	i4		err_code;

	if ($Yseq_ops)
	{
	    /* No use of sequences in union selects. */
	    (void)psf_error(6319L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/*
	** We will allow mixing of UNION and UNION ALL in a query expression.
	** UNION found in an expresion will result in duplicates being
	** eliminated in all terms of the expression, evenm if the user
	** specified UNION ALL in some of query terms comprising the expression
	*/

	/*
	** Find last subselect node in the union linked list.
	** If UNION was specified, we need to change PST_ALLDUPS to PST_NODUPS
	** in all elements of the union list
	*/
	if ($2 == PST_NODUPS)
	{
	    for (ss = $1;
		 ss->pst_sym.pst_value.pst_s_root.pst_union.pst_next;
		 ss = ss->pst_sym.pst_value.pst_s_root.pst_union.pst_next
		)
	    {
		ss->pst_sym.pst_value.pst_s_root.pst_union.pst_dups =
		    PST_NODUPS;
	    }
	}
	else
	{
	    for (ss = $1;
		 ss->pst_sym.pst_value.pst_s_root.pst_union.pst_next;
		 ss = ss->pst_sym.pst_value.pst_s_root.pst_union.pst_next
		)
	    ;
	}

	ss->pst_sym.pst_value.pst_s_root.pst_union.pst_next = $3;
	ss->pst_sym.pst_value.pst_s_root.pst_union.pst_dups = $2;

	/*
	** If UNION was specified, we need to change PST_ALLDUPS to PST_NODUPS
	** in all elements of the list being appended to the union list;
	** remember, that we do not set pst_dups in the last element of the list
	*/
	if ($2 == PST_NODUPS)
	{
	    for (ss = $3;
		 ss->pst_sym.pst_value.pst_s_root.pst_union.pst_next;
		 ss = ss->pst_sym.pst_value.pst_s_root.pst_union.pst_next
		)
	    {
		ss->pst_sym.pst_value.pst_s_root.pst_union.pst_dups =
		    PST_NODUPS;
	    }
	}

	/* Only try to resolve the union if we have not seen any parameters. */
	if (cb->pss_highparm == -1 || cb->pss_defqry != PSQ_PREPARE)
	{
	    status = pst_union_resolve(cb, $1, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}

	$$ = $1;
    }
;

query_term:	    subselect
    {
	register PST_QNODE  *t;
	i4		    err_code;

	/* check for illegal use of VLUPs */
	if ($Ycheck_for_vlups)
	{
	    for (t = $1->pst_left;
	         (t != (PST_QNODE *) NULL && t->pst_sym.pst_type == PST_RESDOM);
		 t = t->pst_left)
	    {
		if (t->pst_sym.pst_dataval.db_length == ADE_LEN_UNKNOWN)
		{
		    /*
		    ** We are in the outermost subselect.
		    ** If db_length of PST_RESDOM node is ADE_LEN_UNKNOWN,
		    ** we must be dealing with illegal usage of VLUPs.
		    */
		    (VOID) psf_error(2218L, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 0);
		    return(E_DB_ERROR);
		}
	    }
	}

	$1->pst_sym.pst_type = PST_ROOT;
	$$ = $1;
    }
	    |	    LPAREN query_expr_1 RPAREN
    {
	$$ = $2;
    }
;

union:	    UNION union_opt
    {
        /* Mark this SELECT stmnt as non-updatable */
        if (cb->pss_qualdepth == 0 ||
		cb->pss_qualdepth == 1 && $Yprev_yyvarsp)
        {
            $Ynonupdt = TRUE;
            $Ynonupdt_reason |= PSS_UNION_IN_OUTERMOST_SUBSEL;
        }

	$$ = $2;
    }
;

union_opt:	/* Nuffin */
    {
	$$ = PST_NODUPS;
    }
	|    DISTINCT
    {
	$$ = PST_NODUPS;
    }
	|    ALL
    {
	$$ = PST_ALLDUPS;
    }
;

subselect:	    select first_n distinct target_spec into_clause from
    {
	PST_SYMBOL	    *sym;
	PST_QNODE	    *rsdm;
	i4		    tuple_width = 0;
	bool		    check_num_attrs;
	bool		    check_tuple_width;
	DB_STATUS	    status;
	i4		    err_code;

	/*
	** if we are processing the outermost subselect of SELECT, 
	** CREATE TABLE AS SELECT, CREATE VIEW, or DGTT AS SELECT, we need to
	** verify that the width of the tuple represented by the target list
	** does not exceed DB_MAXTUP.  For TABLE AS SELECT, CREATE VIEW, or 
	** DGTT AS SELECT we also need to verify that the number of attributes 
	** does not exceed DB_MAX_COLS
	*/
	if (   cb->pss_qualdepth == 1
	    && (   psq_cb->psq_mode == PSQ_RETRIEVE
		   /* 
		   ** for CREATE TABLE/DGTT AS SELECT, query mode gets reset to
		   ** PSQ_RETINTO/PSQ_DGTT_AS_SELECT AFTER we are done 
		   ** processing the <query_expr>
		   */
		|| psq_cb->psq_mode == PSQ_CREATE 
		|| psq_cb->psq_mode == PSQ_DGTT
		|| psq_cb->psq_mode == PSQ_VIEW
	       )
	    && !(cb->pss_stmt_flags & PSS_PARSING_INSERT_SUBSEL)
	   )
	{
	    check_tuple_width = TRUE;

	    check_num_attrs = (psq_cb->psq_mode != PSQ_RETRIEVE);
	}
	else
	{
	    check_tuple_width = check_num_attrs = FALSE;
	}

	if ($Yseq_ops && $3)
	{
	    /* No use of sequences in distinct selects. */
	    (void)psf_error(6319L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* If "first n" was specified, assure that this is the outermost
	** select, both subselect-wise and union-wise, and that we're not
	** creating a view. 
	*/
	if (cb->pss_qualdepth == 1 && 
		!($Ynonupdt_reason & PSS_UNION_IN_OUTERMOST_SUBSEL)) 
	    $Yfirst_n = $2;

	/*
	** Now that we are done parsing the from list, complete building the
	** tree representing the target list
	*/

	sym = &$4->pst_right->pst_sym;	/* symbol for RESDOM's right child */

	{
	    status = psl_p_tlist(&$4, yyvarsp, cb, psq_cb);
	    if (DB_FAILURE_MACRO(status))
	    {
		return(status);
	    }

	    if (check_tuple_width)
	    {
		/*
		** walk down the RESDOM nodes representing elements of the 
		** target spec and compute the width of the tuple represented 
		** by the target spec if we need to verify that the width of 
		** the tuple is within valid limits
		*/
	        for (rsdm = $4; 
	             (rsdm && rsdm->pst_sym.pst_type != PST_TREE);
	             tuple_width += rsdm->pst_sym.pst_dataval.db_length,
	             rsdm = rsdm->pst_left)
	        ;
	    }
	}

	if (check_num_attrs && cb->pss_rsdmno > DB_MAX_COLS)
	{
	    char	command[PSL_MAX_COMM_STRING];
	    i4 	len;
	    i4		max_cols = DB_MAX_COLS;

	    psl_command_string(psq_cb->psq_mode, cb->pss_lang, command, &len);

	    (VOID) psf_error(E_PS0BE0_TOO_MANY_COLS, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 3,
		len, (PTR) command,
		(i4) sizeof(cb->pss_rsdmno), (PTR) &cb->pss_rsdmno,
		(i4) sizeof(max_cols), (PTR) &max_cols);
	    return(E_DB_ERROR);
	}

	/*
	** We donot need to check the tuple_width here.
	** Leave it for opf, qef and dmf to decide.
	** This change is required for supporting increasing tuple size.
	*/
	/*
	if (check_tuple_width && tuple_width > DB_MAXTUP)
	{
	    char	command[PSL_MAX_COMM_STRING];
	    i4 	len;
	    i4		max_width = DB_MAXTUP;

	    psl_command_string(psq_cb->psq_mode, cb->pss_lang, command, &len);

	    (VOID) psf_error(E_PS0BE1_TUPLE_TOO_WIDE, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 3,
		len, (PTR) command,
		(i4) sizeof(tuple_width), (PTR) &tuple_width,
		(i4) sizeof(max_width), (PTR) &max_width);
	    return(E_DB_ERROR);
	}
	*/
	if (status = pst_trfix(cb, &cb->pss_ostream, $4, &psq_cb->psq_error))
	{
	    return (status);
	}

    }
		    where groupby having 
    {
	DB_STATUS	    status;
	PST_QNODE	    *rootnode;
	PST_QNODE	    *nodeptr;
	PST_QNODE	    *resdomnode;
	PST_QNODE	    *wherenode;
	PST_QNODE	    *byhead;
	PST_QNODE	    *bylist;
	PST_QNODE	    *agopnode;
	PST_QNODE	    *treenode;
	PST_QNODE	    *qual;
	PST_RT_NODE	    root;
	i4		    err_code;
	char		    emptycol[DB_MAXNAME];
	char		    colname[DB_MAXNAME + 2];
	i4		    tcount, hcount;
	YYAGG_NODE_PTR	    *agg_node,
			    *cur_agg_list =
				$Yagg_list_stack[cb->pss_qualdepth];
	bool		    empty_gb = TRUE;

	/* Process the INTO clause if present. */
	if ($5 != (PST_QNODE *) NULL)
	{
	    register PST_QNODE	*t, *h;

	    /* First we will verify whether number of resdoms is identical.
	    ** Both trees are PST_TREE terminated.
	    */
	    for (t = $4, tcount = 0; t != (PST_QNODE *) NULL; t = t->pst_left)
	    {
		if (t->pst_sym.pst_type == PST_RESDOM)
		{
		    tcount++;
		}
	    }

	    for (h = $5, hcount = 0; h != (PST_QNODE *) NULL; h = h->pst_left)
	    {
		if (h->pst_sym.pst_type == PST_RESDOM)
		{
		    hcount++;
		}
	    }

	    if (tcount != hcount)
	    {	/* not equal number of nodes */
		(VOID) psf_error(2427L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	    }

	    /* Real processing for the node pairs.
	    ** Since both lists are of equal length, the for loop can be 
	    ** terminated when the end of any of the two lists is found.
	    */
	    for (t = $4, h= $5;
		 t != (PST_QNODE *) NULL;
		 t = t->pst_left, h = h->pst_left
		)
	    {
		if (t->pst_sym.pst_type == PST_RESDOM &&
		    h->pst_sym.pst_type == PST_RESDOM
		   )
		{
		    /* Process the pair */

		    /* `Move' pst_right trees to the local var resdom
		    ** tree.
		    */
		    h->pst_right = t->pst_right;

		    /* Patch resdom no. */
		    h->pst_sym.pst_value.pst_s_rsdm.pst_rsno =
			t->pst_sym.pst_value.pst_s_rsdm.pst_rsno;

		    /* Resolve data types for local vars. */
		    status = pst_parm_resolve(cb, psq_cb, h);
		    if (DB_FAILURE_MACRO(status))
			return(status);
		}
	    }

	    /* Remember the ptr to the true target list, do not update
	    ** the tree yet as we have to process the ORDER BY clause first.
	    */
	    $Ydbpinfo->pss_into_clause = $5;
	}

	/*
	** Make sure that all resdoms have a name.
	*/
	(VOID) MEfill(DB_MAXNAME, ' ', (PTR) emptycol);

	for (resdomnode = $4;
	     (resdomnode != (PST_QNODE *) NULL) &&
	     (resdomnode->pst_sym.pst_type != PST_TREE);
	     resdomnode = resdomnode->pst_left
	    )
	{
	    if(MEcmp((PTR)(resdomnode->pst_sym.pst_value.pst_s_rsdm.pst_rsname),
		(PTR) emptycol, DB_MAXNAME) == 0)
	    {
		STprintf(colname, "col%d",
		    resdomnode->pst_sym.pst_value.pst_s_rsdm.pst_rsno);
		MEmove(STlength(colname), (PTR)colname, ' ',
		    DB_MAXNAME,
		    (PTR) resdomnode->pst_sym.pst_value.pst_s_rsdm.pst_rsname); 
	    }
	}

	/* other semantic checking. */

	/* Search group list for ordinals (like order by). Corresponding 
	** expressions must then be copied to group list. */
	if ($9)
	{
	    PST_QNODE	*gptr;
	    i4		dt_status;

	    status = E_DB_OK;

	    if (!((gptr = $9)->pst_sym.pst_type == PST_GCL &&
		gptr->pst_right == (PST_QNODE *) NULL &&
		(gptr->pst_left == (PST_QNODE *) NULL ||
		    gptr->pst_left->pst_sym.pst_type == PST_TREE)))
		empty_gb = FALSE;

	    if (!empty_gb)
	     for (gptr = $9; gptr && gptr->pst_sym.pst_type == PST_RESDOM;
						gptr = gptr->pst_left)
	    {
		if (gptr->pst_right->pst_sym.pst_type == PST_CONST)
		{
		    status = psl_ordGroup(cb, psq_cb, gptr, $4);
		    if (status != E_DB_OK)
		    {
                        if ( psq_cb->psq_error.err_code !=
                                   E_PS03AB_AGGR_IN_GROUP_BY )
                        {
                            (VOID) psf_error(2932L, 0L, PSF_USERERR, &err_code,
                                   &psq_cb->psq_error, 1, (i4)sizeof(cb->pss_lineno),
                                   &cb->pss_lineno);
                        }
                        else
                        {
                            /* b109012 */
                            (VOID) psf_error(E_PS03AB_AGGR_IN_GROUP_BY, 0L, PSF_USERERR,
                                   &err_code, &psq_cb->psq_error, 0);
                        }
                        return (E_DB_ERROR);

		    }
		}

		/* Then, assure groupby elements are groupable types. */
		status = adi_dtinfo((ADF_CB *)cb->pss_adfcb, 
		    gptr->pst_sym.pst_dataval.db_datatype,
		    &dt_status);
		if (status != E_DB_OK) return(status);
		if (dt_status & AD_NOSORT)
		{
		    char	name[33];
		    i4		err_code;
		    /* Copy column name (if any) and issue message. */
		    name[0] = name[32] = 0x0;
		    if (gptr->pst_right->pst_sym.pst_type == PST_VAR)
	        	MEcopy((PTR)&gptr->pst_right->pst_sym.pst_value.
			    pst_s_var.pst_atname,
	                    DB_MAXNAME, (PTR)&name);
	            (VOID) psf_error(2181L, 0L, PSF_USERERR, &err_code,
	                &psq_cb->psq_error, 1,(i4) STtrmwhite(name), name);
	            return (E_DB_ERROR);
        	}
	    }
	}

	/* If there is a group by clause,
	** check that the columns or expressions in the target list exactly
	** match columns or expressions in the group list or are in an aggregate 
	** function.
	*/
	/* if group by or having or aggs, select can only include set functions
	** and grouping columns
	*/
	if ($9 || $10 || cur_agg_list != (YYAGG_NODE_PTR *) NULL)
	{
	    if (status = psl_ting($4, $9))
	    {
		(VOID) psf_error(2915L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, (i4) sizeof(cb->pss_lineno),
		    &cb->pss_lineno);
		return (E_DB_ERROR);
	    }
	}

	/*
	** If the FROM list contained any joins, merge the join_search quals
	** with the qualification of the subselect
	*/

	if ($Yj_qual->pss_qual != (PST_QNODE *) NULL)
	{
	    if (!$8 || $8->pst_sym.pst_type == PST_QLEND)
	    {
		qual = $Yj_qual->pss_qual;
	    }
	    else
	    {
		status = pst_node(cb, &cb->pss_ostream, $8, $Yj_qual->pss_qual,
		    PST_AND, (PTR) NULL, sizeof(PST_OP_NODE), DB_NODT, (i2) 0,
		    (i4) 0, (DB_ANYTYPE *) NULL, &qual, &psq_cb->psq_error,
		    (i4) 0);
		if (status != E_DB_OK)
		    return (status);
	    }
	}
	else
	{
	    qual = $8;
	}
	
	/* if group by, build agg function, attach having */
	if (($9) && !empty_gb && cur_agg_list != (YYAGG_NODE_PTR *) NULL)
	{
	    for (agg_node = cur_agg_list;
	         agg_node;
		 agg_node = agg_node->agg_next)
	    {
		/* copy where clause and add to aghead */
		if (agg_node->agg_next)
		{
		    $Ydup_rb.pss_tree = qual;
		    $Ydup_rb.pss_dup  = &wherenode;
		    status = pst_treedup(cb, &$Ydup_rb);

		    if (status != E_DB_OK)
			return (status);
		    agg_node->agg_node->pst_right = wherenode;
		}
		else
		    agg_node->agg_node->pst_right = qual;
		/* create the bylist */
		if (agg_node->agg_next)
		{
		    $Ydup_rb.pss_tree = $9;
		    $Ydup_rb.pss_dup  = &bylist;
		    status = pst_treedup(cb, &$Ydup_rb);

		    if (status != E_DB_OK)
			return (status);
		}
		else
		    bylist = $9;
		
		/* Create the byhead node */
		agopnode = agg_node->agg_node->pst_left;

		/* But first, if aggop's parm is not null and it is NOT an
		** OLAP binary aggregate function, change aggop
		** result (and BYHEAD and AGHEAD) to not null, too. This
		** improves ADF buffer alignment during code generation. */
		if (agopnode->pst_left && 
		    agopnode->pst_left->pst_sym.pst_dataval.db_datatype > 0 &&
		    agopnode->pst_sym.pst_dataval.db_datatype < 0 &&
		    agopnode->pst_right == NULL)
		{
		    agopnode->pst_sym.pst_dataval.db_datatype =
			abs(agopnode->pst_sym.pst_dataval.db_datatype);
		    agopnode->pst_sym.pst_dataval.db_length--;
		    agg_node->agg_node->pst_sym.pst_dataval.db_datatype =
			agopnode->pst_sym.pst_dataval.db_datatype;
		    agg_node->agg_node->pst_sym.pst_dataval.db_length--;
		}
		status = pst_node(cb, &cb->pss_ostream, bylist, agopnode, 
		    PST_BYHEAD, (PTR) NULL, sizeof(PST_RSDM_NODE), 
		    agopnode->pst_sym.pst_dataval.db_datatype,
		    agopnode->pst_sym.pst_dataval.db_prec, 
		    agopnode->pst_sym.pst_dataval.db_length, 
		    (DB_ANYTYPE *) NULL,
		    &byhead, &psq_cb->psq_error, (i4) 0);
		if (status != E_DB_OK)
		{
		    return (status);
		}

		/* attach byhead to aghead */
		agg_node->agg_node->pst_left = byhead;

		/* Create the tree, PST_TREE, node */
		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		    (PST_QNODE *) NULL, PST_TREE, (PTR) NULL, 0, DB_NODT, 
		    (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, &treenode,
		    &psq_cb->psq_error, (i4) 0);
		if (status != E_DB_OK)
		{
		    return (status);
		}

		/* Prepend the tree node to the aggregate result domain list */
		byhead = pst_tlprpnd(treenode, byhead);
	    }
	    /* since where clause has been added to aghead nodes, don't
	    ** add to bulk of query.
	    */

	    /* Create a QLEND node. */
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		(PST_QNODE *) NULL, PST_QLEND, (PTR) NULL, 0, DB_NODT, (i2) 0,
		(i4) 0, (DB_ANYTYPE *) NULL, &(qual), &psq_cb->psq_error,
		(i4) 0);
	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);
	    }
	}
	/* move where clause to simple aggregates */
	else if (cur_agg_list != (YYAGG_NODE_PTR *) NULL)
	{
	    for (agg_node = cur_agg_list;
		 agg_node; 
		 agg_node = agg_node->agg_next)
	    {
		/* copy where clause and add to aghead */
		if (agg_node->agg_next)
		{
		    $Ydup_rb.pss_tree = qual;
		    $Ydup_rb.pss_dup  = &wherenode;
		    status = pst_treedup(cb, &$Ydup_rb);

		    if (status != E_DB_OK)
			return (status);
		    agg_node->agg_node->pst_right = wherenode;
		}
		else
		    agg_node->agg_node->pst_right = qual;
	    }

	    /* Create a QLEND node. */
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		(PST_QNODE *) NULL, PST_QLEND, (PTR) NULL, 0, DB_NODT, (i2) 0,
		(i4) 0, (DB_ANYTYPE *) NULL, &(qual), &psq_cb->psq_error,
		(i4) 0);
	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);
	    }
	}

	/* Make the subselect node */
	root.pst_rtuser = FALSE;
	root.pst_union.pst_next  = 0;
	/* Tell whether retrieve unique. If explicit or if
	** group by and no aggregate functions.
	*/
	if ($3 ||
	    ((cur_agg_list == (YYAGG_NODE_PTR *) NULL)
	     && ($9 != (PST_QNODE*) NULL)))
	{
	    root.pst_dups = PST_NODUPS;
	}
	else
	    root.pst_dups = PST_ALLDUPS;

	MEcopy((char *)&$Yflists[cb->pss_qualdepth], sizeof(PST_J_MASK),
				(char *)&$Yfrom_list);
	/* if no from list, better not find where, groupby or having */
	if (BTcount((char *)&$Yfrom_list, PST_NUMVARS) == 0 &&
	    ((qual && qual->pst_sym.pst_type != PST_QLEND)
	    || $9 || $10))
	{
	    (VOID) psf_error(2922L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) sizeof(cb->pss_lineno),
		&cb->pss_lineno);
	    return (E_DB_ERROR);

	}
	MEcopy((char *)&$Yfrom_list, sizeof(PST_J_MASK),
					(char *)&root.pst_tvrm);
	root.pst_tvrc = 
	    BTcount((char*) &$Yfrom_list, BITS_IN($Yfrom_list));
	/* set from list in aghead nodes */
	for (agg_node = cur_agg_list; agg_node; agg_node = agg_node->agg_next)
	{
	    MEcopy((char *)&root.pst_tvrm, sizeof(PST_J_MASK),
		(char *)&agg_node->agg_node->pst_sym.pst_value.
						pst_s_root.pst_tvrm);
	    agg_node->agg_node->pst_sym.pst_value.pst_s_root.pst_tvrc =
		root.pst_tvrc;
	}

	if ($Yin_update_set_clause || $Yin_target_clause || 
		$Yin_groupby_clause)
	{
	    /* As yet unsupported scalar subselect. */
	    i4		err_code;

	    (VOID) psf_error(5121L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** Make the data value of the subselect node identical to that
	** of the first resdom.
	*/

	status = pst_node(cb, &cb->pss_ostream, $4, qual,
	    PST_SUBSEL, (PTR) &root, sizeof(PST_RT_NODE),
	    $4->pst_sym.pst_dataval.db_datatype,
	    $4->pst_sym.pst_dataval.db_prec, $4->pst_sym.pst_dataval.db_length,
	    (DB_ANYTYPE *) NULL, &rootnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);	/* non-zero return means error */
	}

	/*
	** provide OPF with indication of whether correlated variables were used
	** in this subselect
	*/
	if (BTtest(cb->pss_qualdepth, (char *) $Ycorrelation_mask))
	{
	    rootnode->pst_sym.pst_value.pst_s_root.pst_mask1 =
		PST_1CORR_VAR_FLAG_VALID | PST_2CORR_VARS_FOUND;
	}
	else
	{
	    rootnode->pst_sym.pst_value.pst_s_root.pst_mask1 =
		PST_1CORR_VAR_FLAG_VALID;
	}

	if ($Ymult_corr_attrs.depth == cb->pss_qualdepth)
	{
	    /*
	    ** if we were looking for multiple correlated relation references
	    ** because we have encountered COUNT in the target list of a nested
	    ** subselect, check if we did and reset depth
	    */
	    if ($Ymult_corr_attrs.found)
	    {
		cb->pss_flattening_flags |= PSS_MULT_CORR_ATTRS;
	    }

	    $Ymult_corr_attrs.depth = -1;
	}

	if ($Ycorr_aggr.depth == cb->pss_qualdepth)
	{
	    /*
	    ** if we were looking for correlated references because we have
	    ** encountered an aggregate in the target list of this subselect,
	    ** check if we found any and reset depth
	    */
	    if ($Ycorr_aggr.found)
	    {
		cb->pss_flattening_flags |= PSS_CORR_AGGR;
	    }

	    $Ycorr_aggr.depth = -1;
	}

	cb->pss_qualdepth--;
	/* if no set function and a group by clause, add the group by clause
	** to the target list as non-printing resdoms (for sorting).
	*/
	if (cur_agg_list == (YYAGG_NODE_PTR *) NULL && $9 != (PST_QNODE *) NULL)
	{
	    i4		cur_resno;

	    $Ysort_list = (PST_QNODE*) NULL;
	    cur_resno =	$4->pst_sym.pst_value.pst_s_rsdm.pst_rsno;
	    /* append the resdoms to the target list */
	    $4 = pst_tlprpnd($4, $9);

	    /* make the recently added nodes non-printing.
	    ** add sort nodes for them.
	    */
	    for (nodeptr = $4;
		 nodeptr->pst_sym.pst_value.pst_s_rsdm.pst_rsno > cur_resno;
		 nodeptr = nodeptr->pst_left)
	    {
		nodeptr->pst_sym.pst_value.pst_s_rsdm.pst_rsflags &= ~PST_RS_PRINT;
	    }
	}
	/* go down target list,having list if agg in tree, build aggregate */
	/* attach having clause to where clause */
	if ($10 != (PST_QNODE*) NULL)
	{
	    ADI_OP_ID	opno;
	    ADI_OP_ID	left_opno = (ADI_OP_ID) 0;

	    opno = $10->pst_sym.pst_value.pst_s_op.pst_opno;
	    if ($10->pst_left && ($10->pst_sym.pst_type == PST_NOT))
		left_opno = $10->pst_left->pst_sym.pst_value.pst_s_op.pst_opno;

	    if (opno == ADI_EXIST_OP)
		$10->pst_sym.pst_value.pst_s_root.pst_mask1 |= PST_5HAVING;
	    if (left_opno == ADI_EXIST_OP)
		$10->pst_left->pst_sym.pst_value.pst_s_root.pst_mask1 |= PST_5HAVING;

            /* b116202 */
            if ($10->pst_sym.pst_type == PST_BOP &&
                $10->pst_left &&
                $10->pst_left->pst_sym.pst_type == PST_AGHEAD &&
                $10->pst_right &&
                $10->pst_right->pst_sym.pst_type == PST_AGHEAD)
            {
                $10->pst_left->pst_sym.pst_value.pst_s_root.pst_mask1 |= PST_6HAVING;
                $10->pst_right->pst_sym.pst_value.pst_s_root.pst_mask1 |= PST_6HAVING;
            }

	    if (psl_hcheck(cb, $10, $9, &$Yfrom_list))
	    {
		i4		err_code;

		(VOID) psf_error(2920L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, sizeof(cb->pss_lineno), 
		    &cb->pss_lineno);
		return (E_DB_ERROR);
	    }
	    status = psy_apql(cb, &cb->pss_ostream, $10, rootnode,
		&psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	}

	/*
	** Move j_qual to the qualification (if any) of the outer subselect
	** (if any)
	*/
	$Yj_qual = $Yj_qual->pss_next;
	
	/* mark each element in the from list as 'out of current scope' */
	(VOID) pst_snscope(&cb->pss_auxrng, &$Yfrom_list);

	/*
	** return to the previous context (this is not useful now since we
	** disallow subselects inside the ON clause, but who knows, it may
	** become useful.)
	*/
	$Yqual_depth--;

	$$ = rootnode;
    }
;

first_n:
    {
	$$ = 0;		/* default */
    }
	|	FIRST int2_int4_p
    {
	i4	err_code;

	/* Check for "first n" in wrong place (can only be in first select
	** of a query and NOT in create view). */
	if (cb->pss_qualdepth != 1 || psq_cb->psq_mode == PSQ_VIEW ||
		($Ynonupdt_reason & PSS_UNION_IN_OUTERMOST_SUBSEL))
	{
	    (VOID) psf_error(2156L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1,
		    (i4) sizeof(cb->pss_lineno), &cb->pss_lineno);
	    return (E_DB_ERROR);
	}
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    /* No "select first n ..." allowed in Star queries. */
	    (VOID) psf_error(E_PS091F_STAR_NO_FIRSTN, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return(E_DB_ERROR);
	}
	$$ = $2;
    }
;

into_clause:		into cdbp_lvar_list
    {
	DB_STATUS status;

	status = pst_trfix(cb, &cb->pss_ostream, $2, 
		&psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Store the final target list ptr for
	** leftmost subselect
	*/
	$Ydbpinfo->pss_into_clause = $2;

	$$ = $2;
    }
	    |
    {
	$$ = (PST_QNODE *) NULL;
    }
;

cdbp_lvar_list:		cdbp_lvar
    {
	$$ = $1;
    }
		|	cdbp_lvar_list COMMA cdbp_lvar
    {
	/* Looks like ANSI nad DB/2 allow duplicates, so we
	** will not check for them.
	*/

	/*
	** Attach bulk of target list to leftmost node of new element.
	*/
	$$ = pst_tlprpnd($1, $3);
    }
;

cdbp_lvar:		colon generic_ident
    {
	PST_QNODE	*resdomnode;
	PST_RSDM_NODE	resdom;
	DB_STATUS       status;
	DB_PARM_NAME	varname;
	bool		found = FALSE;
	i4		err_code;
	register PSS_DECVAR *var;

	STmove($2, ' ', DB_MAXNAME, varname.db_parm_name);

	/* Find local var/parm by the specified name. */
	for (var = (PSS_DECVAR *) $Ydbpinfo->pss_varq.q_next;
	     var != (PSS_DECVAR *) &$Ydbpinfo->pss_varq;
	     var = (PSS_DECVAR *) var->pss_queue.q_next
	    )
	{
	    if (var->pss_out)
		continue;
	    if (MEcmp((PTR) &varname, (PTR) &var->pss_varname,
		sizeof(var->pss_varname)) == 0
	       )
	    {
		found = TRUE;
		break;
	    }
	}

	if (!found)
	{
	    /* Unknown local variable or parm spec'd. */
	    (VOID) psf_error(2403L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		STlength($2), $2);
	    return (E_DB_ERROR);
	}

	/* Normalize the attribute name */
	STmove($2, ' ', sizeof(resdom.pst_rsname),
	    (char *) resdom.pst_rsname);

	/* Generate a resdom node */
	resdom.pst_rsno = (i4) 0;	/* To be patched later */
	resdom.pst_ntargno = var->pss_no;
	resdom.pst_ttargtype = (i4) PST_LOCALVARNO;
	resdom.pst_rsupdt = (i4) FALSE;
	resdom.pst_rsflags = PST_RS_PRINT;

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_RESDOM, (char *) &resdom,
	    sizeof(PST_RSDM_NODE), DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
	    &resdomnode, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	STRUCT_ASSIGN_MACRO(var->pss_dbdata, resdomnode->pst_sym.pst_dataval);

	$$ = resdomnode;
    }
;

colon:		    COLON
		|
;

select:			SELECT
    {
	PSS_J_QUAL	       *join_qual;
	DB_STATUS              status;

	/*
	** If we were processing a join_search condition, subselects are
	** presently disallowed
	*/
	if (BTtest($Yqual_depth, $Yqual_type))
	{
	    i4	err_code;
	    (VOID) psf_error(E_PS03A0_SUBSEL_IN_JQUAL, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return(E_DB_ERROR);
	}
	
	/* Open memory stream for allocating query tree, if not already
	** open
	*/
	if (!cb->pss_ostream.psf_mstream.qso_handle &&
	    (status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
	    &psq_cb->psq_error)) != E_DB_OK)
	{
	    return (status);    /* non-zero return means error */
	}

	cb->pss_qualdepth++;

	/*
	** clear the bit that would indicate to us that correlated variables
	** were being used
	*/
	BTclear(cb->pss_qualdepth, (char *) $Ycorrelation_mask);

	$Yagg_list_stack[cb->pss_qualdepth] = (YYAGG_NODE_PTR *) NULL;
	$Yin_target_clause = TRUE;
	/*
	** Reset the resdom count for each subselect.
	*/
	cb->pss_rsdmno = 0;
	cb->pss_tlist = (PST_QNODE*) NULL;

	/* note that we are processing append for tuple width check later */
	if (psq_cb->psq_mode == PSQ_APPEND)
	    cb->pss_stmt_flags |= PSS_PARSING_INSERT_SUBSEL;

	/*
	** Initialize psq_mode if uninitialized. Required by psl_yerror.
	** Also, if this is an insert or an update, we need to change the mode
	** so that pst_adresdom works correctly. The mode will be restored in
	** the final production for "insert/update..where..subselect.." case.
	*/
	switch (psq_cb->psq_mode)
	{
	    case 0:
	    case PSQ_APPEND:
	    case PSQ_REPLACE:
	    case PSQ_PROT:
	    case PSQ_DEFQRY:
	    case PSQ_CREDBP:
	    case PSQ_IF:
	    case PSQ_RETURN:
	    case PSQ_MESSAGE:
	    case PSQ_VAR:
	    case PSQ_WHILE:
	    case PSQ_FOR:
	    case PSQ_REPEAT:
		{ 
		    psq_cb->psq_mode = PSQ_RETRIEVE;
		    break;
		}
	    default:
		/* Do not change it. */
		break;
	}

	/*
	** allocate a header for join_search qualification for this
	** subselect
	*/
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(PSS_J_QUAL), 
		 (PTR *) &join_qual, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	/*
	** Note that we "grow" the list upward.  Once the entire subselect
	** is processed, we will shed the PSS_J_QUAL node we just allocated
	*/
	join_qual->pss_qual = (PST_QNODE *) NULL;
	join_qual->pss_next = $Yj_qual;
	$Yj_qual = join_qual;

	/* indicate that we are NOT processing join_search condition */
	BTclear(++$Yqual_depth, $Yqual_type);
    }
;

distinct:		DISTINCT
    {
	/* Mark this SELECT stmnt as non-updatable */
	if (cb->pss_qualdepth == 1)
	{
	    $Ynonupdt = TRUE;
	    $Ynonupdt_reason |= PSS_DISTINCT_IN_OUTERMOST_SUBSEL;
	}

	$$ = TRUE;
    }
		|	ALL
    {
	$$ = FALSE;
    }
		|
    {
	$$ = FALSE;
    }
;

into:		    INTO
    {
	i4	err_code;

	/* Into clause is only allowed in DB procedures. */
	if ($Yisdbp == FALSE)
	{
	    (VOID) psf_error(2419L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return(E_DB_ERROR);
	}

	/* Into clause is only allowed at the outermost scope. */
	if (cb->pss_qualdepth != 1)
	{
	    (VOID) psf_error(2418L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return(E_DB_ERROR);
	}

	/* Into clause must appear only once and must be
	** in the leftmost query term.
	*/
	if ($Ydbpinfo->pss_into_clause != (PST_QNODE *) NULL ||
	    $Ydbpinfo->pss_flags & PSS_1SUB_SEEN
	   )
	{
	    (VOID) psf_error(2428L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return(E_DB_ERROR);
	}

	/* Into clause must not be mixed with other forms
	** of local var assignment statement.
	*/
	if ($Ydbpinfo->pss_flags & PSS_LVAR_SEEN)
	{
	    (VOID) psf_error(2429L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof(cb->pss_lineno), &cb->pss_lineno);
	    return(E_DB_ERROR);
	}
    }
;

target_spec	:	target_list
    {
	$Yin_target_clause = FALSE;

	$$ = $1;
    }
;

target_list:	   	target_item
		|	target_list COMMA target_item 
    {

	/*
	** Attach bulk of target list to leftmost node of new element.
	*/
	$$ = pst_tlprpnd($1, $3);
    }
;

target_item:	    BAOP
    {
	/* list all attributes */
	PST_VAR_NODE	       var;
	PST_QNODE	       *varnode;
	PST_QNODE	       *rsdmnode;
	DB_STATUS	       status;

	/*
	** when we encounter "*" when processing the target list, we are yet to
	** process the FROM list, so for now we just create a dummy VAR and
	** RESDOM nodes to indicate that the target list consists of "*".  Real
	** VAR and RESDOM nodes will be put together later
	** (in the "subselect:" production as soon as we are done processing the
	** from_list)
	*/

	/* Blank out the attribute name */
	MEfill(sizeof(DB_ATT_NAME), ' ', var.pst_atname.db_att_name);
	var.pst_atno.db_att_id = PST_STAR_SEEN;
	
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_VAR, (char *) &var, sizeof(var),
	    DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, &varnode,
	    &psq_cb->psq_error, (i4) 0);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	/* Create the corresponding result domain node */
	status = pst_adresdom((char *) &var.pst_atname, (PST_QNODE *) NULL,
	    varnode, cb, psq_cb, &rsdmnode);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	$$ = rsdmnode;

    }
		|	sel_expr_or_null
    {
	DB_STATUS           status;
	PST_QNODE	    *resdomnode;
	char		    *name;
	char		    atname[sizeof(DB_ATT_NAME)];

	if ($1->pst_sym.pst_type == PST_VAR)
	{
	    name = (char *)&$1->pst_sym.pst_value.pst_s_var.pst_atname;
	}
	else
	{
	    (VOID) MEfill(sizeof(DB_ATT_NAME), (u_char) ' ', (PTR) atname);
	    name = (char *) atname;
	}
	status = pst_adresdom(name, (PST_QNODE *) NULL, $1,
	    cb, psq_cb, &resdomnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$$ = resdomnode;
    }
		|	col_spec EQUAL sel_expr_or_null
    {
	DB_STATUS           status;
	PST_QNODE	    *resdomnode;
        DB_ATT_NAME	    colname;
	i4		    err_code;
	bool		    found = FALSE;
	PSS_DECVAR	    *var;
	char		    *name = (char *) &colname;

	/* normalize the attribute name */
	STmove((char *) $1, ' ', (u_i4)sizeof(DB_ATT_NAME), (char *)&colname);

	if ($Yisdbp == TRUE && ~$Ydbpinfo->pss_flags & PSS_1SUB_SEEN)
	{
	    /* If the outermost scope, treat as local variable. */
	    if (cb->pss_qualdepth == 1)
	    {
		/* Search for the variable; innermost scope first. */
		for (var = (PSS_DECVAR *) $Ydbpinfo->pss_varq.q_next;
		     var != (PSS_DECVAR *) &$Ydbpinfo->pss_varq;
		     var = (PSS_DECVAR *) var->pss_queue.q_next
		    )
		{
		    if (var->pss_out)
			continue;

		    if (MEcmp((PTR) &colname, (PTR) &var->pss_varname,
			sizeof(var->pss_varname)) == 0
		       )
		    {
			found = TRUE;
			break;
		    }
		}

		if (found == TRUE)
		{
		    /* The resdom name needs to be the same
		    ** as of select_expr.
		    */
		    if ($3->pst_sym.pst_type == PST_VAR)
		    {
		     name = (char *)&$3->pst_sym.pst_value.pst_s_var.pst_atname;
		    }
		    else
		    {
			(VOID) MEfill(sizeof(DB_ATT_NAME), (u_char) ' ',
				(PTR) &colname);
		    }

		    /*
		    ** Remember that local var related target list element was
		    ** seen
		    */
		    $Ydbpinfo->pss_flags |= PSS_LVAR_SEEN;
		}
		else
		{
		    /* Var unknown */
		    (VOID) psf_error(2413L, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 1, STlength($1), $1);
		    return (E_DB_ERROR);
		}
	    }
	}

	status = pst_adresdom(name, (PST_QNODE *) NULL, $3,
	    cb, psq_cb, &resdomnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	if (found == TRUE)
	{
	    resdomnode->pst_sym.pst_value.pst_s_rsdm.pst_ntargno = var->pss_no;
	    resdomnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype = PST_LOCALVARNO;
	    STRUCT_ASSIGN_MACRO(var->pss_dbdata, resdomnode->pst_sym.pst_dataval);
	}
	else
	{
	    /* indicate that RESDOM name has been assigned explicitly */
	    resdomnode->pst_sym.pst_type = PSS_2RESDOM;
	}

	$$ = resdomnode;
    }
		|	COLON col_spec EQUAL sel_expr_or_null
    {
	DB_STATUS           status;
	PST_QNODE	    *resdomnode;
        DB_ATT_NAME	    colname;
	i4		    err_code;
	bool		    found = FALSE;
	PSS_DECVAR	    *var;
	char		    *name = (char *) &colname;

	if ($Yisdbp == FALSE)
	{
	    /* Only allowed in DB procedures */
	    (VOID) psf_error(2414L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, STlength($2), $2);
	    return (E_DB_ERROR);	    
	}

	/* Assignment clause only allowed at the outermost scope. */
	if ($Ydbpinfo->pss_flags & PSS_1SUB_SEEN || cb->pss_qualdepth != 1)
	{
	    (VOID) psf_error(2431L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof(cb->pss_lineno), &cb->pss_lineno);
	    return(E_DB_ERROR);
	}

	/* Remember that local var related targ. list element seen. */
	$Ydbpinfo->pss_flags |= PSS_LVAR_SEEN;

	/* normalize the attribute name */
	STmove((char *) $2, ' ', (u_i4)sizeof(DB_ATT_NAME), (char *)&colname);

	/* Search for the variable; innermost scope first. */
	for (var = (PSS_DECVAR *) $Ydbpinfo->pss_varq.q_next;
	     var != (PSS_DECVAR *) &$Ydbpinfo->pss_varq;
	     var = (PSS_DECVAR *) var->pss_queue.q_next
	    )
	{
	    if (var->pss_out)
		continue;

	    if (MEcmp((PTR) &colname, (PTR) &var->pss_varname,
		sizeof(var->pss_varname)) == 0
	       )
	    {
		found = TRUE;
		break;
	    }
	}

	if (found == FALSE)
	{
	    /* Var unknown */
	    (VOID) psf_error(2413L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, STlength($2), $2);
	    return (E_DB_ERROR);
	}

	/* The resdom name needs to be the same
	** as of select_expr.
	*/
	if ($4->pst_sym.pst_type == PST_VAR)
	{
	    name = (char *)&$4->pst_sym.pst_value.pst_s_var.pst_atname;
	}
	else
	{
	    (VOID) MEfill(sizeof(DB_ATT_NAME), (u_char) ' ', (PTR) &colname);
	}

	status = pst_adresdom(name, (PST_QNODE *) NULL, $4,
	    cb, psq_cb, &resdomnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	resdomnode->pst_sym.pst_value.pst_s_rsdm.pst_ntargno = var->pss_no;
	resdomnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype = PST_LOCALVARNO;
	STRUCT_ASSIGN_MACRO(var->pss_dbdata, resdomnode->pst_sym.pst_dataval);

	$$ = resdomnode;
    }
		|	sel_expr_or_null optional_as col_spec
    {
	DB_STATUS           status;
	PST_QNODE	    *resdomnode;
        DB_ATT_NAME	    colname;

	/* normalize the attribute name */
	STmove((char *)$3, ' ', (u_i4)sizeof(DB_ATT_NAME), (char *)&colname);

	status = pst_adresdom((char *) &colname, (PST_QNODE *) NULL, $1,
	    cb, psq_cb, &resdomnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* indicate that RESDOM name has been assigned explicitly */
	resdomnode->pst_sym.pst_type = PSS_2RESDOM;

	$$ = resdomnode;
    }
		|	all_col_ref
    {
	PST_VAR_NODE	       var;
	PST_QNODE	       *varnode;
	PST_QNODE	       *rsdmnode;
	DB_STATUS	       status;
	PSS_RNGTAB             *rngvar;

        status = psl_tbl_ref(psq_cb, cb, $1, $Yin_target_clause,
	    $Yin_groupby_clause, &$Ytbl_refs, &rngvar);
        if (DB_FAILURE_MACRO(status))
	    return(status);

	/* Blank out the attribute name */
	MEfill(sizeof(DB_ATT_NAME), ' ', var.pst_atname.db_att_name);
	var.pst_atno.db_att_id = PST_STAR_SEEN;
	
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_VAR, (char *) &var, sizeof(var),
	    DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, &varnode,
	    &psq_cb->psq_error, (i4) 0);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	varnode->pst_sym.pst_dataval.db_data = (PTR) rngvar;

	/* Create the corresponding result domain node */
	status = pst_adresdom((char *) &var.pst_atname, (PST_QNODE *) NULL,
	    varnode, cb, psq_cb, &rsdmnode);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	$$ = rsdmnode;
    }
;

/*
** AS is optional in <expr> [AS] <column spec>
*/
optional_as:	AS
	|
;

from_u:			FROM from_list
    {
	PST_J_MASK	mask;

	MEcopy((char *)&$Yflists[cb->pss_qualdepth], sizeof(PST_J_MASK), 
					(char *)&mask);
	/*
	** we have to remove vars appearing in this FROM list from the
	** $Yjoin_tbls to allow for correlated queries.
	*/
	BTnot(BITS_IN(mask), (char *) &mask);
	BTand(BITS_IN(mask), (char *) &mask, (char *) &$Yjoin_tbls);

	cb->pss_stmt_flags |= PSS_XTABLE_UPDATE;

    }
		|
;

from:			from_word from_list
    {
	PST_J_MASK	mask;

	MEcopy((char *)&$Yflists[cb->pss_qualdepth], sizeof(PST_J_MASK), 
					(char *)&mask);
	/*
	** we have to remove vars appearing in this FROM list from the
	** $Yjoin_tbls to allow for correlated queries.
	*/
	BTnot(BITS_IN(mask), (char *) &mask);
	BTand(BITS_IN(mask), (char *) &mask, (char *) &$Yjoin_tbls);
	$Yin_from_clause = FALSE;
    }
		|
    {
	MEfill(sizeof(PST_J_MASK), 0, (char *)&$Yflists[cb->pss_qualdepth]);
    }
;

from_word:		FROM
    {
	$Yin_from_clause = TRUE;
	MEfill(sizeof(PST_J_MASK), 0, (char *)&$Yflists[cb->pss_qualdepth]);
    }
;

from_list:		from_list_item
		|	from_list COMMA from_list_item
;

corr_name:		tbl_spec
    {
	$$ = $1;
    }
		|	AS tbl_spec
    {
	$$ = $2;
    }
		|
    {
	$$ = (char *) NULL;
    }
;


corr_name1:		tbl_spec
    {
	$$ = $1;
    }
		|	AS tbl_spec
    {
	$$ = $2;
    }
;

from_list_item:	    obj_spec corr_name
    {
	PST_J_MASK	*mask;
	DB_STATUS	status;
	i4		rngvar_info;
	PSS_RNGTAB	*resrange;
	char		*corr_name = ($2 == (char *) NULL)
						? $1->pss_orig_obj_name
						: $2;

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Capture object name for CREATE SCHEMA
	    */
	    return(psl_cs06s_obj_spec(cb, psq_cb, &($Ydeplist), $1,
				      (u_i4)0));
	}

	/* if schema.object construct was used */
	if ($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)	    
	{
	    status = psl_orngent(&cb->pss_auxrng, cb->pss_qualdepth, corr_name,
		&$1->pss_owner, &$1->pss_obj_name, cb, FALSE, &resrange,
		psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, cb->pss_qualdepth, 
		corr_name, &$1->pss_obj_name, cb, FALSE, &resrange,
		psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    $1->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** if a correlation name was explicitly specified, set a bit in
	** resrange->pss_var_mask
	*/
	if ($2)
	    resrange->pss_var_mask |= PSS_EXPLICIT_CORR_NAME;

	/*
	** In case of DB procedures table name needs to be qualified
	** by the owner name. 
	** But don't qualify name if it's a set-input parameter.
	*/
	if ($Yisdbp 
	    && (cb->pss_stmt_flags & PSS_TXTEMIT) 
	    && ~$1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
	    && (resrange->pss_rgtype != PST_SETINPUT))
	{
	    u_char 	    *owner;

	    if (rngvar_info & PSS_BY_SYNONYM)
	    {
		/*
		** special care must be exercised when dealing with synonyms:
		** if the object referenced by the user was a synonym, name of
		** its owner must be determined by consulting rngvar_info.
		*/
		if (rngvar_info & PSS_USR_OBJ)
		{
		    owner = (u_char *) &cb->pss_user;
		}
		else if (rngvar_info & PSS_DBA_OBJ)
		{
		    owner = (u_char *) &cb->pss_dba;
		}
		else if (rngvar_info & PSS_SYS_OBJ)
		{
		    owner = (u_char *) cb->pss_cat_owner;
		}
		else	    /* user name was explicitly specified */
		{
		    owner = (u_char *) &$1->pss_owner;
		}
	    }
	    else
	    {
		owner = (u_char *) &resrange->pss_ownname;
	    }

	    status = psl_prepend_schemaname(cb->pss_tchain, 
					    $1->pss_orig_obj_name, 
					    owner, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}
	/*
	** As a result of the SYNONYM project, we also may have to do some extra
	** work when processing CREATE VIEW/INTEGRITY/PERMIT.
	**
	** if (object is a SYNONYM)
	** {
	**	replace reference to a synonym with a name of the actual object
	**	qualified by the name of the owner;
	**	if was not correlated, use synonym name as a corelation name;
	** }
	**
	** In addition to that, we will ensure that names of objects used in
	** view definition as it is stored in IIQRYTEXT are qualified with owner
	** name
	*/
	else if (!$Yisdbp)
	{
	    u_char	*actual_obj_owner = (u_char *) &resrange->pss_ownname;

	    if (   $Yqry_mask & PSS_PREFIX_WITH_OWNER 
		&& ~$1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    {
		/*
		** if object name was NOT prefixed with owner name, insert name
		** of the owner of the ACTUAL object (i.e. not of a synonym
		** which may have been used.)
		*/
		status = psl_prepend_schemaname(cb->pss_tchain, 
						$1->pss_orig_obj_name, 
						actual_obj_owner, 
						&psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return (status);
	    }

	    if (rngvar_info & PSS_BY_SYNONYM &&
	        $Yqry_mask & PSS_REPL_SYN_WITH_ACTUAL)
	    {
		PTR	*obj_name_ptr;
		PTR	newpiece;
		i4 	name_len;
		u_char	delim_id[DB_MAX_DELIMID];
#ifdef BYTE_ALIGN
		PTR	align_ptr;
#else
#undef   align_ptr
#define  align_ptr  (*obj_name_ptr)
#endif

		/* The piece ptr is stored after the null terminated string */
		obj_name_ptr = (PTR *) ((char *) $1->pss_orig_obj_name +
					STlength($1->pss_orig_obj_name) + 1);
#ifdef BYTE_ALIGN
		MECOPY_CONST_MACRO((PTR)obj_name_ptr, sizeof(PTR),
				   (PTR)&align_ptr);
#endif
		/*
		** if synonym name was qualified with owner name, and the owner
		** of the synonym is different from the owner of the actual
		** object, we will replace name of the owner of the synonym with
		** that of the actual object
		*/
		if ($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
		    MEcmp((PTR) &$1->pss_owner, (PTR) actual_obj_owner,
			sizeof(DB_OWN_NAME)))
		{
		    PTR	    syn_owner = psq_tbacktrack(align_ptr, 2);

		    /*
		    ** psq_tsubs() may replace a name with preceding blank(s)
		    ** with one without them.  This is undesirable, e.g.
		    ** 
		    **	    create synonym andre.x for $ingres.iirelation;
		    **	    create view v as select * from andre.x;
		    **
		    ** would result in text
		    **
		    **	    create view v as select * from$ingres.iirelation 
		    **
		    ** Therefore, we must add a speca before the actual object
		    ** owner name.
		    */

		    status = psq_tinsert(cb->pss_tchain, (u_char *) " ",
			sizeof(" ") - 1, &newpiece, syn_owner,
			&psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
			return (status);

		    /* convert owner name to a delimited identifier
		    ** (obj_owner pointer gets overwritten)
		    */
		    name_len = psf_trmwhite(DB_MAXNAME, 
			(char *) actual_obj_owner);

		    status = psl_norm_id_2_delim_id(&actual_obj_owner,
						    &name_len, delim_id,
						    &psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
			    return(status);

		    status = psq_tsubs(cb->pss_tchain, syn_owner,
				       actual_obj_owner, name_len,
				       &newpiece, &psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
		    {
			return(status);
		    }
		}

		/*
		** if (synonym name was different from the actual object name)
		** {
		**     if (user did not supply a corelation name)
		**     {
		**         insert actual object name before the synonym name
		**	   which will be used as corelation name;
		**     }
		**     else
		**     {
		**         replace synonym name with actual object name;
		**     }
		** }
		*/
		if (MEcmp((PTR) &$1->pss_obj_name, (PTR) &resrange->pss_tabname,
			  sizeof(DB_TAB_NAME)))
		{
		    u_char	*actual_tbl = (u_char *) &resrange->pss_tabname;

		    /* convert table name to a delimited identifier
		    ** (actual_tbl pointer gets overwritten)
		    */
		    name_len = psf_trmwhite(DB_MAXNAME, (char *) actual_tbl);

		    status = psl_norm_id_2_delim_id(&actual_tbl, 
						    &name_len, delim_id,
						    &psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
			    return(status);

		    if ($2 == (char *) NULL)
		    {
			/* no corelation name was supplied */

			/*
			** if synonym name was not prefixed with owner name and
			** the actual table owner name has not been already
			** inserted, we need to insert a blank before the actual
			** table name to separate it from the previous keyword.
			*/
			if (   ~$1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
			    && ~$Yqry_mask & PSS_PREFIX_WITH_OWNER)
			{
			    /* Add a blank */
			    status = psq_tinsert(cb->pss_tchain, (u_char *) " ",
				sizeof(" ") - 1, &newpiece, align_ptr,
				&psq_cb->psq_error);
			    if (DB_FAILURE_MACRO(status))
				return (status);
			}

			status = psq_tinsert(cb->pss_tchain, actual_tbl, 
					     name_len, &newpiece,
					     align_ptr, &psq_cb->psq_error);
			if (DB_FAILURE_MACRO(status))
			    return (status);

			/*
			** if the table name was not prefixed with the owner
			** name, we don't need to add a blank between the actual
			** table name and the synonym name which will be used as
			** a corelation name because there had to be at least
			** one white char preceding the synonym name
			**
			** This is not quite correct, since the synonym name may
			** have immediately followed some non-blank separator,
			** e.g. comma in a from list:
			**
			**	create synonym andre.s for t;
			**	create view z as select 1 from s,s;
			**
			** will result in text
			**
			**    create view z as select 1 from andre.t s, andre.ts
			**
			** which is not very desirable.
			*/

			/* Add a blank */
			status = psq_tinsert(cb->pss_tchain, (u_char *) " ",
			    sizeof(" ") - 1, &newpiece, align_ptr,
			    &psq_cb->psq_error);
			if (DB_FAILURE_MACRO(status))
			    return (status);
		    }
		    else
		    {
			/*
			** psq_tsubs() strikes again; it may substitute a string
			** for a string preceeded by at least one blank and
			** screw things up as in
			**
			**	create synonym s for t;
			**	create permit select on s x to greg;
			**
			** becomes
			**
			**	create permit select ont x to greg.
			*/

			/* Add a blank */
			status = psq_tinsert(cb->pss_tchain, (u_char *) " ",
			    sizeof(" ") - 1, &newpiece, align_ptr,
			    &psq_cb->psq_error);
			if (DB_FAILURE_MACRO(status))
			    return (status);

			status = psq_tsubs(cb->pss_tchain, align_ptr,
					   actual_tbl, name_len,
					   &newpiece, &psq_cb->psq_error);
			if (DB_FAILURE_MACRO(status))
			    return(status);
		    }
		}
	    }
	}

	BTset(resrange->pss_rgno, (char*) &$Yflists[cb->pss_qualdepth]);

        if (cb->pss_qualdepth == 1)
        {
            if (BTcount((char *)&$Yflists[cb->pss_qualdepth], PST_NUMVARS) > 1)
            {
                /*
                ** FROM-list in the outermost subselect involves more than one
                ** relation - query will not be updateable
                */
                $Ynonupdt = TRUE;
                $Ynonupdt_reason |= PSS_MULT_VAR_IN_OUTERMOST_SUBSEL;
            }
            else if (psq_cb->psq_mode == PSQ_VIEW && !$Ynonupdt)
            {
                /*
                ** remember address of the range variable representing the new
                ** view's simply underlying table
                */
                $Yunderlying_rel = resrange;
            }
        }

	/*
	** save the address for future dereferencing.  Now, given range number,
	** I will get the pointer to a range variable without having to scan the
	** entire table
	*/
	$Yrng_vars[resrange->pss_rgno] = resrange;

	/*
	** productions such as integtbl may need to know thr value of
	** rngvar_info
	*/
	$Yrngvar_info = rngvar_info;
	
	/* Allocate PST_J_MASK to define this table to rest of parse. */
        status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_J_MASK),
	         (PTR *) &mask, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}
	MEfill(sizeof(PST_J_MASK), '\0', (PTR)mask);
	BTset(resrange->pss_rgno, (char *) mask);

	/*
	** we keep track of the tables in the FROM list to make sure that there
	** are no correlated queries appearing in the join_search condition of
	** the FROM list which involve tables from the same FROM list
	*/
	BTor(PST_NUMVARS, (char *)mask, (char *)&$Yjoin_tbls);

	$$ = mask;
    }
	|	LPAREN
    {
	DB_STATUS	status;

	$Ysave_pss_rsdmno = cb->pss_rsdmno;
	status = psl_push_yyvars(psq_cb, cb, yyvarspp);
	if (DB_FAILURE_MACRO(status))
	    return(status);
	yyvarsp = *yyvarspp;
    }
		query_expr RPAREN corr_name1 dcollist
    {
	PST_J_MASK	*mask;
	DB_STATUS	status;
	PSS_RNGTAB	*resrange;

	status = psl_drngent(&cb->pss_auxrng, cb->pss_qualdepth, 
		$5, cb, &resrange, $3, PST_DRTREE, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return (status);

	cb->pss_ses_flag |= PSS_DERTAB_INQ;	/* note derived table in qry */

	/* If there was an override column list, check here that the 
	** count is right, and replace the column names. */
	if ($Ydcol_list.queue.q_next != (QUEUE *)&$Ydcol_list)
	{
	    PSY_COL	*psy_col;
	    i4		i, err_code;

	    for (i = 1, psy_col = (PSY_COL *)$Ydcol_list.queue.q_prev;
		i <= resrange->pss_tabdesc->tbl_attr_count && 
				psy_col != (PSY_COL *)&$Ydcol_list;
		i++, psy_col = (PSY_COL *)psy_col->queue.q_prev)
	    {
		MEcopy((char *)psy_col->psy_colnm.db_att_name, 
		    sizeof(DB_ATT_NAME), 
		    (char *)resrange->pss_attdesc[i]->att_name.db_att_name);
	    }

	    if (resrange->pss_tabdesc->tbl_attr_count >= i ||
		psy_col != (PSY_COL *)&$Ydcol_list)
	    {
		/* Count of override column names is incorrect - error. */
		(VOID) psf_error(2157L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2,
		    sizeof(cb->pss_lineno), &cb->pss_lineno,
		    sizeof(DB_TAB_NAME),
		    resrange->pss_rgname);
		return (E_DB_ERROR);
	    }
	}

	/* And now restore the outer yyvarsp, since recursion is done. */
	$Yprev_yyvarsp->join_id = $Yjoin_id;	/* join_id persists */

	if ($Ynonupdt)
	{
	    /* Propagate non-updateability to containing query. */
	    $Yprev_yyvarsp->nonupdt = TRUE;
	    $Yprev_yyvarsp->nonupdt_reason |= $Ynonupdt_reason;
	}

	yyvarsp = *yyvarspp = $Yprev_yyvarsp;
	cb->pss_rsdmno = $Ysave_pss_rsdmno;	/* restore */

	/*
	** Correlation name was explicitly specified, set a bit in
	** resrange->pss_var_mask
	*/
	resrange->pss_var_mask |= PSS_EXPLICIT_CORR_NAME;

	BTset(resrange->pss_rgno, (char*) &$Yflists[cb->pss_qualdepth]);

        if (cb->pss_qualdepth == 1)
        {
            if (BTcount((char *)&$Yflists[cb->pss_qualdepth], PST_NUMVARS) > 1)
            {
                /*
                ** FROM-list in the outermost subselect involves more than one
                ** relation - query will not be updateable
                */
                $Ynonupdt = TRUE;
                $Ynonupdt_reason |= PSS_MULT_VAR_IN_OUTERMOST_SUBSEL;
            }
            else if (psq_cb->psq_mode == PSQ_VIEW && !$Ynonupdt)
            {
                /*
                ** remember address of the range variable representing the new
                ** view's simply underlying table
                */
                $Yunderlying_rel = resrange;
            }
        }

	/*
	** save the address for future dereferencing.  Now, given range number,
	** I will get the pointer to a range variable without having to scan the
	** entire table
	*/
	$Yrng_vars[resrange->pss_rgno] = resrange;

	/*
	** productions such as integtbl may need to know thr value of
	** rngvar_info
	*/
	$Yrngvar_info = PSS_USR_OBJ;
	
	/* Allocate PST_J_MASK to define this table to rest of parse. */
        status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_J_MASK),
	         (PTR *) &mask, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}
	MEfill(sizeof(PST_J_MASK), '\0', (PTR)mask);
	BTset(resrange->pss_rgno, (char *) mask);

	/*
	** we keep track of the tables in the FROM list to make sure that there
	** are no correlated queries appearing in the join_search condition of
	** the FROM list which involve tables from the same FROM list
	*/
	BTor(PST_NUMVARS, (char *)mask, (char *)&$Yjoin_tbls);

	$$ = mask;
    }
	|	joined_table
    {
	$$ = $1;
    }
;

dcollist:	/* Nuttin' here */
	|	LPAREN dcollist1 RPAREN
;

dcollist1:	col_spec
    {
	DB_STATUS   status;
	PSY_COL     *psy_col;

	/* Open memory stream for allocating query tree, if not already
	** open. This may be necessary if the query includes with clause
	** elements (common query expressions).
	*/
	if (!cb->pss_ostream.psf_mstream.qso_handle &&
	    (status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
	    &psq_cb->psq_error)) != E_DB_OK)
	{
	    return (status);    /* non-zero return means error */
	}

	/* Allocate memory for a column entry
	 */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSY_COL),
			    (PTR *) &psy_col, &psq_cb->psq_error);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/*
	** Copy update column name to column entry.
	*/
	STmove($1, ' ', sizeof(DB_ATT_NAME),
		psy_col->psy_colnm.db_att_name);

	/*
	** Attach element to the list.
	*/
	QUinsert((QUEUE *) psy_col, (QUEUE *) &$Ydcol_list);
    }
	|	dcollist1 COMMA col_spec
    {
	DB_STATUS   status;
	PSY_COL     *psy_col;

	/* Allocate memory for a column entry
	 */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSY_COL),
			    (PTR *) &psy_col, &psq_cb->psq_error);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/*
	** Copy update column name to column entry.
	*/
	STmove($3, ' ', sizeof(DB_ATT_NAME),
		psy_col->psy_colnm.db_att_name);

	/*
	** Attach element to the list.
	*/
	QUinsert((QUEUE *) psy_col, (QUEUE *) &$Ydcol_list);
    }
;

from_item:		obj_spec corr_name
    {
	DB_STATUS	status;
	i4		rngvar_info;
	PSS_RNGTAB	*resrange;
	char		*corr_name = ($2 == (char *) NULL)
						? $1->pss_orig_obj_name
						: $2;

	if (psq_cb->psq_mode == PSQ_CREATE_SCHEMA)
	{
	    /*
	    ** Capture object name for CREATE SCHEMA
	    */
	    return(psl_cs06s_obj_spec(cb, psq_cb, &($Ydeplist), $1,
				      (u_i4)0));
	}

	/* if schema.object construct was used */
	if ($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)	    
	{
	    status = psl_orngent(&cb->pss_auxrng, cb->pss_qualdepth, corr_name,
		&$1->pss_owner, &$1->pss_obj_name, cb, FALSE, &resrange,
		psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, cb->pss_qualdepth, 
		corr_name, &$1->pss_obj_name, cb, FALSE, &resrange,
		psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    $1->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** if a correlation name was explicitly specified, set a bit in
	** resrange->pss_var_mask
	*/
	if ($2)
	    resrange->pss_var_mask |= PSS_EXPLICIT_CORR_NAME;

	/*
	** In case of DB procedures table name needs to be qualified
	** by the owner name. 
	** But don't qualify name if it's a set-input parameter.
	*/
	if ($Yisdbp 
	    && (cb->pss_stmt_flags & PSS_TXTEMIT) 
	    && ~$1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
	    && (resrange->pss_rgtype != PST_SETINPUT))
	{
	    u_char 	    *owner;

	    if (rngvar_info & PSS_BY_SYNONYM)
	    {
		/*
		** special care must be exercised when dealing with synonyms:
		** if the object referenced by the user was a synonym, name of
		** its owner must be determined by consulting rngvar_info.
		*/
		if (rngvar_info & PSS_USR_OBJ)
		{
		    owner = (u_char *) &cb->pss_user;
		}
		else if (rngvar_info & PSS_DBA_OBJ)
		{
		    owner = (u_char *) &cb->pss_dba;
		}
		else if (rngvar_info & PSS_SYS_OBJ)
		{
		    owner = (u_char *) cb->pss_cat_owner;
		}
		else	    /* user name was explicitly specified */
		{
		    owner = (u_char *) &$1->pss_owner;
		}
	    }
	    else
	    {
		owner = (u_char *) &resrange->pss_ownname;
	    }

	    status = psl_prepend_schemaname(cb->pss_tchain, 
					    $1->pss_orig_obj_name, 
					    owner, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}
	/*
	** As a result of the SYNONYM project, we also may have to do some extra
	** work when processing CREATE VIEW/INTEGRITY/PERMIT.
	**
	** if (object is a SYNONYM)
	** {
	**	replace reference to a synonym with a name of the actual object
	**	qualified by the name of the owner;
	**	if was not correlated, use synonym name as a corelation name;
	** }
	**
	** In addition to that, we will ensure that names of objects used in
	** view definition as it is stored in IIQRYTEXT are qualified with owner
	** name
	*/
	else if (!$Yisdbp)
	{
	    u_char	*actual_obj_owner = (u_char *) &resrange->pss_ownname;

	    if (   $Yqry_mask & PSS_PREFIX_WITH_OWNER 
		&& ~$1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    {
		/*
		** if object name was NOT prefixed with owner name, insert name
		** of the owner of the ACTUAL object (i.e. not of a synonym
		** which may have been used.)
		*/
		status = psl_prepend_schemaname(cb->pss_tchain, 
						$1->pss_orig_obj_name, 
						actual_obj_owner, 
						&psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return (status);
	    }

	    if (rngvar_info & PSS_BY_SYNONYM &&
	        $Yqry_mask & PSS_REPL_SYN_WITH_ACTUAL)
	    {
		PTR	*obj_name_ptr;
		PTR	newpiece;
		i4 	name_len;
		u_char	delim_id[DB_MAX_DELIMID];
#ifdef BYTE_ALIGN
		PTR	align_ptr;
#else
#undef   align_ptr
#define  align_ptr  (*obj_name_ptr)
#endif

		/* The piece ptr is stored after the null terminated string */
		obj_name_ptr = (PTR *) ((char *) $1->pss_orig_obj_name +
					STlength($1->pss_orig_obj_name) + 1);
#ifdef BYTE_ALIGN
		MECOPY_CONST_MACRO((PTR)obj_name_ptr, sizeof(PTR),
				   (PTR)&align_ptr);
#endif
		/*
		** if synonym name was qualified with owner name, and the owner
		** of the synonym is different from the owner of the actual
		** object, we will replace name of the owner of the synonym with
		** that of the actual object
		*/
		if ($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA &&
		    MEcmp((PTR) &$1->pss_owner, (PTR) actual_obj_owner,
			sizeof(DB_OWN_NAME)))
		{
		    PTR	    syn_owner = psq_tbacktrack(align_ptr, 2);

		    /*
		    ** psq_tsubs() may replace a name with preceding blank(s)
		    ** with one without them.  This is undesirable, e.g.
		    ** 
		    **	    create synonym andre.x for $ingres.iirelation;
		    **	    create view v as select * from andre.x;
		    **
		    ** would result in text
		    **
		    **	    create view v as select * from$ingres.iirelation 
		    **
		    ** Therefore, we must add a speca before the actual object
		    ** owner name.
		    */

		    status = psq_tinsert(cb->pss_tchain, (u_char *) " ",
			sizeof(" ") - 1, &newpiece, syn_owner,
			&psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
			return (status);

		    /* convert owner name to a delimited identifier
		    ** (obj_owner pointer gets overwritten)
		    */
		    name_len = psf_trmwhite(DB_MAXNAME, 
			(char *) actual_obj_owner);

		    status = psl_norm_id_2_delim_id(&actual_obj_owner,
						    &name_len, delim_id,
						    &psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
			    return(status);

		    status = psq_tsubs(cb->pss_tchain, syn_owner,
				       actual_obj_owner, name_len,
				       &newpiece, &psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
		    {
			return(status);
		    }
		}

		/*
		** if (synonym name was different from the actual object name)
		** {
		**     if (user did not supply a corelation name)
		**     {
		**         insert actual object name before the synonym name
		**	   which will be used as corelation name;
		**     }
		**     else
		**     {
		**         replace synonym name with actual object name;
		**     }
		** }
		*/
		if (MEcmp((PTR) &$1->pss_obj_name, (PTR) &resrange->pss_tabname,
			  sizeof(DB_TAB_NAME)))
		{
		    u_char	*actual_tbl = (u_char *) &resrange->pss_tabname;

		    /* convert table name to a delimited identifier
		    ** (actual_tbl pointer gets overwritten)
		    */
		    name_len = psf_trmwhite(DB_MAXNAME, (char *) actual_tbl);

		    status = psl_norm_id_2_delim_id(&actual_tbl, 
						    &name_len, delim_id,
						    &psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
			    return(status);

		    if ($2 == (char *) NULL)
		    {
			/* no corelation name was supplied */

			/*
			** if synonym name was not prefixed with owner name and
			** the actual table owner name has not been already
			** inserted, we need to insert a blank before the actual
			** table name to separate it from the previous keyword.
			*/
			if (   ~$1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA
			    && ~$Yqry_mask & PSS_PREFIX_WITH_OWNER)
			{
			    /* Add a blank */
			    status = psq_tinsert(cb->pss_tchain, (u_char *) " ",
				sizeof(" ") - 1, &newpiece, align_ptr,
				&psq_cb->psq_error);
			    if (DB_FAILURE_MACRO(status))
				return (status);
			}

			status = psq_tinsert(cb->pss_tchain, actual_tbl, 
					     name_len, &newpiece,
					     align_ptr, &psq_cb->psq_error);
			if (DB_FAILURE_MACRO(status))
			    return (status);

			/*
			** if the table name was not prefixed with the owner
			** name, we don't need to add a blank between the actual
			** table name and the synonym name which will be used as
			** a corelation name because there had to be at least
			** one white char preceding the synonym name
			**
			** This is not quite correct, since the synonym name may
			** have immediately followed some non-blank separator,
			** e.g. comma in a from list:
			**
			**	create synonym andre.s for t;
			**	create view z as select 1 from s,s;
			**
			** will result in text
			**
			**    create view z as select 1 from andre.t s, andre.ts
			**
			** which is not very desirable.
			*/

			/* Add a blank */
			status = psq_tinsert(cb->pss_tchain, (u_char *) " ",
			    sizeof(" ") - 1, &newpiece, align_ptr,
			    &psq_cb->psq_error);
			if (DB_FAILURE_MACRO(status))
			    return (status);
		    }
		    else
		    {
			/*
			** psq_tsubs() strikes again; it may substitute a string
			** for a string preceeded by at least one blank and
			** screw things up as in
			**
			**	create synonym s for t;
			**	create permit select on s x to greg;
			**
			** becomes
			**
			**	create permit select ont x to greg.
			*/

			/* Add a blank */
			status = psq_tinsert(cb->pss_tchain, (u_char *) " ",
			    sizeof(" ") - 1, &newpiece, align_ptr,
			    &psq_cb->psq_error);
			if (DB_FAILURE_MACRO(status))
			    return (status);

			status = psq_tsubs(cb->pss_tchain, align_ptr,
					   actual_tbl, name_len,
					   &newpiece, &psq_cb->psq_error);
			if (DB_FAILURE_MACRO(status))
			    return(status);
		    }
		}
	    }
	}

	BTset(resrange->pss_rgno, (char*) &$Yflists[cb->pss_qualdepth]);

        if (cb->pss_qualdepth == 1)
        {
            if (BTcount((char *)&$Yflists[cb->pss_qualdepth], PST_NUMVARS) > 1)
            {
                /*
                ** FROM-list in the outermost subselect involves more than one
                ** relation - query will not be updateable
                */
                $Ynonupdt = TRUE;
                $Ynonupdt_reason |= PSS_MULT_VAR_IN_OUTERMOST_SUBSEL;
            }
            else if (psq_cb->psq_mode == PSQ_VIEW && !$Ynonupdt)
            {
                /*
                ** remember address of the range variable representing the new
                ** view's simply underlying table
                */
                $Yunderlying_rel = resrange;
            }
        }

	/*
	** save the address for future dereferencing.  Now, given range number,
	** I will get the pointer to a range variable without having to scan the
	** entire table
	*/
	$Yrng_vars[resrange->pss_rgno] = resrange;

	/*
	** productions such as integtbl may need to know thr value of
	** rngvar_info
	*/
	$Yrngvar_info = rngvar_info;
	
	$$ = resrange;	
    }
;

joined_table:	    cross_join
    {
	$$ = $1;
    }
			|   qualified_join
    {
	$$ = $1;
    }
			|   natural_join
    {
	$$ = $1;
    }
	    		|   LPAREN joined_table RPAREN
    {
	$$ = $2;
    }
;

qualified_join:	    from_list_item join_type from_list_item
    {
	DB_STATUS	status;
	PSS_1JOIN	    *join_info;
	PST_J_MASK	    mask;

	if (cb->pss_distrib & DB_3_DDB_SESS &&
	    cb->pss_stmt_flags & PSS_OUTER_OJ)
	{
	    i4	err_code;

	    (VOID) psf_error(5118L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		sizeof("OUTER JOIN syntax") - 1, "OUTER JOIN syntax");
	    return (E_DB_ERROR);
	}

	/* indicate that we will be processing join_search clause */
	BTset(++$Yqual_depth, $Yqual_type);

	/* Set the outer_relation masks for relations in this join */

	join_info = $Ypss_join_info.pss_join + $Ypss_join_info.depth;

	MEcopy((char *)$1, sizeof(PST_J_MASK), (char *)&mask);
	BTor(PST_NUMVARS, (char *)$3, (char *)&mask);

	if ((join_info->join_type & DB_FULL_JOIN) == DB_FULL_JOIN)
	{
	    /*
	    ** For FULL joins left AND right relations are marked as both inner
	    ** and outer
	    */
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, &mask, &mask, 
	                 (i4) join_info->join_id, $Yrng_vars, DB_FULL_JOIN);
	}
	else if (join_info->join_type & DB_LEFT_JOIN)
	{
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, $3, $1,
			 (i4) join_info->join_id, $Yrng_vars, DB_LEFT_JOIN);
	}
	else if (join_info->join_type & DB_RIGHT_JOIN)
	{
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, $1, $3,
			 (i4) join_info->join_id, $Yrng_vars, DB_RIGHT_JOIN);
	}
	else if (join_info->join_type & DB_INNER_JOIN)
	{
	    PST_J_MASK	mask1;
	    MEfill(sizeof(PST_J_MASK), 0, (char *)&mask1);
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, &mask, &mask1,
			 (i4) join_info->join_id, $Yrng_vars, DB_INNER_JOIN);
	}

	/* save masks representing left and right relations of this join */
	MEcopy((char *)$1, sizeof(PST_J_MASK), 
				(char *)&join_info->left_rels);
	MEcopy((char *)$3, sizeof(PST_J_MASK), 
				(char *)&join_info->right_rels);
    }
		    join_specification
    {
	DB_STATUS	status;
	PST_J_MASK	*mask;

        status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_J_MASK),
	         (PTR *) &mask, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}
	MEcopy((char *)$1, sizeof(PST_J_MASK), (char *)mask);
	BTor(PST_NUMVARS, (char *)$3, (char *)mask);

	$Yqual_depth--;		    /* done with this qualification */

	$Ypss_join_info.depth--;    /* done with this join */
	$$ = mask;
    }
;

cross_join:	    from_list_item CROSSJOIN from_list_item
    {
	DB_STATUS	status;
	PSS_1JOIN	    *join_info;
	PST_J_MASK	    *mask;

	/* Set the outer_relation masks for relations in this join */

	$Ypss_join_info.pss_join[++$Ypss_join_info.depth].join_type = 0x00;
	$Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id  = ++$Yjoin_id;
	join_info = $Ypss_join_info.pss_join + $Ypss_join_info.depth;

        status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_J_MASK),
	         (PTR *) &mask, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}
	MEcopy((char *)$1, sizeof(PST_J_MASK), (char *)mask);
	BTor(PST_NUMVARS, (char *)$3, (char *)mask);

	/* Cross joins are inner joins with no ON clause. */
	join_info->join_type |= DB_INNER_JOIN;
	cb->pss_stmt_flags |= PSS_INNER_OJ;
	psl_set_jrel(cb->pss_auxrng.pss_rngtab, mask, (PST_J_MASK *) NULL, 
			 (i4) join_info->join_id, $Yrng_vars, DB_INNER_JOIN);
	$Ypss_join_info.depth--;    /* done with this join */

	/* save masks representing left and right relations of this join */
	MEcopy((char *)$1, sizeof(PST_J_MASK), 
				(char *)&join_info->left_rels);
	MEcopy((char *)$3, sizeof(PST_J_MASK), 
				(char *)&join_info->right_rels);
	$$ = mask;
    }
;

/* The new natural join support merges bits of code from the old "natural"
** and "join_condition" (the empty syntax bit). Natural joins still don't
** conform to the standard - common columns from the sources are supposed
** to be coalesced before the user sees them (though we could figure that
** out) and the column order of the join result isn't followed. However, 
** these requirements seem a bit pedantic, so natural join will be restored
** for the time being. */

natural_join:	    from_list_item NATURAL join_type from_list_item
    {
	PSS_1JOIN	*join_info;
	PST_J_MASK	*mask;
	PST_QNODE	*qual = (PST_QNODE *) NULL;
	i4		left, right;
	PSS_RNGTAB	*left_rel, *right_rel;
	i4		left1, right1;
	PSS_RNGTAB	*left_rel1, *right_rel1;
	i4		cols;
	DMT_ATT_ENTRY	**left_attr, *right_attr;
	PST_QNODE	*var1, *var2, *oper;
	PST_VAR_NODE	var_node;
	PST_OP_NODE	op_node;
	DB_STATUS	status;
	i4		err_code;
	i4		rmask;
	bool		duperr;
	
	/* Not supported yet - just issue error. */
	(VOID) psf_error(5120L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 10);
	if (TRUE)	/* to eliminate compiler warning */
	    return(E_DB_ERROR);

	if (cb->pss_distrib & DB_3_DDB_SESS && 
	    cb->pss_stmt_flags & PSS_OUTER_OJ)
	{
	    (VOID) psf_error(5118L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		sizeof("OUTER JOIN syntax") - 1, "OUTER JOIN syntax");
	    return (E_DB_ERROR);
	}

	/* Set the outer_relation masks for relations in this join */

	join_info = $Ypss_join_info.pss_join + $Ypss_join_info.depth;

        status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_J_MASK),
	         (PTR *) &mask, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}
	MEcopy((char *)$1, sizeof(PST_J_MASK), (char *)mask);
	BTor(PST_NUMVARS, (char *)$4, (char *)mask);

	if ((join_info->join_type & DB_FULL_JOIN) == DB_FULL_JOIN)
	{
	    /*
	    ** For FULL joins left AND right relations are marked as both inner
	    ** and outer
	    */
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, mask, mask,
	                 (i4) join_info->join_id, $Yrng_vars, DB_FULL_JOIN);
	}
	else if (join_info->join_type & DB_LEFT_JOIN)
	{
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, $4, $1,
			 (i4) join_info->join_id, $Yrng_vars, DB_LEFT_JOIN);
	}
	else if (join_info->join_type & DB_RIGHT_JOIN)
	{
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, $1, $4,
			 (i4) join_info->join_id, $Yrng_vars, DB_RIGHT_JOIN);
	}
	else if (join_info->join_type & DB_INNER_JOIN)
	{
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, mask, (PST_J_MASK *) NULL,
			 (i4) join_info->join_id, $Yrng_vars, DB_INNER_JOIN);
	}

	$Ypss_join_info.pss_join[$Ypss_join_info.depth].join_type |=
								    DB_NAT_JOIN;
	/* save masks representing left and right relations of this join */
	MEcopy((char *)$1, sizeof(PST_J_MASK), 
				(char *)&join_info->left_rels);
	MEcopy((char *)$4, sizeof(PST_J_MASK), 
				(char *)&join_info->right_rels);


	/* Originally, there are no nodes to be reused */
	var1 = var2 = oper = (PST_QNODE *) NULL;

	/*
	** Initialize fields in op_node so we don't have to do it repeatedly
	** inside the loop
	*/
	op_node.pst_opno = ADI_EQ_OP;
	op_node.pst_opmeta = PST_NOMETA;
	op_node.pst_isescape = PST_DOESNT_APPLY;
	
	/* For natural joins we have to generate the join_search condition */
	for (left = -1;
	     (left = BTnext(left, (char *) &join_info->left_rels,
	                    PST_NUMVARS)) >= 0;
	    )
	{
	    left_rel = $Yrng_vars[left];
	    for (cols = 0, left_attr = left_rel->pss_attdesc + 1;
	         cols < left_rel->pss_tabdesc->tbl_attr_count;
		 cols++, left_attr++)
	    {
		for (right = -1;
		     (right = BTnext(right, (char *) &join_info->right_rels,
				     PST_NUMVARS)) >= 0;
		    )
		{
		    right_rel = $Yrng_vars[right];

		    /*
		    ** Check for like-named attributes.  If there are no
		    ** like-named attributes, go to next right relation
		    */
		    right_attr = pst_coldesc(right_rel,&(*left_attr)->att_name);
		    if (right_attr == (DMT_ATT_ENTRY *) NULL)
		    {
			continue;
		    }

		    /* See if the common column appears elsewhere in left or 
		    ** right join sources. This is NOT permitted. */
		    duperr = FALSE;
		    for (left1 = left; 
			(left1 = BTnext(left1, (char *) &join_info->left_rels,
	                    PST_NUMVARS)) >= 0 && !duperr; )
		    {
			/* Check for dup in rest of left rels. */
			left_rel1 = $Yrng_vars[left1];
			if (pst_coldesc(left_rel1, &(*left_attr)->att_name))
			    duperr = TRUE;	/* same col in another left rel */
		    }
		    if (!duperr)
		     for (right1 = right;
			(right1 = BTnext(right1, (char *) &join_info->right_rels,
	                    PST_NUMVARS)) >= 0 && !duperr; )
		    {
			/* Check for dup in rest of right rels. */
			right_rel1 = $Yrng_vars[right1];
			if (pst_coldesc(right_rel1, &(*left_attr)->att_name))
			    duperr = TRUE;	/* same col in another right rel */
		    }
		    if (duperr)
		    {
			i4		err_code;

			(VOID) psf_error(E_PS03A5_MULT_COMMON_COLS, 0L, PSF_USERERR,
	        	    &err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
			    &cb->pss_lineno, psf_trmwhite(DB_MAXNAME, 
			    (char *)&(*left_attr)->att_name),
			    (char *)&(*left_attr)->att_name);
			return (E_DB_ERROR);
		    }


		    /*
		    ** We may have a preallocated node representing a column in
		    ** the left relation.  If so, just reinitialize the fileds
		    ** in the node; otherwise, allocate AND initialize the
		    ** fields now.
		    */
		    STRUCT_ASSIGN_MACRO((*left_attr)->att_name,
					var_node.pst_atname);

		    var_node.pst_vno            = left;
		    var_node.pst_atno.db_att_id = (*left_attr)->att_number;

		    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			(PST_QNODE *) NULL, PST_VAR, (char *) &var_node,
			sizeof(var_node), (DB_DT_ID) (*left_attr)->att_type,
			(i2) (*left_attr)->att_prec,
			(i4) (*left_attr)->att_width, (DB_ANYTYPE *) NULL,
			&var1, &psq_cb->psq_error,
			(var1 == (PST_QNODE *) NULL) ? 0 : PSS_NOALLOC);

		    if (DB_FAILURE_MACRO(status))
		    {
			return(status);
		    }
		    var1->pst_sym.pst_dataval.db_collID =
						(*left_attr)->att_collID;

		    /*
		    ** We may have a preallocated node representing a column in
		    ** the right relation.  If so, just reinitialize the fileds
		    ** in the node; otherwise, allocate AND initialize the
		    ** fields now.
		    */

		    var_node.pst_vno            = right;
		    var_node.pst_atno.db_att_id = right_attr->att_number;

		    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			(PST_QNODE *) NULL, PST_VAR, (char *) &var_node,
			sizeof(var_node), (DB_DT_ID) right_attr->att_type,
			(i2) right_attr->att_prec, (i4) right_attr->att_width,
			(DB_ANYTYPE *) NULL, &var2, &psq_cb->psq_error,
			(var2 == (PST_QNODE *) NULL) ? 0 : PSS_NOALLOC);

		    if (DB_FAILURE_MACRO(status))
		    {
			return(status);
		    }
		    var2->pst_sym.pst_dataval.db_collID =
						right_attr->att_collID;

		    /*
		    ** We may have a preallocated node representing comparison.
		    ** If so, just reinitialize the fileds in the node;
		    ** otherwise, allocate AND initialize the fields now.
		    ** Also, since we are not sure if a comparison would be
		    ** legal, and the user should not see the results of out
		    ** vain attempts
		    */

		    rmask = PSS_NOTYPERES_ERR;
		    if (oper != (PST_QNODE *) NULL)
		    {
			/*
			** If oper node has already been allocated, we will make
			** var1 and var2 its children, and indicate to
			** pst_node() that only type resolution need to be
			** performed.
			*/
			oper->pst_left  = var1;
			oper->pst_right = var2;
			rmask |= PSS_TYPERES_ONLY;
		    }
			
		    status = pst_node(cb, &cb->pss_ostream, var1, var2,
			PST_BOP, (char *) &op_node, sizeof(op_node), DB_NODT,
			(i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, &oper,
			&psq_cb->psq_error, rmask);

		    /*
		    ** If the error resulted from an invalid comparison as would
		    ** be indicated by the PSS_NOTYPERES_ERR bit being reset,
		    ** continue; otherwise return to the caller
		    */
		    if (DB_FAILURE_MACRO(status))
		    {
			if (~rmask & PSS_NOTYPERES_ERR)
			{
			    continue;
			}
			
			return(status);
		    }

		    /*
		    ** If this is the first qualification, do not create AND
		    ** node, just make qual point at the PST_BOP we just created
		    */
		    if (qual == (PST_QNODE *) NULL)
		    {
			qual = oper;
		    }
		    else
		    {
			/*
			** The columns can indeed be compared.  Add the comparison
			** to our qualification
			*/
			
			status = pst_node(cb, &cb->pss_ostream, oper, qual,
			    PST_AND, (PTR) NULL, sizeof(PST_OP_NODE), DB_NODT,
			    (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, &qual,
			    &psq_cb->psq_error, (i4) 0);

			if (DB_FAILURE_MACRO(status))
			{
			    return(status);
			}
		    }
		    /* store join_id in the EQUAL node and in the AND node */
		    qual->pst_sym.pst_value.pst_s_op.pst_joinid =
			oper->pst_sym.pst_value.pst_s_op.pst_joinid =
			    join_info->join_id;

		    /*
		    ** Nodes pointed to by var1, var2, and oper have been used.
		    ** We will reset these ptrs to NULL to indicate that new
		    ** nodes need to be allocated
		    */
		    var1 = var2 = oper = (PST_QNODE *) NULL;
		}
	    }
	}

	/*
	** If this is the first join_search qualification, just make
	** j_qual->pss_qual point at it; otherwise build a new PST_AND
	** node with new qual and all the previously collected quals as
	** left and right children, respectively
	*/
	if ($Yj_qual->pss_qual == (PST_QNODE *) NULL)
	{
	    $Yj_qual->pss_qual = qual;
	}
	else
	{
	    status = pst_node(cb, &cb->pss_ostream, qual, $Yj_qual->pss_qual,
		PST_AND, (char *) NULL, sizeof(PST_OP_NODE), DB_NODT, (i2) 0,
		(i4) 0, (DB_ANYTYPE *) NULL, &$Yj_qual->pss_qual,
		&psq_cb->psq_error, (i4) 0);

	    if (DB_FAILURE_MACRO(status))
	    {
		return(status);
	    }

	    /* Note that pst_joinid was set to PST_NOJOIN in pst_node() */
	}

	/* indicate that we will be processing join_search clause */
	BTset(++$Yqual_depth, $Yqual_type);

	/* Set the outer_relation masks for relations in this join */

	join_info = $Ypss_join_info.pss_join + $Ypss_join_info.depth;

	if ((join_info->join_type & DB_FULL_JOIN) == DB_FULL_JOIN)
	{
	    /*
	    ** For FULL joins left AND right relations are marked as both inner
	    ** and outer
	    */
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, mask, mask,
	                 (i4) join_info->join_id, $Yrng_vars, DB_FULL_JOIN);
	}
	else if (join_info->join_type & DB_LEFT_JOIN)
	{
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, $4, $1,
			 (i4) join_info->join_id, $Yrng_vars, DB_LEFT_JOIN);
	}
	else if (join_info->join_type & DB_RIGHT_JOIN)
	{
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, $1, $4,
			 (i4) join_info->join_id, $Yrng_vars, DB_RIGHT_JOIN);
	}
	else if (join_info->join_type & DB_INNER_JOIN)
	{
	    psl_set_jrel(cb->pss_auxrng.pss_rngtab, mask, (PST_J_MASK *) NULL,
			 (i4) join_info->join_id, $Yrng_vars, DB_INNER_JOIN);
	}

	$Yqual_depth--;		    /* done with this qualification */
	$Ypss_join_info.depth--;    /* done with this join */
	$$ = mask;
    }
;

join_type:	    JOIN
    {
	$Ypss_join_info.pss_join[++$Ypss_join_info.depth].join_type =
								  DB_INNER_JOIN;
	$Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id  = ++$Yjoin_id;
	cb->pss_stmt_flags |= PSS_INNER_OJ;
    }
		|   INNERJOIN
    {
	$Ypss_join_info.pss_join[++$Ypss_join_info.depth].join_type =
								  DB_INNER_JOIN;
	$Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id  = ++$Yjoin_id;
	cb->pss_stmt_flags |= PSS_INNER_OJ;
    }
		|   INTERSECTJOIN
    {
	$Ypss_join_info.pss_join[++$Ypss_join_info.depth].join_type =
							  DB_INTERSECT_JOIN;
	$Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id  = ++$Yjoin_id;
	cb->pss_stmt_flags |= PSS_INNER_OJ;
    }
		|   LEFTANTI
    {
	$Ypss_join_info.pss_join[++$Ypss_join_info.depth].join_type =
								  DB_LANTI_JOIN;
	$Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id  = ++$Yjoin_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    }
		|   LEFTANTI JOIN
    {
	$Ypss_join_info.pss_join[++$Ypss_join_info.depth].join_type =
								  DB_LANTI_JOIN;
	$Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id  = ++$Yjoin_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    }
		|   LEFTJOIN
    {
	$Ypss_join_info.pss_join[++$Ypss_join_info.depth].join_type =
								  DB_LEFT_JOIN;
	$Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id  = ++$Yjoin_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    }
		|   LEFTOUTER JOIN
    {
	$Ypss_join_info.pss_join[++$Ypss_join_info.depth].join_type =
								  DB_LEFT_JOIN;
	$Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id  = ++$Yjoin_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    }
		|   RIGHTANTI
    {
	$Ypss_join_info.pss_join[++$Ypss_join_info.depth].join_type =
								  DB_RANTI_JOIN;
	$Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id  = ++$Yjoin_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    }
		|   RIGHTANTI JOIN
    {
	$Ypss_join_info.pss_join[++$Ypss_join_info.depth].join_type =
								  DB_RANTI_JOIN;
	$Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id  = ++$Yjoin_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    }
		|   RIGHTJOIN
    {
	$Ypss_join_info.pss_join[++$Ypss_join_info.depth].join_type =
								  DB_RIGHT_JOIN;
	$Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id  = ++$Yjoin_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    }
		|   RIGHTOUTER JOIN
    {
	$Ypss_join_info.pss_join[++$Ypss_join_info.depth].join_type =
								  DB_RIGHT_JOIN;
	$Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id  = ++$Yjoin_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    }
		|   FULLANTI
    {
	$Ypss_join_info.pss_join[++$Ypss_join_info.depth].join_type =
								  DB_FANTI_JOIN;
	$Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id  = ++$Yjoin_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    }
		|   FULLANTI JOIN
    {
	$Ypss_join_info.pss_join[++$Ypss_join_info.depth].join_type =
								  DB_FANTI_JOIN;
	$Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id  = ++$Yjoin_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    }
		|   FULLJOIN
    {
	$Ypss_join_info.pss_join[++$Ypss_join_info.depth].join_type =
								  DB_FULL_JOIN;
	$Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id  = ++$Yjoin_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    }
		|   FULLOUTER JOIN
    {
	$Ypss_join_info.pss_join[++$Ypss_join_info.depth].join_type =
								  DB_FULL_JOIN;
	$Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id  = ++$Yjoin_id;
	cb->pss_stmt_flags |= PSS_OUTER_OJ;
    }
;

join_specification: join_condition
		|    named_columns_join
;

join_condition: ON boolean_expr
    {
	DB_STATUS	status;

	/*
	** If this is the first join_search qualification, just make
	** j_qual->pss_qual point at it; otherwise build a new PST_AND
	** node with new qual and all the previously collected quals as
	** left and right children, respectively
	*/
	if ($Yj_qual->pss_qual == (PST_QNODE *) NULL)
	{
	    $Yj_qual->pss_qual = $2->pss_tree;
	}
	else
	{
	    status = pst_node(cb, &cb->pss_ostream, $2->pss_tree,
		$Yj_qual->pss_qual, PST_AND, (char *) NULL, sizeof(PST_OP_NODE),
		DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
		&$Yj_qual->pss_qual, &psq_cb->psq_error, (i4) 0);

	    if (DB_FAILURE_MACRO(status))
	    {
		return(status);
	    }

	    /* Note that pst_joinid was set to PST_NOJOIN in pst_node() */
	}
    }
;

named_columns_join: USING LPAREN named_collist RPAREN
;

named_collist:		named_column
		|    named_collist COMMA named_column
;

named_column:		generic_ident
    {
	PSS_1JOIN	*join_info;
	i4		left, right;
	PSS_RNGTAB	*left_rel, *right_rel;
	i4		cols;
	DMT_ATT_ENTRY	*left_attr, *right_attr;
	DB_ATT_NAME	colname;
	PST_QNODE	*var1, *var2, *oper;
	PST_VAR_NODE	var_node;
	PST_OP_NODE	op_node;
	DB_STATUS	status;
	i4		mask;
	bool		found = FALSE;
	
	join_info = $Ypss_join_info.pss_join + $Ypss_join_info.depth;

	/* Originally, there are no nodes to be reused */
	var1 = var2 = oper = (PST_QNODE *) NULL;

	/*
	** Initialize fields in op_node so we don't have to do it repreatedly
	** inside the loop
	*/
	op_node.pst_opno = ADI_EQ_OP;
	op_node.pst_opmeta = PST_NOMETA;
	op_node.pst_isescape = PST_DOESNT_APPLY;
	
	/* For named column joins we have to generate the join_search condition */
	for (left = -1;
	     (left = BTnext(left, (char *) &join_info->left_rels,
	                    PST_NUMVARS)) >= 0;
	    )
	{
	    /* First, look for the column in the left join source. */
	    left_rel = $Yrng_vars[left];
	    STmove($1, ' ', DB_MAXNAME, (char *)&colname);
	    left_attr = pst_coldesc(left_rel, &colname);
	    if (left_attr == NULL)
		continue;

	    for (right = -1;
		 (right = BTnext(right, (char *) &join_info->right_rels,
				     PST_NUMVARS)) >= 0;
		    )
	    {
		/* Now look for the column in the right join source. */
		right_rel = $Yrng_vars[right];
		right_attr = pst_coldesc(right_rel,&left_attr->att_name);
		if (right_attr == (DMT_ATT_ENTRY *) NULL)
			continue;
		found = TRUE;	/* found it in both */

		/* Allocate the PST_VAR for the column in left source. */
		STRUCT_ASSIGN_MACRO(left_attr->att_name,
					var_node.pst_atname);

		var_node.pst_vno            = left;
		var_node.pst_atno.db_att_id = left_attr->att_number;

		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			(PST_QNODE *) NULL, PST_VAR, (char *) &var_node,
			sizeof(var_node), (DB_DT_ID) left_attr->att_type,
			(i2) left_attr->att_prec,
			(i4) left_attr->att_width, (DB_ANYTYPE *) NULL,
			&var1, &psq_cb->psq_error, 0);

		if (DB_FAILURE_MACRO(status))
		{
		    return(status);
		}
		var1->pst_sym.pst_dataval.db_collID = left_attr->att_collID;

		/* Allocate the PST_VAR for the column in right source. */

		var_node.pst_vno            = right;
		var_node.pst_atno.db_att_id = right_attr->att_number;

		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			(PST_QNODE *) NULL, PST_VAR, (char *) &var_node,
			sizeof(var_node), (DB_DT_ID) right_attr->att_type,
			(i2) right_attr->att_prec, (i4) right_attr->att_width,
			(DB_ANYTYPE *) NULL, &var2, &psq_cb->psq_error, 0);

		if (DB_FAILURE_MACRO(status))
		{
		    return(status);
		}
		var2->pst_sym.pst_dataval.db_collID = right_attr->att_collID;

		/* Allocate the PST_BOP node to perform the "=" comparison. */

		status = pst_node(cb, &cb->pss_ostream, var1, var2,
			PST_BOP, (char *) &op_node, sizeof(op_node), DB_NODT,
			(i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, &oper,
			&psq_cb->psq_error, 0);

		/*
		** If the error resulted from an invalid comparison as would
		** be indicated by the PSS_NOTYPERES_ERR bit being reset,
		** continue; otherwise return to the caller
		*/
		if (DB_FAILURE_MACRO(status))
		{
/*
		    if (~mask & PSS_NOTYPERES_ERR)
		    {
			continue;
		    }
*/
			
		    return(status);
		}

		/*
		** If this is the first join_search qualification, just make
		** j_qual->pss_qual point at it; otherwise build a new PST_AND
		** node with new qual and all the previously collected quals as
		** left and right children, respectively */

		if ($Yj_qual->pss_qual == (PST_QNODE *) NULL)
		{
		    $Yj_qual->pss_qual = oper;
		}
		else
		{
		    status = pst_node(cb, &cb->pss_ostream, oper, 
			    $Yj_qual->pss_qual, PST_AND, (char *) NULL, 
			    sizeof(PST_OP_NODE), DB_NODT, (i2) 0,
			    (i4) 0, (DB_ANYTYPE *) NULL, &$Yj_qual->pss_qual,
			    &psq_cb->psq_error, (i4) 0);

		    if (DB_FAILURE_MACRO(status))
		    {
			return(status);
		    }
		}
		/* Store join_id in the EQUAL node. */
		oper->pst_sym.pst_value.pst_s_op.pst_joinid =
			    join_info->join_id;
	    }
	}

	/* If the column wasn't found in both left and right join sources,
	** report the error. */
	if (!found)
	{
	    i4		err_code;

	    (VOID) psf_error(E_PS03AC_MISSING_COLUMN, 0L, PSF_USERERR,
	        &err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, psf_trmwhite(DB_MAXNAME, (char *)&colname),
		&colname);
	    return (E_DB_ERROR);
	}

    }
;

where:			where_word
    {
	/*
	** if there is an aggregate function anywhere in the where_clause, it is
	** illegal for it to be correlated to any range vars from the subselect
	** at this depth.
	*/
	BTor(BITS_IN($Yillegal_agg_relmask),
	     (char *) &$Yflists[cb->pss_qualdepth],
	     (char *) &$Yillegal_agg_relmask);
	$Yin_where_clause++;		/* level of where nesting */
    }
			boolean_expr
    {
	/*
	** Since we are done with this where_clause, remove relations which
	** appeared at this level from $Yillegal_agg_relmask
	*/
	BTnot(  BITS_IN($Yflists[cb->pss_qualdepth]),
		(char *) &$Yflists[cb->pss_qualdepth]);
	BTand(  BITS_IN($Yillegal_agg_relmask),
		(char *) &$Yflists[cb->pss_qualdepth],
		(char *) &$Yillegal_agg_relmask);
	BTnot(  BITS_IN($Yflists[cb->pss_qualdepth]),
		(char *) &$Yflists[cb->pss_qualdepth]);

	$Yin_where_clause--;
	$$ = $3->pss_tree;
    }
		|
    {
	DB_STATUS	status;
	PST_QNODE	*nonode;

	/* Create a QLEND node. */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_QLEND, (PTR) NULL, 0, DB_NODT, (i2) 0,
	    (i4) 0, (DB_ANYTYPE *) NULL, &nonode, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	$$ = nonode;
    }
;

where_word:		WHERE
;

groupby:	  	group_by group_list
    {
	i4	err_code;

	if ($Yseq_ops)
	{
	    /* No use of sequences in grouped selects. */
	    (void)psf_error(6319L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	$Yin_groupby_clause = FALSE;
	$$ = $2;
    }
		|
    {
	$$ = NULL;
    }
;

group_by:   GROUP BY
    {
	/*
	** set in_groupby_clause so that we don't get correlated columns in the
	** group by list.
	*/
	$Yin_groupby_clause = TRUE;

	/* Mark this SELECT stmnt as non-updatable */
	if (cb->pss_qualdepth == 1 || 
		cb->pss_qualdepth == 2 && $Yprev_yyvarsp)
	{
	    $Ynonupdt = TRUE;
	    $Ynonupdt_reason |= PSS_GROUP_BY_IN_OUTERMOST_SUBSEL;
	}

    }
;

having:			having_word
    {
	    $Yinhaving++;
    }
			boolean_expr
    {
	/* Mark this SELECT stmnt as non-updatable */
	if (cb->pss_qualdepth == 1 ||
		cb->pss_qualdepth == 2 && $Yprev_yyvarsp)
	{
	    $Ynonupdt = TRUE;
	    $Ynonupdt_reason |= PSS_HAVING_IN_OUTERMOST_SUBSEL;
	}

	$Yinhaving--;
	$$ = $3->pss_tree;
    }
		|
    {
	$$ = NULL;
    }
;

having_word:		HAVING
;

group_list:	   	select_expr
    {
	PST_QNODE              *newnode;
	DB_STATUS	       status;
	PST_RSDM_NODE	       resdom;

	/* Make RESDOM for grouping column/expression. */
	resdom.pst_ntargno = (i4) 0;
	resdom.pst_ttargtype = (i4) PST_ATTNO;
	resdom.pst_rsupdt = FALSE;
	resdom.pst_rsflags = PST_RS_PRINT;  /* was |= ... */
	resdom.pst_dmuflags = 0;
	/* GROUP BY list element must be numbered */
	resdom.pst_rsno = $Ybylist_elem_no = 1;

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL, $1,
	    PST_RESDOM, (PTR) &resdom, sizeof(PST_RSDM_NODE),
	    $1->pst_sym.pst_dataval.db_datatype, 
	    $1->pst_sym.pst_dataval.db_prec, $1->pst_sym.pst_dataval.db_length,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
		|	group_list COMMA select_expr
    {
	PST_QNODE              *newnode;
	DB_STATUS	       status;
	PST_RSDM_NODE	       resdom;

	/* Make RESDOM for grouping column/expression. */

	resdom.pst_ntargno = (i4) 0;
	resdom.pst_ttargtype = (i4) PST_ATTNO;
	resdom.pst_rsupdt = FALSE;
	resdom.pst_rsflags = PST_RS_PRINT;  /* was |= ... */
	resdom.pst_dmuflags = TRUE;
	resdom.pst_rsno = ++$Ybylist_elem_no;

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL, $3, 
	    PST_RESDOM, (PTR) &resdom, sizeof(PST_RSDM_NODE),
	    $3->pst_sym.pst_dataval.db_datatype, 
	    $3->pst_sym.pst_dataval.db_prec, $3->pst_sym.pst_dataval.db_length,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/* link the values of the left side */
	$$ = pst_tlprpnd($1, newnode);
    }
;

cname:			col_ref
    {
	PST_QNODE	*newnode = (PST_QNODE *) NULL;
	DB_STATUS	status;
	i4		err_code;
	PSS_RNGTAB      *rngvar;

        if (psq_cb->psq_mode == PSQ_DDEXECPROC)
        {
	    /* execution of regproc; bypass parsing */
	    $$ = NULL;
	    break;
	}

	if (!($1->pss_flags &
	          (PSS_TBL_OR_CORR_NAME_SPECIFIED | PSS_TBL_SPECIFIED)))
	{
	    /* column was specified */
	    
	    DB_ATT_NAME	    colname;
            bool            found_resdom = FALSE;
            bool            found_var = FALSE;
	    PSS_DECVAR	    *var;

	    if ($Yin_rule == TRUE)
	    {
		/* If in rule MUST be qualified */
		_VOID_ psf_error(E_US189F_6303_RULE_COL, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1,
		    STlength($1->pss_col_name), $1->pss_col_name);
		return (E_DB_ERROR);
	    }

	    STmove($1->pss_col_name, ' ', sizeof(DB_ATT_NAME),
		(char *) &colname);

	    if ($Yisdbp == TRUE)
	    {
		/* Search for the variable; innermost scope first. */
		for (var = (PSS_DECVAR *) $Ydbpinfo->pss_varq.q_next;
		     var != (PSS_DECVAR *) &$Ydbpinfo->pss_varq;
		     var = (PSS_DECVAR *) var->pss_queue.q_next
		    )
		{
		    if (var->pss_out)
			continue;

		    if (MEcmp((PTR) &colname, (PTR) &var->pss_varname,
			sizeof(var->pss_varname)) == 0
		       )
		    {
			found_var = TRUE;
			break;
		    }
		}
	    }

	    /* If CALLPROC and either not a local var or simple column name */
	    if (psq_cb->psq_mode == PSQ_CALLPROC && !found_var)
	    {
		/* Unknown local variable or isolated column specified */
		(VOID) psf_error($Yisdbp ? 2403L : E_US0986_2438_EXEC_COL, 0L,
		    PSF_USERERR, &err_code, &psq_cb->psq_error, 1,
		    STlength($1->pss_col_name), $1->pss_col_name);
		return (E_DB_ERROR);
	    }

	    /* if parsing a check constraint, we are collecting text
	    ** in 2 separate chains, and the 2nd chain must contain the 
	    ** correlation name NEW (for later use in creating a rule).
	    ** So add "NEW." to the chain.
	    */
	    if (cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS)
	    {
		PTR	oldpiece, newpiece;
		
		/* get a pointer to the column name (which is the
		** next-to-last text piece, as the scanner/grammar
		** has to lookahead to get to this token)
		*/
		oldpiece = psq_tbackfromlast(cb->pss_tchain2, 1);
		if (oldpiece == (PTR) NULL)
		{
		    psf_error(E_PS0002_INTERNAL_ERROR, 0L, PSF_INTERR,
			      &err_code, &psq_cb->psq_error, 0);
		    return(E_DB_OK);
		}

		status = psq_tinsert(cb->pss_tchain2, 
				     (u_char *) ERx(" NEW."),
				     sizeof(ERx(" NEW."))-1,
				     &newpiece, oldpiece,
				     &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return (status);

	    }  /* end if PSS_PARSING_CHECK_CONS */

	    /*
	    ** Since we will no longer expect to see the from_list before we see
	    ** target list, we can do very little when we see a name which may
	    ** or may not turn out to be a column name.  If we are in the
	    ** process of parsing the target clause, simply generate a VAR node,
	    ** and do all the necessary checking later.
	    ** (rjb) Do same thing when parsing a check constraint specified as
	    ** a part of CREATE TABLE statement, since a user can define a check
	    ** constraint before defining the columns in the table.
	    */
	    if ($Yin_target_clause
		|| (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		    && ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		         ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	    {
		PST_VAR_NODE	varnode;

		MEfill(sizeof(PST_VAR_NODE), '\0', (PTR)&varnode);
		STRUCT_ASSIGN_MACRO(colname, varnode.pst_atname);

		/*
		** If local var was found, allocate enough space to accomodate
		** it in case no attribute will be found
		*/
		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		    (PST_QNODE *) NULL, PST_VAR, (char *) &varnode,
		    (found_var) ? max(sizeof(PST_VAR_NODE), 
                    sizeof(PST_CNST_NODE)) : sizeof(varnode),
		    DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, &newnode,
		    &psq_cb->psq_error, (i4) 0);

		if (DB_FAILURE_MACRO(status))
		{
		    return(status);
		}
	    }
	    else
	    {
		/*
		** For each range entry look for attribute in relation in the
		** FROM list.  If there is no FROM list, do not bother to call
		** psl_fatt
		*/
		if ($Yin_groupby_clause && 
		    BTcount((char *)&$Yflists[cb->pss_qualdepth], 
				PST_NUMVARS) == 0)
		{
		    /* If column was not found but there is a var */
		    if ($Yisdbp && found_var)
		    {
			/* Create a CNST node for the var. */
			PST_CNST_NODE	cconst;

			/* Parm or local variable */
			cconst.pst_tparmtype = PST_LOCALVARNO;
			cconst.pst_parm_no = var->pss_no;
			cconst.pst_pmspec  = PST_PMNOTUSED;
			cconst.pst_cqlang = DB_SQL;
			cconst.pst_origtxt = (char *) NULL;
			status = pst_node(cb, &cb->pss_ostream,
			    (PST_QNODE *) NULL, (PST_QNODE *) NULL,
			    PST_CONST, (char *) &cconst, sizeof(cconst),
			    var->pss_dbdata.db_datatype,
			    (i2) var->pss_dbdata.db_prec,
			    (i4) var->pss_dbdata.db_length, 
			    (DB_ANYTYPE *) var->pss_dbdata.db_data,
			    &newnode, &psq_cb->psq_error, (i4) 0);
			if (DB_FAILURE_MACRO(status))
			    return (status);
		    }
		    else
		    {
			(VOID) psf_error(2103L, 0L, PSF_USERERR, &err_code,
			    &psq_cb->psq_error, 2,
			    (i4) sizeof(cb->pss_lineno),
			    &cb->pss_lineno,
			    (i4) STtrmwhite($1->pss_col_name),
			    $1->pss_col_name);
			return (E_DB_ERROR);
		    }
		}
		else
		{
		    PSS_1JOIN   *join_info;
		    PST_J_MASK    join_rels;
		    i4	    mask;

		    if (BTtest($Yqual_depth, $Yqual_type))
		    {
			join_info = $Ypss_join_info.pss_join +
			    $Ypss_join_info.depth;
			mask = JOINREL_MASK;
			MEcopy((char *)&join_info->left_rels,
			    sizeof(PST_J_MASK), (char *)&join_rels);
			BTor(PST_NUMVARS, (char *) &join_info->right_rels,
			     (char *) &join_rels);
		    }
		    else
		    {
			mask = 0;
			MEfill(sizeof(PST_J_MASK), 0, (char *)&join_rels);
		    }
			
                    /* found_var (previously found) may be true but
                    ** if we are in an ORDER BY the host variable would
                    ** not be valid anyway so we should over-ride the
                    ** 'find' if we have a matching resdom and we're in
                    ** an ORDER BY. We should then ensure we do not enter
                    ** the var logic in the follow IF statement.
                    */

                    if ($Yin_orderby)
                    {
                        PST_QNODE	*resdomp;
                    
                        for (resdomp = cb->pss_tlist; resdomp &&
                            resdomp->pst_sym.pst_type == PST_RESDOM;
                            resdomp = resdomp->pst_left)
                        if (!MEcmp((char *)&colname, 
                            (char *)&resdomp->pst_sym.pst_value.pst_s_rsdm.pst_rsname,
                            DB_MAXNAME))
                        {
                            found_resdom = TRUE;  /* got matching RESDOM */
                            newnode = resdomp;
                            break;
                        }
                    }
		    
		    if (!found_var || found_resdom)
		    {
			if (!found_var && !found_resdom) /* there must be a column */
			{
			    /* find attribute */
			    status = psl_fatt(cb, psq_cb, 
				$Yin_orderby | $Yin_groupby_clause, 
				&colname, &newnode, &rngvar, mask | ALLOC_NODE,
				&join_rels);
			    if (DB_FAILURE_MACRO(status))
				return (status);

			    if (rngvar->pss_rgparent != cb->pss_qualdepth)
			    {
				register i4	i;
				/*
				** pss_rgparent MUST be < pss_qualdepth; we set
				** the bit in the correlation for all levels
				** starting with pss_rgparent+1 to pss_qualdepth
				*/
				for (i = rngvar->pss_rgparent +1;
				     i <= cb->pss_qualdepth; i++)
				{
				    BTset(i, (char *) $Ycorrelation_mask);
				}

				if ($Ymult_corr_attrs.depth != -1 &&
				    !$Ymult_corr_attrs.found)
				{
				    if ($Ymult_corr_attrs.rgno == -1)
				    {
					$Ymult_corr_attrs.rgno =
					    rngvar->pss_rgno;
				    }
				    else if ($Ymult_corr_attrs.rgno !=
					 rngvar->pss_rgno)
				    {
					$Ymult_corr_attrs.found = TRUE;
				    }
				}

				if ($Ycorr_aggr.depth != -1)
				{
				    $Ycorr_aggr.found = TRUE;
				}
			    }
			}
		    }    
		    else			/* there is a var */
		    {
			/* There is a local var and we do not want any error
			** messages to be send to user yet.
			*/

			/*
			** find if there is also an attribute (check only)
			*/
			status = psl_fatt(cb, psq_cb, 
			    $Yin_orderby | $Yin_groupby_clause, 
			    &colname, &newnode, &rngvar, mask | FIND_ONLY,
			    &join_rels);
			if (DB_FAILURE_MACRO(status))
			{
			    /* Column was not found, therefore
			    ** create a CNST node for the var.
			    */
			    PST_CNST_NODE	cconst;

			    /* Parm or local variable */
			    cconst.pst_tparmtype = PST_LOCALVARNO;
			    cconst.pst_parm_no = var->pss_no;
			    cconst.pst_pmspec  = PST_PMNOTUSED;
			    cconst.pst_cqlang = DB_SQL;
			    cconst.pst_origtxt = (char *) NULL;
			    status = pst_node(cb, &cb->pss_ostream,
				(PST_QNODE *) NULL, (PST_QNODE *) NULL,
				PST_CONST, (char *) &cconst, sizeof(cconst),
				var->pss_dbdata.db_datatype,
				(i2) var->pss_dbdata.db_prec,
				(i4) var->pss_dbdata.db_length, 
				(DB_ANYTYPE *) var->pss_dbdata.db_data,
				&newnode, &psq_cb->psq_error, (i4) 0);
			    if (DB_FAILURE_MACRO(status))
				return (status);
			}
			else
			{
			    /* Column was found, reexecute call to psl_fatt,
			    ** this time create a var node for the column.
			    */
			    status = psl_fatt(cb, psq_cb,
				$Yin_orderby | $Yin_groupby_clause, 
				&colname, &newnode,
				&rngvar, mask | ALLOC_NODE, &join_rels);
			    if (DB_FAILURE_MACRO(status))
				return (status);

			    if (rngvar->pss_rgparent != cb->pss_qualdepth)
			    {
				register i4	i;
				/*
				** pss_rgparent MUST be < pss_qualdepth;
				** we set the bit in the correlation for
				** all levels starting with pss_rgparent+1
				** to pss_qualdepth
				*/
				for (i = rngvar->pss_rgparent +1;
				     i <= cb->pss_qualdepth; i++)
				{
				    BTset(i, (char *) $Ycorrelation_mask);
				}

				if ($Ymult_corr_attrs.depth != -1 &&
				    !$Ymult_corr_attrs.found)
				{
				    if ($Ymult_corr_attrs.rgno == -1)
				    {
					$Ymult_corr_attrs.rgno =
					    rngvar->pss_rgno;
				    }
				    else if ($Ymult_corr_attrs.rgno !=
					     rngvar->pss_rgno)
				    {
					$Ymult_corr_attrs.found = TRUE;
				    }
				}

				if ($Ycorr_aggr.depth != -1)
				{
				    $Ycorr_aggr.found = TRUE;
				}
			    }
			}
		    }
		}
	    }
	}
	else
	{
	    /* [schema.]table.column was specified */
	    
	    DMT_ATT_ENTRY       *attribute;
	    PST_VAR_NODE	varnode;
	    PST_RL_NODE		rulenode;

	    /* 
	    ** first find a range var referred in this <column reference>
	    ** or, if we are processing an element of a target list, get an
	    ** address of a <table reference> description which we'll be
	    ** able to dereference once the FROM list has been parsed
	    */
	    status = psl_tbl_ref(psq_cb, cb, $1, $Yin_target_clause,
		$Yin_groupby_clause, &$Ytbl_refs, &rngvar);
	    if (DB_FAILURE_MACRO(status))
		return(status);

	    MEfill(sizeof(PST_VAR_NODE), '\0', (PTR)&varnode);

	    /* Normalize the attribute name */
	    STmove($1->pss_col_name, ' ', sizeof(DB_ATT_NAME), 
		(char *) &varnode.pst_atname);

	    /* if parsing a check constraint, we are collecting text
	    ** in 2 separate chains, and the 2nd chain must use the 
	    ** correlation name NEW (for later use in creating a rule).
	    ** So delete the pieces containing <schema name> and "." (if
	    ** schema name was specified) and replace existing correlation name
	    ** with " NEW"
	    */
	    if (cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS)
	    {
		PTR	    oldpiece, corr_piece;
		
		/*
		** backtrack past the column name and period
		** if schema name was specified, the last piece in the chain
		** will contain column name; otherwise, YACC would look ahead
		** one token
		*/
		oldpiece = psq_tbackfromlast(cb->pss_tchain2,
		    ($1->pss_flags & PSS_SCHEMA_SPECIFIED) ? 2 : 3);
		if (oldpiece == (PTR) NULL)
		{
		    psf_error(E_PS0002_INTERNAL_ERROR, 0L, PSF_INTERR,
			      &err_code, &psq_cb->psq_error, 0);
		    return(E_DB_OK);
		}

		/* replace correlation name with NEW */
		status = psq_tsubs(cb->pss_tchain2, oldpiece,
				   (u_char *) ERx(" NEW"),
				   sizeof(ERx(" NEW"))-1,
				   &corr_piece, &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return (status);

		/*
		** if have a schema name, delete pieces containing <schema name>
		** and period
		*/
		if ($1->pss_flags & PSS_SCHEMA_SPECIFIED)
		{
		    /*
		    ** backtrack from the piece containing " NEW", and delete
		    ** piece containing period
		    */
		    oldpiece = psq_tbacktrack(corr_piece, 1);
		    if (oldpiece == (PTR) NULL)
		    {
			psf_error(E_PS0002_INTERNAL_ERROR, 0L, PSF_INTERR,
				  &err_code, &psq_cb->psq_error, 0);
			return(E_DB_OK);
		    }

		    psq_tdelete(cb->pss_tchain2, oldpiece);

		    /*
		    ** backtrack from the piece containing " NEW",and delete the
		    ** piece containing schema name
		    */
		    oldpiece = psq_tbacktrack(corr_piece, 1);
		    if (oldpiece == (PTR) NULL)
		    {
			psf_error(E_PS0002_INTERNAL_ERROR, 0L, PSF_INTERR,
				  &err_code, &psq_cb->psq_error, 0);
			return(E_DB_OK);
		    }

		    psq_tdelete(cb->pss_tchain2, oldpiece);
		}  /* end if PSS_SCHEMA_SPECIFIED) */
	    }  /* end if PSS_PARSING_CHECK_CONS */

	    if ($Yin_target_clause
		|| (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		    && ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		         ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	    {
		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		    (PST_QNODE *) NULL, PST_VAR, (char *) &varnode, 
		    sizeof(varnode), DB_NODT, (i2) 0, (i4) 0, 
		    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);

		if (DB_FAILURE_MACRO(status))
		    return(status);

		newnode->pst_sym.pst_dataval.db_data = (PTR) rngvar;
	    }
	    else
	    {
		DMT_ATT_ENTRY	    tid_att;
		
		/*
		** If processing join_search condition, only relations involved
		** in the join may appear in the join_search condition
		*/
		if (BTtest($Yqual_depth, $Yqual_type))
		{
		    PSS_1JOIN	    *join_info = $Ypss_join_info.pss_join +
						 $Ypss_join_info.depth;

		    if (!BTtest((i4) rngvar->pss_rgno,
				(char *) &join_info->left_rels)
			&&
			!BTtest((i4) rngvar->pss_rgno,
				(char *) &join_info->right_rels)
		       )
		    {
			/*
			** we ARE processing join_search condition and the user
			** tried to refer to a relation which is nether a left
			** nor a right relation for this join.
			*/
			(VOID) psf_error(E_PS03A4_NOT_A_JREL, 0L, PSF_USERERR,
			    &err_code, &psq_cb->psq_error, 2,
			    sizeof(cb->pss_lineno), &cb->pss_lineno,
			    psf_trmwhite(DB_MAXNAME, rngvar->pss_rgname),
			    rngvar->pss_rgname);
			return(E_DB_ERROR);
		    }
		}

		/* Look up the attribute */
		attribute = pst_coldesc(rngvar, &varnode.pst_atname);

		/* Check for attribute not found */
		if (attribute == (DMT_ATT_ENTRY *) NULL)
		{
		    /*
		    ** if rngvar represents a view V and column name was TID, we
		    ** will fabricate an attribute entry for V.TID and remember
		    ** that TID attribute of V was referenced;
		    ** at qrymod time, if the V is updatable, we will translate
		    ** the reference to V.TID to the the reference to TID of V's
		    ** underlying base table, otherwise, an error will be issued
		    */
		    if (   rngvar->pss_tabdesc->tbl_status_mask & DMT_VIEW
			&& !STcompare($1->pss_col_name, 
				      ((*cb->pss_dbxlate & CUI_ID_REG_U) ?
				       "TID" : "tid")))
		    {
			rngvar->pss_var_mask |= PSS_TID_REFERENCE;
			
			attribute = &tid_att;
			psl_bld_tid_descr(attribute, cb);
		    }
		    else
		    {
			if (cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS)
			{
			    char        command[PSL_MAX_COMM_STRING];
			    i4     length;

			    psl_command_string(psq_cb->psq_mode, DB_SQL,
				command, &length);

			    _VOID_ psf_error(E_PS0483_CONS_NO_COL, 0L,
				PSF_USERERR, &err_code, &psq_cb->psq_error, 3,
				length, command,
				(i4) STtrmwhite($1->pss_col_name),
				$1->pss_col_name,
				sizeof(ERx("CHECK")) - 1, ERx("CHECK"));
			}
			else
			{
			    (VOID) psf_error(2100L, 0L, PSF_USERERR, 
				&err_code, &psq_cb->psq_error, 4,
				(i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
				psf_trmwhite(sizeof(DB_TAB_NAME), 
				    (char *) &rngvar->pss_tabname),
				&rngvar->pss_tabname,
				psf_trmwhite(sizeof(DB_OWN_NAME), 
				    (char *) &rngvar->pss_ownname),
				&rngvar->pss_ownname, 
				(i4) STtrmwhite($1->pss_col_name), 
				$1->pss_col_name);
			}
			return (E_DB_ERROR);
		    }
		}

		/* 
		** If processing a CREATE RULE statement then create a RULEVAR 
		** node, otherwise create a VAR node.
		*/
		if ($Yin_rule == TRUE)
		{
							/* PST_BEFORE/AFTER */
		    rulenode.pst_rltype     = rngvar->pss_image;  

		    rulenode.pst_rltargtype = PST_ATTNO;
		    rulenode.pst_rltno	    = attribute->att_number;
		    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL,
			(PST_QNODE *)NULL, PST_RULEVAR, (char *)&rulenode,
			sizeof(rulenode), (DB_DT_ID)attribute->att_type,
			(i2)attribute->att_prec, (i4)attribute->att_width,
			(DB_ANYTYPE *)NULL, &newnode, &psq_cb->psq_error, 
			(i4) 0);
		}
		else
		{
		    varnode.pst_vno 	       = rngvar->pss_rgno;
		    varnode.pst_atno.db_att_id = attribute->att_number;
		    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			(PST_QNODE *) NULL, PST_VAR, (char *) &varnode,
			sizeof(varnode), (DB_DT_ID) attribute->att_type,
			(i2) attribute->att_prec, (i4) attribute->att_width,
			(DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, 
			(i4) 0);
		    newnode->pst_sym.pst_dataval.db_collID =
						attribute->att_collID;

		    if (rngvar->pss_rgparent != cb->pss_qualdepth)
		    {
			register i4	i;
			/*
			** pss_rgparent MUST be < pss_qualdepth; we set the
			** bit in the correlation for all levels starting with
			** pss_rgparent+1 to pss_qualdepth
			*/
			for (i = rngvar->pss_rgparent + 1;
			     i <= cb->pss_qualdepth; i++)
			{
			    BTset(i, (char *) $Ycorrelation_mask);
			}

			if ($Ymult_corr_attrs.depth != -1 &&
			    !$Ymult_corr_attrs.found)
			{
			    if ($Ymult_corr_attrs.rgno == -1)
			    {
				$Ymult_corr_attrs.rgno = rngvar->pss_rgno;
			    }
			    else if ($Ymult_corr_attrs.rgno != rngvar->pss_rgno)
			    {
				$Ymult_corr_attrs.found = TRUE;
			    }
			}

			if ($Ycorr_aggr.depth != -1)
			{
			    $Ycorr_aggr.found = TRUE;
			}
		    }
		}

		if (DB_FAILURE_MACRO(status))
		    return (status);
	    }
	}

	/*
	** if processing a CHECK constraint defined using ALTER TABLE statement
	** and we have created a PST_VAR node (i.e. we found an attribute
	** described by the <col_ref>), set a bit corresponding to the attribute
	** number in $Ycheck_cons_cols.
	*/
	if (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
	    && ( (psq_cb->psq_mode == PSQ_ALTERTABLE) ||
		 (psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) )
	    && newnode->pst_sym.pst_type == PST_VAR
	   )
	{
	    BTset((i4) newnode->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id,
		(char *) &$Ycheck_cons_cols);
	}
	
	$$ = newnode;
    }
;

order_item_list:    	order_item
		|	order_item_list COMMA order_item
;

order_item:		order_column
		|	order_column ASC
    {
	/*
	** if this attribute has been previously seen in the order_by list, we
	** will avoid adding it this time, in which case order_column will
	** return NULL
	*/
	if ($1 != (PST_QNODE *) NULL)
	{
	    $1->pst_sym.pst_value.pst_s_sort.pst_srasc = TRUE;
	}
    }
		|	order_column nonkeyword
    {
	if (STcompare($2, "desc"))
	{
	    i4	    err_code;

	    /*
	    ** NOTE: this production is curently used only by SELECT.
	    ** Should you change it, make sure that the correct message gets
	    ** displayed.
	    ** (andre 4/26/90)
	    */
	    (VOID) psf_error(2501L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, STlength($2), $2);
	    return (E_DB_ERROR);
	}

	/*
	** if this attribute has been previously seen in the order_by list, we
	** will avoid adding it this time, in which case order_column will
	** return NULL
	*/
	if ($1 != (PST_QNODE *) NULL)
	{
	    $1->pst_sym.pst_value.pst_s_sort.pst_srasc = FALSE;
	}
    }
;

order_column:		select_expr
    {
	DB_STATUS	status;
	PST_QNODE	*sortnode;

	if ($Yisdbp == TRUE)
	{
	    status = pst_sqlsort(cb, &cb->pss_ostream, cb->pss_tlist,
		$Ydbpinfo->pss_into_clause,
		&$Ysort_list, $1, &sortnode, psq_cb);
	}
	else
	{
	    status = pst_sqlsort(cb, &cb->pss_ostream, cb->pss_tlist,
		(PST_QNODE *) NULL,
		&$Ysort_list, $1, &sortnode, psq_cb);
	}
	if (status != E_DB_OK)
	{
	    return(status);
	}
	$$ = sortnode;
    }
;

boolean_expr:		boolean_term
    {
	$$ = $1;
    }
		|	boolean_expr OR boolean_term
    {
	DB_STATUS	       status;

	/* will reuse the first PSS_TREEINFO passed from below */
	status = pst_node(cb, &cb->pss_ostream, $1->pss_tree, $3->pss_tree,
	    PST_OR, (PTR) NULL, sizeof(PST_OP_NODE), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &$1->pss_tree, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	if (BTtest($Yqual_depth, $Yqual_type))
	{
	    /*
	    ** If we are processing a join_search condition, set the joinid
	    ** field appropriately.  It has been initialized to PST_NOJOIN in
	    ** pst_node().
	    */
	    $1->pss_tree->pst_sym.pst_value.pst_s_op.pst_joinid =
		    $Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id;
	}

	if (($1->pss_mask |= $3->pss_mask) & PSS_SUBSEL_IN_TREE)
	{
	    cb->pss_flattening_flags |= PSS_SUBSEL_IN_OR_TREE;
	}

	$$ = $1;
    }
;

boolean_term:		boolean_factor
    {
	$$ = $1;
    }
    		|	boolean_term AND boolean_factor
    {
	DB_STATUS	       status;

	/* will reuse the first PSS_TREEINFO passed from below */
	status = pst_node(cb, &cb->pss_ostream, $1->pss_tree, $3->pss_tree,
	    PST_AND, (PTR) NULL, sizeof(PST_OP_NODE), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &$1->pss_tree, &psq_cb->psq_error, (i4) 0);

	if (status != E_DB_OK)
	{
	    return (status);
	}

	if (BTtest($Yqual_depth, $Yqual_type))
	{
	    /*
	    ** If we are processing a join_search condition, set the joinid
	    ** field appropriately.  It has been initialized to PST_NOJOIN in
	    ** pst_node().
	    */
	    $1->pss_tree->pst_sym.pst_value.pst_s_op.pst_joinid =
		    $Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id;
	}

	$1->pss_mask |= $3->pss_mask;

	$$ = $1;
    }
;

boolean_factor:		boolean_primary
    {
	$$ = $1;
    }
		|	NOT boolean_primary
    {
	DB_STATUS	       status;

	/* reuse PSS_TREEINFO passed from below */
	status = pst_node(cb, &cb->pss_ostream, $2->pss_tree,
	    (PST_QNODE *) NULL, PST_NOT, (PTR) NULL, 0, DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &$2->pss_tree, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/*
	** if multiple correlated relation references occurred in the tree
	** rooted in NOT EXISTS we need to indicate to OPF that no flattening is
	** to take place
	*/
	if ($2->pss_mask & PSS_0MULT_CORR_ATTR_IN_EXIST)
	{
	    cb->pss_flattening_flags |= PSS_MULT_CORR_ATTRS;
	    $2->pss_mask &= ~PSS_0MULT_CORR_ATTR_IN_EXIST;
	}

	/*
	** if we were looking for and found a correlated attribute reference in
	** the tree rooted in NOT EXISTS, we set PSS_CORR_AGGR in 
	** cb->pss_flattening_flags to remind us to set PST_CORR_AGGR in 
	** pst_mask1 of the query tree header
	*/
	if ($2->pss_mask & PSS_CORR_ATTR_IN_EXIST)
	{
	    cb->pss_flattening_flags |= PSS_CORR_AGGR;
	    $2->pss_mask &= ~PSS_CORR_ATTR_IN_EXIST;
	}

	$$ = $2;
    }
;

boolean_primary:	predicate
    {
	$$ = $1;
    }
		|	LPAREN boolean_expr RPAREN
    {
	$$ = $2;
    }
;

between:	    BETWEEN
    {
	$$ = TRUE;
    }
       |	    NOT BETWEEN
    {
	$$ = FALSE;
    }
;

symmetric:	/* empty */
    {
	$$ = FALSE;
    }
	|	    ASYMMETRIC
    {
	$$ = FALSE;
    }
	|	    SYMMETRIC
    {
	$$ = TRUE;
    }
;

in:		    IN
    {
	$$ = TRUE;
    }
	|	    NOT IN
    {
	/*
	** If NOT IN was specified then
	**     if $Ycorr_aggr.depth has not been previously set, 
	**	   we will set it to -1 * (pss_qualdepth + 1) (setting it to a 
	** 	   negative number enables us to distinguish cases when we set 
	**	   out to search for correlated aggregates after seeing an 
	**	   aggregate in target list vs. cases when we do it after 
	**	   seeing NOT IN, != ALL, or EXISTS) and start looking for 
	**	   correlated attributes.  If we find a correlated attribute in
	**	   the right subtree of NOT IN, we will indicate to OPF that 
	**	   the query contained a correlated aggregate.
	**
	**     if $Ymult_corr_attrs.depth has not been previously set, we will 
	**         set it to -1 * (pss_qualdepth + 1) and start looking for 
	**	   correlated attributes.  If we find correlated attributes from
	**	   at least 2 different relations within that subselect, and the
	**	   parent of EXISTS node is a NOT node, we will indicate to OPF
	**	   that the query should not be flattened.  Of course, if have 
	**	   previously found an instance of multiple correlated 
	**	   attributes in a tree rooted in NOT EXISTS or in a tree of a 
	**	   subselect whose target list involves count() or count(*),
	** 	   there is no point in looking for any more instances of the 
	**	   same.
	**
	** NOTE!!!!: we are only interested in correlated references and 
	**	     multiple correlated attributes in the right subtree of 
	**	     NOT IN (<subselect>), but in order to avoid additional 
	**	     shift/reduce conflicts, we may set $Ycorr_aggr.depth 
	**	     and $Ymult_corr_attrs.depth here and reset them to -1 in 
	**		predicate: select_expr in select_expr 
	**	     and 
	**		predicate: select_expr in LPAREN sel_expr_list RPAREN
	**	     productions.  
	**	     THEREFORE, if you are planning to use this production in 
	**	                some new context, be sure to at least reset 
	**	      		$Ycorr_aggr.depth and $Ymult_corr_attrs.depth
	**			to -1
	*/
	if (   ~cb->pss_flattening_flags & PSS_CORR_AGGR 
	    && $Ycorr_aggr.depth == -1
	    && cb->pss_qualdepth > 0)
	{
	    $Ycorr_aggr.depth = -cb->pss_qualdepth - 1;
	    $Ycorr_aggr.found = FALSE;
	}

        if (   ~cb->pss_flattening_flags & PSS_MULT_CORR_ATTRS 
	    && $Ymult_corr_attrs.depth == -1     
	    && cb->pss_qualdepth > 0)
        {
            $Ymult_corr_attrs.depth = -cb->pss_qualdepth - 1;
            $Ymult_corr_attrs.found = FALSE;
            $Ymult_corr_attrs.rgno = -1;
        }

	$$ = FALSE;
    }
;

is_null:	    IS NULLWORD
    {
	$$ = TRUE;
    }
	|	    IS NOT NULLWORD
    {
	$$ = FALSE;
    }
;

like:		    LIKE
    {
	$$ = TRUE;
    }
	|	    NOTLIKE
    {
	$$ = FALSE;
    }
;

subsel_pred_qualifier:  ALL
    {
	$$ = ALL_SUBSEL;
    }
		     |	SOME
    {
	$$ = SOME_SUBSEL;
    }
/* NOTE: the subselect qualifier ANY has been moved into a separate 
**       'predicate' sub-production to eliminate a reduce/reduce conflict
**       with the new set_function ANY.        (rblumer  28-dec-1992)
*/
;

/*
** WHERE clause predicates must not use any set functions, unless their
** arguments are correlated references. 
*/
predicate:		select_expr comparison select_expr
    {
	PSS_TREEINFO	    *treeinfo;
	DB_STATUS	    status;

	if ($3->pst_sym.pst_type == PST_SUBSEL)
	{
	    /* "select_expr compop (subselect)" */
	    status = psl_subsel_compare(cb, $1, $3, (ADI_OP_ID) $2,
		(i4) PST_ONE_SUBSELECT, &treeinfo,
		(bool) BTtest($Yqual_depth, $Yqual_type), &$Ypss_join_info,
		(bool)(($Yisdbp && $Ydbpinfo->pss_flags & PSS_INCOND &&
		!($Yisdbp && $Ydbpinfo->pss_flags & PSS_INFORQ)) || $Yin_rule),
		$Yin_rule ? E_US189E_6302_RULE_QUAL : 2415L, psq_cb);
	}
	else if ($1->pst_sym.pst_type == PST_SUBSEL)
	{
	    /* "(subselect) compop select_expr" - transformed to 
	    ** "select_expr reverse_compop (subselect)" */
	    status = psl_subsel_compare(cb, $3, $1, (ADI_OP_ID) revops[$2],
		(i4) PST_ONE_SUBSELECT, &treeinfo,
		(bool) BTtest($Yqual_depth, $Yqual_type), &$Ypss_join_info,
		(bool)(($Yisdbp && $Ydbpinfo->pss_flags & PSS_INCOND &&
		!($Yisdbp && $Ydbpinfo->pss_flags & PSS_INFORQ)) || $Yin_rule),
		$Yin_rule ? E_US189E_6302_RULE_QUAL : 2415L, psq_cb);
	}
	else
	{
	    /* No subselects. */
	    status = psl_simple_compare(cb, $1, $3, (ADI_OP_ID) $2,
		(i4) PST_DOESNT_APPLY, (char) 0, &treeinfo,
		(bool) BTtest($Yqual_depth, $Yqual_type), 
		(bool)$Yin_target_clause, &$Ypss_join_info, psq_cb);
	}

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	$$ = treeinfo;
    }
		|	select_expr comparison ANY LPAREN subselect RPAREN
    {
	PSS_TREEINFO	*treeinfo;
	DB_STATUS	status;
	i4		meta_op;

	meta_op = PST_ANY_SUBSELECT;

	status = psl_subsel_compare(cb, $1, $5, (ADI_OP_ID) $2, meta_op,
	    &treeinfo, (bool) BTtest($Yqual_depth, $Yqual_type),
	    &$Ypss_join_info,
	    (bool)(($Yisdbp && $Ydbpinfo->pss_flags & PSS_INCOND &&
	    !($Yisdbp && $Ydbpinfo->pss_flags & PSS_INFORQ)) || $Yin_rule),
	    $Yin_rule ? E_US189E_6302_RULE_QUAL : 2415L, psq_cb);

	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	$$ = treeinfo;
    }
		|	select_expr comparison subsel_pred_qualifier
    {
	/*
	** If != ALL was specified then
	**     if $Ycorr_aggr.depth has not been previously set, 
	**	   we will set it to -1 * (pss_qualdepth + 1) (setting it to a 
	**         negative number enables us to distinguish cases when we set 
	**	   out to search for correlated aggregates after seeing an 
	**	   aggregate in target list vs. cases when we do it after seeing
	**	   NOT IN, != ALL, or EXISTS) and start looking for correlated 
	**	   attributes.  If we find a correlated attribute in the right 
	**	   subtree of != ALL, we will indicate to OPF that the query 
	**	   contained a correlated aggregate.
	**     if $Ymult_corr_attrs.depth has not been previously set, we will 
	**         set it to -1 * (pss_qualdepth + 1) and start looking for 
	**	   correlated attributes.  If we find correlated attributes from
	**	   at least 2 different relations within that subselect, and the
	**	   parent of EXISTS node is a NOT node, we will indicate to OPF
	**	   that the query should not be flattened.  Of course, if have 
	**	   previously found an instance of multiple correlated 
	**	   attributes in a tree rooted in NOT EXISTS or in a tree of a 
	**	   subselect whose target list involves count() or count(*),
	** 	   there is no point in looking for any more instances of the 
	**	   same.
	*/
	if ($2 == ADI_NE_OP && $3 == ALL_SUBSEL)
	{
	    if (   ~cb->pss_flattening_flags & PSS_CORR_AGGR 
	        && $Ycorr_aggr.depth == -1
	        && cb->pss_qualdepth > 0)
	    {
	        $Ycorr_aggr.depth = -cb->pss_qualdepth - 1;
	        $Ycorr_aggr.found = FALSE;
	    }

	    if (   ~cb->pss_flattening_flags & PSS_MULT_CORR_ATTRS 
		&& $Ymult_corr_attrs.depth == -1     
		&& cb->pss_qualdepth > 0)
	    {
	        $Ymult_corr_attrs.depth = -cb->pss_qualdepth - 1;
	        $Ymult_corr_attrs.found = FALSE;
	        $Ymult_corr_attrs.rgno = -1;
	    }
	}
    }
			LPAREN subselect RPAREN
    {
	PSS_TREEINFO	*treeinfo;
	DB_STATUS	status;
	i4		meta_op;

        if ($2 == ADI_NE_OP && $3 == ALL_SUBSEL)
	{
            /* 
	    ** When processing != ALL, OPF will fold the left subtree into the
	    ** subtree representing the subselect; this means that variables 
	    ** referenced in the left subtree will, in essence, be involved in 
	    ** correlated references.  Therefore, if we were looking for and 
	    ** failed to find a single or multiple correlated references in the
	    ** subtree representing the subselect, we must take into 
	    ** consideration variables referenced in the left subtree.  
	    ** In particular, we will build a map of variables referenced in 
	    ** the left subtree, OR into it a map (consisting of at most one 
	    ** bit - otherwise we would not even get here) of variables involved
	    ** in correlated references in the right subtree and use the 
	    ** resulting map to determine whether to claim that we found one or
	    ** more correlated references.
	    */
	    if (   ($Ycorr_aggr.depth != -1 && !$Ycorr_aggr.found)
		|| ($Ymult_corr_attrs.depth != -1 && !$Ymult_corr_attrs.found))
	    {
		i4		num_corr_vars;
		PST_VRMAP	var_map;

		psy_vcount($1, &var_map);

		/* 
		** if we found one variable involved in correlated references 
		** in the tree representing the subselect, we need to set a 
		** bit representing that variable in var_map - this will
		** make it easier for us to avoid counting the same variable 
		** twice
		*/
		if (   $Ymult_corr_attrs.depth != -1
		    && $Ymult_corr_attrs.rgno != -1)
		{
		    BTset($Ymult_corr_attrs.rgno, (char *) &var_map);
		}

		/* 
		** now count the number of variables involved in correlated 
		** references
		*/
		num_corr_vars = BTcount((char *) &var_map, PST_NUMVARS);

		if (num_corr_vars > 0)
		{
		    if ($Ycorr_aggr.depth != -1 && !$Ycorr_aggr.found)
		    {
			$Ycorr_aggr.found = TRUE;
		    }

		    if (   $Ymult_corr_attrs.depth != -1 
			&& !$Ymult_corr_attrs.found
			&& num_corr_vars > 1)
		    {
			$Ymult_corr_attrs.found = TRUE;
		    } 
		} 
	    } 
	    
	    /*
            ** if we looked for and found a correlated attribute reference 
	    ** because we hit != ALL, we need to set PSS_CORR_AGGR in 
	    ** pss_flattening_flags and reset depth to indicate that we are 
	    ** done with our search; 
	    **
	    ** similarly, if we looked for and found multiple correlated 
	    ** references because we hit != ALL, we need to set 
	    ** PSS_MULT_CORR_ATTRS in pss_flattening_flags and reset depth to 
	    ** indicate that we are done with our search
            */
	    if ($Ycorr_aggr.depth == -cb->pss_qualdepth - 1)
            {
                if ($Ycorr_aggr.found)
                {
	            cb->pss_flattening_flags |= PSS_CORR_AGGR;
                }
 
                $Ycorr_aggr.depth = -1;
	    }

	    if ($Ymult_corr_attrs.depth == -cb->pss_qualdepth - 1)
	    {
		if ($Ymult_corr_attrs.found)
		{
		    cb->pss_flattening_flags |= PSS_MULT_CORR_ATTRS;
		}

		$Ymult_corr_attrs.depth = -1;
	    }
        }

	meta_op = ($3 == ALL_SUBSEL) ? PST_ALL_SUBSELECT : PST_ANY_SUBSELECT;

	status = psl_subsel_compare(cb, $1, $6, (ADI_OP_ID) $2, meta_op,
	    &treeinfo, (bool) BTtest($Yqual_depth, $Yqual_type),
	    &$Ypss_join_info,
	    (bool)(($Yisdbp && $Ydbpinfo->pss_flags & PSS_INCOND &&
	    !($Yisdbp && $Ydbpinfo->pss_flags & PSS_INFORQ)) || $Yin_rule),
	    $Yin_rule ? E_US189E_6302_RULE_QUAL : 2415L, psq_cb);

	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	$$ = treeinfo;
    }
		|	select_expr between symmetric select_expr AND select_expr
    {
	PSS_TREEINFO	    *treeinfo;
	PST_QNODE           *lnode1, *lnode2;
	PST_QNODE           *rnode1, *rnode2;
	PST_QNODE	    *ornode1, *ornode2;
	PST_QNODE           *xnode2, *xnode3, *xnode4, *ynode2, *znode2;
	YYAGG_NODE_PTR	    *agg_node_list = (YYAGG_NODE_PTR *) NULL;
	PST_OP_NODE	    opnode;
	DB_STATUS	    status;
	i4		    nores_flag;

	/* "between" predicates are transformed here into the corresponding
	** ">="/"<=" parse tree nodes. 
	** "x between [asymmetric] y and z" becomes "x >= y and x <= z". 
	** "x between symmetric y and z" becomes
	** "(x >= y or x >= z) and (x <= z or x <= y)", which is the CNF
	** form for "(x >= y and x <= z) or (x >= z and x <= y)". 
	** "not between [asymmetric]" simply inserts a NOT operator and lets 
	** OPF perform the corresponding transform.
	** "x not between symmetric y and z" is done here because of the
	** greater complexity (that OPF doesn't handle as well) and becomes
	** "(x < y or x > z) and (x < z or x > y)". */

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   $Yin_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}

	/* Verify collation compatibility between 1st and 2nd/3rd exprs. */
	if (!(psl_validate_collation_mix($1->pst_sym.pst_dataval.db_collID,
	    $4->pst_sym.pst_dataval.db_collID)))
	{
	    /* Collation conflict. */
	    i4	err_code;
	    (VOID) psf_error(6427L, 0L, PSF_USERERR, &err_code, 
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	else if (!(psl_validate_collation_mix($1->pst_sym.pst_dataval.db_collID,
	    $6->pst_sym.pst_dataval.db_collID)))
	{
	    /* Collation conflict. */
	    i4	err_code;
	    (VOID) psf_error(6427L, 0L, PSF_USERERR, &err_code, 
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

        status = psf_malloc(cb, &cb->pss_ostream, sizeof(PSS_TREEINFO), 
	         (PTR *) &treeinfo, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	/* "x >= y" or "x < y" (NOT BETWEEN SYMMETRIC) */
	opnode.pst_opno = ADI_GE_OP;
	opnode.pst_opmeta = PST_NOMETA;
	opnode.pst_isescape = PST_DOESNT_APPLY;
	if (!$2 && $3)
	    opnode.pst_opno = ADI_LT_OP;	/* not between symm. */

	status = pst_node(cb, &cb->pss_ostream, $1, $4, PST_BOP,
	    (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &lnode1, &psq_cb->psq_error, nores_flag);

	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	/* Make copy of x operand for second comparison. */

	/*
	** when copying a subtree, add newly created PST_AGHEAD nodes to the
	** list of AGHEAD nodes.  This is done to fix bug 20499
	*/
	$Ydup_rb.pss_op_mask |= PSS_5DUP_ATTACH_AGHEAD;
	$Ydup_rb.pss_1ptr     = (PTR) &agg_node_list;  

	$Ydup_rb.pss_tree = $1;
	$Ydup_rb.pss_dup  = &xnode2;
	status = pst_treedup(cb, &$Ydup_rb);

	if (DB_FAILURE_MACRO(status))
	    return (status);

	if (agg_node_list != (YYAGG_NODE_PTR *) NULL)
	{
	    /*
	    ** tree copy contains some AGGHEAD nodes which must be inserted into
	    ** appropriate AGGHEAD list
	    */
	    YYAGG_NODE_PTR	*agg_list_elem, *next_elem = agg_node_list;

	    while ((agg_list_elem = next_elem) != (YYAGG_NODE_PTR *) NULL)
	    {
		/*
		** must remember agg_list_elem->agg_next as it will ALWAYS get
		** changed when psl_insert_into_agg_list() inserts agg_list_elem
		** into appropriate list
		*/
		next_elem = agg_list_elem->agg_next;

		/* insert it into approprite AGGHEAD list */
		psl_insert_into_agg_list(
		    psl_find_node(agg_list_elem->agg_node, PST_VAR),
		    agg_list_elem, $Yagg_list_stack, cb->pss_qualdepth,
		    &$Yflists[0]);
	    }
	}

	/*
	** since $Ydup_rb may be used throughout the grammar, reset pss_op_mask
	** and pss_1ptr to their old values.
	*/
	$Ydup_rb.pss_op_mask &= ~PSS_5DUP_ATTACH_AGHEAD;
	$Ydup_rb.pss_1ptr     = NULL;

	/* "x <= z" or "x > z" (NOT BETWEEN SYMMETRIC) */
	opnode.pst_opno = ADI_LE_OP;
	if (!$2 && $3)
	    opnode.pst_opno = ADI_GT_OP;	/* not between symm. */

	status = pst_node(cb, &cb->pss_ostream, xnode2, $6, PST_BOP,
	    (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &rnode1, &psq_cb->psq_error, nores_flag);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	/* If not SYMMETRIC, compose final AND here. */
	if (!$3)
	{
	    /* note that treeinfo->pss_tree will point at the resulting tree */
	    status = pst_node(cb, &cb->pss_ostream, lnode1, rnode1, PST_AND,
		(PTR) NULL, sizeof(PST_OP_NODE), DB_NODT, (i2) 0, (i4) 0,
		(DB_ANYTYPE *) NULL, &treeinfo->pss_tree, &psq_cb->psq_error,
		nores_flag);

	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);
	    }

	    if (BTtest($Yqual_depth, $Yqual_type))
	    {
		/*
		** If we are processing a join_search condition, set the joinid
		** field appropriately.  It has been initialized to PST_NOJOIN
		** in pst_node().
		*/
		treeinfo->pss_tree->pst_sym.pst_value.pst_s_op.pst_joinid =
		    lnode1->pst_sym.pst_value.pst_s_op.pst_joinid =
		    rnode1->pst_sym.pst_value.pst_s_op.pst_joinid =
			$Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id;
	    }

	    /* [asymmetric] with NOT - just plunk NOT in front for OPF
	    ** to normalize. For NOT BETWEEN SYMMETRIC the transform is 
	    ** done here because it is more complex and we're smarter. */
	    if (!$2)
	    {
		status = pst_node(cb, &cb->pss_ostream, treeinfo->pss_tree, 
		    (PST_QNODE *) NULL, PST_NOT, (PTR) NULL, 0, DB_NODT, (i2) 0,
		    (i4) 0, (DB_ANYTYPE *) NULL, &treeinfo->pss_tree,
		    &psq_cb->psq_error, nores_flag);

		if (DB_FAILURE_MACRO(status))
		{
		    return (status);
		}
	    }
	}
	else
	{
	    /* SYMMETRIC - do the rest in here. */

	    /* First, allocate 2 more copies of x operand and 1 each
	    ** of y and z operands. */
	    $Ydup_rb.pss_op_mask |= PSS_5DUP_ATTACH_AGHEAD;
	    $Ydup_rb.pss_1ptr     = (PTR) &agg_node_list;  

	    $Ydup_rb.pss_tree = $1;
	    $Ydup_rb.pss_dup  = &xnode3;
	    status = pst_treedup(cb, &$Ydup_rb);

	    if (DB_FAILURE_MACRO(status))
		return (status);

	    $Ydup_rb.pss_tree = $1;
	    $Ydup_rb.pss_dup  = &xnode4;
	    status = pst_treedup(cb, &$Ydup_rb);

	    if (DB_FAILURE_MACRO(status))
		return (status);

	    $Ydup_rb.pss_tree = $4;
	    $Ydup_rb.pss_dup  = &ynode2;
	    status = pst_treedup(cb, &$Ydup_rb);

	    if (DB_FAILURE_MACRO(status))
		return (status);

	    $Ydup_rb.pss_tree = $6;
	    $Ydup_rb.pss_dup  = &znode2;
	    status = pst_treedup(cb, &$Ydup_rb);

	    if (DB_FAILURE_MACRO(status))
		return (status);

	    /* Do the agg_node thing for all of them. */

	    if (agg_node_list != (YYAGG_NODE_PTR *) NULL)
	    {
		/*
		** tree copy contains some AGGHEAD nodes which must be inserted
		** into appropriate AGGHEAD list
		*/
		YYAGG_NODE_PTR	*agg_list_elem, *next_elem = agg_node_list;

		while ((agg_list_elem = next_elem) != (YYAGG_NODE_PTR *) NULL)
		{
		    /*
		    ** must remember agg_list_elem->agg_next as it will ALWAYS
		    ** get changed when psl_insert_into_agg_list() inserts 
		    ** agg_list_elem into appropriate list
		    */
		    next_elem = agg_list_elem->agg_next;

		    /* insert it into approprite AGGHEAD list */
		    psl_insert_into_agg_list(
			psl_find_node(agg_list_elem->agg_node, PST_VAR),
			agg_list_elem, $Yagg_list_stack, cb->pss_qualdepth,
			&$Yflists[0]);
		}
	    }

	    /*
	    ** since $Ydup_rb may be used throughout the grammar, reset 
	    ** pss_op_mask and pss_1ptr to their old values.
	    */
	    $Ydup_rb.pss_op_mask &= ~PSS_5DUP_ATTACH_AGHEAD;
	    $Ydup_rb.pss_1ptr     = NULL;

	    /* "x >= z" or "x < z" (NOT) */
	    if (!$2)
		opnode.pst_opno = ADI_LT_OP;
	    else opnode.pst_opno = ADI_GE_OP;

	    status = pst_node(cb, &cb->pss_ostream, xnode3, znode2, PST_BOP,
		(char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
		(DB_ANYTYPE *) NULL, &lnode2, &psq_cb->psq_error, nores_flag);
	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);
	    }

	    /* "x <= y" or "x > y" (NOT) */
	    if (!$2)
		opnode.pst_opno = ADI_GT_OP;
	    else opnode.pst_opno = ADI_LE_OP;

	    status = pst_node(cb, &cb->pss_ostream, xnode4, ynode2, PST_BOP,
		(char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
		(DB_ANYTYPE *) NULL, &rnode2, &psq_cb->psq_error, nores_flag);
	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);
	    }

	    /* "x >= y or x >= z" or "x < y or x > z" (NOT) */
	    status = pst_node(cb, &cb->pss_ostream, lnode1, 
		($2) ? lnode2 : rnode1, PST_OR,
		(PTR) NULL, sizeof(PST_OP_NODE), DB_NODT, (i2) 0, (i4) 0,
		(DB_ANYTYPE *) NULL, &ornode1, &psq_cb->psq_error,
		nores_flag);

	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);
	    }

	    if (BTtest($Yqual_depth, $Yqual_type))
	    {
		/*
		** If we are processing a join_search condition, set the joinid
		** field appropriately.  It has been initialized to PST_NOJOIN
		** in pst_node().
		*/
		ornode1->pst_sym.pst_value.pst_s_op.pst_joinid =
		    lnode1->pst_sym.pst_value.pst_s_op.pst_joinid =
		    lnode2->pst_sym.pst_value.pst_s_op.pst_joinid =
			$Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id;
	    }

	    /* "x <= z or x <= y" or "x < z or x > y" (NOT) */
	    status = pst_node(cb, &cb->pss_ostream, ($2) ? rnode1 : lnode2, 
		rnode2, PST_OR,
		(PTR) NULL, sizeof(PST_OP_NODE), DB_NODT, (i2) 0, (i4) 0,
		(DB_ANYTYPE *) NULL, &ornode2, &psq_cb->psq_error,
		nores_flag);

	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);
	    }

	    if (BTtest($Yqual_depth, $Yqual_type))
	    {
		/*
		** If we are processing a join_search condition, set the joinid
		** field appropriately.  It has been initialized to PST_NOJOIN
		** in pst_node().
		*/
		ornode2->pst_sym.pst_value.pst_s_op.pst_joinid =
		    rnode1->pst_sym.pst_value.pst_s_op.pst_joinid =
		    rnode2->pst_sym.pst_value.pst_s_op.pst_joinid =
			$Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id;
	    }

	    /* Finally, AND the ORs together. */

	    /* note that treeinfo->pss_tree will point at the resulting tree */
	    status = pst_node(cb, &cb->pss_ostream, ornode1, ornode2, PST_AND,
		(PTR) NULL, sizeof(PST_OP_NODE), DB_NODT, (i2) 0, (i4) 0,
		(DB_ANYTYPE *) NULL, &treeinfo->pss_tree, &psq_cb->psq_error,
		nores_flag);

	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);
	    }

	    if (BTtest($Yqual_depth, $Yqual_type))
	    {
		/*
		** If we are processing a join_search condition, set the joinid
		** field appropriately.  It has been initialized to PST_NOJOIN
		** in pst_node().
		*/
		treeinfo->pss_tree->pst_sym.pst_value.pst_s_op.pst_joinid =
			$Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id;
	    }
	}

	treeinfo->pss_mask = (i4) 0;

	$$ = treeinfo;
    }

		|	select_expr in select_expr
    {
	PSS_TREEINFO	    *treeinfo;
	DB_STATUS	    status;
	ADI_OP_ID	operator;
	i4		meta_op;

	if ($3->pst_sym.pst_type == PST_SUBSEL)
	{
	    /* "select_expr in (subselect)" */

	    if ($2)
	    {
		operator = (ADI_OP_ID) ADI_EQ_OP;
		meta_op = (i4) PST_ANY_SUBSELECT;
	    }
	    else
	    {
		/*
		** a tree for NOT IN subselect will be the same as the one for
		** != ALL subselect.  This fixes bug 34433
		*/
		operator = (ADI_OP_ID) ADI_NE_OP;
		meta_op  = (i4) PST_ALL_SUBSELECT;

        	/* 
		** When processing NOT IN, OPF will fold the left subtree into
		** the subtree representing the subselect; this means that
		** variables referenced in the left subtree will, in essence, 
		** be involved in correlated references.  Therefore, if we were
		** looking for and failed to find a single or multiple 
		** multiple correlated references in the subtree representing 
		** the subselect, we must take into consideration variables 
		** referenced in the left subtree. In particular, we will build 
		** a map of variables referenced in the left subtree, OR into 
		** it a map (consisting of at most one bit - otherwise we would 
		** not even get here) of variables involved in correlated 
		** references in the right subtree and use the resulting 
		** map to determine whether to claim that we found one or
		** more correlated references.
		*/
		if (   ($Ycorr_aggr.depth != -1 && !$Ycorr_aggr.found)
	            || ($Ymult_corr_attrs.depth != -1 && !$Ymult_corr_attrs.found))
		{
	            i4		num_corr_vars;
	            PST_VRMAP	var_map;
    
	            psy_vcount($1, &var_map);
    
	            /* 
	            ** if we found one variable involved in correlated 
		    ** references in the tree representing the subselect, 
		    ** we need to set a bit representing that variable in 
		    ** var_map - this will make it easier for us to avoid 
		    ** counting the same variable twice
	            /*
	            if (   $Ymult_corr_attrs.depth != -1
	        	&& $Ymult_corr_attrs.rgno != -1)
	            {
	        	BTset($Ymult_corr_attrs.rgno, (char *) &var_map);
	            }
    
	            /* 
	            ** now count the number of variables involved in correlated 
	            ** references
	            */
	            num_corr_vars = BTcount((char *) &var_map, PST_NUMVARS);
    
	            if (num_corr_vars > 0)
	            {
	        	if ($Ycorr_aggr.depth != -1 && !$Ycorr_aggr.found)
	        	{
		            $Ycorr_aggr.found = TRUE;
	        	}
    
	        	if (   $Ymult_corr_attrs.depth != -1 
		            && !$Ymult_corr_attrs.found
		            && num_corr_vars > 1)
	        	{
		            $Ymult_corr_attrs.found = TRUE;
	        	} 
	            } 
        	}
	        
        	/*
        	** if we looked for and found a correlated attribute reference 
		** because we hit NOT IN, we need to set PSS_CORR_AGGR in 
		** pss_flattening_flags and reset depth to indicate that we are 
		** done with our search; 
		**
		** similarly, if we looked for and found multiple correlated 
		** references because we hit NOT IN, we need to set 
		** PSS_MULT_CORR_ATTRS in pss_flattening_flags and reset depth
		** to indicate that we are done with our search
        	*/
        	if ($Ycorr_aggr.depth == -cb->pss_qualdepth - 1)
        	{
                    if ($Ycorr_aggr.found)
                    {
	        	cb->pss_flattening_flags |= PSS_CORR_AGGR;
                    }
     
                    $Ycorr_aggr.depth = -1;
        	}
    
        	if ($Ymult_corr_attrs.depth == -cb->pss_qualdepth - 1)
        	{
	            if ($Ymult_corr_attrs.found)
		    {
			cb->pss_flattening_flags |= PSS_MULT_CORR_ATTRS;
		    }
    
		    $Ymult_corr_attrs.depth = -1;
        	}
	    }
	
	    status = psl_subsel_compare(cb, $1, $3, operator, meta_op,
		&treeinfo, (bool) BTtest($Yqual_depth, $Yqual_type),
		&$Ypss_join_info,
		(bool)(($Yisdbp && $Ydbpinfo->pss_flags & PSS_INCOND &&
		!($Yisdbp && $Ydbpinfo->pss_flags & PSS_INFORQ)) || $Yin_rule),
		$Yin_rule ? E_US189E_6302_RULE_QUAL : 2415L, psq_cb);

	}
	else
	{
	    /* "select_expr in non-subselect-expr" */

	    /* 
	    ** when we have encountered NOT IN, we may have set $Ycorr_aggr.
	    ** depth and/or $Ymult_corr_attrs.depth to -cb->pss_qualdepth - 1.
	    ** However, unless NOT IN were followed by a (SUBSELECT), we are 
	    ** not interested in checking whether the <select_expr> involved 
	    ** correlated references; therefore here we simply reset 
	    ** $Ycorr_aggr.depth and $Ymult_corr_attrs.depth to -1
	    */
	    if (!$2)
	    {
        	if ($Ycorr_aggr.depth == -cb->pss_qualdepth - 1)
        	{
	            $Ycorr_aggr.depth = -1;
        	}
    
        	if ($Ymult_corr_attrs.depth == -cb->pss_qualdepth - 1)
        	{
	            $Ymult_corr_attrs.depth = -1;
        	}
	    }

	    status = psl_simple_compare(cb, $1, $3,
		(ADI_OP_ID) (($2) ? ADI_EQ_OP : ADI_NE_OP),
		(i4) PST_DOESNT_APPLY, (char) 0, &treeinfo,
		(bool) BTtest($Yqual_depth, $Yqual_type), 
		(bool)$Yin_target_clause, &$Ypss_join_info, psq_cb);

	}

	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	$$ = treeinfo;
    }
		|	select_expr in LPAREN sel_expr_list RPAREN
    {
	PST_QNODE           *resultnode;
	PST_QNODE           *newnode;
	PST_QNODE           *copynode;
	PST_QNODE	    *ineq = (PST_QNODE *)NULL;
	PSS_EXLIST          *valnode;
	PST_QNODE           *ornode;
	YYAGG_NODE_PTR	    *agg_node_list = (YYAGG_NODE_PTR *) NULL;
	PSS_TREEINFO	    *treeinfo;
	PST_OP_NODE	    opnode;
	DB_STATUS	    status;
	PST_J_ID	    join_id;
	i4		    nores_flag;

	/* 
	** when we have encountered NOT IN, we may have set $Ycorr_aggr.depth
	** and/or $Ymult_corr_attrs.depth to -cb->pss_qualdepth - 1.  
	** However, unless NOT IN were followed by a (SUBSELECT), we are not 
	** interested in checking whether the <select_expr> involved correlated
	** references; therefore here we simply reset $Ycorr_aggr.depth and
	** $Ymult_corr_attrs.depth to -1
	*/
	if (!$2)
	{
            if ($Ycorr_aggr.depth == -cb->pss_qualdepth - 1)
            {
                $Ycorr_aggr.depth = -1;
            }
    
            if ($Ymult_corr_attrs.depth == -cb->pss_qualdepth - 1)
            {
                $Ymult_corr_attrs.depth = -1;
            }
	}

	/*
	** don't do type resolution if parsing a check constraint specified
	** inside CREATE TABLE statement, as we may not know the type of the
	** column (e.g. if it hasn't been defined yet)
	*/
	if (   $Yin_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}

        status = psf_malloc(cb, &cb->pss_ostream, sizeof(PSS_TREEINFO), 
	         (PTR *) &treeinfo, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	resultnode = (PST_QNODE *) NULL;
	opnode.pst_opno = ADI_EQ_OP;
	opnode.pst_opmeta = PST_NOMETA;
	opnode.pst_isescape = PST_DOESNT_APPLY;

	/*
	** determine join id based on whether we are processing a join_search
	** condition
	*/
	join_id = (BTtest($Yqual_depth, $Yqual_type))
		    ? $Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id
		    : PST_NOJOIN;

	/*
	** if expression list contains more than 1 value, we will need to make
	** copies of select_expr
	*/

	if ($Yexprlist->pss_next != (PSS_EXLIST *) NULL)
	{
	    /*
	    ** when copying a subtree, add newly created PST_AGHEAD nodes to the
	    ** list of AGHEAD nodes.  This is done to fix bug 20499
	    */
	    $Ydup_rb.pss_op_mask |= PSS_5DUP_ATTACH_AGHEAD;
	    $Ydup_rb.pss_1ptr     = (PTR) &agg_node_list;
	}

	/*			    
	** Predicate x [NOT] IN (l1, l2, ..., ln) is equivalent to
	** [NOT] ((x = l1) OR (x = l2) OR ... OR (x = ln)) and the generated
	** tree will reflect that.
	** Note that the trees representing l1,l2,...,ln hang off nodes
	** in a singly linked list with $Yexprlist pointing to the first node
	** in the list.
	** (Trees were linked in reverse order, but here the order will
	** be reversed again.)
	*/
	
	for (valnode = $Yexprlist;
	     valnode != (PSS_EXLIST *) NULL;
	     valnode = valnode->pss_next)
	{
	    /* First check for collation conflicts. */
	    if (!(psl_validate_collation_mix($1->pst_sym.pst_dataval.db_collID,
		valnode->pss_expr->pst_sym.pst_dataval.db_collID)))
	    {
		i4	err_code;
		(VOID) psf_error(6427L, 0L, PSF_USERERR, &err_code, 
		    &psq_cb->psq_error, 0);
	    }

	    /* Then new code to pack constant IN-lists into a single "=" BOP. 
	    ** NOTE - not done for "not in" lists. */
	    if (valnode->pss_expr->pst_sym.pst_type == PST_CONST && ineq && $2
		&& ~cb->pss_distrib & DB_3_DDB_SESS)
	    {
		ineq->pst_sym.pst_value.pst_s_op.pst_flags |= PST_INLIST;
					/* flag it to be sure */
		valnode->pss_expr->pst_left = ineq->pst_right;
		ineq->pst_right = valnode->pss_expr;
					/* link 'em together */
		continue;
	    }

	    /* if not the last value node, copy the select expr */
	    if (valnode->pss_next != NULL)
	    {
		$Ydup_rb.pss_tree = $1;
		$Ydup_rb.pss_dup  = &copynode;
		status = pst_treedup(cb, &$Ydup_rb);

		if (DB_FAILURE_MACRO(status))
		    return (status);
	    }	    
	    else
		copynode = $1;

	    status = pst_node(cb, &cb->pss_ostream, copynode, valnode->pss_expr,
		PST_BOP, (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0,
		(i4) 0, (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error,
		nores_flag);

	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);
	    }

	    newnode->pst_sym.pst_value.pst_s_op.pst_joinid = join_id;
	    if (valnode->pss_expr->pst_sym.pst_type == PST_CONST)
		ineq = newnode;
	    
	    /* no result, make the op a result, else create an OR node */
	    if (resultnode)
	    {	
		status = pst_node(cb, &cb->pss_ostream, newnode, resultnode, 
		    PST_OR, (PTR) NULL, sizeof(PST_OP_NODE), DB_NODT, (i2) 0,
		    (i4) 0, (DB_ANYTYPE *) NULL, &ornode, &psq_cb->psq_error,
		    nores_flag);
		if (DB_FAILURE_MACRO(status))
		{
		    return (status);
		}

		/* in pst_node() pst_joinid was set to PST_NOJOIN */
		ornode->pst_sym.pst_value.pst_s_op.pst_joinid = join_id;
		
		resultnode = ornode;
	    }
	    else
		resultnode = newnode;
	}

	if (!$2)    /* NOT IN was specified: will negate the qualification */
	{
	    /* negate the qualification */
	    status = pst_node(cb, &cb->pss_ostream, resultnode,
		(PST_QNODE *) NULL, PST_NOT, (PTR) NULL, 0, DB_NODT, (i2) 0,
		(i4) 0, (DB_ANYTYPE *) NULL, &resultnode, &psq_cb->psq_error,
		nores_flag);
	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);
	    }
	}

	if (agg_node_list != (YYAGG_NODE_PTR *) NULL)
	{
	    /*
	    ** tree copy contains some AGGHEAD nodes which must be inserted into
	    ** appropriate AGGHEAD list
	    */
	    YYAGG_NODE_PTR	*agg_list_elem, *next_elem = agg_node_list;

	    while ((agg_list_elem = next_elem) != (YYAGG_NODE_PTR *) NULL)
	    {
		/*
		** must remember agg_list_elem->agg_next as it will ALWAYS get
		** changed when psl_insert_into_agg_list() inserts agg_list_elem
		** into appropriate list
		*/
		next_elem = agg_list_elem->agg_next;

		/* insert it into approprite AGGHEAD list */
		psl_insert_into_agg_list(
		    psl_find_node(agg_list_elem->agg_node, PST_VAR),
		    agg_list_elem, $Yagg_list_stack, cb->pss_qualdepth,
		    &$Yflists[0]);
	    }
	}

	if ($Yexprlist->pss_next != (PSS_EXLIST *) NULL)
	{
	    /*
	    ** since $Ydup_rb may be used throughout the grammar, reset
	    ** pss_op_mask and pss_1ptr to their old values.
	    */
	    $Ydup_rb.pss_op_mask &= ~PSS_5DUP_ATTACH_AGHEAD;
	    $Ydup_rb.pss_1ptr     = NULL;
	}

	/* Reset for nested subqueries. */	
	$Yexprlist = (PSS_EXLIST *) NULL;

	treeinfo->pss_mask = (i4) 0;
	treeinfo->pss_tree = resultnode;

	$$ = treeinfo;
    }
		|	EXISTS
    {
	/*
	** If $Ymult_corr_attrs.depth has not been previously set, we will set
	** it to -1 * (pss_qualdepth + 1) and start looking for correlated
	** attributes.  If we find correlated attributes from at least 2
	** different relations within that subselect, and some ancestor of
	** EXISTS node is a NOT node, we will indicate to OPF that the query
	** should not be flattened.  Of course, if we have previously found an
	** instance of multiple correlated attributes in a tree rooted in
	** NOT EXISTS or in a tree of a subselect whose target list involves
	** count() or count(*), there is no point in looking for any more
	** instances of the same.
	*/
	if (~cb->pss_flattening_flags & PSS_MULT_CORR_ATTRS &&
	    $Ymult_corr_attrs.depth == -1     &&
	    cb->pss_qualdepth > 0)
	{
	    $Ymult_corr_attrs.depth = -cb->pss_qualdepth - 1;
	    $Ymult_corr_attrs.found = FALSE;
	    $Ymult_corr_attrs.rgno = -1;
	}

	/*
	** If $Ycorr_aggr.depth has not been previously set, we will set
	** it to -1 * (pss_qualdepth + 1) (setting it to a negative number 
	** enables us to distinguish cases when we set out to search for 
	** correlated aggregates after seeing an aggregate in target list vs. 
	** cases when we do it after seeing NOT IN, != ALL, or EXISTS) and 
	** start looking for correlated attributes.  If we find a correlated 
	** attribute within that subselect, and some ancestor of EXISTS node is
	** a NOT node, we will indicate to OPF that the query contained a 
	** correlated aggregate.
	*/
	if (   ~cb->pss_flattening_flags & PSS_CORR_AGGR 
	    && $Ycorr_aggr.depth == -1
	    && cb->pss_qualdepth > 0)
	{
	    $Ycorr_aggr.depth = -cb->pss_qualdepth - 1;
	    $Ycorr_aggr.found = FALSE;
	}
    }
			LPAREN subselect RPAREN
    {
	PSS_TREEINFO	*treeinfo;
	DB_STATUS	status;

	status = psl_subsel_compare(cb, (PST_QNODE *) NULL, $4,
	    (ADI_OP_ID) ADI_EXIST_OP, (i4) PST_ANY_SUBSELECT, &treeinfo,
	    (bool) BTtest($Yqual_depth, $Yqual_type), &$Ypss_join_info,
	    (bool)(($Yisdbp && $Ydbpinfo->pss_flags & PSS_INCOND &&
	    !($Yisdbp && $Ydbpinfo->pss_flags & PSS_INFORQ)) || $Yin_rule),
	    $Yin_rule ? E_US189E_6302_RULE_QUAL : 2415L, psq_cb);

	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	/*
	** Indicate presence of a subselect. Do not call psl_subsel
	** which returns error for more than 1 resdom.
	*/
	cb->pss_stmt_flags |= PSS_SUBINTREE; /* pss_subintree = TRUE */

	if ($Ymult_corr_attrs.depth == -cb->pss_qualdepth - 1)
	{
	    /*
	    ** if we were looking for multiple correlated relation references
	    ** because we hit EXISTS, check if we did and reset depth to avoid
	    ** confusion in the future.
	    */
	    if ($Ymult_corr_attrs.found)
	    {
		/*
		** Now if we come across NOT and its child has
		** PSS_0MULT_CORR_ATTR_IN_EXIST in its pss_mask, we will be
		** able to conclude that there were multiple correlated relation
		** references in the tree rooted in NOT EXISTS, so we should
		** indicate to OPF that no flattening should take place
		*/
		treeinfo->pss_mask |= PSS_0MULT_CORR_ATTR_IN_EXIST;
	    }

	    /*
	    ** we reset depth since otherwise it would be very messy to
	    ** determine if the multiple correlated relation references occurred
	    ** in the tree rooted in the given NOT EXISTS.
	    */
	    $Ymult_corr_attrs.depth = -1;
	}

	if ($Ycorr_aggr.depth == -cb->pss_qualdepth - 1)
	{
	    /*
	    ** if we were looking for correlated attribute reference because 
	    ** we hit EXISTS, check if we did and reset depth to avoid confusion
	    ** in the future.
	    */
	    if ($Ycorr_aggr.found)
	    {
		/*
		** Now if we come across NOT and its child has
		** PSS_CORR_ATTR_IN_EXIST in its pss_mask, we will know to set
		** PSS_CORR_AGGR bit in pss_flattening_flags which will 
		** eventually result in PST_CORR_AGGR being set if 
		** PST_QTREE.pst_mask1 where OPF expects to find it
		*/
		treeinfo->pss_mask |= PSS_CORR_ATTR_IN_EXIST;
	    }

	    $Ycorr_aggr.depth = -1;
	}

	$$ = treeinfo;
    }
		|    	select_expr is_null
    {
	DB_STATUS	    status;
	PSS_TREEINFO        *treeinfo;

	status = psl_simple_compare(cb, $1, (PST_QNODE *) NULL,
	    (ADI_OP_ID) (($2) ? ADI_ISNUL_OP : ADI_NONUL_OP),
	    (i4) PST_DOESNT_APPLY, (char) 0, &treeinfo,
	    (bool) BTtest($Yqual_depth, $Yqual_type), 
	    (bool)$Yin_target_clause, &$Ypss_join_info, psq_cb);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	$$ = treeinfo;
    }
		|	element like select_expr
    {
	PSS_TREEINFO        *treeinfo;
	DB_STATUS	    status;

	status = psl_simple_compare(cb, $1, $3,
	    (ADI_OP_ID) (($2) ? ADI_LIKE_OP : ADI_NLIKE_OP),
	    (i4) PST_NO_ESCAPE, (char) 0, &treeinfo,
	    (bool) BTtest($Yqual_depth, $Yqual_type), 
	    (bool)$Yin_target_clause, &$Ypss_join_info, psq_cb);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	$$ = treeinfo;
    }
		|	element like select_expr ESCAPE strconst_e
    {
	PSS_TREEINFO	*treeinfo;
	DB_STATUS	status;

	if (STlength($5) != 1)
	{
	    i4         err_code;

	    (VOID) psf_error(2713L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		STlength($5), $5);
	    return (E_DB_ERROR);
	}

	status = psl_simple_compare(cb, $1, $3,
	    (ADI_OP_ID) (($2) ? ADI_LIKE_OP : ADI_NLIKE_OP),
	    (i4) PST_HAS_ESCAPE, *$5, &treeinfo,
	    (bool) BTtest($Yqual_depth, $Yqual_type), 
	    (bool)$Yin_target_clause, &$Ypss_join_info, psq_cb);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	$$ = treeinfo;
    }
;

select_expr:		arith_term
    {
	$$ = $1;
    }
		|	select_expr UAOP arith_term
    {
	PST_QNODE              *newnode;
	PST_OP_NODE	       opnode;
	DB_STATUS	       status;
	i4		       nores_flag;

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   $Yin_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}

	opnode.pst_opno = $2;
	opnode.pst_opmeta = PST_NOMETA;
	opnode.pst_isescape = PST_DOESNT_APPLY;

	status = pst_node(cb, &cb->pss_ostream, $1, $3,
	    PST_BOP, (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK)
	{
	    return (status);
	}
	else if (BTtest($Yqual_depth, $Yqual_type))
	{
	    /*
	    ** If we are processing a join_search condition, set the joinid
	    ** field appropriately.  It has been initialized to PST_NOJOIN in
	    ** pst_node().
	    */
	    newnode->pst_sym.pst_value.pst_s_op.pst_joinid =
		    $Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id;
	}

	$$ = newnode;
    }
;

arith_term:		arith_factor
    {
	$$ = $1;
    }
		|	arith_term bin_op arith_factor
    {
	PST_QNODE              *newnode;
	PST_OP_NODE	       opnode;
	DB_STATUS	       status;
	i4		       nores_flag;

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   $Yin_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}

	opnode.pst_opno = $2;
	opnode.pst_opmeta = PST_NOMETA;
	opnode.pst_isescape = PST_DOESNT_APPLY;

	if ($1->pst_sym.pst_type == PST_SUBSEL ||
	    $3->pst_sym.pst_type == PST_SUBSEL)
	    opnode.pst_opmeta = PST_ONE_SUBSELECT;

	status = pst_node(cb, &cb->pss_ostream, $1, $3,
	    PST_BOP, (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK)
	{
	    return (status);
	}
	else if (BTtest($Yqual_depth, $Yqual_type))
	{
	    /*
	    ** If we are processing a join_search condition, set the joinid
	    ** field appropriately.  It has been initialized to PST_NOJOIN in
	    ** pst_node().
	    */
	    newnode->pst_sym.pst_value.pst_s_op.pst_joinid =
		    $Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id;
	}

	$$ = newnode;
    }
;

arith_factor:		primary BAOPH arith_factor
    {
	PST_QNODE              *newnode;
	PST_OP_NODE	       opnode;
	DB_STATUS	       status;
	i4		       nores_flag;

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   $Yin_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}

	opnode.pst_opno = $2;
	opnode.pst_opmeta = PST_NOMETA;
	opnode.pst_isescape = PST_DOESNT_APPLY;

	status = pst_node(cb, &cb->pss_ostream, $1, $3,
	    PST_BOP, (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK)
	{
	    return (status);
	}
	else if (BTtest($Yqual_depth, $Yqual_type))
	{
	    /*
	    ** If we are processing a join_search condition, set the joinid
	    ** field appropriately.  It has been initialized to PST_NOJOIN in
	    ** pst_node().
	    */
	    newnode->pst_sym.pst_value.pst_s_op.pst_joinid =
		    $Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id;
	}

	$$ = newnode;
    }
		|	primary
    {
	$$ = $1;
    }
;

bin_op:			BAOP
    {
	$$ = $1;
    }
		|	BDIVP
    {
	$$ = $1;
    }
;

primary:		element
    {
	$$ = $1;
    }
		|	UAOP primary
    {
	PST_QNODE              *newnode;
	PST_OP_NODE	       opnode;
	DB_STATUS	       status;
	i4		       nores_flag;

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   $Yin_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}

	/*
	** The scanner is unable to distinguish between unary and binary +,
	** and unary and binary -.  Therefore, translate the binary operator
	** ids to unary ones here.
	*/
	if ($1 == ADI_ADD_OP)
	    opnode.pst_opno = ADI_PLUS_OP;
	else if ($1 == ADI_SUB_OP)
	    opnode.pst_opno = ADI_MINUS_OP;

	opnode.pst_opmeta = PST_NOMETA;
	opnode.pst_isescape = PST_DOESNT_APPLY;

	status = pst_node(cb, &cb->pss_ostream, $2, (PST_QNODE *) NULL,
	    PST_UOP, (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK)
	{
	    return (status);
	}
        else if ((newnode->pst_sym.pst_type != PST_CONST) && 
                   (BTtest($Yqual_depth, $Yqual_type)))
	{
	    /*
	    ** If we are processing a join_search condition, set the joinid
	    ** field appropriately.  It has been initialized to PST_NOJOIN in
	    ** pst_node().
	    */
	    newnode->pst_sym.pst_value.pst_s_op.pst_joinid =
		    $Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id;
	}

	$$ = newnode;
    }
;

element:		cname
    {
	$$ = $1;
    }
    		|	set_or_scalar_function
    {
	i4		err_code;

	if ($1->pst_sym.pst_type == PST_AGHEAD ||
	    $1->pst_sym.pst_type == PST_BOP && $1->pst_left &&
	    $1->pst_left->pst_sym.pst_type == PST_UOP &&
	    $1->pst_left->pst_left &&
	    $1->pst_left->pst_left->pst_sym.pst_type == PST_AGHEAD)
	{
	    PST_QNODE	*a1 = $1;
	    PST_QNODE	*a2 = NULL;

	    if ($1->pst_sym.pst_type == PST_BOP)
	    {
		/* avg(x) => sum(x) / count(x) */
		a1 = $1->pst_left->pst_left;
		a2 = $1->pst_right;
	    }
	    if (   ($Yisdbp && $Ydbpinfo->pss_flags & PSS_INCOND) &&
		  !($Yisdbp && $Ydbpinfo->pss_flags & PSS_INFORQ)
		|| ($Yin_rule == TRUE))
	    {
		/* Not allowed in conditions in DB proc
		** control statements or CREATE RULE statments.
		*/
		(VOID) psf_error($Yin_rule ? E_US189E_6302_RULE_QUAL : 2415L,
		    0L, PSF_USERERR, &err_code, &psq_cb->psq_error, 1,
		    sizeof(cb->pss_lineno), &cb->pss_lineno);
		return (E_DB_ERROR);
	    }

	    if (BTtest($Yqual_depth, $Yqual_type))
	    {
		/* use of AGGREGATES in join_search condition is illegal */
		(VOID) psf_error(E_PS03A6_AGGR_IN_JOIN_COND, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	    }

	    if ($Yin_orderby)
	    {
		/* Not allowed in order by expressions. */
		(VOID) psf_error(E_PS03AA_AGGR_IN_ORDER_BY, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	    }
	    if ($Yin_groupby_clause)
	    {
		/* Not allowed in group by expressions. */
		(VOID) psf_error(E_PS03AB_AGGR_IN_GROUP_BY, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	    }
	    /*
	    ** for flattening we care if we have one or multiple aggregates,
	    ** so use two flags as a two-bit counter indicating that we have
	    ** none, one, or more than one
	    */
	    if (cb->pss_flattening_flags & PSS_AGHEAD || 
		$1->pst_sym.pst_type == PST_BOP)
		cb->pss_flattening_flags |= PSS_AGHEAD_MULTI;
	    cb->pss_flattening_flags |= PSS_AGHEAD;

	    /*
	    ** if we are processing elements of a target list, wait until the from
	    ** list is processed before checking for illegal use of aggregates in
	    ** where_clause and appending AGGHEAD to the appropriate AGGHEAD list
	    */
	    if (!$Yin_target_clause)
	    {
		PST_QNODE		*var_node;
		YYAGG_NODE_PTR      *agg_list_elem;
		DB_STATUS		status;

		if ((var_node = psl_find_node($1, PST_VAR)) != (PST_QNODE *) NULL &&
		    BTtest(var_node->pst_sym.pst_value.pst_s_var.pst_vno,
		       (char *) &$Yillegal_agg_relmask) ||
		    var_node == NULL && $Yinhaving == 0 && BTnext((i4)-1, 
			(char *) &$Yillegal_agg_relmask, PST_NUMVARS) != -1)
				/* 2nd test clumsily looks for count(*) 
				** in where, but NOT in having cl subselect */
		{
		    (VOID) psf_error(2930L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1, sizeof(cb->pss_lineno),
			&cb->pss_lineno);
		    return (E_DB_ERROR);
		}

		/* save location of new agg head */
		status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(YYAGG_NODE_PTR), 
		    (PTR *) &agg_list_elem, &psq_cb->psq_error);
		if (status != E_DB_OK)
		return (status);
		agg_list_elem->agg_node = a1;

		/* insert it into approprite AGGHEAD list */
		psl_insert_into_agg_list(var_node, agg_list_elem, $Yagg_list_stack,
				     cb->pss_qualdepth, &$Yflists[0]);
		if (a2 != NULL)
		{
		    /* save location of 2nd AGHEAD for xformed avg(x). */
		    status = psf_malloc(cb, &cb->pss_ostream, 
			(i4) sizeof(YYAGG_NODE_PTR), (PTR *) &agg_list_elem, 
			&psq_cb->psq_error);
		    if (status != E_DB_OK)
			return (status);
		    agg_list_elem->agg_node = a2;

		    /* insert it into appropriate AGHEAD list */
		    psl_insert_into_agg_list(var_node, agg_list_elem, 
			$Yagg_list_stack, cb->pss_qualdepth, &$Yflists[0]);
		}
	    }
	    /*
	    ** we may want to know if a subselect with aggregate(s) in its target
	    ** list involved any correlated references; if we are in the target list
	    ** of a subselect other than an outermost one, and $Ycorr_aggr.depth
	    ** has not been previously set, we set it to the current pss_qualdepth
	    ** and start looking for correlated references.  If such reference(s)
	    ** is(are) found, PSS_CORR_AGGR will be set in cb->pss_flattening_flags,
	    ** and after the query tree header is built, PST_CORR_AGGR will be set 
	    ** in the header flag field.  We will not be looking for correlated 
	    ** references if cb->pss_flattening_flags indicates that we have already
	    ** found an occurrence
	    */
	    else if (cb->pss_qualdepth > 1		&&
	         ~cb->pss_flattening_flags & PSS_CORR_AGGR	&&
		 $Ycorr_aggr.depth == -1)
	    {
		$Ycorr_aggr.depth = cb->pss_qualdepth;
		$Ycorr_aggr.found = FALSE;
	    }

	    /*
	    ** If aggregate occurred in the target list of the outermost subselect
	    ** of a SELECT, mark it as non-updatable
	    */
	    if (cb->pss_qualdepth == 1 && $Yin_target_clause)
	    {
		$Ynonupdt = TRUE;
		$Ynonupdt_reason |= PSS_SET_FUNC_IN_OUTERMOST_SUBSEL;
	    }

	     	cb->pss_stmt_flags |= PSS_AGINTREE;	/* pss_agintree = TRUE */
	}   /* end of aggregate function stuff */

	$$ = $1;
    }
		|	case_function
    {
	i4	err_code;

	if (psl_seqop_search($1))
	{
	    /* No sequence operators in case expressions. */
	    (void)psf_error(6319L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	$$ = $1;
    }
		|	cast_expr
    {
	i4	err_code;

	if (psl_seqop_search($1))
	{
	    /* No sequence operators in cast expressions. */
	    (void)psf_error(6319L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	$$ = $1;
    }
		|	seq_operator
    {
	i4	err_code;

	if ($Yin_where_clause || $Yinhaving || $Yin_orderby)
	{
	    /* No use of sequences in where, having or order by clauses. */
	    (void)psf_error(6319L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	$$ = $1;
    }
		|	constant
    {
	$$ = $1;
    }
		|	LPAREN select_expr_or_subselect RPAREN
    {
	$$ = $2;
    }
		|	cdbp_parmlvar
    {
	$$ = $1;
    }
;

select_expr_or_subselect:	select_expr
		|	subselect
;

comparison:		BDOP
    {
	$$ = $1;
    }
		|	EOP
    {
	$$ = $1;
    }
    		|	EQUAL
    {
	$$ = $1;
    }
		|	NAME
    {
	ADI_OP_NAME	opname;
	ADI_OP_ID	opid;
	ADI_OPINFO	opinfo;
	ADF_CB		*adf_scb = (ADF_CB*) cb->pss_adfcb;
	DB_STATUS	status;
	i4		err_code;

	/* Allow user-defined predicate function names to be used in
	** infix notation. Originally used for OME spatial functions:
	** inside, intesects and overlaps. 
	*/
	STmove($1, '\0', sizeof(ADI_OP_NAME), (char *)&opname);
					/* copy operator name */
	status = adi_opid(adf_scb, &opname, &opid);
	if (status == E_DB_OK) status = adi_op_info(adf_scb, opid, &opinfo);
					/* get operator ID, then info */
	if (status != E_DB_OK || opinfo.adi_optype != ADI_PRED_FUNC)
	{	/* is this a valid infix?? */
	    (VOID) psf_error(2931L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, (i4) STtrmwhite($1), $1);
	    return (E_DB_ERROR);
	}
	$$ = opid;
    }
;

sel_expr_list:		select_expr
    {
        PSS_EXLIST *exlist_ptr;	    
        DB_STATUS   status;

        status = psf_malloc(cb, &cb->pss_ostream, sizeof(PSS_EXLIST), 
	         (PTR *) &exlist_ptr, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

        /*								    
	** The node corresponding to a select_expr will be placed into a linked
	** list to be processed later
	*/							    
        exlist_ptr->pss_expr = $1;
        exlist_ptr->pss_next = $Yexprlist;
        $Yexprlist           = exlist_ptr;
    }
		|	sel_expr_list COMMA select_expr
    {
        PSS_EXLIST *exlist_ptr;	    
        DB_STATUS   status;

        status = psf_malloc(cb, &cb->pss_ostream, sizeof(PSS_EXLIST), 
	         (PTR *) &exlist_ptr, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

        /*								    
	** The node corresponding to a select_expr will be placed into a linked
	** list to be processed later
	*/							    
        exlist_ptr->pss_expr = $3;
        exlist_ptr->pss_next = $Yexprlist;
        $Yexprlist           = exlist_ptr;
    }
;

constant:		number
    {
	DB_STATUS              status;
	PST_CNST_NODE	       cconst;
	PST_QNODE	       *newnode;

	/* Non-parameter number constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst, sizeof(cconst),
	    $1->db_datatype, (i2) $1->db_prec, (i4) $1->db_length, 
	    (DB_ANYTYPE *) $1->db_data, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
		|	SCONST
    {
	DB_STATUS              status;
	PST_CNST_NODE	       cconst;
	PST_QNODE	       *newnode;
	i4			constSize;

	/* Non-parameter text constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	constSize = $1->db_t_count + DB_CNTSIZE;
	/* STAR may need to create a global tempTbl and VARCHAR(0) is invalid */
	if (constSize == DB_CNTSIZE)
	    ++constSize;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst, sizeof(cconst),
	    DB_VCH_TYPE, (i2) 0, constSize, 
	    (DB_ANYTYPE *) $1, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
		|	bit_or_hex_const
    {
	DB_STATUS              status;
	PST_CNST_NODE	       cconst;
	PST_QNODE	       *newnode;

	/* hex constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst, sizeof(cconst),
	    DB_VCH_TYPE, (i2) 0, (i4) ($1->db_t_count + DB_CNTSIZE),
	    (DB_ANYTYPE *) $1, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
		|	UCONST
    {
	DB_STATUS              status;
	PST_CNST_NODE	       cconst;
	PST_QNODE	       *newnode;
	i4			constSize;

	/* Non-parameter Unicode constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	constSize = $1->count * sizeof(UCS2) + DB_CNTSIZE;
	/* STAR may need to create a global tempTbl and VARCHAR(0) is invalid */
	if (constSize == DB_CNTSIZE)
	    constSize += sizeof(UCS2);
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst, sizeof(cconst),
	    DB_NVCHR_TYPE, (i2) 0, constSize, 
	    (DB_ANYTYPE *) $1, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
		|	DCONST	
    {
	DB_STATUS	status;
	PST_QNODE	       *newnode;

	status = psl_ansi_strtodt(cb, psq_cb, DB_ADTE_TYPE, 0,
			(DB_TEXT_STRING *)$1, &newnode, 
			(DB_DATA_VALUE *) NULL, 0);

	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
		|	TMWOCONST	
    {
	DB_STATUS	status;

	status = psl_ansi_strtodt(cb, psq_cb, DB_TMWO_TYPE, 0,
		       (DB_TEXT_STRING *)$1, &$$, 
			(DB_DATA_VALUE *) NULL, 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}
    }
		|	TMWCONST	
    {
	DB_STATUS	status;

	status = psl_ansi_strtodt(cb, psq_cb, DB_TMW_TYPE, 0,
			(DB_TEXT_STRING *)$1, &$$, 
			(DB_DATA_VALUE *) NULL, 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}
    }
		|	TMECONST	
    {
	DB_STATUS	status;

	status = psl_ansi_strtodt(cb, psq_cb, DB_TME_TYPE, 0,
			(DB_TEXT_STRING *)$1, &$$, 
			(DB_DATA_VALUE *) NULL, 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}
    }
		|	TSWOCONST
    {
	DB_STATUS	status;

	status = psl_ansi_strtodt(cb, psq_cb, DB_TSWO_TYPE, 0,
			(DB_TEXT_STRING *)$1, &$$, 
			(DB_DATA_VALUE *) NULL, 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}
    }
		|	TSWCONST	
    {
	DB_STATUS	status;

	status = psl_ansi_strtodt(cb, psq_cb, DB_TSW_TYPE, 0,
			(DB_TEXT_STRING *)$1, &$$,
			(DB_DATA_VALUE *) NULL, 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}
    }
		|	TSTMPCONST	
    {
	DB_STATUS	status;

	status = psl_ansi_strtodt(cb, psq_cb, DB_TSTMP_TYPE, 0,
			(DB_TEXT_STRING *)$1, &$$, 
			(DB_DATA_VALUE *) NULL, 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}
    }
		|	interval_const
    {
	$$ = $1;
    }
		|	QDATA
    {
	DB_STATUS              status;
	PST_CNST_NODE	       cconst;
	PST_QNODE	       *newnode;
	DB_DATA_VALUE	       *dbval;

	dbval = (DB_DATA_VALUE*) $1;
	/* Non-parameter arbitrary constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	/* we set this because we don't know the type */
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst, sizeof(cconst),
	    dbval->db_datatype, (i2) (dbval->db_prec), (i4) (dbval->db_length),
	    (DB_ANYTYPE *) dbval->db_data, &newnode, &psq_cb->psq_error,
	    (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
	|		DOLLAR I2CONST EQUAL QDATA
    {
	i4                err_code;
	PST_QNODE	       *parmnode;
	DB_STATUS	       status;

	/* parameters not allowed in non-repeat queries */
	if ((cb->pss_defqry != PSQ_DEFQRY) &&
	    (cb->pss_defqry != PSQ_DEFCURS))
	{
	    (VOID) psf_error(2110L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) sizeof(cb->pss_lineno),
		&cb->pss_lineno);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate a constant node with a parameter number */
	status = pst_2adparm(cb, psq_cb, &cb->pss_ostream, *$2, $4,
	    &parmnode, &cb->pss_highparm);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = parmnode;
    }
	|	    QUESTIONMARK
    {
	PST_QNODE	*newnode;
	DB_STATUS	status;
	PST_CNST_NODE	const_node;
	i4		err_code;
	i4		psq_mode;

	/* parameter markers allowed only in PREPARE statements.
	** We also won't allow parameters in certain DSQL statements.
	** The ones allowed are the ones that actually return a query
	** tree from pst_execute, with the exception of create rule,
	** integrity, and permit;  those seem too ddl-ish and weren't
	** allowed historically anyway.
	** SET SESSION AUTHORIZATION is special-cased in execute, so
	** I guess it's OK here, as bizarre as that may seem.
	*/

	psq_mode = psq_cb->psq_mode;
	if (cb->pss_defqry != PSQ_PREPARE ||
	  !(psq_mode == PSQ_APPEND ||
	    psq_mode == PSQ_DELETE ||
	    psq_mode == PSQ_REPLACE ||
	    psq_mode == PSQ_RETRIEVE ||
	    psq_mode == PSQ_RETINTO ||
	    psq_mode == PSQ_DGTT_AS_SELECT ||
	    psq_mode == PSQ_DELCURS ||
	    psq_mode == PSQ_REPCURS ||
	    psq_mode == PSQ_VIEW ||
	    psq_mode == PSQ_SET_SESS_AUTH_ID) )
	{
	    (VOID) psf_error(2306L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		sizeof(cb->pss_lineno), &cb->pss_lineno);
	    return (E_DB_ERROR); 
	}

	/* Allocate a constant node with a parameter number */

	++cb->pss_highparm;
	if ($Yin_target_clause)
	   ++cb->pss_targparm;
	const_node.pst_tparmtype = PST_USER;
	const_node.pst_parm_no = cb->pss_highparm + 1;
	const_node.pst_pmspec = PST_PMNOTUSED;
	const_node.pst_cqlang = DB_SQL;
	const_node.pst_origtxt = (char *) NULL;

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL, 
	    (PST_QNODE *) NULL, PST_CONST, (PTR) &const_node,
	    sizeof(const_node), (DB_DT_ID)DB_NODT, (i2) 0, (i4)0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);

	if (status != E_DB_OK)
	    return (status);

	$$ = newnode;
    }
	|	    USER
    {
	DB_STATUS	    status;

	status = psl_usr_func("user", cb, BTtest($Yqual_depth, $Yqual_type),
	    &$Ypss_join_info, &$$, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	    CURDATE
    {
	DB_STATUS	    status;

	status = psl_usr_func("current_date", cb,
	    BTtest($Yqual_depth, $Yqual_type), &$Ypss_join_info,
	    &$$, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	    CURTIME
    {
	DB_STATUS	    status;

	status = psl_usr_func("current_time", cb,
	    BTtest($Yqual_depth, $Yqual_type), &$Ypss_join_info,
	    &$$, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	    CURTIME LPAREN number RPAREN
    {
	DB_STATUS	    status;

	status = psl_usr_func("current_time", cb,
	    BTtest($Yqual_depth, $Yqual_type), &$Ypss_join_info,
	    &$$, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	    CURTIMESTAMP
    {
	DB_STATUS	    status;

	status = psl_usr_func("current_timestamp", cb,
	    BTtest($Yqual_depth, $Yqual_type), &$Ypss_join_info,
	    &$$, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	    CURTIMESTAMP LPAREN number RPAREN
    {
	DB_STATUS	    status;

	status = psl_usr_func("current_timestamp", cb,
	    BTtest($Yqual_depth, $Yqual_type), &$Ypss_join_info,
	    &$$, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	   LOCTIME 
    {
	DB_STATUS	    status;

	status = psl_usr_func("local_time", cb,
	    BTtest($Yqual_depth, $Yqual_type), &$Ypss_join_info,
	    &$$, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	   LOCTIME LPAREN number RPAREN
    {
	DB_STATUS	    status;

	status = psl_usr_func("local_time", cb,
	    BTtest($Yqual_depth, $Yqual_type), &$Ypss_join_info,
	    &$$, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	   LOCTIMESTAMP
    {
	DB_STATUS	    status;

	status = psl_usr_func("local_timestamp", cb,
	    BTtest($Yqual_depth, $Yqual_type), &$Ypss_join_info,
	    &$$, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	   LOCTIMESTAMP LPAREN number RPAREN
    {
	DB_STATUS	    status;

	status = psl_usr_func("local_timestamp", cb,
	    BTtest($Yqual_depth, $Yqual_type), &$Ypss_join_info,
	    &$$, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	    CURRENT_USER
    {
	DB_STATUS	    status;

	status = psl_usr_func("current_user", cb,
	    BTtest($Yqual_depth, $Yqual_type), &$Ypss_join_info,
	    &$$, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	    SESSION_USER
    {
	DB_STATUS	    status;

	status = psl_usr_func("session_user", cb,
	    BTtest($Yqual_depth, $Yqual_type), &$Ypss_join_info,
	    &$$, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	    SYSTEM_USER
    {
	DB_STATUS	    status;

	status = psl_usr_func("system_user", cb,
	    BTtest($Yqual_depth, $Yqual_type), &$Ypss_join_info,
	    &$$, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	    INITIAL_USER
    {
	DB_STATUS	    status;

	status = psl_usr_func("initial_user", cb,
	    BTtest($Yqual_depth, $Yqual_type), &$Ypss_join_info,
	    &$$, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	    DBA
    {
	ADI_OP_ID	       opid;
	DB_STATUS	       status;

	/* first get function id */
	{
	    ADI_OP_NAME	    funcname;
	    ADF_CB	    *adf_scb = (ADF_CB*) cb->pss_adfcb;
	    i4	    err_code;
	    /*
	    ** ADF didn't want to do any work, so we act as if the user entered
	    ** _dba()
	    */
	    STmove("_dba", '\0', sizeof(ADI_OP_NAME), (char *) &funcname);
	    
	    status = adi_opid(adf_scb, &funcname, &opid);
	    if (status != E_DB_OK)
	    {
		(VOID) psf_error(2906L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		    &cb->pss_lineno, (i4) (sizeof("$DBA") - 1), "$DBA");
		return (E_DB_ERROR);
	    }
	}

	/* now create a node representing the function */
	{
	    PST_OP_NODE	       opnode;
	    PST_QNODE	       *newnode;
	    
	    opnode.pst_opno = opid;
	    opnode.pst_opmeta = PST_NOMETA;
	    opnode.pst_isescape = PST_DOESNT_APPLY;
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		(PST_QNODE *) NULL, PST_COP, (char *) &opnode, sizeof(opnode),
		DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, &newnode,
		&psq_cb->psq_error, (i4) 0);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }
	    else if (BTtest($Yqual_depth, $Yqual_type))
	    {
		/*
		** If we are processing a join_search condition, set the joinid
		** field appropriately.  It has been initialized to PST_NOJOIN in
		** pst_node().
		*/
		newnode->pst_sym.pst_value.pst_s_op.pst_joinid =
			$Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id;
	    }
	    
	    $$ = newnode;
	}
    }
	|	    INGRES
    {
	PST_CNST_NODE	    cconst;

	/* buffer to store $ingres as a string constant */
	DEFINE_DB_TEXT_STRING(ingres,"ingres")
	PST_QNODE	    *newnode;
	DB_STATUS           status;

	/*@FIX_ME@ I don't like this -- what if cat owner not "$ingres"? */
	MEcopy(cb->pss_cat_owner->db_own_name, 
	       ingres.db_t_count, (char *) &(ingres.db_t_text[0]));

	/* Non-parameter text constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), DB_VCH_TYPE, (i2) 0,
	    (i4) (ingres.db_t_count + DB_CNTSIZE),
	    (DB_ANYTYPE *) &ingres, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
;

interval_const:	INTERVAL SCONST interval_type
    {
	DB_STATUS	status;
	PST_QNODE	*nodep;
	DB_DT_ID	int_type;

	if ($3 >= INT_DAY * 8)
	    int_type = DB_INDS_TYPE;
	else int_type = DB_INYM_TYPE;

	status = psl_ansi_strtodt(cb, psq_cb, int_type, $3,
			(DB_TEXT_STRING *)$2, &nodep, 
			(DB_DATA_VALUE *) NULL, $Yinterval_frac);
	if (status != E_DB_OK)
	{
	    return (status);
	}
	$$ = nodep;
    }
;

interval_type: nonkeyword interval_junk1 interval_junk2
    {
	i4	ij2;
	bool	badword = FALSE;

	if (STcompare($1, "year") == 0)
	    $$ = INT_YEAR;
	else if (STcompare($1, "month") == 0)
	    $$ = INT_MONTH;
	else if (STcompare($1, "day") == 0)
	    $$ = INT_DAY;
	else if (STcompare($1, "hour") == 0)
	    $$ = INT_HOUR;
	else if (STcompare($1, "minute") == 0)
	    $$ = INT_MINUTE;
	else if (STcompare($1, "second") == 0)
	    $$ = INT_SECOND;
	else badword = TRUE;

	/* Validate field range and encode for conversion. */
	if (badword || $3 && $$ >= $3 ||
	    ($$ <= INT_MONTH && $3 >= INT_DAY))
	{
	    /* Syntax error in literal. */
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_OK);
	}

	/* Set 2nd field of range. */
	ij2 = $3;
	if (ij2 == 0)
	    ij2 = $$;

	$$ = $$*8 + ij2;		/* encode field range */
    }

interval_junk1:	/* nuttin' */
    {
	$Yinterval_frac = 6;		/* default fracs of seconds */
    }
	|	LPAREN I2CONST RPAREN
    {
	$Yinterval_frac = *$2;
    }
	|	LPAREN I2CONST COMMA I2CONST RPAREN
    {
	$Yinterval_frac = *$4;
    }
;

interval_junk2:	/* still nuttin' */
    {
	$$ = 0;
    }
	|	TO nonkeyword LPAREN I2CONST RPAREN
    {
	if (STcompare($2, "second") != 0)
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}
	$Yinterval_frac = *$4;
	$$ = INT_SECOND;
    }
	|	TO nonkeyword
    {
	if (STcompare($2, "month") == 0)
	    $$ = INT_MONTH;
	else if (STcompare($2, "hour") == 0)
	    $$ = INT_HOUR;
	else if (STcompare($2, "minute") == 0)
	    $$ = INT_MINUTE;
	else if (STcompare($2, "second") == 0)
	{
	    $$ = INT_SECOND;
	    $Yinterval_frac = 6;		/* default fracs of seconds */
	}
	else
	{
	    /* Everything else is a syntax error - including year
	    ** and day, since they can't be the low end field. */
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}
    }
;

number:		 	I2CONST
    {
	$Ydb_pdata.db_datatype	= DB_INT_TYPE;
	$Ydb_pdata.db_prec  	= 0;
	$Ydb_pdata.db_length	= 2;
	$Ydb_pdata.db_data	= (PTR) &$Ydb_vdata;
	$Ydb_vdata.db_i2type	= *$1;
	$$ = &$Ydb_pdata;
    }
		|	I4CONST
    {
	$Ydb_pdata.db_datatype	= DB_INT_TYPE;
	$Ydb_pdata.db_prec  	= 0;
	$Ydb_pdata.db_length	= 4;
	$Ydb_pdata.db_data	= (PTR) &$Ydb_vdata;
	$Ydb_vdata.db_i4type	= *$1;
	$$ = &$Ydb_pdata;
    }
		|	I8CONST
    {
	$Ydb_pdata.db_datatype	= DB_INT_TYPE;
	$Ydb_pdata.db_prec  	= 0;
	$Ydb_pdata.db_length	= 8;
	$Ydb_pdata.db_data	= (PTR) &$Ydb_vdata;
	$Ydb_vdata.db_i8type	= *$1;
	$$ = &$Ydb_pdata;
    }

		|	DECCONST
    {
	i2		prec;

	I2ASSIGN_MACRO(*$1, prec);
	$Ydb_pdata.db_datatype	= DB_DEC_TYPE;
	$Ydb_pdata.db_prec  	= prec;
	$Ydb_pdata.db_length	= DB_PREC_TO_LEN_MACRO(DB_P_DECODE_MACRO(prec));
	$Ydb_pdata.db_data	= (PTR)((u_char *)$1 + sizeof(i2));
	$$ = &$Ydb_pdata;
    }
		|	F4CONST
    {
	$Ydb_pdata.db_datatype	= DB_FLT_TYPE;
	$Ydb_pdata.db_prec  	= 0;
	$Ydb_pdata.db_length	= 4;
	$Ydb_pdata.db_data	= (PTR) &$Ydb_vdata;
	$Ydb_vdata.db_f4type	= *$1;
	$$ = &$Ydb_pdata;
    }
		|	F8CONST
    {
	$Ydb_pdata.db_datatype	= DB_FLT_TYPE;
	$Ydb_pdata.db_prec  	= 0;
	$Ydb_pdata.db_length	= 8;
	$Ydb_pdata.db_data	= (PTR) &$Ydb_vdata;
	$Ydb_vdata.db_f8type	= *$1;
	$$ = &$Ydb_pdata;
    }
;

avg_min_max_sum:	AVG
    {
	$$ = AGGR_AVG;
    }
		|	MIN
    {
	$$ = AGGR_MIN;
    }
		|	MAX
    {
	$$ = AGGR_MAX;
    }
		|	SUM
    {
	$$ = AGGR_SUM;
    }
;

set_or_scalar_function:	count LPAREN BAOP RPAREN
    {
	PST_QNODE   *aghdnode;
	DB_STATUS   status;
	
	status = psl_set_function(cb, psq_cb, yyvarsp /** i.e. $Y  **/,
				  ERx("count(*)"), PST_NDISTINCT, 
				  TRUE, (PST_QNODE *) NULL, 
				  (PST_QNODE *) NULL, &aghdnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$$ = aghdnode;
    }
		|	count LPAREN set_fun_dist select_expr RPAREN
    {
	PST_QNODE   *aghdnode;
	DB_STATUS   status;
	
	status = psl_set_function(cb, psq_cb, yyvarsp /** i.e. $Y  **/,
				  ERx("count"), $3, TRUE, $4, 
				  (PST_QNODE *) NULL, &aghdnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$$ = aghdnode;
    }
		|	ANY LPAREN
    {
	i4	    err_code;

	if (!($Yaggr_allowed & PSS_AGG_ALLOWED))
	{
	    (VOID) psf_error(2928L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		sizeof(ERx("any")) - 1, ERx("any"));
	    return (E_DB_ERROR);
	}
	else
	{
	    $Yaggr_allowed &= ~PSS_AGG_ALLOWED;
	}
    }
			set_fun_dist select_expr RPAREN
    {
	PST_QNODE   *aghdnode;
	DB_STATUS   status;
	
	/* for ANY, we don't care about distinct values 
	 */
	status = psl_set_function(cb, psq_cb, yyvarsp /** i.e. $Y  **/,
				  ERx("any"), PST_DONTCARE, TRUE, 
				  $5, (PST_QNODE *) NULL, &aghdnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$$ = aghdnode;
    }
		|	avg_min_max_sum
    {
	i4	    err_code;

	if (!($Yaggr_allowed & PSS_AGG_ALLOWED))
	{
	    (VOID) psf_error(2928L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		STlength(aggr_func_names[$1]), aggr_func_names[$1]);
	    return (E_DB_ERROR);
	}
	else
	{
	    $Yaggr_allowed &= ~PSS_AGG_ALLOWED;
	}
    }
		        LPAREN set_fun_dist select_expr RPAREN
    {
	PST_QNODE   *aghdnode;
	DB_STATUS   status;
	
	/* for MIN and MAX we don't care about distinct values */
	if ($1 == AGGR_MIN || $1 == AGGR_MAX)
	{
	    $4 = PST_DONTCARE;
	}

	status = psl_set_function(cb, psq_cb, yyvarsp /** i.e. $Y  **/,
				  aggr_func_names[$1], $4, FALSE,
				  $5, (PST_QNODE *) NULL, &aghdnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$$ = aghdnode;
    }
		|	nonreswd_function
    {
	$$ = $1;
    }
;

count:		COUNT
    {
	i4	    err_code;

	if (!($Yaggr_allowed & PSS_AGG_ALLOWED))
	{
	    (VOID) psf_error(2928L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		sizeof(ERx("count")) - 1, ERx("count"));
	    return (E_DB_ERROR);
	}
	else
	{
	    $Yaggr_allowed &= ~PSS_AGG_ALLOWED;
	}
    }
;

set_fun_dist:		
    {
	$$ = PST_BDISTINCT;
    }
		|	ALL
    {
	$$ = PST_NDISTINCT;
    }
		|	DISTINCT
    {
	$$ = PST_DISTINCT;
    }
;

set_fun_all_dist:	DISTINCT
    {
	$$ = PST_DISTINCT;
    }
		|	ALL
    {
	$$ = PST_NDISTINCT;
    }
;

nonreswd_function:	func LPAREN RPAREN
    {
	PST_QNODE	       *newnode;
	DB_STATUS	       status;

	status = psl_nary_func(cb, psq_cb, yyvarsp, $1, &newnode);
	if (status != E_DB_OK)
	    return (status);
	$$ = newnode;
    }
	    |		func LPAREN set_fun_all_dist select_expr RPAREN
    {
	PST_QNODE   *aghdnode;
	DB_STATUS   status;
	
	if ($1->adi_optype != ADI_AGG_FUNC)
	{
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}

	/* Not going to use the func-args mechanism, pop what func pushed */
	$Yarg_ix = $Yarg_base;
	$Yarg_base = $Yarg_stack[--$Yarg_stack_ix];

	status = psl_set_function(cb, psq_cb, yyvarsp /** i.e. $Y  **/,
				  (char *)&$1->adi_opname, $3, FALSE, 
				  $4, (PST_QNODE *) NULL, &aghdnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$$ = aghdnode;
    }
	| SUBSTRING LPAREN sel_expr_or_null from_or_comma sel_expr_or_null RPAREN
    {
	ADI_OPINFO	func;
	DB_STATUS	status;
	i4		err_code;
	PST_QNODE	*newnode;

	/* ANSI style substring.
	** "func" production not used, do its work here.
	** Find substring opinfo and do 2-operand function.
	*/
	status = adi_op_info(cb->pss_adfcb, ADI_SUBSTRING_OP, &func);
	if (status != E_DB_OK)
	    return (status);
	/* Stack current arglist base, reset to current arglist position */
	if ($Yarg_stack_ix >= PSS_YYMAXDEPTH)
	{
	    (void) psf_error(2800L, 0, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, sizeof(cb->pss_lineno),
		&cb->pss_lineno);
	    return (E_DB_ERROR);
	}
	$Yarg_stack[$Yarg_stack_ix++] = $Yarg_base;
	$Yarg_base = $Yarg_ix;

	/* Put string and from args where they belong */
	status = psl_arg_room(cb, psq_cb, yyvarsp, 2);
	if (status != E_DB_OK)
	    return (status);
	$Yfunc_args[$Yarg_ix++] = $3;
	$Yfunc_args[$Yarg_ix++] = $5;
	status = psl_nary_func(cb, psq_cb, yyvarsp, &func, &newnode);
	if (status != E_DB_OK)
	    return (status);
	$$ = newnode;
    }
	    |	func LPAREN sel_expr_or_null IN sel_expr_or_null RPAREN
    {
	DB_STATUS	status;
	i4		err_code;
	PST_QNODE	*newnode;

	/* This is the ANSI POSITION function - func MUST be "position". */

	if ($1->adi_opid != ADI_POS_OP)
	{
	    (void)psf_error(2934L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, (i4) STtrmwhite((char *)&($1->adi_opname)), 
		$1->adi_opname);
	    return (E_DB_ERROR);
	}
	status = psl_arg_room(cb, psq_cb, yyvarsp, 2);
	if (status != E_DB_OK)
	    return (status);
	$Yfunc_args[$Yarg_ix++] = $3;
	$Yfunc_args[$Yarg_ix++] = $5;
	status = psl_nary_func(cb, psq_cb, yyvarsp, $1, &newnode);
	if (status != E_DB_OK)
	    return (status);
	$$ = newnode;

    }
	    |	func LPAREN trim_or_extract_spec FROM sel_expr_or_null RPAREN
    {
	DB_STATUS	status;
	i4		err_code;
	PST_QNODE	*newnode;
	ADI_OPINFO	*opinfo;
	bool		extract = FALSE;

	/* This is ANSI syntax for the TRIM or EXTRACT functions - funcname
	** must be either TRIM or EXTRACT. */

	/* Determine if this is TRIM or EXTRACT. TRIMs always have 3 byte
	** constant for $3. EXTRACT only has 3 bytes if it is DAY. */
	if ($3->pst_sym.pst_dataval.db_length != 3 ||
	    MEcmp($3->pst_sym.pst_dataval.db_data, "day", 3) == 0)
	    extract = TRUE;

	if (($1->adi_opid != ADI_TRIM_OP && $1->adi_opid != ADI_DPART_OP) ||
	    ($1->adi_opid == ADI_TRIM_OP && extract) ||
	    ($1->adi_opid == ADI_DPART_OP && !extract))
	{
	    /* Plain old syntax error. */
	    psl_yerror(3, cb, psq_cb);
	    return (E_DB_ERROR);
	}

	/* Change trim() to atrim(). */
	if ($1->adi_opid == ADI_TRIM_OP)
	{
            status = psf_malloc(cb, &cb->pss_ostream, sizeof(ADI_OPINFO), 
	         (PTR *) &opinfo, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return(status);

	    status = adi_op_info((ADF_CB *)cb->pss_adfcb, ADI_ATRIM_OP, opinfo);
	    if (status != E_DB_OK)
		return(status);
	}
	else opinfo = $1;

	status = psl_arg_room(cb, psq_cb, yyvarsp, 2);
	if (status != E_DB_OK)
	    return (status);

	/* If this is EXTRACT, parms are in sequence. If TRIM, they're
	** backwards. */
	if (extract)
	{
	    $Yfunc_args[$Yarg_ix++] = $3;
	    $Yfunc_args[$Yarg_ix++] = $5;
	}
	else
	{
	    $Yfunc_args[$Yarg_ix++] = $5;
	    $Yfunc_args[$Yarg_ix++] = $3;
	}

	status = psl_nary_func(cb, psq_cb, yyvarsp, opinfo, &newnode);
	if (status != E_DB_OK)
	    return (status);
	$$ = newnode;
    }
    	|	SUBSTRING LPAREN sel_expr_or_null from_or_comma sel_expr_or_null
			for_or_comma sel_expr_or_null RPAREN
    {
	ADI_OPINFO	func;
	DB_STATUS	status;
	i4		err_code;
	PST_QNODE	*newnode;

	/* ANSI style substring.
	** "func" production not used, do its work here.
	** Find substring opinfo and do 3-operand function.
	*/
	status = adi_op_info(cb->pss_adfcb, ADI_SUBSTRING_OP, &func);
	if (status != E_DB_OK)
	    return (status);
	/* Stack current arglist base, reset to current arglist position */
	if ($Yarg_stack_ix >= PSS_YYMAXDEPTH)
	{
	    (void) psf_error(2800L, 0, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, sizeof(cb->pss_lineno),
		&cb->pss_lineno);
	    return (E_DB_ERROR);
	}
	$Yarg_stack[$Yarg_stack_ix++] = $Yarg_base;
	$Yarg_base = $Yarg_ix;

	status = psl_arg_room(cb, psq_cb, yyvarsp, 3);
	if (status != E_DB_OK)
	    return (status);
	$Yfunc_args[$Yarg_ix++] = $3;
	$Yfunc_args[$Yarg_ix++] = $5;
	$Yfunc_args[$Yarg_ix++] = $7;
	status = psl_nary_func(cb, psq_cb, yyvarsp, &func, &newnode);
	if (status != E_DB_OK)
	    return (status);
	$$ = newnode;
    }
	    | func LPAREN func_argcommalist RPAREN
    {
	PST_QNODE	       *newnode;
	DB_STATUS	       status;

	status = psl_nary_func(cb, psq_cb, yyvarsp, $1, &newnode);
	if (status != E_DB_OK)
	    return (status);
	$$ = newnode;
    }
;

from_or_comma:		FROM
	    | COMMA
;

for_or_comma:		FOR
	    | COMMA
;

func_argcommalist:	func_arg
	|		func_argcommalist COMMA func_arg
;

/* Parse one arg for nonreswd_func ( arg, ... ).
** arg expr pointers are saved in the func_args array.
*/
func_arg:	sel_expr_or_null
    {
	DB_STATUS status;

	status = psl_arg_room(cb, psq_cb, yyvarsp, 1);
	if (status != E_DB_OK)
	    return (status);
	if (($Yarg_ix - $Yarg_base) == ADI_MAX_OPERANDS)
	{
	    i4 err_code;
	    i4 maxops = ADI_MAX_OPERANDS;

	    (void)psf_error(2423, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		sizeof(maxops), &maxops);
	    return (E_DB_ERROR);
	}
	$Yfunc_args[$Yarg_ix++] = $1;
    }
;


func:		    name_or_interval
    {
	ADI_OP_NAME	       funcname;
	ADI_OP_ID	       opid;
	ADI_OPINFO	       *opinfo;
	ADF_CB		       *adf_scb = (ADF_CB*) cb->pss_adfcb;
	DB_STATUS	       status;
	i4		       err_code;

	STmove($1, '\0', sizeof(ADI_OP_NAME), (char *) &funcname);
	status = adi_opid(adf_scb, &funcname, &opid);
	if (status != E_DB_OK)
	{
	    (VOID) psf_error(2906L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, (i4) STtrmwhite($1), $1);
	    return (E_DB_ERROR);
	}

        status = psf_malloc(cb, &cb->pss_ostream, sizeof(ADI_OPINFO), 
	         (PTR *) &opinfo, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}
	status = adi_op_info(adf_scb, opid, opinfo);
	if (status != E_DB_OK)
	{
	    (VOID) psf_error(2906L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, (i4) STtrmwhite($1), $1);
	    return (E_DB_ERROR);
	}

	/* Stack current arglist base, reset to current arglist position */
	if ($Yarg_stack_ix >= PSS_YYMAXDEPTH)
	{
	    (void) psf_error(2800L, 0, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, sizeof(cb->pss_lineno),
		&cb->pss_lineno);
	    return (E_DB_ERROR);
	}
	$Yarg_stack[$Yarg_stack_ix++] = $Yarg_base;
	$Yarg_base = $Yarg_ix;
	$$ = opinfo;
    }
;

name_or_interval:	NAME
    {
	$$ = $1;
    }
	|	INTERVAL
    {
	$$ = "interval";
    }
;

trim_or_extract_spec:		nonkeyword strconst_e
    {
	PST_QNODE	*newnode;
	PST_CNST_NODE	cconst;
	DB_STATUS	status;
	i1		trimcode;
	i4		err_code, copylen;
	char		trimval[3];

	/* Validate trim specifier value. */
	if (STbcompare($1, 0, "trailing", 0, TRUE) == 0)
	    trimcode = ADF_TRIM_TRAILING;
	else if (STbcompare($1, 0, "leading", 0, TRUE) == 0)
	    trimcode = ADF_TRIM_LEADING;
	else if (STbcompare($1, 0, "both", 0, TRUE) == 0)
	    trimcode = ADF_TRIM_BOTH;
	else
	{
	    /* Bad value for trim code. */
	    psf_error(2936L, 0L, PSF_USERERR,
		      &err_code, &psq_cb->psq_error, 2,
		      sizeof(cb->pss_lineno), &cb->pss_lineno,
		      STlength($1), $1);
	    return(E_DB_ERROR);
	}

	trimval[0] = (i1)trimcode;

	/* Now add trim character. */
	trimval[1] = trimval[2] = 0;
	copylen = STlength($2);
	if (copylen > 2)
	    copylen = 2;
	if (copylen == 0)
	    trimval[1] = ' ';
	else MEcopy($2, copylen, &trimval[1]);
	if (copylen <= 1)
	    trimval[2] = 0;

	/* Now make a PST_CONST with this stuff in it and return. */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), DB_CHA_TYPE, (i2) 0, (i4) 3,
	    (DB_ANYTYPE *) &trimval, &newnode, &psq_cb->psq_error,
	    (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$$ = newnode;
    }
		|	nonkeyword
    {
	PST_QNODE	*newnode;
	PST_CNST_NODE	cconst;
	DB_STATUS	status;
	i4		err_code;
	i2		i, constlen;
	char		trimval[3];
	char		*cptr;
	bool		found = TRUE;

	/* Validate specifier - trim field or extract field. */

	/* Trim character defaults to ' '. */
	constlen = 3;
	cptr = &trimval[0];
	trimval[1] = ' ';
	trimval[2] = 0;
	if (STbcompare($1, 0, "trailing", 0, TRUE) == 0)
	    trimval[0] = ADF_TRIM_TRAILING;
	else if (STbcompare($1, 0, "leading", 0, TRUE) == 0)
	    trimval[0] = ADF_TRIM_LEADING;
	else if (STbcompare($1, 0, "both", 0, TRUE) == 0)
	    trimval[0] = ADF_TRIM_BOTH;
	else
	{
	    for (i = 0; i < EXTRACT_FIELDS_COUNT; i++)
	     if (STbcompare($1, 0, extract_fields[i], 0, TRUE) == 0)
		break;

	    if (i >= EXTRACT_FIELDS_COUNT)
		found = FALSE;
	    else 
	    {
		constlen = STlength(extract_fields[i]);
		cptr = extract_fields[i];
	    }
	}

	if (!found)
	{
	    /* Plain old syntax error. */
	    psl_yerror(3, cb, psq_cb);
	    return(E_DB_ERROR);
	}

	/* Now make a PST_CONST with this stuff in it and return. */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), DB_CHA_TYPE, (i2) 0, (i4) constlen,
	    (DB_ANYTYPE *) cptr, &newnode, &psq_cb->psq_error,
	    (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$$ = newnode;
    }
		|	strconst_e
    {
	PST_QNODE	*newnode;
	PST_CNST_NODE	cconst;
	DB_STATUS	status;
	i1		trimcode;
	i4		copylen;
	char		trimval[3];

	/* Trim code defaults to 2 (both). */
	trimval[0] = (i1)ADF_TRIM_BOTH;

	/* Now add trim character. */
	trimval[1] = trimval[2] = 0;
	copylen = STlength($1);
	if (copylen > 2)
	    copylen = 2;
	if (copylen == 0)
	    trimval[1] = ' ';
	else MEcopy($1, copylen, &trimval[1]);
	if (copylen == 1)
	{
	    trimval[2] = 0;
	}

	/* Now make a PST_CONST with this stuff in it and return. */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), DB_CHA_TYPE, (i2) 0, (i4) 3,
	    (DB_ANYTYPE *) &trimval, &newnode, &psq_cb->psq_error,
	    (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$$ = newnode;
    }
;

case_function:		case_word case_body END
    {
	$$ = $2;
    }
		|	NULLIF LPAREN select_expr COMMA select_expr RPAREN
    {
	/* This is a bit drawn out. NULLIF is literally defined as 
	** "case when v1 = v2 then NULL else v1 end", and the entire parse
	** tree structure is built here. */

	DB_STATUS	status;
	PST_QNODE	*casep, *whlistp, *whopp, *constp;
	PST_QNODE	*srcecopy;
	PSS_TREEINFO	*treeinfo;
	PST_OP_NODE	eqnode;
	PST_CNST_NODE	constnode;
	PST_CASE_NODE	casenode;
	DB_DATA_VALUE	db_data;
	i4	        nores_flag;
	char		buf[DB_CNTSIZE + 1];

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   $Yin_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}

	/* Build WHOP, WHLIST to represent NULLIF's else case. */
	status = pst_node(cb, &cb->pss_ostream, NULL, $3,
		PST_WHOP, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whopp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	/* Allocate PST_WHLIST node and attach WHOP node to pst_right. */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL, whopp,
		PST_WHLIST, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whlistp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	/* Build "v1 = v2" comparison, then NULL constant value to attach
	** to upper WHLIST. */

	/* Copy the v1 source expression. */
	$Ydup_rb.pss_tree = $3;
	$Ydup_rb.pss_dup  = &srcecopy;;
	status = pst_treedup(cb, &$Ydup_rb);

	if (status != E_DB_OK) return (status);

	/* Set up "=" comparison between v1 and v2. */
	status = psl_simple_compare(cb, srcecopy, $5,
		ADI_EQ_OP, (i4)PST_DOESNT_APPLY, (char)0, &treeinfo, 
		(bool)BTtest($Yqual_depth, $Yqual_type), (bool)$Yin_target_clause,
		&$Ypss_join_info, psq_cb);

	if (status != E_DB_OK) return (status);

	/* NULL constant node */
	db_data.db_datatype = -DB_LTXT_TYPE;
	db_data.db_prec     = 0;
	db_data.db_length   = DB_CNTSIZE + 1;
	db_data.db_data	    = (PTR) buf;

	status = adc_getempty ((ADF_CB *)cb->pss_adfcb, &db_data);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	constnode.pst_tparmtype = PST_USER;
	constnode.pst_parm_no = 0;
	constnode.pst_pmspec  = PST_PMNOTUSED;
	constnode.pst_cqlang = DB_SQL;
	constnode.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &constnode,
	    sizeof(constnode), -DB_LTXT_TYPE, (i2) 0, (i4) (1 + DB_CNTSIZE),
	    (DB_ANYTYPE *) db_data.db_data, &constp, &psq_cb->psq_error,
	    (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Build WHOP, WHLIST to contain NULLIF's "when v1 = v2 then NULL". */
	status = pst_node(cb, &cb->pss_ostream, treeinfo->pss_tree, constp,
		PST_WHOP, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whopp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	/* Allocate PST_WHLIST node and attach WHOP node to pst_right. */
	status = pst_node(cb, &cb->pss_ostream, whlistp, whopp,
		PST_WHLIST, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whlistp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	/* Finally init case node, then allocate PST_CASEOP node and attach 
	** NULLIF "when list". */
	casenode.pst_caselen = 0;
	casenode.pst_casedt = (DB_DT_ID) DB_NODT;
	casenode.pst_caseprec = 0;
	casenode.pst_casetype = PST_SEARCHED_CASE;

	status = pst_node(cb, &cb->pss_ostream, whlistp, (PST_QNODE *)NULL, 
		PST_CASEOP, (char *)&casenode, (i4)sizeof(PST_CASE_NODE), 
		DB_NODT, (i2)0, (i4)0, (DB_ANYTYPE *)NULL, &casep, 
		&psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	$$ = casep;
    }
		|	COALESCE LPAREN coalesce_list RPAREN
    {
	DB_STATUS	status;
	PST_QNODE	*casep, *whlistp;
	PST_CASE_NODE	casenode;
	DB_DATA_VALUE	db_data;
	i4	        nores_flag;

	/* COALESCE(v1, v2, ..., vn) compiles to "CASE WHEN v1 IS NOT NULL THEN v1
	** ELSE WHEN v2 IS NOT NULL THEN v2 ... ELSE vn". Once we return here,
	** all we need to do is allocate the case node and attach whlist from
	** below. */

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   $Yin_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}

	/* Build case node and attach WHLIST chain to it. */
	casenode.pst_caselen = 0;
	casenode.pst_casedt = (DB_DT_ID) DB_NODT;
	casenode.pst_caseprec = 0;
	casenode.pst_casetype = PST_SEARCHED_CASE;

	status = pst_node(cb, &cb->pss_ostream, $3, (PST_QNODE *)NULL, 
		PST_CASEOP, (char *)&casenode, (i4)sizeof(PST_CASE_NODE), 
		DB_NODT, (i2)0, (i4)0, (DB_ANYTYPE *)NULL, &casep, 
		&psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	/* Final step is to find last WHLIST and make it into "ELSE vn"
	** by removing "vn IS NOT NULL" from corresponding WHOP node. */
	for (whlistp = $3; whlistp->pst_left != NULL; 
		whlistp = whlistp->pst_left);	/* loop ends when we're at
						** last WHLIST */
	whlistp->pst_right->pst_left = (PST_QNODE *) NULL;

	$$ = casep;
    }
;

case_word:		CASE
    {
    }
;

case_body:		searched_case
    {
	DB_STATUS	status;
	PST_QNODE	*casep;
	PST_CASE_NODE	casenode;
	i4	        nores_flag;

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   $Yin_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}


	/* Init case node, then allocate PST_CASEOP node and attach "when list". */
	casenode.pst_caselen = 0;
	casenode.pst_casedt = (DB_DT_ID) DB_NODT;
	casenode.pst_caseprec = 0;
	casenode.pst_casetype = PST_SEARCHED_CASE;

	status = pst_node(cb, &cb->pss_ostream, $1, (PST_QNODE *)NULL, 
		PST_CASEOP, (char *)&casenode, (i4)sizeof(PST_CASE_NODE), 
		DB_NODT, (i2)0, (i4)0, (DB_ANYTYPE *)NULL, &casep, 
		&psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	$$ = casep;
    }
		|	select_expr simple_case
    {
	DB_STATUS	status;
	PST_QNODE	*casep, *whlistp;
	PST_CASE_NODE	casenode;
	i4 		nores_flag;

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   $Yin_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}


	/* Init case node, then allocate PST_CASEOP node and attach "when list" 
	** and source value expression. */
	casenode.pst_caselen = 0;
	casenode.pst_casedt = (DB_DT_ID) DB_NODT;
	casenode.pst_caseprec = 0;
	casenode.pst_casetype = PST_SIMPLE_CASE;

	/* Now loop over "when" list, creating search expressions for each. */
	for (whlistp = $2; whlistp && whlistp->pst_right->pst_left;
		whlistp = whlistp->pst_left)
	{
	    PST_QNODE	*srcecopy;
	    PSS_TREEINFO *treeinfo;

	    /* Copy the source expression. */
	    $Ydup_rb.pss_tree = $1;
	    $Ydup_rb.pss_dup  = &srcecopy;;
	    status = pst_treedup(cb, &$Ydup_rb);

	    if (status != E_DB_OK) return (status);

	    /* Set up "=" comparison between source and "when" clause 
	    ** comparand expression. */
	    status = psl_simple_compare(cb, srcecopy, whlistp->pst_right->pst_left,
		ADI_EQ_OP, (i4)PST_DOESNT_APPLY, (char)0, &treeinfo, 
		(bool)BTtest($Yqual_depth, $Yqual_type), (bool)$Yin_target_clause,
		&$Ypss_join_info, psq_cb);

	    if (status != E_DB_OK) return (status);

	    /* Finally, replace comparand expression of "when" clause by new
	    ** "=" comparison. */
	    whlistp->pst_right->pst_left = treeinfo->pss_tree;
	}

	status = pst_node(cb, &cb->pss_ostream, $2, $1,
		PST_CASEOP, (char *)&casenode, (i4)sizeof(PST_CASE_NODE), 
		DB_NODT, (i2)0, (i4)0, (DB_ANYTYPE *)NULL, &casep, 
		&psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	$$ = casep;
    }
;

searched_case:		searched_when_list case_else
    {
	PST_QNODE	*nodep;

	/* Just loop down left side of "when list" and attach case_else to end. */
	for (nodep = $1; nodep->pst_left && 
		nodep->pst_left->pst_sym.pst_type == PST_WHLIST;
		nodep= nodep->pst_left);
	nodep->pst_left = $2;

	$$ = $1;
    }
;

searched_when_list:	searched_when_list_item
    {
	$$ = $1;
    }
		|	searched_when_list searched_when_list_item
    {
	PST_QNODE	*nodep;

	/* Attach "when item" to list. */
	for (nodep = $1; nodep->pst_left && 
		nodep->pst_left->pst_sym.pst_type == PST_WHLIST;
		nodep= nodep->pst_left);
	nodep->pst_left = $2;

	$$ = $1;
    }
;

searched_when_list_item: WHEN boolean_expr THEN sel_expr_or_null
    {
	DB_STATUS	status;
	PST_QNODE	*whlistp, *whopp;
	i4 		nores_flag;

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   $Yin_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}


	/* Allocate PST_WHOP node and attach search and result expressions. */
	status = pst_node(cb, &cb->pss_ostream, $2->pss_tree, $4,
		PST_WHOP, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whopp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	/* Allocate PST_WHLIST node and attach WHOP node to pst_right. */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL, whopp,
		PST_WHLIST, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whlistp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	$$ = whlistp;
    }
;

simple_case:		simple_when_list case_else
    {
	PST_QNODE	*nodep;

	/* Just loop down left side of "when list" and attach case_else to end. */
	for (nodep = $1; nodep->pst_left && 
		nodep->pst_left->pst_sym.pst_type == PST_WHLIST;
		nodep= nodep->pst_left);
	nodep->pst_left = $2;

	$$ = $1;
    }
;

simple_when_list:	simple_when_list_item
    {
	$$ = $1;
    }
		|	simple_when_list simple_when_list_item
    {
	PST_QNODE	*nodep;

	/* Attach "when item" to list. */
	for (nodep = $1; nodep->pst_left && 
		nodep->pst_left->pst_sym.pst_type == PST_WHLIST;
		nodep= nodep->pst_left);
	nodep->pst_left = $2;

	$$ = $1;
    }
;

simple_when_list_item: WHEN select_expr THEN sel_expr_or_null
    {
	DB_STATUS	status;
	PST_QNODE	*whlistp, *whopp;
	i4 		nores_flag;

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   $Yin_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}


	/* Allocate PST_WHOP node and attach search and result expressions. */
	status = pst_node(cb, &cb->pss_ostream, $2, $4,
		PST_WHOP, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whopp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	/* Allocate PST_WHLIST node and attach WHOP node to pst_right. */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL, whopp,
		PST_WHLIST, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whlistp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	$$ = whlistp;
    }
;

case_else:		/* nothing */
    {
	DB_STATUS	status;
	PST_QNODE	*whlistp, *whopp;
	PST_QNODE	*newnode = (PST_QNODE *) NULL;
	PST_CNST_NODE	cconst;
	DB_DATA_VALUE	db_data;
	char		buf[DB_CNTSIZE + 1];
	i4		nores_flag;

	/*
	** Just allocate NULL constant and attach to WHOP to WHLIST.
	*/

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   $Yin_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}

	db_data.db_datatype = -DB_LTXT_TYPE;
	db_data.db_prec     = 0;
	db_data.db_length   = DB_CNTSIZE + 1;
	db_data.db_data	    = (PTR) buf;

	status = adc_getempty ((ADF_CB *)cb->pss_adfcb, &db_data);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* NULL constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), -DB_LTXT_TYPE, (i2) 0, (i4) (1 + DB_CNTSIZE),
	    (DB_ANYTYPE *) db_data.db_data, &newnode, &psq_cb->psq_error,
	    (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Allocate PST_WHOP node and attach NULL as "else" result expression. */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL, newnode,
		PST_WHOP, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whopp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	/* Allocate PST_WHLIST node and attach WHOP node to pst_right. */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL, whopp,
		PST_WHLIST, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whlistp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	$$ = whlistp;

    }
		|	ELSE sel_expr_or_null
    {
	DB_STATUS	status;
	PST_QNODE	*whlistp, *whopp;
	i4		nores_flag;

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   $Yin_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}


	/* Allocate PST_WHOP node and attach "else" result expression. */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL, $2,
		PST_WHOP, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whopp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	/* Allocate PST_WHLIST node and attach WHOP node to pst_right. */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL, whopp,
		PST_WHLIST, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whlistp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	$$ = whlistp;
    }
;

coalesce_list:		coalesce_list_item
    {
	$$ = $1;
    }
		|	coalesce_list COMMA coalesce_list_item
    {
	PST_QNODE	*cp;

	/* Hook the WHLISTs together. */
	for (cp = $1; cp->pst_left; cp = cp->pst_left);
				/* find end of current list */
	cp->pst_left = $3;	/* add the latest to end */
	$$ = $1;
    }
;

coalesce_list_item:	sel_expr_or_null
    {
	DB_STATUS	status;
	PST_QNODE	*whlistp, *whopp;
	PST_QNODE	*srcecopy;
	PSS_TREEINFO	*treeinfo;
	i4	        nores_flag;

	/* Each coalesce_list_item represents a parameter and generates a
	** "when vj is not null then vj" entry in the big case. */

	/*
	** don't do type resolution if parsing target list or a CHECK constraint
	** specified inside CREATE GTABLE statement, as we may not know the type
	** of the column (e.g. if it hasn't been defined yet)
	*/
	if (   $Yin_target_clause 
	    || (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	{
	    nores_flag = PSS_NORES;
	}
	else
	{
	    nores_flag = 0;
	}

	/* Copy the vj source expression. */
	$Ydup_rb.pss_tree = $1;
	$Ydup_rb.pss_dup  = &srcecopy;;
	status = pst_treedup(cb, &$Ydup_rb);

	if (status != E_DB_OK) return (status);

	/* Build "vj is not null" comparison. */

	status = psl_simple_compare(cb, srcecopy, (PST_QNODE *) NULL,
	    ADI_NONUL_OP, (i4) PST_DOESNT_APPLY, (char) 0, &treeinfo,
	    (bool) BTtest($Yqual_depth, $Yqual_type), 
	    (bool)$Yin_target_clause, &$Ypss_join_info, psq_cb);
	if (status != E_DB_OK) return (status);

	/* Build WHOP, WHLIST to contain COALESCE "when vj is not null then vj". */
	status = pst_node(cb, &cb->pss_ostream, treeinfo->pss_tree, $1,
		PST_WHOP, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whopp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	/* Allocate PST_WHLIST node and attach WHOP node to pst_right. */
	status = pst_node(cb, &cb->pss_ostream, NULL, whopp,
		PST_WHLIST, (PTR)NULL, (i4)0, DB_NODT, (i2)0, (i4)0, 
		(DB_ANYTYPE *)NULL, &whlistp, &psq_cb->psq_error, nores_flag);

	if (status != E_DB_OK) return(status);

	$$ = whlistp;
    }
;

cast_expr:		CAST LPAREN sel_expr_or_null AS cast_type RPAREN
    {
	PST_OP_NODE	       opnode;
	PST_QNODE	       *newnode;
	PST_QNODE	       *dec_node = NULL;
	ADF_CB		       *adf_scb = (ADF_CB*) cb->pss_adfcb;
	ADI_OP_ID	       opid;
	DB_STATUS	       status;
	bool		       delay_type_resolution;

	{
	    status = adi_castid(adf_scb, &opid, $5);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }

	    /*
	    ** delay type resolution if processing target list or a CHECK constraint
	    ** specified as a part of CREATE TABLE statement until we have type info
	    ** on attributes that may be involved in expressions passed to the
	    ** function
	    */
	    if (   $Yin_target_clause 
		|| (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
		&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
	    {
		delay_type_resolution = TRUE;
	    }
	    else
	    {
		delay_type_resolution = FALSE;
	    }

	    if (!delay_type_resolution)
	    {
		/*
		** additional processing for unary functions.  For the time
		** being, it will consist of setting default precision and scale
		** for specified argument to decimal() function
		*/
		status = psl_1ary_func_extra_proc(cb, opid, $3, &dec_node,
		    &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		return(status);
	    }
	    
	    opnode.pst_opno = opid;
	    opnode.pst_opmeta = PST_NOMETA;
	    opnode.pst_isescape = PST_DOESNT_APPLY;

	    status = pst_node(cb, &cb->pss_ostream, $3, dec_node,
		(dec_node == NULL) ? PST_UOP : PST_BOP,
		(char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
		(DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error,
		(delay_type_resolution) ? PSS_NORES : 0);

	    if (status != E_DB_OK)
	    {
		return (status);
	    }
	    else if (BTtest($Yqual_depth, $Yqual_type))
	    {
		/*
		** If we are processing a join_search condition, set the joinid
		** field appropriately.  It has been initialized to PST_NOJOIN in
		** pst_node().
		*/
		newnode->pst_sym.pst_value.pst_s_op.pst_joinid =
		    $Ypss_join_info.pss_join[$Ypss_join_info.depth].join_id;
	    }

	    $Ydb_pdata.db_data = NULL;		/* Ensure no junk here */
	    if ($Ydb_pdata.db_length == 0)
		$Ydb_pdata.db_datatype = 0;	/* length is set later */
	    STRUCT_ASSIGN_MACRO($Ydb_pdata, newnode->pst_sym.pst_dataval);

	    if (cb->pss_distrib & DB_3_DDB_SESS)
	    {
		/* Dbmsinfo() & some constant funcs are evaluated to constants */
		status = psl_proc_func(cb, opid, $3, &newnode, 
		    &psq_cb->psq_error);
		if (status != E_DB_OK)
		{
		    return (status);
		}
	    }
	    $$ = newnode;
	    
	}
    }
;

cast_type:		tname collate
    {
	DB_STATUS	status;

	status = adi_encode_colspec(cb->pss_adfcb, $1, 0, (i4 *)NULL, 
			(i4)ADI_F4_CAST, &$Ydb_pdata);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	if ($2 >= 0)
	{
	    status = psl_collation_check(psq_cb, cb, &$Ydb_pdata, $2);
	    if (DB_FAILURE_MACRO(status))
	    {
		return(status);
	    }
	}

	$Ydb_pdata.db_collID = $2;
	$$ = &$Ydb_pdata;
    }
		|	tname LPAREN intconst_e RPAREN collate
    {
	DB_STATUS	status;
	i4		len = $3;

	status = adi_encode_colspec(cb->pss_adfcb, $1, 1, &len,
			(i4) 0, &$Ydb_pdata);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	if ($5 >= 0)
	{
	    status = psl_collation_check(psq_cb, cb, &$Ydb_pdata, $5);
	    if (DB_FAILURE_MACRO(status))
	    {
		return(status);
	    }
	}

	$Ydb_pdata.db_collID = $5;
	$$ = &$Ydb_pdata;
    }
		|	tname LPAREN intconst_e COMMA intconst_e RPAREN
    {
	DB_STATUS	status;
	i4		lenvec[2];

	lenvec[0] = $3;
	lenvec[1] = $5;
	status = adi_encode_colspec(cb->pss_adfcb, $1, 2, lenvec,
			(i4) 0, &$Ydb_pdata);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	$$ = &$Ydb_pdata;
    }
		|	tname TO tname
    {
	DB_STATUS	status;
	char		*value;

	/* INTERVAL X TO Y(n) */
	status = psl_ct11_tname_name_name(cb, psq_cb, $1, "to", $3, 
						&value);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	status = adi_encode_colspec(cb->pss_adfcb, value, 0, (i4 *)NULL,
			(i4) 0, &$Ydb_pdata);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	$$ = &$Ydb_pdata;
    }
		|	tname TO tname LPAREN intconst_e RPAREN
    {
	DB_STATUS	status;
	i4		len;
	char		*value;

	/* INTERVAL X TO Y(n) */
	status = psl_ct11_tname_name_name(cb, psq_cb, $1, "to", $3, 
						&value);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	len = $5;
	status = adi_encode_colspec(cb->pss_adfcb, value, 1, &len,
			(i4) 0, &$Ydb_pdata);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	$$ = &$Ydb_pdata;
    }
;

seq_operator:		ansi_seqop
    {
	$$ = $1;
    }
		|	oracle_seqop
    {
	$$ = $1;
    }
;

ansi_seqop:		aseqopwd obj_spec
    {
	PST_QNODE	*newnode = (PST_QNODE *) NULL;
	DB_STATUS	status;
	i4		err_code;
	PST_SEQOP_NODE	seqop;
	PSS_SEQINFO	seqinfo;
	i4		privs = DB_NEXT;
	i4		seq_mask = 0;
	i4		gseq_flags;

	/* Verify it's ok to issue next/current value. */
	if ($Yin_groupby_clause || $Yinhaving || ($Ynonupdt &&
	    ($Ynonupdt_reason & PSS_UNION_IN_OUTERMOST_SUBSEL)) ||
	    $Yin_where_clause)
	{
	    (void)psf_error(6319L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Fill in SEQOP node */
	STmove($2->pss_orig_obj_name, ' ', sizeof(DB_NAME),
	       (char *)&seqop.pst_seqname);
	/* If name was qualified, copy schema qualifier. 
	** Otherwise use session userid as default qualifier. */
	if ($2->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    STmove((char *)&$2->pss_owner, ' ', sizeof(DB_OWN_NAME),
	       (char *)&seqop.pst_owner);
	else STRUCT_ASSIGN_MACRO(cb->pss_user, seqop.pst_owner);

	seq_mask |= (($2->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    ? PSS_SEQ_BY_OWNER
	    : PSS_USRSEQ | PSS_DBASEQ | PSS_INGSEQ);

	/* Find the sequence first. */
	status = psy_gsequence(cb, &seqop.pst_owner, 
		&seqop.pst_seqname, seq_mask, &seqinfo, NULL,
		&gseq_flags, &privs, psq_cb->psq_mode, FALSE, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
	else if (gseq_flags & (PSS_MISSING_SEQUENCE | PSS_INSUF_SEQ_PRIVS))
	{
	    /*
	    **    sequence does not exist
	    ** or the current user lacks a required privilege on it
	    */
	    return(E_DB_ERROR);
	}

	STRUCT_ASSIGN_MACRO(seqinfo.pss_seqid, seqop.pst_seqid);
	seqop.pst_seqflag = $1;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_SEQOP, (char *) &seqop,
	    sizeof(seqop), seqinfo.pss_dt, 
	    DB_PS_ENCODE_MACRO(seqinfo.pss_prec, 0), seqinfo.pss_length,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error,
	    (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$Yseq_ops = TRUE;
	$$ = newnode;
    }
;

aseqopwd:		NEXTVAL FOR
    {
	$$ = PST_SEQOP_NEXT;
    }
	|	CURRVAL FOR
    {
	$$ = PST_SEQOP_CURR;
    }
;

oracle_seqop:		generic_ident PERIOD generic_ident PERIOD oseqopwd
    {
	PST_QNODE	*newnode = (PST_QNODE *) NULL;
	DB_STATUS	status;
	i4		err_code;
	PST_SEQOP_NODE	seqop;
	PSS_SEQINFO	seqinfo;
	i4		privs = DB_NEXT;
	i4		gseq_flags;

	/* Verify it's ok to issue next/current value. */
	if ($Yin_groupby_clause || $Yinhaving || ($Ynonupdt &&
	    ($Ynonupdt_reason & PSS_UNION_IN_OUTERMOST_SUBSEL)) ||
	    $Yin_where_clause)
	{
	    (void)psf_error(6319L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Fill in SEQOP node */
	STmove($1, ' ', sizeof(DB_OWN_NAME), (char *) &seqop.pst_owner);
	STmove($3, ' ', sizeof(DB_NAME), (char *) &seqop.pst_seqname);
	/* STRUCT_ASSIGN_MACRO(cb->pss_user, seqop.pst_owner); */

	/* Find the sequence first. */
	status = psy_gsequence(cb, &seqop.pst_owner, 
		&seqop.pst_seqname, (i4)PSS_SEQ_BY_OWNER, &seqinfo, NULL,
		&gseq_flags, &privs, psq_cb->psq_mode, FALSE, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
	else if (gseq_flags & (PSS_MISSING_SEQUENCE | PSS_INSUF_SEQ_PRIVS))
	{
	    /*
	    **    sequence does not exist
	    ** or the current user lacks a required privilege on it
	    */
	    return(E_DB_ERROR);
	}

	STRUCT_ASSIGN_MACRO(seqinfo.pss_seqid, seqop.pst_seqid);
	seqop.pst_seqflag = $5;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_SEQOP, (char *) &seqop,
	    sizeof(seqop), seqinfo.pss_dt, 
	    DB_PS_ENCODE_MACRO(seqinfo.pss_prec, 0), seqinfo.pss_length,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error,
	    (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$Yseq_ops = TRUE;
	$$ = newnode;
    }
		|	generic_ident PERIOD oseqopwd
    {
	PST_QNODE	*newnode = (PST_QNODE *) NULL;
	DB_STATUS	status;
	i4		err_code;
	PST_SEQOP_NODE	seqop;
	PSS_SEQINFO	seqinfo;
	i4		privs = DB_NEXT;
	i4		seq_mask = 0;
	i4		gseq_flags;

	/* Verify it's ok to issue next/current value. */
	if ($Yin_groupby_clause || $Yinhaving || ($Ynonupdt &&
	    ($Ynonupdt_reason & PSS_UNION_IN_OUTERMOST_SUBSEL)) ||
	    $Yin_where_clause)
	{
	    (void)psf_error(6319L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Fill in SEQOP node */
	STmove($1, ' ', sizeof(DB_NAME), (char *) &seqop.pst_seqname);
	MEfill(sizeof(DB_OWN_NAME), ' ', (PTR) &$Yobj_spec.pss_owner);
	/* Name wasn't qualified, use session userid as default qualifier. */
	STRUCT_ASSIGN_MACRO(cb->pss_user, seqop.pst_owner);

	seq_mask = PSS_USRSEQ | PSS_DBASEQ | PSS_INGSEQ;

	/* Find the sequence first. */
	status = psy_gsequence(cb, &seqop.pst_owner, 
		&seqop.pst_seqname, seq_mask, &seqinfo, NULL,
		&gseq_flags, &privs, psq_cb->psq_mode, FALSE, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
	else if (gseq_flags & (PSS_MISSING_SEQUENCE | PSS_INSUF_SEQ_PRIVS))
	{
	    /*
	    **    sequence does not exist
	    ** or the current user lacks a required privilege on it
	    */
	    return(E_DB_ERROR);
	}

	STRUCT_ASSIGN_MACRO(seqinfo.pss_seqid, seqop.pst_seqid);
	seqop.pst_seqflag = $3;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_SEQOP, (char *) &seqop,
	    sizeof(seqop), seqinfo.pss_dt, 
	    DB_PS_ENCODE_MACRO(seqinfo.pss_prec, 0), seqinfo.pss_length,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error,
	    (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$Yseq_ops = TRUE;
	$$ = newnode;
    }
;

oseqopwd:		NEXTVAL
    {
	$$ = PST_SEQOP_NEXT;
    }
		|	CURRVAL
    {
	$$ = PST_SEQOP_CURR;
    }
;

sel_expr_or_null:	select_expr
    {
	$$ = $1;
    }
		|	null_word
    {
	$$ = $1;
    }
;

null_word:		NULLWORD
    {
	PST_QNODE	*newnode = (PST_QNODE *) NULL;
	DB_STATUS	status;
	PST_CNST_NODE	cconst;
	DB_DATA_VALUE	db_data;
	char		buf[DB_CNTSIZE + 1];

	db_data.db_datatype = -DB_LTXT_TYPE;
	db_data.db_prec     = 0;
	db_data.db_length   = DB_CNTSIZE + 1;
	db_data.db_data	    = (PTR) buf;

	status = adc_getempty ((ADF_CB *)cb->pss_adfcb, &db_data);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* NULL constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), -DB_LTXT_TYPE, (i2) 0, (i4) (1 + DB_CNTSIZE),
	    (DB_ANYTYPE *) db_data.db_data, &newnode, &psq_cb->psq_error,
	    (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$$ = newnode;
    }
;
	
relocate:          RELOCATE obj_spec TO NAME
    {
	i4             err_code, err_num = 0L;
	DB_STATUS	    status;
	i4		    rngvar_info;
	QEU_CB		    *qeu_cb;
	DMU_CB		    *dmu_cb;
	PSS_RNGTAB	    *resrange;
	bool		    audit_err = FALSE;

	psq_cb->psq_mode = PSQ_RELOCATE;

	/* "relocate" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6206L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Look up the table to be relocated */
	if ($2->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, "", &$2->pss_owner,
		&$2->pss_obj_name, cb, FALSE, &resrange, psq_cb->psq_mode,
		&psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, -1, "", &$2->pss_obj_name,
		cb, FALSE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
		&rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    $2->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* If table resides in multiple locations MODIFY RELOCATE
	** must be used.
	*/
	if (resrange->pss_tabdesc->tbl_status_mask & DMT_MULTIPLE_LOC)
	{
	    err_num = 6207L;
	}
	/* Don't allow relocation of views */
	else if (resrange->pss_tabdesc->tbl_status_mask & DMT_VIEW)
	{
	    err_num = 6205L;
	}
	else if (MEcmp((PTR) &resrange->pss_ownname,
	    (PTR) &cb->pss_user, sizeof(DB_OWN_NAME)))
	{
	    err_num = 6204L;
	    audit_err = TRUE;
	}

	if (err_num != 0L)
	{
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE && audit_err )
	    {
		/* Must audit RELOCATE failure. */
		DB_STATUS   local_status;
		DB_ERROR    e_error;

	        local_status = psy_secaudit(FALSE, cb,
	    		(char *)&resrange->pss_tabname,
			&resrange->pss_tabdesc->tbl_owner,
	    		sizeof(DB_TAB_NAME), SXF_E_TABLE,
	      		I_SX2026_TABLE_ACCESS, SXF_A_FAIL | SXF_A_RELOCATE,
	      		&e_error);
	    }

	    /*
	    ** let user know if name supplied by the user was resolved to a
	    ** synonym
	    */
	    if (rngvar_info & PSS_BY_SYNONYM)
	    {
		psl_syn_info_msg(cb, resrange, $2, rngvar_info,
		    sizeof("RELOCATE") - 1, "RELOCATE", &psq_cb->psq_error);
	    }

	    (VOID) psf_error(err_num, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &resrange->pss_tabname),
		&resrange->pss_tabname);
	    return (E_DB_ERROR);
	}

	/* Allocate QEU_CB for RELOCATE and initialize its header */
	status = psl_qeucb(cb, DMU_RELOCATE_TABLE, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	qeu_cb = (QEU_CB *) cb->pss_object;

	/* Allocate a DMU control block */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMU_CB),
		&dmu_cb, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	MEfill(sizeof(DMU_CB), '\0', dmu_cb);
	qeu_cb->qeu_d_cb = dmu_cb;

	/* Fill in the DMU control block header */
	dmu_cb->type = DMU_UTILITY_CB;
	dmu_cb->length = sizeof(DMU_CB);
	dmu_cb->dmu_flags_mask = DMU_EXTTOO_MASK;
	dmu_cb->dmu_db_id = (char*) cb->pss_dbid;

	cb->pss_resrng = resrange;

	/* Put it in the control block */
	STRUCT_ASSIGN_MACRO(resrange->pss_tabid, dmu_cb->dmu_tbl_id);
	dmu_cb->dmu_nphys_parts = resrange->pss_tabdesc->tbl_nparts;

	/*
	** Allocate 1 location entry (`RELOCATE' is not supposed to handle
	** multiple locations - this is done by `MODIFY'.
	*/
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_LOC_NAME),
	    (PTR *) &dmu_cb->dmu_location.data_address, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Put the new location name in the control block */
	STmove($4, ' ', sizeof(DB_LOC_NAME),
	    (char *) dmu_cb->dmu_location.data_address);
	dmu_cb->dmu_location.data_in_size = sizeof(DB_LOC_NAME);

	/* Indicate no old locations. */
	dmu_cb->dmu_olocation.data_in_size = 0;

	/* Invalidate table info on RDF cache */
	{
	    RDF_CB		rdf_cb;

	    pst_rdfcb_init(&rdf_cb, cb);
	    STRUCT_ASSIGN_MACRO(cb->pss_resrng->pss_tabid,
				rdf_cb.rdf_rb.rdr_tabid);
	    status = rdf_call(RDF_INVALIDATE, (PTR) &rdf_cb);
	    if (status != E_DB_OK)
	    {
		(VOID) psf_rdf_error(RDF_INVALIDATE, &rdf_cb.rdf_error,
				&psq_cb->psq_error);
		return (status);
	    }
	}
    }
;

rollback:             rollbkstmnt TO generic_ident
    {
	QEF_RCB                *qef_rcb;
	DB_STATUS	       status;
	DB_SP_NAME	       *spname;

	psq_cb->psq_mode = PSQ_RLSAVE;

	/* Allocate memory for savepoint name */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(DB_SP_NAME), 
	    (PTR *) &spname, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Give QEF pointer to name */
	STmove($3, ' ', sizeof(DB_SP_NAME), (char *) spname);
	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_spoint = spname;
    }
          |		rollbkstmnt TO intconst_p
    {
	QEF_RCB                *qef_rcb;
	DB_STATUS	       status;
	DB_SP_NAME	       *spname;
	char		       numbuf[25];

	psq_cb->psq_mode = PSQ_RLSAVE;

	/* Allocate memory for savepoint name */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(DB_SP_NAME), 
	    (PTR *) &spname, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Give QEF pointer to name */
	CVla((i4) $3, (PTR) numbuf);
	STmove(numbuf, ' ', sizeof(DB_SP_NAME), (char *) spname);
	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_spoint = spname;
    }
	  |             rollbkstmnt WITH xa_xid_parm
    {
	psq_cb->psq_mode = PSQ_XA_ROLLBACK;
    }
          |	    rollbkstmnt
    {
	QEF_RCB                *qef_rcb;

	psq_cb->psq_mode = PSQ_ROLLBACK;
	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_spoint = (DB_SP_NAME *) NULL;
    }
;

rollbkstmnt:	    ROLLBACK work
    {
	DB_STATUS              status;
	QEF_RCB		       *qef_rcb;

	/* Create the QEF control block for abort */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;
    }
;

xa_xid_parm:         nonkeyword EQUAL strconst
    {
	DB_STATUS              status;
	i4                err_code;

	if (STcasecmp($1, "xa_xid") != 0)
	{
	    (VOID) psf_error(6353L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		(i4)STlength($1), $1);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate memory for distributed transaction id */
	status = psf_malloc(cb, &cb->pss_ostream, (i4)(STlength($3) + 1),
		(PTR *) &psq_cb->psq_distranid, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	STcopy($3, psq_cb->psq_distranid);
    }
;

/*
** Yacc production:  register_event	- Register an event
**
** Statement Syntax:
**	REGISTER DBEVENT [dbevent_owner.]dbevent_name
**
** Return State:
**	Statement Mode = PSQ_EVREGISTER
**	Statement Type = PST_EVREGISTER
**	PST_STATEMENT.pst_eventstmt filled with dbevent data.
*/
register_event:	reg_ev_kword event_name event_tail
    {
	$$ = $3;
    }
;
reg_ev_kword:	REGISTEREVENT
    {
	/* "register dbevent" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	err_code;

	    (VOID) psf_error(6350L, 0L, PSF_USERERR, &err_code, 
		&psq_cb->psq_error, 1,
		(i4) sizeof("REGISTER DBEVENT") - 1, "REGISTER DBEVENT");
	    return (E_DB_ERROR);
	}

	psq_cb->psq_mode = PSQ_EVREGISTER;

	if ($Yisdbp == FALSE)	/* Open memory stream for allocating objects */
	{
	    DB_STATUS	status;
	    if ((status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
				    &psq_cb->psq_error)) != E_DB_OK)
		return (status);
	}
    }
;
event_name:	obj_spec
    {
	PST_STATEMENT	*evstmt;
	PST_EVENTSTMT   *ev;
	DB_STATUS	status;
	i4		ev_mask = 0;
	i4		ret_flags;
	PSS_EVINFO	ev_info;
	i4		stmt_type;
	i4		priv_to_check;
	i4		err_code;

	switch (psq_cb->psq_mode)
	{
	    case PSQ_EVREGISTER:
		stmt_type = PST_EVREG_TYPE;
		priv_to_check = (i4) DB_EVREGISTER;
		break;
	    case PSQ_EVDEREG:
		stmt_type = PST_EVDEREG_TYPE;
		priv_to_check = (i4) 0;
		break;
	    case PSQ_EVRAISE:
		stmt_type = PST_EVRAISE_TYPE;
		priv_to_check = (i4) DB_EVRAISE;
		break;
	    default:
		/* this is very bad */
		_VOID_ psf_error(E_PS0002_INTERNAL_ERROR, 0L, PSF_INTERR,
		    &err_code, &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	}

	ev_mask |= (($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	    ? PSS_EV_BY_OWNER
	    : PSS_USREVENT | PSS_DBAEVENT | PSS_INGEVENT);

	status = psy_gevent(cb, &$1->pss_owner, &$1->pss_obj_name,
	    (DB_TAB_ID *) NULL, ev_mask, &ev_info, &ret_flags, &priv_to_check,
	    psq_cb->psq_mode, (i4) FALSE, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return (status);
	else if (ret_flags & (PSS_MISSING_EVENT | PSS_INSUF_EV_PRIVS))
	{
	    /*
	    **    dbevent does not exist
	    ** or the current user lacks a required privilege on it
	    ** or we are reparsing a dbproc in order to determine if it is
	    **    grantable and the user does not posess a required privilege on
	    **    the dbevent WGO 
	    */
	    return(E_DB_ERROR);
	}

	/* Allocate statement node */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_STATEMENT),
			    (PTR *) &evstmt, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	MEfill(sizeof(PST_STATEMENT), (u_char) 0, (PTR) evstmt);

	evstmt->pst_type = stmt_type;
        evstmt->pst_mode = psq_cb->psq_mode;

	ev = &evstmt->pst_specific.pst_eventstmt;
	/*
	** copy alert name structure (event owner, name, and database) into the
	** statement description, plus security label.
	*/
	STRUCT_ASSIGN_MACRO(ev_info.pss_alert_name, ev->pst_event);

	/* if emitting query text, and the schema/owner name has not been
	** specified, add the event's schema name to the query
	*/
	if (   (cb->pss_stmt_flags & PSS_TXTEMIT) 
	    && (~$1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA))
	{
	    status = psl_prepend_schemaname(cb->pss_tchain, 
		$1->pss_orig_obj_name, 
		(u_char *) ev_info.pss_alert_name.dba_owner.db_own_name,
		&psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
	        return (status);
	}

	$Ytmp_stmt = evstmt;
    }
;

event_tail:	/* Common null production to complete DBEVENT statements */
    {
	PST_STATEMENT	*evstmt;	/* DBEVENT statement */
	PST_PROCEDURE	*prnode;	/* DBP node may need to be created */
	DB_STATUS	status;

	evstmt = $Ytmp_stmt;	/* Was set by event_name production */
	$Ytmp_stmt = NULL;	/* Reset for safety */
	if ($Yisdbp)		/* Return statement to be patched in DBP */
	{
	    $$ = evstmt;
	}
	else			/* Not a DBP */
	{
           /* Create procedure (for OPC) and attach the DBEVENT statement */
            status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_PROCEDURE),
                                (PTR *)&prnode, &psq_cb->psq_error);
            if (status != E_DB_OK)
                return (status);
            prnode->pst_mode = 0;
            prnode->pst_vsn = PST_CUR_VSN;
            prnode->pst_isdbp = FALSE;
	    prnode->pst_flags = 0;
            prnode->pst_stmts = evstmt;
            prnode->pst_parms = (PST_DECVAR *)NULL;
            MEfill(sizeof(prnode->pst_dbpid), (u_char)0,
                   (PTR)&prnode->pst_dbpid);
            status = psf_mroot(cb, &cb->pss_ostream, (PTR)prnode,
                               &psq_cb->psq_error);
            if (status != E_DB_OK)
                return (status);
            $$ = NULL;          /* Unused outside of DBP */
        } 
    }
;
/*
** Yacc production:  remove_event	- Remove a dbevent registration
**
** Statement Syntax:
**	REMOVE DBEVENT [dbevent_owner.]dbevent_name
**
** Return State:
**	Statement Mode = PSQ_EVDEREG
**	Statement Type = PST_EVDEREG
**	PST_STATEMENT.pst_eventstmt filled with dbevent data.
*/
remove_event: 	rem_ev_kword event_name event_tail
    {
	$$ = $3;
    }
;
rem_ev_kword:	REMOVEEVENT
    {
	/* "remove dbevent" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	err_code;

	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("REMOVE DBEVENT") - 1, "REMOVE DBEVENT");
	    return (E_DB_ERROR);
	}

	psq_cb->psq_mode = PSQ_EVDEREG;

	if ($Yisdbp == FALSE)	/* Open memory stream for allocating objects */
	{
	    DB_STATUS	status;
	    if ((status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
				    &psq_cb->psq_error)) != E_DB_OK)
		return (status);
	}
    }
;
/*
** Yacc production:  raise_event	- Raise a dbevent
**
** Statement Syntax:
**	RAISE DBEVENT [dbevent_owner.]dbevent_name [dbevent_text]
**		[WITH [NO]SHARE]
**
** Return State:
**	Statement Mode = PSQ_EVRAISE
**	Statement Type = PST_EVRAISE
**	PST_STATEMENT.pst_eventstmt filled with dbevent data.
*/
raise_event: 	ras_ev_kword event_name ras_ev_options event_tail
    {
	$$ = $4;
    }
;
ras_ev_kword:	RAISEEVENT
    {
	/* "raise dbevent" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	err_code;

	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("RAISE DBEVENT") - 1, "RAISE DBEVENT");
	    return (E_DB_ERROR);
	}

	psq_cb->psq_mode = PSQ_EVRAISE;

	if ($Yisdbp == FALSE)	/* Open memory stream for allocating objects */
	{
	    DB_STATUS	status;
	    if ((status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
				    &psq_cb->psq_error)) != E_DB_OK)
		return (status);
	}
    }
;
ras_ev_options:	ras_ev_value ras_ev_with
    {
	/* Ytmp_stmt was set by event_name production */
	$Ytmp_stmt->pst_specific.pst_eventstmt.pst_evvalue = $1;
	$Ytmp_stmt->pst_specific.pst_eventstmt.pst_evflags |= $2;
    }
ras_ev_value:	/* No optional text */
    {
	$$ = NULL;
    }
	|	colon NAME	/* Text specified in a variable */
    {
	DB_STATUS       status;
	PST_CNST_NODE	constnd;
	PST_QNODE	*newnode;
	DB_PARM_NAME	varname;
	PSS_DECVAR 	*var;
	DB_DT_ID	dtype;
	bool		found = FALSE;
	i4		err_code;

	if ($Yisdbp == FALSE)
	{
	    _VOID_ psf_error(E_PS0D36_EVENT_TEXT_QUOTE, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 1,
			     STlength($2), $2);
	    return (E_DB_ERROR);
	}

	/* Find local var/parm by the specified name */
	STmove($2, ' ', DB_MAXNAME, varname.db_parm_name);

	for (var = (PSS_DECVAR *)$Ydbpinfo->pss_varq.q_next;
	     var != (PSS_DECVAR *)&$Ydbpinfo->pss_varq;
	     var = (PSS_DECVAR *)var->pss_queue.q_next)
	{
	    if (var->pss_out)
		continue;
	    if (MEcmp((PTR)&varname, (PTR)&var->pss_varname,
		sizeof(var->pss_varname)) == 0)
	    {
		found = TRUE;
		break;
	    }
	}

	if (!found)	/* Unknown local var/parm specified */
	{
	    _VOID_ psf_error(2403L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 1, STlength($2), $2);
	    return (E_DB_ERROR);
	}

	/* Type of var must be non-nullable string */
	if (   ((dtype = var->pss_dbdata.db_datatype) < 0)
	    || (dtype != DB_CHR_TYPE && dtype != DB_TXT_TYPE &&
		dtype != DB_CHA_TYPE && dtype != DB_VCH_TYPE && 
	        dtype != DB_NCHR_TYPE && dtype != DB_NVCHR_TYPE)
	   )
	{
	    _VOID_ psf_error(E_PS0D37_EVENT_TEXT_TYPE, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 1,
			     STlength($2), $2);
	    return (E_DB_ERROR);
	}

	/* Parm or local variable */
	constnd.pst_tparmtype = PST_LOCALVARNO;
	constnd.pst_parm_no = var->pss_no;
	constnd.pst_pmspec  = PST_PMNOTUSED;
	constnd.pst_cqlang = DB_SQL;
	constnd.pst_origtxt = NULL;
	status = pst_node(cb, &cb->pss_ostream,
			  (PST_QNODE *)NULL, (PST_QNODE *)NULL, PST_CONST,
			  (char *)&constnd, sizeof(constnd),
			  var->pss_dbdata.db_datatype,
			  (i2)var->pss_dbdata.db_prec, 
			  (i4)var->pss_dbdata.db_length, 
			  (DB_ANYTYPE *)var->pss_dbdata.db_data,
			  &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	    return (status);
	$$ = newnode;
    }
	|	SCONST		/* Text specified as constant */
    {
	DB_STATUS       status;
	PST_CNST_NODE	constnd;
	PST_QNODE	*newnode;

	constnd.pst_tparmtype = PST_USER;
	constnd.pst_parm_no = 0;
	constnd.pst_pmspec  = PST_PMNOTUSED;
	constnd.pst_cqlang = DB_SQL;
	constnd.pst_origtxt = NULL;
	status = pst_node(cb, &cb->pss_ostream,
			  (PST_QNODE *)NULL, (PST_QNODE *)NULL, PST_CONST,
			  (char *)&constnd, sizeof(constnd),
			  DB_VCH_TYPE, (i2)0, (i4)($1->db_t_count + DB_CNTSIZE),
			  (DB_ANYTYPE *)$1, &newnode, &psq_cb->psq_error,
			  (i4) 0);
	if (status != E_DB_OK)
	    return (status);
	$$ = newnode;
    }
;
ras_ev_with:	/* No WITH clause specified */
    {
	$$ = 0;
    }
	|	WITH nonkeyword
    {
	i4		err_code;

	if (STcompare($2, "noshare") == 0)
	{
	    $$ = PST_EVNOSHARE;
	}
	else if (STcompare($2, "share") == 0)
	{
	    $$ = 0;
	}
	else
	{
	    _VOID_ psf_error(E_PS0D38_EVENT_WITH, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 1,
			     STlength($2), $2);
	    return (E_DB_ERROR);
	}
    }
;

save_tbl:	    obj_spec
    {
	DB_STATUS		status;
	i4			rngvar_info;
	PSS_RNGTAB		*rngvar;
	i4			err_code, err_num = 0L;
	i4			mask;
	i4			mask2;
	char			*duve_prefix;
	i4			duve_len;

	if ($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, "", &$1->pss_owner,
		&$1->pss_obj_name, cb, TRUE, &rngvar, psq_cb->psq_mode,
		&psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, -1, "", &$1->pss_obj_name,
		cb, TRUE, &rngvar, psq_cb->psq_mode, &psq_cb->psq_error,
		&rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    $1->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	/* User may issue SAVE only against his/her tables */
	if (MEcmp((PTR) &rngvar->pss_ownname, (PTR) &cb->pss_user,
		       sizeof(DB_OWN_NAME)))
	{
	    err_num = E_PS0424_ILLEGAL_TBL_REF;
	}
	else
	{
	    mask = rngvar->pss_tabdesc->tbl_status_mask;
	    mask2 = rngvar->pss_tabdesc->tbl_2_status_mask;

	    /* 
	    ** May not run SAVE against catalogs but allow for
	    ** special tables created by VERIFYDB since they aren't
	    ** really catalogs anyway.
	    */
	    duve_prefix = "iiqeflist";
	    duve_len = sizeof("iiqeflist") - 1;

	    if ((mask & DMT_CATALOG) && 
		(MEcmp(duve_prefix, (PTR)&rngvar->pss_tabname, duve_len)))
	    {
		err_num = 2126L;
	    }
	    /* SAVE may only be run against base tables */
	    else if (mask & DMT_VIEW
		     || mask & DMT_IDX
		     || mask2 & DMT_TEXTENSION)
	    {
		err_num = 2127L;
	    }
	}

	if (err_num != 0L)
	{
	    /*
	    ** let user know if name supplied by the user was resolved to a
	    ** synonym
	    */
	    if (rngvar_info & PSS_BY_SYNONYM)
	    {
		psl_syn_info_msg(cb, rngvar, $1, rngvar_info,
		    sizeof("SAVE") - 1, "SAVE", &psq_cb->psq_error);
	    }

	    if (err_num == E_PS0424_ILLEGAL_TBL_REF)
	    {
		/*
		** Audit failure to save table.
		*/
		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    DB_ERROR	e_error;

		    (VOID) psy_secaudit(FALSE, cb, (char *) &rngvar->pss_tabname,
			(DB_OWN_NAME *)&rngvar->pss_ownname,
			sizeof(rngvar->pss_tabname),SXF_E_TABLE, 
			I_SX2719_TABLE_SAVE, SXF_A_FAIL | SXF_A_CONTROL,
			&e_error);
		}

		(VOID) psf_error(E_PS0424_ILLEGAL_TBL_REF, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 3,
		    sizeof("SAVE") - 1, "SAVE",
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &rngvar->pss_tabname),
		    &rngvar->pss_tabname,
		    psf_trmwhite(sizeof(DB_OWN_NAME), 
			(char *) &rngvar->pss_ownname),
		    &rngvar->pss_ownname);
	    }
	    else
	    {
		(VOID) psf_error(err_num, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1,
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &rngvar->pss_tabname),
		    &rngvar->pss_tabname);
	    }

	    return (E_DB_ERROR);    /* non-zero return means error */
	}	    
	else
	{
	    RDF_CB		rdf_cb;
	    STRUCT_ASSIGN_MACRO(rngvar->pss_tabid,
		    ((DMT_CB *) ((QEU_CB *) cb->pss_object)->qeu_d_cb)->dmt_id);
	    /* invalidate RDF's cache */

	    pst_rdfcb_init(&rdf_cb, cb);
	    STRUCT_ASSIGN_MACRO(rngvar->pss_tabid, rdf_cb.rdf_rb.rdr_tabid);

	    status = rdf_call(RDF_INVALIDATE, (PTR) &rdf_cb);
	    if (status != E_DB_OK)
	    {
		(VOID) psf_rdf_error(RDF_INVALIDATE, &rdf_cb.rdf_error,
				&psq_cb->psq_error);
		return (status);
	    }
	}
    }
;

save:           savstmnt save_tbl UNTIL date
	|	savstmnt save_tbl
;

savstmnt:          SAVE
    {
	i4                err_code;
	QEU_CB		       *qeu_cb;
	DMT_CB		       *dmt_cb;
	DB_STATUS	       status;
	DMT_CHAR_ENTRY	       *chr;

	psq_cb->psq_mode = PSQ_SAVE;

	/* "save" is not allowed in distributed */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(5605L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate QEU_CB for SAVE and initialize its header */
	status = psl_qeucb(cb, DMT_ALTER, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	qeu_cb = (QEU_CB *) cb->pss_object;

	/* Allocate a DMT control block */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMT_CB),
	    (PTR *) &dmt_cb, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	qeu_cb->qeu_d_cb = dmt_cb;

	/* Fill in the DMT control block header */
	dmt_cb->type = DMT_TABLE_CB;
	dmt_cb->length = sizeof(DMT_CB);
	dmt_cb->dmt_db_id = (char*) cb->pss_dbid;
        dmt_cb->dmt_mustlock = FALSE;

	/* Allocate the characteristics array */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMT_CHAR_ENTRY),
	    (PTR *) &dmt_cb->dmt_char_array.data_address, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	dmt_cb->dmt_char_array.data_in_size = sizeof(DMT_CHAR_ENTRY);

	/* Make the characteristic being changed the save date */

	chr = (DMT_CHAR_ENTRY *) dmt_cb->dmt_char_array.data_address;
	chr->char_id	= DMT_C_SAVEDATE;
	chr->char_value = 0;

    }
;

date:              month intconst_e intconst_e
    {
	i4		       err_code;
	register i4	       i;
	register i4       date;
	i4		       value;
	ADF_CB		       *adf_scb = (ADF_CB*) cb->pss_adfcb;
	QEU_CB		       *qeu_cb;
	DMT_CB		       *dmt_cb;
	DMT_CHAR_ENTRY	       *chr;

	/* Check out the year */
	if ($3 < 1970 || $3 > 2035)
	{
	    (VOID) psf_error(5603L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, sizeof($3), &($3));
	    return (E_DB_ERROR);
	}

	/* Check out the day */
	if ($2 < 1 || psq_monsize((i4) $1, (i4) $3) < $2)
	{
	    (VOID) psf_error(5602L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, sizeof($2), &($2));
	    return (E_DB_ERROR);
	}

	/* Convert date */

	/* "date" will be number of days from 1970 for a while */
	date = 0;

	/* Do year conversion */
	date += ($3 - 1970) * 365;
	if ($3 > 1970)
	    date += ($3 - 1973) / 4 + 1;	    /* Add one day for each leap year */

	/* Do month conversion */
	for (i = 1; i < $1; i++)
	    date += psq_monsize((i4)i, (i4)$3);

	/* Do date conversion */
	date += $2 - 1;

	/* Convert the date to be the number of hours since 1970 */
	date *= 24;

	/* Convert to minutes */
	date *= 60;

	/* Convert to seconds */
	date *= 60;

	/* Adjust to GMT */

    	if( date > MAXI4)
    	    value = MAXI4;
    	else
    	    value = date;
    
    	date -=	TMtz_search(adf_scb->adf_tzcb, TM_TIMETYPE_LOCAL,
    	    	    	    value);

	/* Store number of seconds in control block */
	qeu_cb = (QEU_CB *) cb->pss_object;
	dmt_cb = (DMT_CB *) qeu_cb->qeu_d_cb;
	chr = (DMT_CHAR_ENTRY *) dmt_cb->dmt_char_array.data_address;
	chr->char_value = date;
    }
;

month:             NAME
    {
	DB_STATUS              status;
	i4		       monthno;
	
	/* Translate month name to month number */
	status = psq_month($1, &monthno, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	$$ = monthno;
    }
          |
                    intconst_p
    {
	char                   numbuf[25];
	i4		       err_code;

	if ($1 < 0 || $1 > 12)
	{
	    CVla((i4)$1, numbuf);
	    (VOID) psf_error(5601L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, STtrmwhite(numbuf), numbuf);
	    return (E_DB_ERROR);
	}

	$$ = $1;
    }
;

savepoint:	    spoint sp_name
;

spoint:		    SAVEPOINT
    {
	DB_STATUS              status;
	QEF_RCB		       *qef_rcb;

	psq_cb->psq_mode = PSQ_SVEPOINT;

	/* Allocate QEF control block for savepoint */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_modifier = QEF_MSTRAN;
	qef_rcb->qef_flag   = DB_SQL;
	qef_rcb->qef_sess_id = cb->pss_sessid;
	qef_rcb->qef_db_id  = cb->pss_dbid;

	/* Allocate the savepoint name */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_SP_NAME),
	    (PTR *) &qef_rcb->qef_spoint, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
    }
;

sp_name:	    generic_ident
    {
	QEF_RCB		       *qef_rcb;

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;

	/* Fill in the savepoint name */
	STmove($1, ' ', sizeof(DB_SP_NAME), (char *) qef_rcb->qef_spoint);

    }
	|	    intconst_p
    {
	QEF_RCB		       *qef_rcb;
	char		       numbuf[25];

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;

	/* Fill in the savepoint name */
	CVla((i4) $1, numbuf);
	STmove(numbuf, ' ', sizeof(DB_SP_NAME), (char *) qef_rcb->qef_spoint);
    }
;

setaggr:	    SETAGGR strsetparam
    {
	i4                err_code;

	psq_cb->psq_mode = PSQ_OBSOLETE;

	if (cb->pss_ses_flag & PSS_WARNINGS)
	{
	    /* "set aggregate [no]project" is no longer supported */
	    (VOID) psf_error(5979L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	}
    }
;

setautocommit:		setauto_kwd on_or_off
    {
	DB_STATUS              status;
	QEF_RCB		       *qef_rcb;

	/* Allocate QEF control block for autocommit */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;
	qef_rcb->qef_auto = $2;
    }
;

setauto_kwd:	    SETAUTOCOMMIT
    {
	psq_cb->psq_mode = PSQ_AUTOCOMMIT;
    }
;

setcpufact:	    SETCPUFACT intsetparam
    {
	i4                err_code;
	DB_STATUS	       status;
	OPF_CB		       *opf_cb;

	psq_cb->psq_mode = PSQ_SCPUFACT;

	/* "set cpufactor" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(5945L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Create control block for setting cpu factor in OPF */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_level = OPF_SESSION;
	opf_cb->opf_alter = OPF_CPUFACTOR;
	opf_cb->opf_value = $2;
    }
;

setdatefmt:	    SETDATEFMT 	strconst_e
    {
	i4         err_code;

	psq_cb->psq_mode = PSQ_SDATEFMT;

	/*
	** Possible formats are "us", "multinational", "iso", "finland",
	** "sweden".
	*/
	if (!STcasecmp((char *) $2, "us"))
	{
	    psq_cb->psq_dtefmt = DB_US_DFMT;
	}
	else if (!STcasecmp((char *) $2, "multinational"))
	{
	    psq_cb->psq_dtefmt = DB_MLTI_DFMT;
	}
	else if (!STcasecmp((char *) $2, "iso4"))
	{
	    psq_cb->psq_dtefmt = DB_ISO4_DFMT;
	}
	else if (!STcasecmp((char *) $2, "iso"))
	{
	    psq_cb->psq_dtefmt = DB_ISO_DFMT;
	}
	else if (!STcasecmp((char *) $2, "finland"))
	{
	    psq_cb->psq_dtefmt = DB_FIN_DFMT;
	}
	else if (!STcasecmp((char *) $2, "sweden"))
	{
	    psq_cb->psq_dtefmt = DB_FIN_DFMT;
	}
	else if (!STcasecmp((char *) $2, "german"))
	{
	    psq_cb->psq_dtefmt = DB_GERM_DFMT;
	}
	else
	{
	    (VOID) psf_error(5934L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STtrmwhite((char *) $2), $2);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    DB_STATUS       status;
	    char            buf[sizeof("set date_format 'multinational'")];

	    STprintf(buf, "set date_format '%s' ", $2);

	    status = psl_send_setqry(cb, buf, psq_cb);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
    }
;

setddl_concur:	    setddlconcur_kwd on_or_off
    {
	DB_STATUS	status;
	QEF_RCB		*qef_rcb;

	/* Allocate QEF control block for autocommit */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;
	qef_rcb->qef_r3_ddb_req.qer_d12_ddl_concur_on_b = $2;
    }
;

setddlconcur_kwd:   SETDDLCONCUR 
    {
	i4		err_code;

	/* "set ddl_concurrency" is allowed only in distributed */
	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(2086L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1, sizeof("SET DDL_CONCURRENCY")-1,
			"SET DDL_CONCURRENCY");
	    return (E_DB_ERROR);

	}
	else
	{
	    psq_cb->psq_mode = PSQ_DDLCONCUR;
	}
    }
;

on_or_off:	    ON
    {
	$$ = QEF_ON;
    }
	    |	    nonkeyword
    {
	i4	    err_code;

	if (STcompare($1, "off") == 0)
	    $$ = QEF_OFF;
	else  /* syntax error */
	{
	    err_code = (psq_cb->psq_mode == PSQ_DDLCONCUR) ? 5985L : 5983L;

	    (VOID) psf_error(err_code, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,(i4) STtrmwhite($1), $1);
	    return (E_DB_ERROR);    /* non-zero return means error */

	}
    }
;

setdecimal:	    SETDECIMAL strconst_e
    {
	i4		err_code;
	char		*str;

	psq_cb->psq_mode = PSQ_SDECIMAL;

	/* Period and comma are only allowable decimal markers */
	if (!STcompare((char *) $2, ","))
	{
	    str = "set decimal ',' ";
	}
	else if (!STcompare((char *) $2, "."))
	{
	    str = "set decimal '.' ";
	}
	else
	{
	    (VOID) psf_error(5936L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 1,
		(i4) STtrmwhite((char *) $2), (char *) $2);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Give new decimal character back to caller */
	psq_cb->psq_decimal.db_decspec = TRUE;
	psq_cb->psq_decimal.db_decimal = *((char *) $2);

	/* Change decimal character in session control block */
	cb->pss_decimal = *((char *) $2);

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    DB_STATUS       status;

	    status = psl_send_setqry(cb, str, psq_cb);

	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
    }
;

setiotrace:	    SETIOTRACE
    {
	DB_STATUS	    ret_val;
	DB_DEBUG_CB	    *debug_cb;

	/* "set [no]io_trace" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4		err_code;

	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("SET [NO]IO_TRACE")-1, "SET [NO]IO_TRACE");
	    return (E_DB_ERROR);
	}

	psq_cb->psq_mode = PSQ_DMFTRACE;

	/* Allocate the debug control block */
	ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
	    (PTR *) &debug_cb, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR) debug_cb,
	    &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	debug_cb->db_trace_point = DM_IOTRACE;
	debug_cb->db_value_count = 0;
	if ($1 == PSL_ONSET)
	    debug_cb->db_trswitch = DB_TR_ON;
	else
	    debug_cb->db_trswitch = DB_TR_OFF;
    }
;

setjoinop:	    SETJOINOP
    {
	i4                err_code;

	psq_cb->psq_mode = PSQ_OBSOLETE;

	if (cb->pss_ses_flag & PSS_WARNINGS)
	{
	    /* Set [no]joinop no longer supported */
	    (VOID) psf_error(5933L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	}
    }
;

setjournal:	    SETJOURNAL
    {
	i4                err_code;

	psq_cb->psq_mode = PSQ_ALLJOURNAL;

	/* "set journaling" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(5951L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	if ($1 == PSL_ONSET)
	    cb->pss_ses_flag |= PSS_JOURNALING;     /* pss_journaling=TRUE */
	else
	    cb->pss_ses_flag &= ~PSS_JOURNALING;    /*pss_journaling = FALSE */
    }
	  |	    SETJOURNAL ON
    {
	psq_cb->psq_mode = PSQ_SJOURNAL;
    }
		    obj_spec
    {
	i4             err_code, err_num = 0L;
	DB_STATUS	    status;
	i4		    rngvar_info;
	QEU_CB		    *qeu_cb;
	DMT_CB		    *dmt_cb;
	PSS_RNGTAB	    *rngvar;
	DMT_CHAR_ENTRY	    *chr;

	/* "set journaling" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(5951L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	if ($4->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, "", &$4->pss_owner,
		&$4->pss_obj_name, cb, FALSE, &rngvar, psq_cb->psq_mode,
		&psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, -1, "", &$4->pss_obj_name, cb,
		FALSE, &rngvar, psq_cb->psq_mode, &psq_cb->psq_error,
		&rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    $4->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (DB_FAILURE_MACRO(status))
	    return (status);

	if (	(rngvar->pss_tabdesc->tbl_status_mask &
	    	    (DMT_CATALOG|DMT_EXTENDED_CAT))
	    ||  (rngvar->pss_tabdesc->tbl_2_status_mask & DMT_TEXTENSION))
	{
	    /* Disallow SET JOURNALING on catalogs. */
	    err_num = 2762L;
	}
	else if (MEcmp((PTR) &rngvar->pss_ownname, (PTR) &cb->pss_user,
	               sizeof(DB_OWN_NAME)))
	{
	    /* disallow SET [NO]JOURNALING on someone else's tables */
	    err_num = 2753L;
	}
	else if (rngvar->pss_tabdesc->tbl_status_mask & DMT_IDX)
	{
	    /* Disallow SET JOURNALING on indices */
	    err_num = 2766L;
	}
	else
	{
	    i4		ref_cons_exists = FALSE;

	    /* 
	    ** one may not alter journaling status of a table involved in a
	    ** REFERENCES constraint
	    */
	    status = psl_find_cons(cb, rngvar, psl_qual_ref_cons, (PTR *) NULL,
		(DB_INTEGRITY *) NULL, &ref_cons_exists, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	
	    if (!ref_cons_exists)
	    {
		/*
		** table is not a REFERENCES constraint dependent object
		** need to check if table is a REFERENCES constraint
		** independent object
		*/
		status = psl_find_iobj_cons(cb, rngvar, &ref_cons_exists,
			   &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return(status);
	    }

	    if (ref_cons_exists)
		err_num = E_PS04B1_SET_JOUR_ON_REF_TBL;
	}

	if (err_num != 0L)
	{
	    /*
	    ** let user know if name supplied by the user was resolved to a
	    ** synonym
	    */
	    if (rngvar_info & PSS_BY_SYNONYM)
	    {
		psl_syn_info_msg(cb, rngvar, $4, rngvar_info,
		    sizeof("SET JOURNALING") - 1, "SET JOURNALING",
		    &psq_cb->psq_error);
	    }

	    if (err_num == 2753L)
	    {
		(VOID) psf_error(2753L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 2,
		    sizeof("SET [NO]JOURNALING") - 1, "SET [NO]JOURNALING",
		    psf_trmwhite(sizeof(rngvar->pss_tabname),
				 (char *) &rngvar->pss_tabname),
		    (char *) &rngvar->pss_tabname);
	    }
	    else if (err_num == E_PS04B1_SET_JOUR_ON_REF_TBL)
	    {
		(VOID) psf_error(E_PS04B1_SET_JOUR_ON_REF_TBL, 0L, PSF_USERERR, 
		    &err_code, &psq_cb->psq_error, 2,
		    psf_trmwhite(sizeof(rngvar->pss_tabname),
			(char *) &rngvar->pss_tabname),
		    (PTR) &rngvar->pss_tabname,
		    psf_trmwhite(sizeof(rngvar->pss_ownname),
			(char *) &rngvar->pss_ownname),
		    (PTR) &rngvar->pss_ownname);
	    }
	    else
	    {
		(VOID) psf_error(err_num, 0L, PSF_USERERR,&err_code,
		    &psq_cb->psq_error, 1,
		    psf_trmwhite(sizeof(rngvar->pss_tabname),
				 (char *) &rngvar->pss_tabname),
		    (char *) &rngvar->pss_tabname);
	    }

	    return (E_DB_ERROR);
	}

	/* Allocate QEU_CB for SET JOURNALING and initialize its header */
	status = psl_qeucb(cb, DMT_ALTER, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	qeu_cb = (QEU_CB *) cb->pss_object;

	/* Allocate a DMT control block */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMT_CB),
	    (PTR *) &dmt_cb, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	qeu_cb->qeu_d_cb = dmt_cb;

	/* Fill in the DMT control block header */
	dmt_cb->type = DMT_TABLE_CB;
	dmt_cb->length = sizeof(DMT_CB);
	dmt_cb->dmt_db_id = (char*) cb->pss_dbid;
        dmt_cb->dmt_mustlock = FALSE;

	/* Allocate the characteristics array */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMT_CHAR_ENTRY),
	    (PTR *) &dmt_cb->dmt_char_array.data_address, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	dmt_cb->dmt_char_array.data_in_size = sizeof(DMT_CHAR_ENTRY);

	/* Make the characteristic being changed the journaled bit */
	chr = (DMT_CHAR_ENTRY *) dmt_cb->dmt_char_array.data_address;
	chr->char_id = DMT_C_JOURNALED;
	chr->char_value = ($1 == PSL_ONSET) ? DMT_C_ON : DMT_C_OFF;

	STRUCT_ASSIGN_MACRO(rngvar->pss_tabid, dmt_cb->dmt_id);

	/* invalidate RDF's cache */
	{
	    RDF_CB              rdf_cb;

	    pst_rdfcb_init(&rdf_cb, cb);
	    STRUCT_ASSIGN_MACRO(rngvar->pss_tabid, rdf_cb.rdf_rb.rdr_tabid);
	    status = rdf_call(RDF_INVALIDATE, (PTR) &rdf_cb);
	    if (status != E_DB_OK)
	    {
		(VOID) psf_rdf_error(RDF_INVALIDATE, &rdf_cb.rdf_error,
					&psq_cb->psq_error);
		return (status);
	    }
	}
    }
;

setjtimeout:	    SETJOINOP nonkeyword setjint
    {
	DB_STATUS	       status;
	OPF_CB		       *opf_cb;
	i4			flag;

	psq_cb->psq_mode = PSQ_JTIMEOUT;

	if (STcompare($2, "timeout") == 0)
	    flag = OPF_TIMEOUT;
	else if (STcompare($2, "timeoutabort") == 0)
	    flag = OPF_TIMEOUTABORT;
	else if (STcompare($2, "notimeout") == 0)
	    flag = OPF_NOTIMEOUT;
	else if ((STcompare($2, "newenum") == 0 ||
		STcompare($2, "greedy") == 0) && $3 == 0)
	    flag = OPF_NEWENUM;
	else if ((STcompare($2, "nonewenum") == 0 ||
		STcompare($2, "nogreedy") == 0) && $3 == 0)
	    flag = OPF_NONEWENUM;
	else
	{
	    i4	    err_code;

	    /* set joinop [no]timeout syntax error */
	    (VOID) psf_error(2582L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		(i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
		(i4) STlength($2), $2);
	    return (E_DB_ERROR);
	}
	if (flag == OPF_TIMEOUTABORT)
	{
            status = psy_ckdbpr(psq_cb, (u_i4)DBPR_TIMEOUT_ABORT);
            if (status)
            {
		i4         err_code;
                /*
                ** Audit failure to set TIMEOUTABORT 
                */
		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    DB_ERROR        e_error;
		    DB_STATUS       local_status;
		    local_status = psy_secaudit(FALSE, cb,
			     "TIMEOUT_ABORT", &cb->pss_user,
			     sizeof(DB_TAB_NAME), SXF_E_RESOURCE,
			     I_SX2754_SET_TIMEOUTABORT, SXF_A_FAIL,
			     &e_error);
		}

                (VOID) psf_error(9353L, 0L, PSF_USERERR,
                                 &err_code, &psq_cb->psq_error, 0);
                return(status);
            }
       	}

	/* Create control block for setting cpu factor in OPF */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_level = OPF_SESSION;
	opf_cb->opf_alter = flag;
	opf_cb->opf_value = $3;
    }
;

setjint:   int2_int4_p
    {
    }
	|
    {
	$$ = 0;
    }
;

setlockmode:	    setlockstmnt setlockscope WHERE setlockparms
    {
	DB_STATUS		status;

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    status = psl_lm5_setlockmode_distr(cb, $Yscanbuf_ptr, &$Yxlated_qry,
			psq_cb);

	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
    }
;

setlockstmnt:	    SETLOCKMODE
    {
	DB_STATUS		status;

	status = psl_lm1_setlockstmnt(cb, psq_cb);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    }
;

setlockscope:	    SESSION
    {
	DMC_CB			*dmc_cb;

	dmc_cb	= (DMC_CB *) cb->pss_object;
	dmc_cb->dmc_sl_scope = DMC_SL_SESSION;

	/* there is special distributed handling for SET LOCKMODE SESSION */
	cb->pss_stmt_flags |= PSS_SET_LOCKMODE_SESS; 

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    DB_STATUS		status;

	    status = psl_lm6_setlockscope_distr(cb, (PSS_RNGTAB *)NULL,
				&$Yxlated_qry, &psq_cb->psq_error);

	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
	/* keep track of text of set lockmode stmnt for QEF */
	$Yscanbuf_ptr = (PTR) cb->pss_nxtchar;
    }
	  |	    ON obj_spec
    {
	DB_STATUS		status;
	i4			rngvar_info;
	DMC_CB			*dmc_cb;
	PSS_RNGTAB	       *rngvar;

	dmc_cb	= (DMC_CB*) cb->pss_object;
	dmc_cb->dmc_sl_scope = DMC_SL_TABLE;

	if ($2->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, "", &$2->pss_owner,
			&$2->pss_obj_name, cb, FALSE, &rngvar,
			psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, -1, "", &$2->pss_obj_name, cb,
		FALSE, &rngvar, psq_cb->psq_mode, &psq_cb->psq_error,
		&rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    $2->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (DB_FAILURE_MACRO(status))
	    return (status);

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    STRUCT_ASSIGN_MACRO(rngvar->pss_tabid, dmc_cb->dmc_table_id);
	}
	else
	{
	    status = psl_lm6_setlockscope_distr(cb, rngvar, &$Yxlated_qry,
	    			&psq_cb->psq_error);

	    if (DB_FAILURE_MACRO(status))
		return(status);

	    /* keep track of text of set lockmode stmnt for QEF (distr) */
	    if ($2->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
		$Yscanbuf_ptr = (PTR) cb->pss_nxtchar;
	    else
		$Yscanbuf_ptr = (PTR) cb->pss_prvtok;
	}
    }
;

setlockparms:	    setlockparm
	    |	    setlockparms COMMA setlockparm
;

setlockparm:	    setlockkey EQUAL nonkeyword
    {
	DB_STATUS		status;

	status = psl_lm3_setlockparm_name($1, $3, cb, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    }
	  |	    setlockkey EQUAL ROW
    {
	DB_STATUS		status;

	status = psl_lm3_setlockparm_name($1, "row", cb, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    }
	  |	    setlockkey EQUAL TABLE
    {
	DB_STATUS		status;

	status = psl_lm3_setlockparm_name($1, "table", cb, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    }
	|	    setlockkey EQUAL SESSION
    {
	DB_STATUS		status;

	status = psl_lm3_setlockparm_name($1, "session", cb,
	    &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    }
	  |	    setlockkey EQUAL intsetparam
    {
	DB_STATUS		status;

	status = psl_lm4_setlockparm_num($1, $3, cb, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    }
;

setlockkey:	    nonkeyword
    {
	i4			lockkey_type;
	DB_STATUS		status;

	status = psl_lm2_setlockkey(cb, $1, &lockkey_type, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
	else
	{
	    $$ = lockkey_type;
	}
    }

        |           LEVEL
    {
        i4                      lockkey_type;
        DB_STATUS               status;
 
        status = psl_lm2_setlockkey(cb, "level", &lockkey_type,
                                    &psq_cb->psq_error);
 
        if (DB_FAILURE_MACRO(status))
        {
            return(status);
        }
        else
        {
            $$ = lockkey_type;
        }
    }
;
 
settransaction:     settranstmnt settranmodes
    {
        DB_STATUS               status;
 
        status = psl_st0_settransaction(cb, psq_cb);
        if (DB_FAILURE_MACRO(status))
            return(status);
    }
;
settranstmnt:       SETTRANSACTION
    {
        DB_STATUS               status;
 
        status = psl_st1_settranstmnt(cb, psq_cb);
        if (DB_FAILURE_MACRO(status))
            return(status);
    }
;

settranmodes:	    settranmode
	    |	    settranmode COMMA settranmode
;

settranmode:	    settranisolation_level
	   |	    settranaccess_mode
;

settranisolation_level:     ISOLATION LEVEL isolation_level
    {
        DB_STATUS               status;
 
        status = psl_st2_settranisolation_level(cb, &psq_cb->psq_error, 
		(i4)$3);
        if (DB_FAILURE_MACRO(status))
            return(status);
    }
;

isolation_level:    READ COMMITTED
    {
	$$ = (i4)DMC_C_READ_COMMITTED;
    }
        |           READ UNCOMMITTED
    {
	$$ = (i4)DMC_C_READ_UNCOMMITTED;
    }
        |           REPEATABLE READ
    {
	$$ = (i4)DMC_C_REPEATABLE_READ;
    }
        |           SERIALIZABLE
    {
	$$ = (i4)DMC_C_SERIALIZABLE;
    }
;

settranaccess_mode:  access_mode
    {
        DB_STATUS               status;
 
        status = psl_st3_accessmode(cb, &psq_cb->psq_error, $1);
        if (DB_FAILURE_MACRO(status))
            return(status);
    }
;

access_mode :       READ ONLY
    {
	$$ = (i4)DMC_C_READ_ONLY;
    }
	|           READ WRITE
    {
	$$ = (i4)DMC_C_READ_WRITE; 
    }
;

setlocktrace:	    SETLOCKTRACE
    {
	DB_STATUS	    ret_val;
	DB_DEBUG_CB	    *debug_cb;

	/* "set [no]lock_trace" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	err_code;

	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("SET [NO]LOCK_TRACE")-1, "SET [NO]LOCK_TRACE");
	    return (E_DB_ERROR);
	}

	psq_cb->psq_mode = PSQ_DMFTRACE;

	/* Allocate the debug control block */
	ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
	    (PTR *) &debug_cb, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR) debug_cb,
	    &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	debug_cb->db_trace_point = DM_LOCKTRACE;
	debug_cb->db_value_count = 0;
	debug_cb->db_trswitch = ($1 == PSL_ONSET) ? DB_TR_ON : DB_TR_OFF;
    }
;

/*
** Yacc production:	setlogging	- Enable/disable logging
** Statement syntax:
**			SET [NO]LOGGING
**
** Statement to Enable/Disable Logging in current session.
** Must be DBA to execute this statement.
**
** Parse action is to allocate a DMC_CB structure for a DMC_ALTER call
** which will be executed by the PSQ_SLOGGING statement.
**
** Return State:
**	psq_mode				PSQ_SLOGGING
**	dmc_cb->dmc_char_entry[0].char_id	DMC_C_LOGGING
**	dmc_cb->dmc_char_entry[0].char_value	DMC_C_ON/DMC_C_OFF
*/
setlogging:	    SETLOGGING
    {
	DB_STATUS	    status;
	DMC_CB		    *dmc_cb;
	DMC_CHAR_ENTRY	    *dmc_char;
	i4		    err_code;

	/* "set [no]logging" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("SET [NO]LOGGING") - 1, "SET [NO]LOGGING");
	    return (E_DB_ERROR);
	}

	psq_cb->psq_mode = PSQ_SLOGGING;

	/*
	** Check for priviledge to turn off logging.
	** User must be the DBA to enable or disable logging.
	*/
	if (MEcmp((PTR)&cb->pss_user, (PTR)&cb->pss_dba,
	      sizeof(DB_OWN_NAME)) != 0)
	{
	    _VOID_ psf_error(E_PS0F81_SETLG_PRIV_ERR, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** Create control block for DMC_ALTER call for Set [No]Logging
	*/
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMC_CB), (PTR *) &dmc_cb,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	status = psf_mroot(cb, &cb->pss_ostream, (PTR) dmc_cb, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** Format Alter Control Block.
	*/
	cb->pss_object	    = (PTR) dmc_cb;
	dmc_cb->type	    = DMC_CONTROL_CB;
	dmc_cb->length	    = sizeof (DMC_CB);
	dmc_cb->dmc_op_type = DMC_SESSION_OP;
	dmc_cb->dmc_session_id	= (PTR)cb->pss_sessid;
	dmc_cb->dmc_db_id   = cb->pss_dbid;
	dmc_cb->dmc_flags_mask = 0;

	/*
	** Allocate characteristics array with entry for Set Logging.
	*/
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMC_CHAR_ENTRY),
	     (PTR *) &dmc_char, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	dmc_cb->dmc_char_array.data_in_size = sizeof(DMC_CHAR_ENTRY);
	dmc_cb->dmc_char_array.data_address = (char *) dmc_char;
	dmc_char->char_id = DMC_C_LOGGING;
	dmc_char->char_value = (($1 == PSL_ONSET) ? DMC_C_ON: DMC_C_OFF);
    }
;

setlogtrace:	    SETLOGTRACE
    {
	DB_STATUS	    ret_val;
	DB_DEBUG_CB	    *debug_cb;

	/* "set [no]log_trace" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	err_code;

	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("SET [NO]LOG_TRACE") - 1, "SET [NO]LOG_TRACE");
	    return (E_DB_ERROR);
	}

	psq_cb->psq_mode = PSQ_DMFTRACE;

	/* Allocate the debug control block */
	ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
	    (PTR *) &debug_cb, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR) debug_cb,
	    &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	debug_cb->db_trace_point = DM_LOGTRACE;
	debug_cb->db_value_count = 0;
	debug_cb->db_trswitch = ($1 == PSL_ONSET) ? DB_TR_ON : DB_TR_OFF;
    }
;

setmnyfmt:	    SETMNYFMT strconst_e
    {
	i4                err_code;

	psq_cb->psq_mode = PSQ_SMNFMT;

	/* First character of parameter must specify leading or trailing */
	if (((char *) $2)[0] == 't' || ((char *) $2)[0] == 'T')
	{
	    /* Give trailing indicator back to caller */
	    psq_cb->psq_mnyfmt.db_mny_lort = DB_TRAIL_MONY;
	}
	else if (((char *) $2)[0] == 'l' || ((char *) $2)[0] == 'L')
	{
	    /* Give leading indicator back to caller */
	    psq_cb->psq_mnyfmt.db_mny_lort = DB_LEAD_MONY;
	}
	else if ( (((char *) $2)[0] == 'n' || ((char *) $2)[0] == 'N') &&
	          (((char *) $2)[1] == 'o' || ((char *) $2)[1] == 'O') &&
	          (((char *) $2)[2] == 'n' || ((char *) $2)[2] == 'N') &&
	          (((char *) $2)[3] == 'e' || ((char *) $2)[3] == 'E') )
	{
	    /* Give leading indicator back to caller */
	    psq_cb->psq_mnyfmt.db_mny_lort = DB_NONE_MONY;
	    psq_cb->psq_mnyfmt.db_mny_sym[0] = EOS;
	}
	else
	{
	    (VOID) psf_error(5935L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, STtrmwhite((char *) $2), (char *) $2);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

 	if ( (psq_cb->psq_mnyfmt.db_mny_lort == DB_LEAD_MONY) ||
 	     (psq_cb->psq_mnyfmt.db_mny_lort == DB_TRAIL_MONY) )
	{
 	    /* Second character of parameter must be a colon */
	    if (((char *) $2)[1] != ':')
	    {
	        (VOID) psf_error(5935L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, STtrmwhite((char *) $2), (char *) $2);
	        return (E_DB_ERROR);    /* non-zero return means error */
	    }

	    /* Next 0 - 4 characters is the currency symbol */
	    if (STlength(&((char *) $2)[2]) > DB_MAXMONY)
	    {
	        (VOID) psf_error(5935L, 0L, PSF_USERERR, &err_code,
	          	&psq_cb->psq_error, 1, STtrmwhite((char *) $2), $2);
	        return (E_DB_ERROR);
	    }

	    /* Give money symbol back to caller */
	    STcopy(&((char *) $2)[2], psq_cb->psq_mnyfmt.db_mny_sym);
	}

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    char	str[sizeof("set money_format '' ") + 2 + DB_MAXMONY];
	    DB_STATUS	status;

	    status = psl_send_setqry(cb,
			STpolycat(3, "set money_format '", $2, "' ", str),
			psq_cb);

	    if (DB_FAILURE_MACRO(status))
		return (status);
	}
    }
;

setmnyprec:	    SETMNYPREC intsetparam
    {
	i4                err_code;

	psq_cb->psq_mode = PSQ_SMNPREC;

	/* Specified precision must be between 0 and 2, inclusive */
	if ($2 < 0 || $2 > 2)
	{
	    (VOID) psf_error(5937L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, sizeof($2), &$2);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Give money precision back to caller */
	psq_cb->psq_mnyfmt.db_mny_prec = $2;

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    char	str[sizeof("set money_prec   ")];
	    char	num[1 + sizeof(EOS)];
	    DB_STATUS	status;

	    CVla($2, num);

	    status = psl_send_setqry(cb,
			STpolycat(3, "set money_prec ", num, " ", str),
			psq_cb);

	    if (DB_FAILURE_MACRO(status))
	    {
		return(status);
	    }
	}
    }
;

setmxio:	    setmxio_kwd intsetparam
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_ONSET)
	{
	    (VOID) psf_error(6236L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv |= DBPR_QDIO_LIMIT;
	psy_cb->psy_fl_dbpriv  |= DBPR_QDIO_LIMIT;
	psy_cb->psy_qdio_limit  = $2;

    }
		|   setmxio_kwd
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_OFFSET)
	{
	    (VOID) psf_error(6237L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv  = DBPR_QDIO_LIMIT;
    }
;

setmxio_kwd:	    SETMXIO
    {
	i4                err_code;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_MXQUERY;

	/* "SET [NO]MAX..." is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6235L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	if ((status = psy_qminit(cb, psq_cb, &cb->pss_ostream)) != E_DB_OK)
	    return(status);

	$$ = $1;
    }
;

setmxrow:	    setmxrow_kwd intsetparam
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_ONSET)
	{
	    (VOID) psf_error(6236L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv |= DBPR_QROW_LIMIT;
	psy_cb->psy_fl_dbpriv  |= DBPR_QROW_LIMIT;
	psy_cb->psy_qrow_limit  = $2;

    }
		|   setmxrow_kwd
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_OFFSET)
	{
	    (VOID) psf_error(6237L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv  |= DBPR_QROW_LIMIT;
    }
;

setmxrow_kwd:	    SETMXROW
    {
	i4                err_code;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_MXQUERY;

	/* "SET [NO]MAX..." is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6235L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	if ((status = psy_qminit(cb, psq_cb, &cb->pss_ostream)) != E_DB_OK)
	    return(status);

	$$ = $1;
    }
;

setmxcpu:	    setmxcpu_kwd intsetparam
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_ONSET)
	{
	    (VOID) psf_error(6236L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv |= DBPR_QCPU_LIMIT;
	psy_cb->psy_fl_dbpriv  |= DBPR_QCPU_LIMIT;
	psy_cb->psy_qcpu_limit  = $2;

    }
		|   setmxcpu_kwd
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_OFFSET)
	{
	    (VOID) psf_error(6237L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv  |= DBPR_QCPU_LIMIT;
    }
;

setmxcpu_kwd:	    SETMXCPU
    {
	i4                err_code;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_MXQUERY;

	/* "SET [NO]MAX..." is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6235L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	if ((status = psy_qminit(cb, psq_cb, &cb->pss_ostream)) != E_DB_OK)
	    return(status);

	$$ = $1;
    }
;

setmxidle:	    setmxidle_kwd intsetparam
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_ONSET)
	{
	    (VOID) psf_error(6236L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv |= DBPR_IDLE_LIMIT;
	psy_cb->psy_fl_dbpriv  |= DBPR_IDLE_LIMIT;
	psy_cb->psy_idle_limit  = $2;

    }
		|   setmxidle_kwd
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_OFFSET)
	{
	    (VOID) psf_error(6237L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv  |= DBPR_IDLE_LIMIT;
    }
;
setmxidle_kwd:	    SETMXIDLE
    {
	i4                err_code;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_MXSESSION;

	if ((status = psy_qminit(cb, psq_cb, &cb->pss_ostream)) != E_DB_OK)
	    return(status);

	$$ = $1;
    }
;

setmxconnect:	    setmxconnect_kwd intsetparam
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_ONSET)
	{
	    (VOID) psf_error(6236L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv |= DBPR_CONNECT_LIMIT;
	psy_cb->psy_fl_dbpriv  |= DBPR_CONNECT_LIMIT;
	psy_cb->psy_connect_limit  = $2;

    }
		|   setmxconnect_kwd
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_OFFSET)
	{
	    (VOID) psf_error(6237L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv  |= DBPR_CONNECT_LIMIT;
    }
;

setmxconnect_kwd:	    SETMXCONNECT
    {
	i4                err_code;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_MXSESSION;

	if ((status = psy_qminit(cb, psq_cb, &cb->pss_ostream)) != E_DB_OK)
	    return(status);

	$$ = $1;
    }
;
setmxpage:	    setmxpage_kwd intsetparam
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_ONSET)
	{
	    (VOID) psf_error(6236L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv |= DBPR_QPAGE_LIMIT;
	psy_cb->psy_fl_dbpriv  |= DBPR_QPAGE_LIMIT;
	psy_cb->psy_qpage_limit = $2;

    }
		|   setmxpage_kwd
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_OFFSET)
	{
	    (VOID) psf_error(6237L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv  |= DBPR_QPAGE_LIMIT;
    }
;

setmxpage_kwd:	    SETMXPAGE
    {
	i4                err_code;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_MXQUERY;

	/* "SET [NO]MAX..." is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6235L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	if ((status = psy_qminit(cb, psq_cb, &cb->pss_ostream)) != E_DB_OK)
	    return(status);

	$$ = $1;
    }
;

setmxcost:	    setmxcost_kwd intsetparam
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_ONSET)
	{
	    (VOID) psf_error(6236L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv |= DBPR_QCOST_LIMIT;
	psy_cb->psy_fl_dbpriv  |= DBPR_QCOST_LIMIT;
	psy_cb->psy_qcost_limit = $2;

    }
		|   setmxcost_kwd
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_OFFSET)
	{
	    (VOID) psf_error(6237L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv  |= DBPR_QCOST_LIMIT;
    }
;

setmxcost_kwd:	    SETMXCOST
    {
	i4                err_code;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_MXQUERY;

	/* "SET [NO]MAX..." is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6235L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	if ((status = psy_qminit(cb, psq_cb, &cb->pss_ostream)) != E_DB_OK)
	    return(status);

	$$ = $1;
    }
;

setprintqry:	    SETPRINTQRY
    {
	DB_DEBUG_CB	       *debug_cb;
	DB_STATUS	       ret_val;

	/* Allocate the debug control block */
	ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream,
	    &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
	    (PTR *) &debug_cb, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR) debug_cb,
	    &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	debug_cb->db_value_count = 0;
	if ($1 == PSL_ONSET)
	    debug_cb->db_trswitch = DB_TR_ON;
	else
	    debug_cb->db_trswitch = DB_TR_OFF;

	debug_cb->db_trace_point = 129;	    /* 128 + 1 - first trace flag
					    ** of session trace flags.
					    */
	psq_cb->psq_mode = PSQ_PSFTRACE;
    }
;
	

/*
** Yacc rule:  setprintrules	- Print rule names as they fire.
**
** Statement Syntax:
**	SET [NO]PRINTRULES
**
** Return State:
**	DB_DEBUG_CB.db_trswitch = On|Off
*/
setprintrules:	    SETPRTRULES
    {
	DB_DEBUG_CB	       *debug_cb;
	DB_STATUS	       ret_val;

	/* "set [no]printrules" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	err_code;

	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("SET [NO]PRINTRULES")-1, "SET [NO]PRINTRULES");
	    return (E_DB_ERROR);
	}

	/* Allocate the debug control block */
	ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
			     (PTR *)&debug_cb, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR)debug_cb,
			    &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	debug_cb->db_value_count = 0;
	if ($1 == PSL_ONSET)
	    debug_cb->db_trswitch = DB_TR_ON;
	else
	    debug_cb->db_trswitch = DB_TR_OFF;
	debug_cb->db_trace_point = QEF_T_RULES;		/* qea_callproc */
	psq_cb->psq_mode = PSQ_QEFTRACE;
    }
;

/*
** Yacc production:	setrules	- DBA turn rules on/off
** Statement syntax:
**			SET [NO]RULES
** Return State:
**	DEBUG_CB.db_trace_point = QEF_T_NORULES
*/
setrules:      SETRULES
    {
	i4		err_code;
	DB_DEBUG_CB	*debug_cb;
	DB_STATUS	ret_val;

	/* "set [no]rules" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("SET [NO]RULES")-1, "SET [NO]RULES");
	    return (E_DB_ERROR);
	}

	/* Confirm that the DBA is turning rules off */
	if (MEcmp((PTR)&cb->pss_user, (PTR)&cb->pss_dba,
	      sizeof(DB_OWN_NAME)) != 0)
	{
	    _VOID_ psf_error(E_US18AA_6314_SET_NORULES, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	/* Allocate the debug control block */
	ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
			     (PTR *)&debug_cb, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_mroot(cb, &cb->pss_ostream,(PTR)debug_cb, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	debug_cb->db_value_count = 0;
	if ($1 == PSL_ONSET)			/* Note reverse logic! */
	    debug_cb->db_trswitch = DB_TR_OFF;
	else
	    debug_cb->db_trswitch = DB_TR_ON;
	debug_cb->db_trace_point = QEF_T_NORULES;	/* qea_callproc */
	psq_cb->psq_mode = PSQ_QEFTRACE;
    }  
;

/*
** Yacc production:  setprintevents    - Print dbevents when raised/received.
**
** Statement Syntax:
**      SET [NO]PRINTEVENTS
**
** Return State:
**      DB_DEBUG_CB.db_trswitch = On|Off
*/
setprintevents:      SETPRTEVENTS
    {
        DB_DEBUG_CB            *dbg_cb;
        DB_STATUS              ret_val;

	/* "set [no]printdbevents" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	err_code;

	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("SET [NO]PRINTDBEVENTS")-1,
		"SET [NO]PRINTDBEVENTS");
	    return (E_DB_ERROR);
	}

        /* Allocate the debug control block */
        ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
        if (ret_val != E_DB_OK)
            return (ret_val);
        ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
                             (PTR *)&dbg_cb, &psq_cb->psq_error);
        if (ret_val != E_DB_OK)
            return (ret_val);
        ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR)dbg_cb, &psq_cb->psq_error);
        if (ret_val != E_DB_OK)
            return (ret_val);
        dbg_cb->db_value_count = 0;
        if ($1 == PSL_ONSET)
            dbg_cb->db_trswitch = DB_TR_ON;
        else
            dbg_cb->db_trswitch = DB_TR_OFF;
        dbg_cb->db_trace_point = QEF_T_EVENTS;         /* qea_event */
        psq_cb->psq_mode = PSQ_QEFTRACE;
    }
;

/*
** Yacc production:  setlogevents    - Log dbevents when raised/received.
**
** Statement Syntax:
**      SET [NO]LOGDBEVENTS
**
** Return State:
**      DB_DEBUG_CB.db_trswitch = On|Off
*/
setlogevents:      SETLOGEVENTS
    {
        DB_DEBUG_CB            *dbg_cb;
        DB_STATUS              ret_val;

	/* "set [no]logdbevents" is not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	err_code;

	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("SET [NO]LOGDBEVENTS")-1,
		"SET [NO]LOGDBEVENTS");
	    return (E_DB_ERROR);
	}

        /* Allocate the debug control block */
        ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
        if (ret_val != E_DB_OK)
            return (ret_val);
        ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
                             (PTR *)&dbg_cb, &psq_cb->psq_error);
        if (ret_val != E_DB_OK)
            return (ret_val);
        ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR)dbg_cb, &psq_cb->psq_error);
        if (ret_val != E_DB_OK)
            return (ret_val);
        dbg_cb->db_value_count = 0;
        if ($1 == PSL_ONSET)
            dbg_cb->db_trswitch = DB_TR_ON;
        else
            dbg_cb->db_trswitch = DB_TR_OFF;
        dbg_cb->db_trace_point = QEF_T_LGEVENTS;         /* qea_event */
        psq_cb->psq_mode = PSQ_QEFTRACE;
    }
;

setoptimizeonly:    SETOPTIMIZEONLY
    {
	/*
	** It has been decided to implement thsi statement by acting as if user
	** entered "set [no]trace point op160"
	*/

	OPF_CB		       *opf_cb;
	DB_STATUS	ret_val;

	psq_cb->psq_mode = PSQ_SQEP;	/* NOTE: PSQ_SQEP does for any OPF
					** alter values */

	/* Allocate the OPF control block */
	ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
			    &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_level = OPF_SESSION;
	if ($1 == PSL_ONSET)
	    opf_cb->opf_alter = OPF_OPTIMIZEONLY;
	else
	    opf_cb->opf_alter = OPF_NOOPTIMIZEONLY;
    }
;

setflatten:	    SETFLATTEN
    {
	DB_STATUS	       status;
	OPF_CB		       *opf_cb;

	psq_cb->psq_mode = PSQ_SQEP;	/* NOTE: PSQ_SQEP does for any OPF
					** alter values */

	/* Create control block for setting flattening indicator in OPF */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_level = OPF_SESSION;
	if ($1 == PSL_ONSET)
	    opf_cb->opf_alter = OPF_NOSUBSELECT;
	else
	    opf_cb->opf_alter = OPF_SUBSELECT;
    }
;

sethash:	    SETHASH
    {
	DB_STATUS	       status;
	OPF_CB		       *opf_cb;

	psq_cb->psq_mode = PSQ_SQEP;	/* NOTE: PSQ_SQEP does for any OPF
					** alter values */

	/* Create control block for setting hash operations indicator in OPF */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_level = OPF_SESSION;
	if ($1 == PSL_ONSET)
	    opf_cb->opf_alter = OPF_HASH;
	else
	    opf_cb->opf_alter = OPF_NOHASH;
    }
;

setojflatten:	    SETOJFLATTEN
    {
	DB_STATUS	       status;
	OPF_CB		       *opf_cb;

	psq_cb->psq_mode = PSQ_SQEP;	/* NOTE: PSQ_SQEP does for any OPF
					** alter values */

	/* Create control block for setting OJ flattening indicator in OPF */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_level = OPF_SESSION;
	if ($1 == PSL_ONSET)
	    opf_cb->opf_alter = OPF_OJSUBSELECT;
	else
	    opf_cb->opf_alter = OPF_NOOJSUBSELECT;
    }
;

setparallel:	    SETPARALLEL parconst
    {
	DB_STATUS	       status;
	OPF_CB		       *opf_cb;

	psq_cb->psq_mode = PSQ_SQEP;	/* NOTE: PSQ_SQEP does for any OPF
					** alter values */

	/* Create control block for setting parallel query indicator in OPF */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_level = OPF_SESSION;
	opf_cb->opf_value = $2;
	if ($1 == PSL_ONSET)
	    opf_cb->opf_alter = OPF_PARALLEL;
	else
	{
	    opf_cb->opf_alter = OPF_NOPARALLEL;
	    opf_cb->opf_value = -1;
	}
    }
;

parconst:   int2_int4_p
    {
    }
	|
    {
	$$ = 4;
    }
;

setqep:		    SETQEP
    {
	DB_STATUS	       status;
	OPF_CB		       *opf_cb;

	psq_cb->psq_mode = PSQ_SQEP;

	/* Create control block for setting qep factor in OPF */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_level = OPF_SESSION;
	if ($1 == PSL_ONSET)
	    opf_cb->opf_alter = OPF_QEP;
	else
	    opf_cb->opf_alter = OPF_NOQEP;
    }
;

setrandomseed:	    SETRANDOMSEED intsetparam
    {
	psq_cb->psq_mode = PSQ_SETRANDOMSEED;
	psq_cb->psq_random_seed = $2;
    }
    |		    SETRANDOMSEED
    {
	u_i4	tmppid;
	u_i4	tmpnow = TMsecs();

	PCpid(&tmppid);
	psq_cb->psq_mode = PSQ_SETRANDOMSEED;
	psq_cb->psq_random_seed = tmppid * tmpnow; 
    }
;

setretinto:	    SETRETINTO strsetparam
    {
	i4                err_code;

	psq_cb->psq_mode = PSQ_OBSOLETE;

	if (cb->pss_ses_flag & PSS_WARNINGS)
	{
	    /* "set ret_into" no longer supported */
	    (VOID) psf_error(5978L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	}
    }
;

set_stat_tbl:	    QDATA
    {
	DB_TEXT_STRING	    *text_string;
	PSS_RNGTAB	    *rngvar;
	DB_STATUS           status;
	i4		    rngvar_info;
	DB_TAB_NAME         tabname;
	DB_DT_ID	    totype;

	/*
	** before we call qdata_cvt() to convert input value into longtext, make
	** sure that the input value is of "character type", i.e. c, char, text,
	** varchar, or longtext
	*/

	status = psl_must_be_string(cb, $1, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/*
	** if the input datatype was nullable, so must be the output datatype
	*/

	totype = ($1->db_datatype < 0) ? -DB_LTXT_TYPE : DB_LTXT_TYPE;

	if (qdata_cvt(cb, psq_cb, $1, totype, (PTR *) &text_string) != E_DB_OK)
	{
	    return (E_DB_ERROR);
	}

	STmove(sconvert(text_string), ' ', sizeof(DB_TAB_NAME), 
	    (char *) &tabname);

 	status = psl_rngent(&cb->pss_auxrng, -1, "", &tabname, cb, FALSE, 
	   &rngvar, psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
	if (status == E_DB_INFO)
	{
	    status = E_DB_OK;
	    if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		(char *)&tabname, &psq_cb->psq_error))
	    {
		return(E_DB_ERROR);
	    }
	}
	if (status != E_DB_OK)
	    return (status);

	$$ = rngvar;
   }
	    |	    obj_spec
    {
	PSS_RNGTAB          *rngvar;
	DB_STATUS           status;
	i4		    rngvar_info;

	if ($1->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, "", &$1->pss_owner,
		&$1->pss_obj_name, cb, FALSE, &rngvar, psq_cb->psq_mode,
		&psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, -1, "", &$1->pss_obj_name, cb,
		FALSE, &rngvar, psq_cb->psq_mode, &psq_cb->psq_error,
		&rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    $1->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (DB_FAILURE_MACRO(status))
	    return (status);

	$$ = rngvar;
    }
;		    

/*
** Yacc production:	setsession	- set session parameters
** Statement syntax:
**
**	SET SESSION 
**		[ ADD/DROP PRIVILEGES ()] 
**              [,READ ONLY / READ WRITE]
**              [,ISOLATION LEVEL isolation_level]
**              [WITH 
**                  [  session_param = param_value]
**                  [, word ]
**		    [, PRIVILEGES = ( param, {param} ) | ALL | DEFAULT]
**
*/
setsession:	    setsessstmt setsessopts setsesswith

setsessstmt:	    SETSESSION
    {
	DB_STATUS		status;
	QEF_RCB			*qef_rcb;

	/*
	** Doing a SET SESSION statement
	*/
	psq_cb->psq_mode = PSQ_SET_SESSION;
	psq_cb->psq_ret_flag=0;
	psq_cb->psq_privs=0;

	/* Open memory stream for statement */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

    }
;

setsessopts:	setsessopt
	|	setsessopt COMMA setsessopt
	|       /* Nothing */
;

setsessopt:	ADD PRIVILEGES LPAREN usr_priv_list RPAREN
    {
	PSY_CB	    *psy_cb;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;
/*
	TRdisplay ("setsessadp: ADD P L list R - calling psl_us10_usrpriv\n");
*/
	status=psl_us10_set_priv(psq_cb, cb,PSQ_SET_APRIV, $4);
	if(DB_FAILURE_MACRO(status))
		return status;
    }
	|       DROP PRIVILEGES LPAREN usr_priv_list RPAREN
    {
	PSY_CB	    *psy_cb;
	DB_STATUS   status;

	psy_cb = (PSY_CB *) cb->pss_object;
/*
	TRdisplay ("setsessadp: DROP P L list R - calling psl_us10_usrpriv\n");
*/
	status=psl_us10_set_priv(psq_cb, cb, PSQ_SET_DPRIV, $4);
	if(DB_FAILURE_MACRO(status))
		return status;
    }
	| ISOLATION LEVEL isolation_level
    {
	psq_cb->psq_ret_flag |= PSQ_SET_ISOLATION;
	psq_cb->psq_isolation = $3;
    }
	| ISOLATION LEVEL nonkeyword
    {
	if (!STcompare($3, "system"))
	{
	    psq_cb->psq_ret_flag |= PSQ_SET_ISOLATION;
	    psq_cb->psq_isolation = DMC_C_SYSTEM;
	}
	else
	{
	    i4    err_code;

	    (VOID) psf_error(5923L, 0L, PSF_USERERR, &err_code, 
		    &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
    }
	| access_mode
    {
	psq_cb->psq_ret_flag |= PSQ_SET_ACCESSMODE;
	psq_cb->psq_accessmode = $1;
    }
;

setsesswith:	WITH setsessparms
	|	/* Nothing */
;

setsessparms:	setsessparm
	|	setsessparm COMMA setsessparms
;

setsessparm:        nonkeyword EQUAL nonkeyword
    {
	DB_STATUS status;
	status=psl_us9_set_nonkw_eq_nonkw(psq_cb, cb, $1,$3, TRUE);
	if(DB_FAILURE_MACRO(status))
			return status;
    }	
    | nonkeyword EQUAL strconst
    {
	DB_STATUS status;
	status=psl_us9_set_nonkw_eq_nonkw(psq_cb, cb, $1,$3, FALSE);
	if(DB_FAILURE_MACRO(status))
		return status;
	
    }
    | nonkeyword  EQUAL int2_int4
    {
	DB_STATUS status;
	status=psl_us14_set_nonkw_eq_int(psq_cb, cb, $1,(i4)$3);
	if(DB_FAILURE_MACRO(status))
		return status;
    }
    | nonkeyword EQUAL ROLLBACK SAVEPOINT generic_ident
    {
	DB_STATUS status;
	status=psl_us11_set_nonkw_roll_svpt(psq_cb, cb, $1,$5);
	if(DB_FAILURE_MACRO(status))
		return status;
    }
    | nonkeyword EQUAL ROLLBACK nonkeyword
    {
	DB_STATUS status;
	status=psl_us12_set_nonkw_roll_nonkw(psq_cb, cb, $1,$4);
	if(DB_FAILURE_MACRO(status))
		return status;
    }
    |   PRIVILEGES EQUAL LPAREN usr_priv_list RPAREN
    {
	DB_STATUS   status;

/*
	TRdisplay("setsessparm: P L list R -  calling psl_us10_set_priv\n");
*/
	status=psl_us10_set_priv(psq_cb, cb, PSQ_SET_PRIV, $4);
	if(DB_FAILURE_MACRO(status))
		return status;
    }
    | PRIVILEGES EQUAL DEFAULT
     {
	DB_STATUS   status;

/*
	TRdisplay("setsessparm: P EQUAL DEFAULT - calling psl_us10_set_priv\n" ) ;
*/
	status=psl_us10_set_priv(psq_cb, cb, PSQ_SET_DEFPRIV, 0);
	if(DB_FAILURE_MACRO(status))
		return status;
      }
	
    | PRIVILEGES EQUAL ALL
     {
	DB_STATUS   status;

/*
	TRdisplay ( "setsessparm: P EQUAL ALL -  calling psl_us10_usrpriv\n");
*/
	status=psl_us10_set_priv(psq_cb, cb, PSQ_SET_ALLPRIV, 0);
	if(DB_FAILURE_MACRO(status))
		return status;
      }
    | nonkeyword
    {
	DB_STATUS   status;
	i4     err_code;

	status=psl_us15_set_nonkw(psq_cb, cb, $1);
	if(DB_FAILURE_MACRO(status))
		return status;
    }
;

setstats:	    SETSTATS set_stat_tbl
    {
	DB_STATUS	       status;
	QEU_CB		       *qeu_cb;
	DMT_CB		       *dmt_cb;
	DMT_CHAR_ENTRY	       *chr;
        DB_ERROR		e_error;
	i4			err_code;

	status = psy_ckdbpr(psq_cb, (u_i4) DBPR_TABLE_STATS);

	if (DB_FAILURE_MACRO(status))
	{
	    /*
	    ** Not allowed to change table stats
	    */
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		status = psy_secaudit(FALSE, 
			cb, 
			$2->pss_tabname.db_tab_name,
			&$2->pss_ownname, 
			sizeof($2->pss_tabname),
			SXF_E_TABLE, I_SX273C_TABLE_STATS,
			SXF_A_FAIL | SXF_A_CONTROL, 
			&e_error);
	    }

	     (VOID) psf_error(E_PS035B_CANT_ACCESS_TBL_STATS, 
			0L, PSF_USERERR, &err_code, &psq_cb->psq_error, 0);
	    return E_DB_ERROR;
	}

	psq_cb->psq_mode = PSQ_SSTATS;

	/* Allocate QEU_CB for SET STATISTICS and initialize its header */
	status = psl_qeucb(cb, DMT_ALTER, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	qeu_cb = (QEU_CB *) cb->pss_object;

	/* Allocate a DMT control block */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMT_CB),
	    (PTR *) &dmt_cb, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	qeu_cb->qeu_d_cb = dmt_cb;

	/* Fill in the DMT control block header */
	dmt_cb->type = DMT_TABLE_CB;
	dmt_cb->length = sizeof(DMT_CB);
	dmt_cb->dmt_db_id = (char*) cb->pss_dbid;
        dmt_cb->dmt_mustlock = FALSE;

	/* Allocate the characteristics array */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMT_CHAR_ENTRY),
	    (PTR *) &dmt_cb->dmt_char_array.data_address, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	dmt_cb->dmt_char_array.data_in_size = sizeof(DMT_CHAR_ENTRY);

	/* Make the characteristic being changed the journaled bit */
	chr = (DMT_CHAR_ENTRY *) dmt_cb->dmt_char_array.data_address;
	chr->char_id = DMT_C_ZOPTSTATS;
	if ($1 == PSL_ONSET)
	    chr->char_value = DMT_C_ON;
	else
	    chr->char_value = DMT_C_OFF;

	STRUCT_ASSIGN_MACRO($2->pss_tabid, dmt_cb->dmt_id);

	/* Star requires table and owner for issuing query */
	STRUCT_ASSIGN_MACRO($2->pss_tabname, dmt_cb->dmt_table);
	STRUCT_ASSIGN_MACRO($2->pss_ownname, dmt_cb->dmt_owner);

	/* invalidate RDF's cache */
	{
	    RDF_CB		rdf_cb;

	    pst_rdfcb_init(&rdf_cb, cb);
	    STRUCT_ASSIGN_MACRO($2->pss_tabid, rdf_cb.rdf_rb.rdr_tabid);
	    status = rdf_call(RDF_INVALIDATE, (PTR) &rdf_cb);
	    if (status != E_DB_OK)
	    {
		(VOID) psf_rdf_error(RDF_INVALIDATE, &rdf_cb.rdf_error,
				&psq_cb->psq_error);
		return (status);
	    }
	}
    }
;

settrace:	    settracestmnt strsetparam
    {
	i4                err_code;
	SCF_CB		       scf_cb;
	SCF_SCI		       sci_list;
	DB_TERM_NAME	       termname;
	CL_ERR_DESC	       cl_error;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_STRACE;

	/*
	** Possible single parameters are "terminal", "output", "input",
	** "point".  Error is anything else.
	*/
	if (!STcasecmp($2, "terminal"))
	{
	    if ($1 == PSL_ONSET)
	    {
		/* Get user's terminal name */
	        scf_cb.scf_length = sizeof(SCF_CB);
	        scf_cb.scf_type = SCF_CB_TYPE;
	        scf_cb.scf_facility = DB_PSF_ID;
	        scf_cb.scf_session = DB_NOSESSION;
		scf_cb.scf_len_union.scf_ilength = 1;
		/* may cause lint message */
		scf_cb.scf_ptr_union.scf_sci = (SCI_LIST*) &sci_list;
		sci_list.sci_code = SCI_UTTY;
		sci_list.sci_length = sizeof(termname);
		sci_list.sci_aresult = (PTR) &termname;
		sci_list.sci_rlength = NULL;
		status = scf_call(SCU_INFORMATION, &scf_cb);
		if (status == E_DB_OK)
		{
		    /* set trace terminal */
		    if (TRset_file(TR_T_OPEN, termname.db_term_name,
			sizeof(termname), &cl_error))
		    {
		        (VOID) psf_error(5988L, 0L, PSF_USERERR, &err_code,
		    		&psq_cb->psq_error, 1, 
				sizeof (termname.db_term_name),
				termname.db_term_name);
		    }
		}
		else
		{
		    (VOID) psf_error(E_PS0378_SCF_TERM_ERR,
			scf_cb.scf_error.err_code, PSF_INTERR,
			&err_code, &psq_cb->psq_error, 0);
		}
	    }
	    else
	    {
		/* set notrace terminal */
		TRset_file(TR_T_CLOSE, NULL, 0, &cl_error);
	    }
	}
	else if (!STcasecmp($2, "output"))
	{
	    /* "set trace output" without filename not allowed */
	    if ($1 == PSL_ONSET)
	    {
		(VOID) psf_error(5973L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 0);
		return (E_DB_ERROR);	/* non-zero return means error */
	    }
	    else
	    {
		/* set notrace output */
		TRset_file(TR_F_CLOSE, NULL, 0, &cl_error);
	    }
	}
	else if (!STcasecmp($2, "input"))
	{
	    /* "set trace input" without filename not allowed */
	    if ($1 == PSL_ONSET)
	    {
		(VOID) psf_error(5973L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 0);
		return (E_DB_ERROR);	/* non-zero return means error */
	    }
	    else
	    {
		/* set notrace input */
		TRset_file(TR_I_CLOSE, NULL, 0, &cl_error);
	    }
	}
	else if (!STcasecmp($2, "point"))
	{
	    /* "set trace point" without facility code not allowed */
	    (VOID) psf_error(5965L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);	/* non-zero return means error */
	}
	else
	{
	    (VOID) psf_error(5962L, 0L,  PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STtrmwhite($2), $2);
	    return (E_DB_ERROR);	/* non-zero return means error */
	}
    }
	  |
		    settracestmnt strsetparam strsetparam
    {
	i4                err_code;
	CL_ERR_DESC	       cl_error;

	psq_cb->psq_mode = PSQ_STRACE;

	/*
	** Valid parameters are "terminal", "output", "input", "point".
	** Error if none of these.
	*/
	if (!STcasecmp($2, "terminal"))
	{
	    /* "set notrace terminal" must not have a second parm */
	    if ($1 == PSL_OFFSET)
	    {
		(VOID) psf_error(5963L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 0);
		return (E_DB_ERROR);	/* non-zero return means error */
	    }
	    else
	    {
		/* set trace terminal termname */
		if (TRset_file(TR_T_OPEN, $3, STlength($3), &cl_error))
		{
		    (VOID) psf_error(5988L, 0L, PSF_USERERR, &err_code,
		    	&psq_cb->psq_error, 1, 
			STlength ($3), $3);
		}
	    }
	}
	else if (!STcasecmp($2, "output"))
	{
	    /* "set notrace output" must not have a second parm */
	    if ($1 == PSL_OFFSET)
	    {
		(VOID) psf_error(5964L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 0);
		return (E_DB_ERROR);	/* non-zero return means error */
	    }
	    else
	    {
		/* set trace output filename */
		if (TRset_file(TR_F_SAFEOPEN, $3, STlength($3), &cl_error))
		{
		    (VOID) psf_error(5988L, 0L, PSF_USERERR, &err_code,
		    	&psq_cb->psq_error, 1, 
			STlength ($3), $3);
		}
	    }
	}
	else if (!STcasecmp($2, "input"))
	{
	    /* "set notrace input" must not have a second parm */
	    if ($1 == PSL_OFFSET)
	    {
		(VOID) psf_error(5964L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 0);
		return (E_DB_ERROR);	/* non-zero return means error */
	    }
	    else
	    {
		/* set trace input filename */
		if (TRset_file(TR_I_OPEN, $3, STlength($3), &cl_error))
		{
		    (VOID) psf_error(5988L, 0L, PSF_USERERR, &err_code,
		    	&psq_cb->psq_error, 1, 
			STlength ($3), $3);
		}
	    }
	}
	else if (!STcasecmp($2, "point"))
	{
	    i4                 facility;	/* facility code */
	    i4		       flagno;		/* flag number w/i facility */
	    i4	       status;
	    DB_DEBUG_CB	       *debug_cb;
	    DB_STATUS	       ret_val;

	    /* Allocate the debug control block */
	    ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream,
		&psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
		(PTR *) &debug_cb, &psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR) debug_cb,
		&psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    debug_cb->db_value_count = 0;
	    if ($1 == PSL_ONSET)
		debug_cb->db_trswitch = DB_TR_ON;
	    else
		debug_cb->db_trswitch = DB_TR_OFF;

	    /*
	    ** Decode the facility code;  getfacil() returns an error code
	    ** for psf_error if the facility code doesn't make sense.
	    ** FIXME - facility code is not set */
	    if ((status = getfacil($3, &facility, &flagno)) != E_PS0000_OK)
	    {
		(VOID) psf_error(status, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, (i4) STtrmwhite($3), $3);
		return (E_DB_ERROR);	/* non-zero return means error */
	    }
	    else
	    {
		debug_cb->db_trace_point = flagno;
		psq_cb->psq_mode = facility;

		if (facility == PSQ_QEFTRACE && flagno == QEF_T_NORULES &&
		    MEcmp((PTR)&cb->pss_user, (PTR)&cb->pss_dba,
			     sizeof(DB_OWN_NAME)) != 0
		   )
		{
		    _VOID_ psf_error(E_US18AA_6314_SET_NORULES, 0L, PSF_USERERR,
				     &err_code, &psq_cb->psq_error, 0);
		    return (E_DB_ERROR);
		}
	    }
	}
	else
	{
	    (VOID) psf_error(5962L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STtrmwhite($2), $2);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    }
	  |
		    settracestmnt strsetparam strsetparam intconst_p
    {
	i4                err_code;

	/*
	** This form of the "set [no]trace command makes sense only with
	** "set [no]trace point".
	*/
	if (!STcasecmp($2, "terminal") ||
	    !STcasecmp($2, "output")   ||
	    !STcasecmp($2, "input"))
	{
	    (VOID) psf_error(5968L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	else if (!STcasecmp($2, "point"))
	{
	    i4		       facility;	/* facility code */
	    i4		       flagno;		/* flag number w/i facility */
	    i4	       status;
	    DB_STATUS	       ret_val;
	    DB_DEBUG_CB	       *debug_cb;

	    /* Allocate the debug control block */
	    ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream,
		&psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
		(PTR *) &debug_cb, &psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR) debug_cb,
		&psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    debug_cb->db_value_count = 1;
	    debug_cb->db_vals[0] = $4;
	    if ($1 == PSL_ONSET)
		debug_cb->db_trswitch = DB_TR_ON;
	    else
		debug_cb->db_trswitch = DB_TR_OFF;

	    /*
	    ** Decode the facility code.  getfacil() returns an error code
	    ** for psf_error if the facility code doesn't make sense.
	    */
	    if ((status = getfacil($3, &facility, &flagno)) != E_PS0000_OK)
	    {
		(VOID) psf_error(status, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, (i4) STtrmwhite($3), $3);
		return (E_DB_ERROR);
	    }
	    else
	    {
		psq_cb->psq_mode = facility;
		debug_cb->db_trace_point = flagno;
	    }
	}
	else
	{
	    (VOID) psf_error(5962L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STtrmwhite($2), $2);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    }
	  |
		    settracestmnt strsetparam strsetparam intconst_p intconst_p
    {
	i4                err_code;

	/*
	** This form of the "set [no]trace" command makes sense only with
	** "set [no]trace point".
	*/
	if (!STcasecmp($2, "terminal") ||
	    !STcasecmp($2, "output")   ||
	    !STcasecmp($2, "input"))
	{
	    (VOID) psf_error(5968L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	else if (!STcasecmp($2, "point"))
	{
	    i4		       facility;	/* facility code */
	    i4		       flagno;		/* flag number w/i facility */
	    i4	       status;
	    DB_STATUS	       ret_val;
	    DB_DEBUG_CB	       *debug_cb;

	    /* Allocate the debug control block */
	    ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream,
		&psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
		(PTR *) &debug_cb, &psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR) debug_cb,
		&psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    debug_cb->db_value_count = 2;
	    debug_cb->db_vals[0] = $4;
	    debug_cb->db_vals[1] = $5;
	    if ($1 == PSL_ONSET)
		debug_cb->db_trswitch = DB_TR_ON;
	    else
		debug_cb->db_trswitch = DB_TR_OFF;

	    /*
	    ** Decode the facility code.  getfacil() returns an error code
	    ** for psf_error if the facility code doesn't make sense.
	    */
	    if ((status = getfacil($3, &facility, &flagno)) != E_PS0000_OK)
	    {
		(VOID) psf_error(status, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, (i4) STtrmwhite($3), $3);
		return (E_DB_ERROR);
	    }
	    else
	    {
		psq_cb->psq_mode = facility;
		debug_cb->db_trace_point = flagno;
	    }
	}
	else
	{
	    (VOID) psf_error(5962L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STtrmwhite($2), $2);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    }
;
	
settracestmnt:	    SETTRACE
    {
	psq_cb->psq_mode = PSQ_STRACE;

	/*
	** "set trace" is allowed in distributed, even though the current
	** spec doesn't list it.
	*/
	$$ = $1;
    }
;

setresstruct:	    SETRESSTRUCT strsetparam
    {
	i4            err_code;
	DB_STATUS	   status;
	OPF_CB		   *opf_cb;
	char		   *ch = $2;
	bool		   not_distr = ((cb->pss_distrib & DB_3_DDB_SESS) == 0);
	i4		   *val, dummy;

	psq_cb->psq_mode = PSQ_SRINTO;

	if (not_distr)
	{
	    /* Allocate OPF control block for set result_structure command */
	    status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	    status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
		&psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	    status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
		&psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);

	    /* Fill in OPF control block */
	    opf_cb->opf_length = sizeof(opf_cb);
	    opf_cb->opf_type = OPFCB_CB;
	    opf_cb->opf_owner = (PTR)DB_PSF_ID;
	    opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	    opf_cb->opf_level = OPF_SESSION;
	    opf_cb->opf_alter = OPF_RET_INTO;
	    opf_cb->opf_compressed = FALSE;
	    val = &opf_cb->opf_value;
	}
	else /* distributed */
	{
	    val = &dummy;
	}

	if (!CMcmpnocase(ch, "c"))
	{
	    ch = CMnext(ch);
	    if (not_distr)
	        opf_cb->opf_compressed = TRUE;
	}

	/* Decode storage structure.  Error if unknown. */
	*val = uld_struct_xlate(ch);
	if (*val == 0)
	{
	    (VOID) psf_error(5916L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STtrmwhite($2), $2);
	    return (E_DB_ERROR);
	}

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    /* cheapsort is the longest option */
	    char	str[sizeof("set result_structure 'cheapsort' ")];
	    DB_STATUS	status;

	    status = psl_send_setqry(cb,
			STpolycat(3, "set result_structure '", $2, "' ", str),
			psq_cb);
	    
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
    }
;

setwork:    sw_stmnt sw_locations sw_actionword LPAREN sw_loclist RPAREN
;

sw_stmnt:	    SETWORK
    {
	DB_STATUS		status;
	i4			err_code;
	DMC_CB			*dmc_cb;

	/* do this right away so that a syntax error will be generated if
	** anything goes wrong later on
	*/
	psq_cb->psq_mode = PSQ_SWORKLOC;

	/* "set work locations..." is not allowed in distributed */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(2767L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Create control block for DMC_ALTER call for set work locations */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMC_CB), (PTR *) &dmc_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	status = psf_mroot(cb, &cb->pss_ostream, (PTR) dmc_cb, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	cb->pss_object	       = (PTR) dmc_cb;
	dmc_cb->type	       = DMC_CONTROL_CB;
	dmc_cb->length	       = sizeof (DMC_CB);
	dmc_cb->dmc_op_type    = DMC_SESSION_OP;
	dmc_cb->dmc_session_id = (PTR)cb->pss_sessid;
	dmc_cb->dmc_flags_mask = DMC_LOC_MODE;
	dmc_cb->dmc_db_id      = cb->pss_dbid;
	dmc_cb->dmc_names_loc  = NULL;
    }
;

sw_locations:	    NAME
    {
	i4			err_code;

	/* "locations" is the only word acceptable here */
	if (STcasecmp($1, "locations"))
	{
	    (VOID) psf_error(2551L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof (cb->pss_lineno),
		&cb->pss_lineno, STtrmwhite($1), $1);
	    return (E_DB_ERROR);
	}
    }
;

sw_actionword:	    ADD
    {
	((DMC_CB *) cb->pss_object)->dmc_s_type = DMC_S_ADD_LOCS;
    }
	|	    DROP
    {    
	((DMC_CB *) cb->pss_object)->dmc_s_type = DMC_S_DROP_LOCS;
    }
	|	    NAME
    {
	i4		err_code;
	
	/* "use" is the only other valid word here */
	if (STcasecmp($1, "use"))
	{
	    (VOID) psf_error(2551L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof (cb->pss_lineno),
		&cb->pss_lineno, STtrmwhite($1), $1);
	    return (E_DB_ERROR);
	}

	((DMC_CB*) cb->pss_object)->dmc_s_type = DMC_S_TRADE_LOCS;
    }
;	
	
sw_loclist:	    sw_locname
			|
		    sw_locname COMMA sw_loclist
;

sw_locname:	    NAME
    {
	DB_STATUS		status;
	DMC_CB			*dmc_cb;
	DMC_LLIST_ITEM		*tmp;

	dmc_cb	= (DMC_CB*) cb->pss_object;
	tmp = dmc_cb->dmc_names_loc;

	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMC_LLIST_ITEM),
	     (PTR *) &dmc_cb->dmc_names_loc, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	MEmove(STlength($1), (PTR)$1, ' ', sizeof(DB_LOC_NAME),
		(PTR)dmc_cb->dmc_names_loc->dmc_lname.db_loc_name);
	/* location names must be in lowercase */
	if (*cb->pss_dbxlate & CUI_ID_REG_U)
	    CVlower(dmc_cb->dmc_names_loc->dmc_lname.db_loc_name);
	dmc_cb->dmc_names_loc->dmc_llink = tmp;
    }
;

setrole:	SETROLE 
    { 
	DB_STATUS status;
	psq_cb->psq_ret_flag=0;
        psq_cb->psq_mode = PSQ_SETROLE;
	if ((status = psy_qminit(cb, psq_cb, &cb->pss_ostream)) != E_DB_OK)
	    return(status);
    }
    generic_ident setrole_passwd
    {
        DB_STATUS               status;
	i4                 err_code;

	/*
	** SET ROLE not available in distributed yet
	*/
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("SET ROLE")-1,
		"SET ROLE");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	/*
	** Check for magic NONE, need to check if delimeted or not
	*/
	if(!STcasecmp($3,"none"))
	{
		if($Yid_type!=PSS_ID_DELIM)
		{
			psq_cb->psq_ret_flag|=PSQ_SET_NOROLE;
		}
	}
	/*
	** Save the role name
	*/
	STmove($3, ' ', sizeof(psq_cb->psq_rolename), 
			(char*)&psq_cb->psq_rolename.db_own_name);
	
      }

setrole_passwd: /* Empty */
	  {
		/* Fill password to empty */
		MEfill(sizeof(psq_cb->psq_password),' ',
			(PTR)&psq_cb->psq_password);
	  }
	| WITH nonkeyword EQUAL name_or_sconst
	  {
		i4                 err_code;
		/*
		** Should be WITH PASSWORD = 'pwd'
		*/
		if(STcasecmp($2,"password")==0)
		{
			/* Blank pad full DB_PASSWORD */
			MEmove(STlength($4), $4, ' ', 
				sizeof(psq_cb->psq_password),
				(char*)&psq_cb->psq_password);
			psq_cb->psq_ret_flag|=PSQ_SET_ROLE_PASSWORD;
		}
		else
		{
		    (void) psf_error(E_PS0F86_SET_ROLE_WITH, 0L, 
			PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1, 
			(i4) STlength($2), $2);
		    return (E_DB_ERROR);    /* non-zero return means error */
		}
	  }
;

setunicodesub:      SETUNICODESUB 
    {
     i4                 err_code;

        /* "set usub " is not allowed in distributed yet */
        if (cb->pss_distrib & DB_3_DDB_SESS)
        {
            (VOID) psf_error(5951L, 0L, PSF_USERERR,
                &err_code, &psq_cb->psq_error, 0);
            return (E_DB_ERROR);
        }

        psq_cb->psq_mode = PSQ_SETUNICODESUB;

        if ($1 == PSL_GOVAL)    /* psq_usub_stat = FALSE */
          psq_cb->psq_usub_stat = AD_UNISUB_ON;
        else                     /* psq_usub_stat = TRUE */
          psq_cb->psq_usub_stat = AD_UNISUB_OFF;

        *psq_cb->psq_usub_char = '\0';

        if (cb->pss_distrib & DB_3_DDB_SESS)
        {
            DB_STATUS   status;
            status = psl_send_setqry(cb, "set usub", psq_cb);
            if (DB_FAILURE_MACRO(status))
                return (status);
        }
    } | SETUNICODESUB strconst_e
    {
        i4                 err_code;
        char               inchar[4] = {'\0'};
        i4                 inlength = 0;

        /* "set usub " is not allowed in distributed yet */
        if (cb->pss_distrib & DB_3_DDB_SESS)
        {
            (VOID) psf_error(5951L, 0L, PSF_USERERR,
                &err_code, &psq_cb->psq_error, 0);
            return (E_DB_ERROR);
        }

        psq_cb->psq_mode = PSQ_SETUNICODESUB;

        if ($1 == PSL_GOVAL)    /* psq_usub_stat =TRUE */
          psq_cb->psq_usub_stat = AD_UNISUB_ON;
        else                     /* psq_usub_stat = FALSE */
          psq_cb->psq_usub_stat = AD_UNISUB_OFF;

       inlength = CMbytecnt($2);
       STmove($2, '\0', inlength, (char*)&psq_cb->psq_usub_char);
 
       if (cb->pss_distrib & DB_3_DDB_SESS)
       {
            char  str[sizeof("set unicode_substitution '' ") + 2 + 4];
            DB_STATUS   status;

            status = psl_send_setqry(cb,
                     STpolycat(3, "set unicode_substitution '", $2, "' ", str),
                     psq_cb);

            if (DB_FAILURE_MACRO(status))
                return (status);
       }
    }
;

setupdrowcnt:       SETUPDROWCNT strsetparam 
    {
        DB_STATUS               status;
        QEF_RCB                 *qef_rcb;
	i4                 err_code;
	bool                    not_distr=(cb->pss_distrib & DB_3_DDB_SESS) 
					== 0;
	i4			*val, dummy;

        psq_cb->psq_mode = PSQ_UPD_ROWCNT;

	if (not_distr)
	{
           /* Allocate QEF control bock for update_rowcount */
           status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
           if (status != E_DB_OK)
              return (status);
           status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB),
			&cb->pss_object, &psq_cb->psq_error);
           if (status != E_DB_OK)
              return (status);
           status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
                        &psq_cb->psq_error);
           if (status != E_DB_OK)
              return (status);

           /* Fill in the QEF control block */
           qef_rcb = (QEF_RCB *) cb->pss_object;
           qef_rcb->qef_length = sizeof(QEF_RCB);
           qef_rcb->qef_type = QEFRCB_CB;
           qef_rcb->qef_owner = (PTR)DB_PSF_ID;
           qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	   qef_rcb->qef_sess_id = cb->pss_sessid;
           val = &qef_rcb->qef_upd_rowcnt;
      }
      else /* distributed */
      {
           val = &dummy;
      }

      if (STcompare($2, "changed") == 0)	
      {
	 *val = QEF_ROWCHGD;
      }

      else if (STcompare($2, "qualified") == 0)
      {
          *val = QEF_ROWQLFD;
      }

      else  /* syntax error */
      {
           /* set update_rowcount syntax error */
            (void) psf_error(E_PS0F85_SET_UPDATE_ROWCOUNT_STMT, 0L, 
		PSF_USERERR, &err_code,
                &psq_cb->psq_error, 1, (i4) STlength($2), $2);
            return (E_DB_ERROR);    /* non-zero return means error */
      }

      if (cb->pss_distrib & DB_3_DDB_SESS)        
      {
         DB_STATUS       status;

         /* qualified is the longest option */
	 char            buf[sizeof("set update_rowcount qualified ")];

         status = psl_send_setqry(cb,
                        STpolycat(3, "set update_rowcount ", $2, " ", buf),
                        psq_cb);

         if (DB_FAILURE_MACRO(status))
              return(status);
       }
      }
;

intsetparam:	    intconst_p
    {
	$$ = $1;
    }
	  |	    SCONST
    {
	i4                     num;
	i4		       err_code;

	/*
	** If a string used in place of an integer can't be converted to an
	** integer, give an error.
	*/
	if (CVal(sconvert($1), &num) != OK)
        {
	    (VOID) psf_error(5969L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, STtrmwhite((char *) $1), (char *) $1);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	$$ = num;
    }
;

strsetparam:	    strconst
    {
	$$ = $1;
    }
	  |	    nonkeyword
    {
	$$ = $1;
    }
;

intconst_e:         intconst_p
    {
	$$ = $1;
    }
	|	    error
    {
	(VOID) psl_sx_error(2722L, cb, psq_cb);
	YYABORT;
    }
;

/* FIXME need to examine uses, some should be extended do i8, some not. */
intconst_p:          int2_int4_p
    {
	$$ = $1;
    }
	  |	    QDATA
    {
	i4		    value;
	ADF_CB		    adf_cb;
	ADF_CB		    *adf_scb = (ADF_CB*) cb->pss_adfcb;
	DB_DATA_VALUE	    tdv;
	ADI_DT_NAME	    dt_fname;
	ADI_DT_NAME	    dt_tname;
	i4		    err_code;
	
	/* Copy the session ADF block into local one */
	STRUCT_ASSIGN_MACRO(*adf_scb, adf_cb);

	adf_cb.adf_errcb.ad_ebuflen = 0;
	adf_cb.adf_errcb.ad_errmsgp = 0;
	tdv.db_prec		    = 0;
	tdv.db_length		    = 4;
	tdv.db_datatype		    = DB_INT_TYPE;
	tdv.db_data		    = (PTR) &value;
	    
	if (adc_cvinto(&adf_cb, $1, &tdv) != E_DB_OK)
	{
	    (VOID) adi_tyname(&adf_cb, $1->db_datatype, &dt_fname);
	    (VOID) adi_tyname(&adf_cb, (DB_DT_ID) DB_INT_TYPE, &dt_tname);
	    (VOID) psf_error(2911L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 3,
		sizeof (cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(sizeof (dt_fname), (char *) &dt_fname), &dt_fname, 
		psf_trmwhite(sizeof (dt_tname), (char *) &dt_tname), &dt_tname);
	    return (E_DB_ERROR);
	}

	/* The values is expected to be 0 or positive. */
	if (value < 0)
	{
	    (VOID) adi_tyname(&adf_cb, $1->db_datatype, &dt_fname);
	    (VOID) psf_error(2929L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		psf_trmwhite(sizeof (dt_fname), (char *) &dt_fname), &dt_fname);
	    return (E_DB_ERROR);
	}

	$$ = value;
    }
;

int2_int4_p:        I4CONST
    {
	$$ = *$1;
    }
          |	    I2CONST
    {
	$$ = *$1;
    }
;

int2_int4:          UAOP int2_int4_p
    {
	if ($1 == ADI_SUB_OP)
	    $$ = -$2;
	else
	    $$ = $2;
    }
	    |	    int2_int4_p
    {
	$$ = $1;
    }
;

strconst:	    SCONST
    {
	$$ = sconvert($1);
    }
	  |	    QDATA
    {
	DB_TEXT_STRING	    *value;
	DB_STATUS	    status;
	DB_DT_ID	    totype;

	/*
	** before we call qdata_cvt() to convert input value into longtext, make
	** sure that the input value is of "character type", i.e. c, char, text,
	** varchar, or longtext
	*/

	status = psl_must_be_string(cb, $1, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/*
	** if the input datatype was nullable, so must be the output datatype
	*/

	totype = ($1->db_datatype < 0) ? -DB_LTXT_TYPE : DB_LTXT_TYPE;
							   
	if (qdata_cvt(cb, psq_cb, $1, totype, (PTR *) &value) != E_DB_OK)
	    return (E_DB_ERROR);

	$$ = sconvert(value);
    }
;

strconst_e:	    SCONST
    {
	$$ = sconvert($1);
    }
	  |	    QDATA
    {
	DB_TEXT_STRING	    *value;
	DB_STATUS	    status;
	DB_DT_ID	    totype;

	/*
	** before we call qdata_cvt() to convert input value into longtext, make
	** sure that the input value is of "character type", i.e. c, char, text,
	** varchar, or longtext
	*/

	status = psl_must_be_string(cb, $1, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/*
	** if the input datatype was nullable, so must be the output datatype
	*/

	totype = ($1->db_datatype < 0) ? -DB_LTXT_TYPE : DB_LTXT_TYPE;

	if (qdata_cvt(cb, psq_cb, $1, totype, (PTR *) &value) != E_DB_OK)
	    return (E_DB_ERROR);

	$$ = sconvert(value);
    }
	|	    error	    
    {
	(VOID) psl_sx_error(2723L, cb, psq_cb);
	YYABORT;
    }
;

bit_or_hex_const:   HEXCONST
    {
	$$ = $1;
    }
	|	    BITCONST
    {
	$$ = $1;
    }
;

update:	    updatekwd from_item from_u
    {
	i4	err_code;

	$Yaggr_allowed &= ~(PSS_AGG_ALLOWED | PSS_STMT_AGG_ALLOWED);

	/* Updates on secondary index tables that are btrees
	** are not allowed.
	*/
	if ($2->pss_tabdesc->tbl_status_mask & DMT_IDX
	    &&
	    $2->pss_tabdesc->tbl_storage_type == DMT_BTREE_TYPE
	   )
	{
	    (VOID) psf_error(2124L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(sizeof(DB_TAB_NAME), (char *) &$2->pss_tabname),
		&$2->pss_tabname);
	    return(E_DB_ERROR);	    
	}

	cb->pss_resrng = $2;
	$Yin_update_set_clause = TRUE;
    }
	    SET updatelist
    {
	/*
	** aggregates are not allowed in the updatelist, but are OK in the
	** where_clause
	*/
	$Yaggr_allowed |= (PSS_AGG_ALLOWED | PSS_STMT_AGG_ALLOWED);
	$Yin_update_set_clause = FALSE;
    }
	    where_cur
    {
	PST_QNODE	    *rsdmnode;
	PST_QNODE	    *rootnode;
	PST_RT_NODE	    root;
	PST_QTREE	    *tree;
	DB_STATUS	    status;
	i4		    err_code;
	i4		    qrymod_resp_mask;
	PST_QNODE	    *qual;
	PST_PROCEDURE	    *pnode;
	i4		    tbl_stat_mask;
	i4		    tbl_2_stat_mask;
	i4		    hdr_mask;
	PSC_CURBLK	    *cursor = (PSC_CURBLK *) NULL;
	extern PSF_SERVBLK  *Psf_srvblk;
	i4		    mask;

	/*
	** Mode could have been altered by a subselect in the WHERE clause.
	** If so, we need to restore it. Note that "where current of" will
	** never alter the mode.
	*/
	if (psq_cb->psq_mode == PSQ_RETRIEVE)
	{
	    psq_cb->psq_mode = PSQ_REPLACE;
	}

	/*
	** For searched update a tid node must be added here.
	** For positioned update we must NOT add one.
	*/

	if (psq_cb->psq_mode == PSQ_REPLACE)
	{
	    if (~cb->pss_distrib & DB_3_DDB_SESS)
	    {
		PST_QNODE       *tidnode;
		PST_RSDM_NODE   resdom;
		PST_VAR_NODE    tidvar;

		hdr_mask = 0;

		/* Set up a var. node representing the tid.
		** pst_adresdom should not be used here because it relies on
		** cb->pss_rsdmno, which may be incorrect now due to the fact
		** that subselects in the where clause reset it every time a new
		** target list is started.
		*/

		tidvar.pst_vno = $2->pss_rgno;
		tidvar.pst_atno.db_att_id = 0;	    /* tid is always column 0 */
		STmove(((*cb->pss_dbxlate & CUI_ID_REG_U) ? "TID" : "tid"),
			' ', DB_MAXNAME, tidvar.pst_atname.db_att_name);

		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		    (PST_QNODE *) NULL, PST_VAR, (char *) &tidvar, sizeof(tidvar),
		    DB_TID8_TYPE, (i2) 0, (i4) DB_TID8_LENGTH, (DB_ANYTYPE *) NULL,
		    &tidnode, &psq_cb->psq_error, (i4) 0);
		if (status != E_DB_OK)
		{
		    return (status);	    /* non-zero return means error */
		}

		/* Set up a resdom result domain representing a tid. */
		resdom.pst_rsno = 0;
		cb->pss_rsdmno++; /* Count resdoms */
		resdom.pst_ntargno = (i4) 0;
		resdom.pst_ttargtype = (i4) PST_ATTNO;
		resdom.pst_rsupdt = FALSE;
		resdom.pst_dmuflags = 0;
		resdom.pst_rsflags = 0; /* no PST_RS_PRINT*/

		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL, tidnode,
		    PST_RESDOM, (PTR) &resdom, sizeof(resdom), DB_TID8_TYPE, (i2) 0,
		    (i4) DB_TID8_LENGTH, (DB_ANYTYPE *) NULL, &rsdmnode, 
		    &psq_cb->psq_error, (i4) 0);
		if (status != E_DB_OK)
		{
		    return (status);	/* non-zero return means error */
		}

		/* prepend the tid node to the target list */
		(VOID) pst_tlprpnd(rsdmnode, $6);

		/* remember qualification */
	    }
	    else
	    {
		hdr_mask = PST_1INSERT_TID;
	    }

	    /* remember qualification */
	    qual = $8;
	}
	else	/* PSQ_REPCURS */
	{
	    hdr_mask = 0;

	    cursor = (PSC_CURBLK *) $8;

	    /* Check if cursor updateable */
	    if (cursor->psc_forupd == FALSE)
	    {
		(VOID) psf_error(2217L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1,
		    psf_trmwhite(DB_MAXNAME, cursor->psc_blkid.db_cur_name),
		    cursor->psc_blkid.db_cur_name);
		return (E_DB_ERROR);
	    }

	    /*
	    ** For update cursor we must compare names of objects and of object
	    ** owners.
	    */
	    if (MEcmp((PTR) &(cursor->psc_tabnm),
		      (PTR) &($2->pss_tabname), sizeof(DB_TAB_NAME)) ||
		MEcmp((PTR) &(cursor->psc_ownnm),
		      (PTR) &($2->pss_ownname), sizeof(DB_OWN_NAME)))
	    {
		(VOID) psf_error(2227L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 4,
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &(cursor->psc_tabnm)),
		    &(cursor->psc_tabnm),
		    psf_trmwhite(sizeof(DB_OWN_NAME), 
			(char *) &(cursor->psc_ownnm)),
		    &(cursor->psc_ownnm),
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &($2->pss_tabname)),
		    &($2->pss_tabname),
		    psf_trmwhite(sizeof(DB_OWN_NAME), 
			(char *) &($2->pss_ownname)),
		    &($2->pss_ownname));
		return(E_DB_ERROR);
	    }

	    /*
	    ** When arguments of update are processed, we are not aware
	    ** of the fact that this is positioned update, which requires
	    ** additional processing. For this reason, the processing has
	    ** to be done here. This is not as clean as I would like it to
	    ** be, but it looks like this is the easiest solution.
	    ** We need to walk down the resdom branch and make sure that
	    ** all of them have been declared for update. We also need to
	    ** make sure that all VAR nodes, if any, are replaced by CURVAL
	    ** nodes (that can be done in place).
	    */
	    for (rsdmnode = $6;
		 rsdmnode != (PST_QNODE *) NULL &&
		    rsdmnode->pst_sym.pst_type == PST_RESDOM;
		 rsdmnode = rsdmnode->pst_left)
	    {
		PSC_RESCOL	*rescol;

		rescol = psq_ccol(cursor,
		    (DB_ATT_NAME *) rsdmnode->pst_sym.pst_value.pst_s_rsdm.
					pst_rsname);

		/*
		** A column must have been specified in the FOR UPDATE
		** clause, therefore we should complain about it being
		** not updateable. 
		*/
		if (rescol == (PSC_RESCOL *) NULL)
		{
		    (VOID) psf_error(2207L, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 3,
			sizeof(cb->pss_lineno), &cb->pss_lineno,
			psf_trmwhite(DB_MAXNAME, cursor->psc_blkid.db_cur_name),
			cursor->psc_blkid.db_cur_name,
			psf_trmwhite(DB_MAXNAME,
			    rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_rsname),
			rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_rsname);
		    return (E_DB_ERROR);
		}

		/*
		** at this point we know that the column has been implicitly or
		** explicitly declared in the FOR UPDATE <column name list>
		*/
		/*
		** if a user has NOT specified FOR UPDATE/READONLY, we would
		** build a list of attributes consisting of all attributes of
		** the table or view over which the cursor was being defined.
		** If a cursor was defined on a view, some of the view's
		** attributes may be non-updatable because they are based on an
		** expression.  For every such attribute, a bit will be set in
		** psc_expmap.
		*/
		if (BTtest((i4) rescol->psc_attid.db_att_id,
			(char *) &cursor->psc_expmap))
		{
		    /*
		    ** this attribute may not be updated because it is based on
		    ** an expression
		    */
		    (VOID) psf_error(E_PS0402_NONUPDATABLE_COLUMN, 0L,
			PSF_USERERR, &err_code, &psq_cb->psq_error, 3,
			psf_trmwhite((u_i4) sizeof(rescol->psc_attname),
			    (char *) &rescol->psc_attname),
			(PTR) &rescol->psc_attname,
			psf_trmwhite((u_i4) sizeof(cursor->psc_tabnm),
			    cursor->psc_tabnm.db_tab_name),
			(PTR) cursor->psc_tabnm.db_tab_name,
			psf_trmwhite((u_i4) DB_MAXNAME,
			    cursor->psc_blkid.db_cur_name),
			(PTR) cursor->psc_blkid.db_cur_name);
		    return(E_DB_ERROR);
		}

		/*
		** at this point we know that the column has been implicitly or
		** explicitly declared in the FOR UPDATE <column name list> and
		** it is based on a column of a base table; the last test is to
		** determine whether a user possesses sufficient privilege to
		** update this column:
		*/
	
		if (!BTtest((i4) rescol->psc_attid.db_att_id,
			(char *) &cursor->psc_updmap))
		{
		    /*
		    ** user lacks a privilege required to update this attribute
		    */
		    (VOID) psf_error(E_PS0403_CURS_UPDT_NO_PRIV, 0L,
			PSF_USERERR, &err_code, &psq_cb->psq_error, 3,
			psf_trmwhite((u_i4) sizeof(rescol->psc_attname),
			    (char *) &rescol->psc_attname),
			(PTR) &rescol->psc_attname,
			psf_trmwhite((u_i4) sizeof(cursor->psc_tabnm),
			    cursor->psc_tabnm.db_tab_name),
			(PTR) cursor->psc_tabnm.db_tab_name,
			psf_trmwhite((u_i4) DB_MAXNAME,
			    cursor->psc_blkid.db_cur_name),
			(PTR) cursor->psc_blkid.db_cur_name);
		    return(E_DB_ERROR);
		}
	    }

	    /* create QLEND node as qualification */
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		    (PST_QNODE *) NULL, PST_QLEND, (PTR) NULL, 0, DB_NODT,
		    (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, &qual,
		    &psq_cb->psq_error, (i4) 0);
	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);	/* non-zero return means error */
	    }
	}

	/* Make the root node */
	root.pst_rtuser = TRUE;
	root.pst_union.pst_next  = 0;
	root.pst_dups   = PST_ALLDUPS;
	MEcopy((char *)&$Yflists[cb->pss_qualdepth], sizeof(PST_J_MASK),
				(char *)&$Yfrom_list);
	root.pst_tvrc   = BTcount((char *) &$Yfrom_list, BITS_IN($Yfrom_list));
	MEcopy((char *)&$Yfrom_list, sizeof(PST_J_MASK),
					(char *)&root.pst_tvrm);

	/*
	** If the FROM list contained any joins, merge the join_search quals
	** with the qualification of the subselect
	*/

	if ($Yj_qual->pss_qual != (PST_QNODE *) NULL)
	{
	    if (!qual || qual->pst_sym.pst_type == PST_QLEND)
	    {
		qual = $Yj_qual->pss_qual;
	    }
	    else
	    {
		status = pst_node(cb, &cb->pss_ostream, qual,
		    $Yj_qual->pss_qual, PST_AND, (PTR) NULL,
		    sizeof(PST_OP_NODE), DB_NODT, (i2) 0, (i4) 0,
		    (DB_ANYTYPE *) NULL, &qual, &psq_cb->psq_error, (i4) 0);
		if (status != E_DB_OK)
		    return (status);
	    }

	    /*
	    ** Note that we need not "discard" this PSS_J_QUAL node, since it
	    ** was allocated on stack and should be kept around.  We do have to
	    ** make sure that the qual pointer is set to NULL, though.  Not
	    ** doing so inside a dbproc could prove to be disasterous.
	    */
	    $Yj_qual->pss_qual = (PST_QNODE *) NULL;
	}

	status = pst_node(cb, &cb->pss_ostream, $6, qual, PST_ROOT,
	    (PTR) &root, sizeof(PST_RT_NODE), DB_INT_TYPE, (i2) 0, (i4) 4,
	    (DB_ANYTYPE *) NULL, &rootnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);	/* non-zero return means error */
	}

	/* Now check the target list to see if there are any
	** resdoms with pst_ttargtype of PST_USER, if so
	** convert them to PST_ATTNO.
	*/
	for (rsdmnode = rootnode->pst_left;
	 rsdmnode != (PST_QNODE *) NULL && 
	 rsdmnode->pst_sym.pst_type == PST_RESDOM;
	 rsdmnode = rsdmnode->pst_left)
	{
	    if (rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype
		== PST_USER)
	    {
		rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype
		    = PST_ATTNO;
	    }
	}

	/* For repeat queries we must determine if the query is shareable.
	** We already know that this is an SQL query, so the only criterion
	** to be checked out is whether all relations/views are DBA owned or
	** are catalogs.
	*/
	if (cb->pss_defqry == PSQ_DEFQRY)
	{
	    status = psl_shareable(psq_cb, cb,&$Yqp_shareable, &$Yshr_qryinfo);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }
	}

	/* Apply the qrymod algorithm (views, permits, integrities) */
	status = psy_qrymod(rootnode, cb, psq_cb, &$Yjoin_id,
	    &qrymod_resp_mask);
	if (status != E_DB_OK)
	    return (status);

	/*
	** if processing UPDATE WHERE CURRENT OF CURSOR, we delayed replacing
	** PST_VAR with PST_CURVAL until now to make life easier for psy_view()
	*/
	if (psq_cb->psq_mode == PSQ_REPCURS)
	{
	    for (rsdmnode = rootnode->pst_left;
		 rsdmnode != (PST_QNODE *) NULL &&
		    rsdmnode->pst_sym.pst_type == PST_RESDOM;
		 rsdmnode = rsdmnode->pst_left)
	    {
		status = psl_curval(cb, psq_cb, cursor, &rsdmnode->pst_right);
		if (DB_FAILURE_MACRO(status))
		{
		    return (status);
		}
	    }
	}

	tbl_stat_mask = cb->pss_resrng->pss_tabdesc->tbl_status_mask;
	tbl_2_stat_mask = cb->pss_resrng->pss_tabdesc->tbl_2_status_mask;

	/* Make sure base table is updateable;
	** In case of an index or a non-extended catalog
	** catalog update privilege must be on.
	** In case of security catalog make sure session has
	** security privilege active.
	** Bug 34079, since 6.0 you were never supposed to be 
        ** able to update a secondary index.  Fixed it so 
        ** the same error is returned whether you have update 
        ** syscat or not (jennifer)
	**
	** if PSS_REPAIR_SYSCAT and PSS_CATUPD are set in cb->pss_ses_flag,
	** allow UPDATE on indexes which are non-extended catalogs
	*/
        if (tbl_2_stat_mask & DMT_READONLY)
        {
            (VOID) psf_error(E_US14E6_5350_READONLY_TBL_ERR, 0L, PSF_USERERR,
                         &err_code, &psq_cb->psq_error, 0);
            return(E_DB_ERROR);
        }
	else if (tbl_stat_mask & DMT_IDX)
	{
	    if (!(   tbl_stat_mask & DMT_CATALOG
		  && ~tbl_stat_mask & DMT_EXTENDED_CAT
		  && cb->pss_ses_flag & PSS_CATUPD
		  && cb->pss_ses_flag & PSS_REPAIR_SYSCAT
		 )
	       )
	    {
		_VOID_ psf_error(2106L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1,
		    psf_trmwhite(sizeof(DB_TAB_NAME),
		        (char *) &cb->pss_resrng->pss_tabname),
		    &cb->pss_resrng->pss_tabname);
		return(E_DB_ERROR);
	    }
	}
	else if ( ( (tbl_stat_mask & DMT_CATALOG
		     	|| tbl_2_stat_mask & DMT_TEXTENSION)
		 && ~tbl_stat_mask & DMT_EXTENDED_CAT
		 && !(cb->pss_ses_flag & PSS_CATUPD))
		     ||
		     ((tbl_stat_mask & DMT_SECURE) &&
        	       !(cb->pss_ustat & DU_USECURITY)))
	{
		i4 local_status;
		DB_ERROR	    e_error;

		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    local_status = psy_secaudit(FALSE, cb,
			    (char *)&cb->pss_resrng->pss_tabname,
			    &cb->pss_resrng->pss_tabdesc->tbl_owner,
			    sizeof(DB_TAB_NAME), 
			    SXF_E_TABLE,
			    I_SX2020_PROT_REJECT, 
			    SXF_A_FAIL|SXF_A_UPDATE, 
			    &e_error);

		    if (local_status > status)
			status = local_status;
		}

		/* process security_alarms */
		local_status = psy_do_alarm_fail(cb, 
				cb->pss_resrng, PSQ_REPLACE, &e_error);
		if (local_status > status)
		    status = local_status;
	    _VOID_ psf_error(2107L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname);
	    return (E_DB_ERROR);
	}

	cb->pss_qualdepth--;

	mask=($Yisdbp) ? 0 : PST_0FULL_HEADER,

	/* Make the header */
	status = pst_header(cb, psq_cb, PST_UNSPECIFIED, (PST_QNODE *) NULL,
	    rootnode, &tree, &pnode, (mask | hdr_mask), &$Yxlated_qry);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/* set pst_numjoins.  $Yjoin_id contains the highest join id */
	tree->pst_numjoins = $Yjoin_id;

	/* Fix the root in QSF */
	if (pnode != (PST_PROCEDURE *) NULL)
	{
	    status = psf_mroot(cb, &cb->pss_ostream, (PTR) pnode, &psq_cb->psq_error);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }
	}
	$$ = tree;
    }
;

updatekwd:	    UPDATE
    {
	DB_STATUS              status;

	psq_cb->psq_mode = PSQ_REPLACE;

	/* Open memory stream for allocating query tree */
	if ($Yisdbp == FALSE)
	{
	    if ((status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
		&psq_cb->psq_error)) != E_DB_OK)
	    {
		return (status);    /* non-zero return means error */
	    }
	}
	else
	{
	    /*
	    ** To indicate that in 'i= :i' in a subselect the first
	    ** "i" must not be processed as a local var (bug 8269).
	    */
	    $Ydbpinfo->pss_flags |= PSS_1SUB_SEEN;
	}

	MEfill(sizeof(PST_J_MASK), 0, (char *)&$Yflists[++cb->pss_qualdepth]);

	/* Start off with no columns */
	cb->pss_rsdmno = 0;
    }
;

updatelist:		update_item
	|		updatelist COMMA update_item
    {
	/*
	** Attach bulk of target list to leftmost node of new element.
	*/
	$$ = pst_tlprpnd($1, $3);

    }
;

update_item:		col_spec EQUAL select_expr
    {
	DB_STATUS              status;
	PST_QNODE	       *resdomnode;
        DB_ATT_NAME	       colname;

	/* normalize the attribute name */
	STmove((char *)$1, ' ', (u_i4)sizeof(DB_ATT_NAME), (char *) &colname);

	/*
	** pst_adresdom will check if $1 is a column of updated relation.
	*/
	status = pst_adresdom((char *) &colname, (PST_QNODE *) NULL, $3,
	    cb, psq_cb, &resdomnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$$ = resdomnode;
    }
	    |		col_spec EQUAL DEFAULT
    {
	DB_STATUS              status;
	PST_QNODE	       *resdomnode, *constnode;
        DB_ATT_NAME	       colname;
	DMT_ATT_ENTRY	       *coldesc;
	i4		       err_code;
	DB_ERROR	       err_blk;

	/* normalize the attribute name */
	STmove((char *)$1, ' ', (u_i4)sizeof(DB_ATT_NAME), (char *) &colname);

	coldesc = pst_coldesc(cb->pss_resrng, &colname);
	if (coldesc == (DMT_ATT_ENTRY *) NULL)
	{
	    /* Couldn't find the column. */
	    psf_error(2100L, 0L, PSF_USERERR, &err_code, &psq_cb->psq_error, 4,
		(i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname,
		psf_trmwhite(sizeof(DB_OWN_NAME), 
		    (char *) &cb->pss_resrng->pss_ownname),
		&cb->pss_resrng->pss_ownname,
		psf_trmwhite(sizeof(DB_ATT_NAME), (char *)&colname), 
		&colname);
	    return (E_DB_ERROR);
	}

	if (coldesc->att_flags & DMT_F_NDEFAULT ||
	    (coldesc->att_type > 0 && 
		EQUAL_CANON_DEF_ID(coldesc->att_defaultID, 
						DB_DEF_NOT_SPECIFIED)))
	{
	    /* Mandatory column value not present */
	    (void) psf_error(2779L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, psf_trmwhite(sizeof(DB_ATT_NAME),
			(char *) &colname), &colname);
	    return(E_DB_ERROR);
	}
	status = psl_make_default_node(cb, &cb->pss_ostream, cb->pss_resrng, 
			coldesc->att_number, &constnode, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/*
	** pst_adresdom will check if $1 is a column of updated relation
	** (though it doesn't need to, because pst_coldesc() already did).
	*/
	status = pst_adresdom((char *) &colname, (PST_QNODE *) NULL,
	    constnode, cb, psq_cb, &resdomnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	$$ = resdomnode;
    }
	    |		col_spec EQUAL NULLWORD
    {
	DB_STATUS	status;
	PST_QNODE	*newnode;
	PST_QNODE	*resdomnode;
	PST_CNST_NODE	pst_cnst_node;
	DB_DT_ID	datatype;
	i2		dataprec;
	i4		datalen;
	i4		err_code;
        DB_ATT_NAME	colname;

	/* normalize the attribute name */
	STmove((char *)$1, ' ', (u_i4)sizeof(DB_ATT_NAME), (char *) &colname);

	/*
	** pst_adresdom will check if $1 is a column of updated relation.
	*/
	status = pst_adresdom((char *) &colname, (PST_QNODE *) NULL, 
	    (PST_QNODE *) NULL, cb, psq_cb, &resdomnode);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** Verify if column to be updated is nullable.
	*/
	datatype = resdomnode->pst_sym.pst_dataval.db_datatype;
	dataprec = resdomnode->pst_sym.pst_dataval.db_prec;
	datalen = resdomnode->pst_sym.pst_dataval.db_length;
	if (datatype > 0)
	{
	    /* nonnullable data type */
	    (VOID) psf_error(2780L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, STtrmwhite($1), $1);
	    return (E_DB_ERROR);
	}

	/*
	** Create a constant node for the NULL value.
	*/
	pst_cnst_node.pst_tparmtype = PST_USER;
	pst_cnst_node.pst_parm_no = 0;
	pst_cnst_node.pst_pmspec = PST_PMNOTUSED;
	pst_cnst_node.pst_cqlang = DB_SQL;
	pst_cnst_node.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &pst_cnst_node,
	    sizeof (PST_CNST_NODE), datatype, dataprec, datalen,
	    (DB_ANYTYPE *) "1", &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/*
	** Initialize the value associated with the const node to NULL.
	*/
	status = adc_getempty ((ADF_CB *)cb->pss_adfcb, 
			       &newnode->pst_sym.pst_dataval);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/*
	** Hook up the const node to resdom node.
	*/
	resdomnode->pst_right = newnode;

	$$ = resdomnode;
    }
;

where_cur:	    where
    {
	/*
	** for DELETE and UPDATE we need to notify SCF if no qualification was
	** provided; as of now where_cur is only used by DELETE and UPDATE, so
	** we don't need to check query mode.
	** We only need to notify SCF if the DELETE/UPDATE is part of a
	** PREPARE statement. Bug 106509.
	*/
	if ( (cb->pss_defqry == PSQ_PREPARE) &&
	     ($1->pst_sym.pst_type == PST_QLEND) )
	    psq_cb->psq_flag |= PSQ_ALLDELUPD;
	else
	    psq_cb->psq_flag &= ~PSQ_ALLDELUPD;

	$$ = $1;
    }
	    |	    WHERE CURRENT OF cursor_id
    {
	PSC_CURBLK             *cursor;
	DB_STATUS	       status;
	i4		       err_code;

	/* Look up the cursor */
	status = psq_crfind(cb, $4, &cursor, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return(status);

	/* Complain if not found */
	if (cursor == (PSC_CURBLK *) NULL || cursor->psc_open == FALSE)
	{
	    (VOID) psf_error(2205L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(DB_MAXNAME, $4->db_cur_name), $4->db_cur_name);
	    return (E_DB_ERROR);
	}

	if (psq_cb->psq_mode == PSQ_DELETE)
	{
	    psq_cb->psq_mode = PSQ_DELCURS;

	    /* check for delete permission */
	    if (cursor->psc_delall == FALSE)
	    {
		(VOID) psf_error(2211L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2,
		    sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME, $4->db_cur_name), $4->db_cur_name);
		return (E_DB_ERROR);
	    }
	}
	else if (psq_cb->psq_mode == PSQ_REPLACE)
	{
	    psq_cb->psq_mode = PSQ_REPCURS;
	}

	/* Hand found cursor id back to caller */
	STRUCT_ASSIGN_MACRO(cursor->psc_blkid, psq_cb->psq_cursid);

	/* type casting only for the compiler and lint */
	$$ = (PST_QNODE *) cursor;
    }
;

/* Assume Star inherits Dynamic SQL cursor names -- mention in the spec */
/* Allow for internal cursor id or user name */
cursor_id:	QUERYID
    {
	$$ = $1;
    }
	|	generic_ident
    {
	/*
	** A Dynamic SQL cursor name from the user.  The zero assignment
	** indicates to look this cursor up by name alone.
	*/
	psq_cb->psq_cursid.db_cursor_id[0] = 0;
	psq_cb->psq_cursid.db_cursor_id[1] = 0;
	STmove((char *)$1, ' ', DB_MAXNAME, psq_cb->psq_cursid.db_cur_name);
	$$ = &psq_cb->psq_cursid;
    }
;

comment:    comment_stmt comment_obj long_remark short_remark
    {
	i4		err_code;
	DB_STATUS	status;
	DB_IICOMMENT	*comment;
	PTR		p;

	/* At least one of long_remark, short_remark must be specified */
	if ($3 == (DB_TEXT_STRING *) NULL && $4 == (DB_TEXT_STRING *) NULL)
	{
	    (VOID) psf_error(E_PS0BA2_NO_REMARK_SPECIFIED, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** to get to this point we must have at least 1 remark specified,
	** and it has been determined that comment object exists
	*/

	/* Allocate DB_1_IICOMMENT structure */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_1_IICOMMENT),
			    &p, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	comment = &((DB_1_IICOMMENT *) p)->dbc_tuple;
	((DB_1_IICOMMENT *) p)->dbc_flag = 0;
	
	/* initialize II_DBCOMMENT tuple */
	STRUCT_ASSIGN_MACRO(cb->pss_resrng->pss_tabid, comment->dbc_tabid);
	comment->dbc_type = ((comment->dbc_attid = (i2) $2) == 0L)
							? DBC_T_TABLE
							: DBC_T_COLUMN;

	if ($3 == (DB_TEXT_STRING *) NULL)
	{
	    /* long remark was not specified */
	    comment->dbc_len_long = (u_i2) 0;
	}
	else
	{
	    MEcopy((PTR) $3->db_t_text,
	           (comment->dbc_len_long = $3->db_t_count),
		   (PTR) comment->dbc_long);
	    ((DB_1_IICOMMENT *) p)->dbc_flag |= DBC_LR_SPECIFIED;
	}

	if ($4 == (DB_TEXT_STRING *) NULL)
	{
	    /* short remark was not specified */
	    MEfill(DBC_L_SHORT, (u_char) ' ', (PTR) comment->dbc_short);
	}
	else
	{
	    MEmove($4->db_t_count, (PTR) $4->db_t_text, (char) ' ',
	           DBC_L_SHORT, (PTR) comment->dbc_short);
	    ((DB_1_IICOMMENT *) p)->dbc_flag |= DBC_SR_SPECIFIED;
	}

	comment->dbc_sequence = (i2) 0;

	((PSY_CB *) cb->pss_object)->psy_tupptr = p;
    }
;

comment_stmt:	COMMENT_ON
    {
	i4                err_code;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_COMMENT;

	/* "COMMENT" not allowed in distributed yet */
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (VOID) psf_error(6350L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) sizeof("COMMENT")-1, "COMMENT");
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate the PSY_CB for the COMMENT statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);
    }
;

comment_obj:	TABLE obj_spec
    {
	i4		err_code;
	DB_STATUS       status;
	i4		rngvar_info;
	PSS_RNGTAB	*resrange;

	if ($2->pss_objspec_flags & PSS_OBJSPEC_EXPL_SCHEMA)
	{
	    status = psl_orngent(&cb->pss_auxrng, -1, "", &$2->pss_owner,
		&$2->pss_obj_name, cb, TRUE, &resrange, psq_cb->psq_mode,
		&psq_cb->psq_error, &rngvar_info);
	}
	else
	{
	    status = psl_rngent(&cb->pss_auxrng, -1, "", &$2->pss_obj_name, cb,
		TRUE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
		&rngvar_info);
	    if (status == E_DB_INFO)
	    {
		status = E_DB_OK;
		if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		    $2->pss_orig_obj_name, &psq_cb->psq_error))
		{
		    return(E_DB_ERROR);
		}
	    }
	}

	if (DB_FAILURE_MACRO(status))
	    return (status);

	if (MEcmp((PTR) &resrange->pss_ownname, (PTR) &cb->pss_user,
		  sizeof(DB_OWN_NAME)))
	{
	    DB_ERROR	e_error;
	    /*
	    ** let user know if name supplied by the user was resolved to a
	    ** synonym
	    */
	    if (rngvar_info & PSS_BY_SYNONYM)
	    {
		psl_syn_info_msg(cb, resrange, $2, rngvar_info,
		    sizeof("COMMENT") - 1, "COMMENT", &psq_cb->psq_error);
	    }
	    /*
	    ** must audit failure to comment
	    */
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		status = psy_secaudit(FALSE, cb, resrange->pss_tabname.db_tab_name,
			&resrange->pss_ownname, sizeof(resrange->pss_tabname),
			SXF_E_TABLE, I_SX2039_TBL_COMMENT,
			SXF_A_FAIL | SXF_A_CONTROL, 
			&e_error);
	    }

	    /*
	    ** user definitely may not add/change a comment on someone else's
	    ** table
	    */
	    (VOID) psf_error(E_PS0424_ILLEGAL_TBL_REF, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 3,
		sizeof("COMMENT") - 1, "COMMENT",
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &resrange->pss_tabname),
		&resrange->pss_tabname,
		psf_trmwhite(sizeof(DB_OWN_NAME), 
		    (char *) &resrange->pss_ownname),
		&resrange->pss_ownname);

		return(E_DB_ERROR);
	}

	STRUCT_ASSIGN_MACRO(resrange->pss_tabname,
			    ((PSY_CB *) cb->pss_object)->psy_tabname[0]);
	cb->pss_resrng = resrange;

	$$ = 0L;
    }

	    |   COLUMN  comment_col

    {
	DMT_ATT_ENTRY   *attribute;
	PSY_CB		*psy_cb = (PSY_CB *) cb->pss_object;
	i4		err_code;

	/*
	** figure out if the column exists;
	** column name was stored in comment_col production
	*/
	attribute = pst_coldesc(cb->pss_resrng,
			&((PSY_COL *) psy_cb->psy_colq.q_next)->psy_colnm);

	/* Check for attribute not found */
	if (attribute == (DMT_ATT_ENTRY *) NULL)
	{
	    char	*colnm;

	    colnm = (char *) &((PSY_COL *) psy_cb->psy_colq.q_next)->psy_colnm;

	    (VOID) psf_error(E_PS0BA3_NONEXISTENT_COLUMN, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 2,
			psf_trmwhite(sizeof(DB_TAB_NAME), 
			    (char *) psy_cb->psy_tabname),
			psy_cb->psy_tabname,
			psf_trmwhite(sizeof(DB_ATT_NAME), colnm), colnm);

	    return(E_DB_ERROR);
	}
	else
	{
	    $$ = attribute->att_intlid;		
	}
    }
;

col_ref:		generic_ident
    {
	/* column */

	$Ycol_ref.pss_tab_name = (char *) NULL;
	$Ycol_ref.pss_col_name = $1;
	$Ycol_ref.pss_flags = 0;

	$$ = &$Ycol_ref;
    }
		|	generic_ident PERIOD generic_ident
    {
	/* table.column or corr_name.column */

	$Ycol_ref.pss_flags = PSS_TBL_OR_CORR_NAME_SPECIFIED;
	$Ycol_ref.pss_tab_name = $1;
	$Ycol_ref.pss_col_name = $3;

	$$ = &$Ycol_ref;
    }
	/*
	** various flavors of <schema>.<table>.<column>
	** We are forced to expand schema_spec in-line because doing otherwise
	** (i.e. using schema_spec here) results in two shift-reduce conflicts
	** as the grammar tries to figure out whether a given identifier is a
	** schema name or a table name
	*/
		|	generic_ident PERIOD generic_ident PERIOD generic_ident
    {
	/* <schema>.table.column */

	/* If this is a modify statement, it's possible that the alternate
	** keyword set is turned on, and SESSION won't be recognized as
	** a keyword -- recognize it by hand here.
	*/
	if (STcompare($1,"session") == 0)
	{
	    if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		$3, &psq_cb->psq_error))
	    {
		return(E_DB_ERROR);
	    }

	    STRUCT_ASSIGN_MACRO(cb->pss_sess_owner, $Ycol_ref.pss_schema_name);
	}
	else
	{
	    MEmove(STlength($1), (PTR) $1, ' ',
		    sizeof($Ycol_ref.pss_schema_name),
		    (PTR) &$Ycol_ref.pss_schema_name);
	}
	$Ycol_ref.pss_flags = PSS_TBL_SPECIFIED | PSS_SCHEMA_SPECIFIED;
	$Ycol_ref.pss_tab_name = $3;
	$Ycol_ref.pss_col_name = $5;
	    
	$$ = &$Ycol_ref;
    }
		|	DBA PERIOD generic_ident PERIOD generic_ident
    {
	/* $DBA.table.column */

	$Yid_type = PSS_ID_DBA;
	$Ycol_ref.pss_flags = PSS_TBL_SPECIFIED | PSS_SCHEMA_SPECIFIED;
	MEmove(STlength(cb->pss_dbaname), (PTR) cb->pss_dbaname, ' ',
	    sizeof($Ycol_ref.pss_schema_name),
	    (PTR) &$Ycol_ref.pss_schema_name);
	$Ycol_ref.pss_tab_name = $3;
	$Ycol_ref.pss_col_name = $5;
	    
	$$ = &$Ycol_ref;
    }
		|	INGRES PERIOD generic_ident PERIOD generic_ident
    {
	/* $INGRES.table.column */

	$Yid_type = PSS_ID_INGRES;
	$Ycol_ref.pss_flags = PSS_TBL_SPECIFIED | PSS_SCHEMA_SPECIFIED;
	MEmove(sizeof(*cb->pss_cat_owner), (PTR) cb->pss_cat_owner, ' ',
	    sizeof($Ycol_ref.pss_schema_name),
	    (PTR) &$Ycol_ref.pss_schema_name);
	$Ycol_ref.pss_tab_name = $3;
	$Ycol_ref.pss_col_name = $5;
	    
	$$ = &$Ycol_ref;
    }
/*****************************************************************************
**
** NOTE: SCONST IS NOT ALLOWED IN SCHEMA NAME, EXCEPT IN THE FOLLOWING CASES:
**	
**	REGISTER ... AS LINK FROM SCONST.SCONST
**
**	SELECT ... FROM ... WITH TABLE = SCONST.SCONST
**
** THE FOLLOWING PRODUCTION IS THUS COMMENTED OUT
**
		|	SCONST PERIOD NAME PERIOD NAME
    {
	$Ycol_ref.pss_flags = PSS_TBL_SPECIFIED | PSS_SCHEMA_SPECIFIED;
	MEmove($1->db_t_count, (PTR) $1->db_t_text, ' ',
	    sizeof($Ycol_ref.pss_schema_name),
	    (PTR) &$Ycol_ref.pss_schema_name);
	$Ycol_ref.pss_tab_name = $3;
	$Ycol_ref.pss_col_name = $5;
	    
	$$ = &$Ycol_ref;
    }
**
** END OF COMMENT
**
*****************************************************************************/
		|	SESSION PERIOD generic_ident PERIOD generic_ident
    {
	/* session.table.column */
	/* See also above: id.id.id */

	if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		$3, &psq_cb->psq_error))
	{
	    return(E_DB_ERROR);
	}

	$Ycol_ref.pss_flags = PSS_TBL_SPECIFIED | PSS_SCHEMA_SPECIFIED;
	STRUCT_ASSIGN_MACRO(cb->pss_sess_owner, $Ycol_ref.pss_schema_name);
	$Ycol_ref.pss_tab_name = $3;
	$Ycol_ref.pss_col_name = $5;
	    
	$$ = &$Ycol_ref;
    }
;

all_col_ref:		generic_ident PERIOD BAOP
    {
	/* table.* or corr_name.* */

	$Ycol_ref.pss_flags = PSS_TBL_OR_CORR_NAME_SPECIFIED | PSS_ALL_COLUMNS;
	$Ycol_ref.pss_tab_name = $1;
	$Ycol_ref.pss_col_name = (char *) NULL;

	$$ = &$Ycol_ref;
    }
	/*
	** various flavors of <schema>.<table>.*
	** We are forced to expand schema_spec in-line because doing otherwise
	** (i.e. using schema_spec here) results in two shift-reduce conflicts
	** as the grammar tries to figure out whether a given indeitifer is a
	** schema namer or a table name
	*/
		|	generic_ident PERIOD generic_ident PERIOD BAOP
    {
	/* <schema>.table.* */

	$Ycol_ref.pss_flags =
	    PSS_TBL_SPECIFIED | PSS_SCHEMA_SPECIFIED | PSS_ALL_COLUMNS;
	MEmove(STlength($1), (PTR) $1, ' ',
	    sizeof($Ycol_ref.pss_schema_name),
	    (PTR) &$Ycol_ref.pss_schema_name);
	$Ycol_ref.pss_tab_name = $3;
	$Ycol_ref.pss_col_name = (char *) NULL;
	    
	$$ = &$Ycol_ref;
    }
		|	DBA PERIOD generic_ident PERIOD BAOP
    {
	/* $DBA.table.* */

	$Ycol_ref.pss_flags =
	    PSS_TBL_SPECIFIED | PSS_SCHEMA_SPECIFIED | PSS_ALL_COLUMNS;
	MEmove(STlength(cb->pss_dbaname), (PTR) cb->pss_dbaname, ' ',
	    sizeof($Ycol_ref.pss_schema_name),
	    (PTR) &$Ycol_ref.pss_schema_name);
	$Ycol_ref.pss_tab_name = $3;
	$Ycol_ref.pss_col_name = (char *) NULL;
	    
	$$ = &$Ycol_ref;
    }
		|	INGRES PERIOD generic_ident PERIOD BAOP
    {
	/* $INGRES.table.* */

	$Ycol_ref.pss_flags =
	    PSS_TBL_SPECIFIED | PSS_SCHEMA_SPECIFIED | PSS_ALL_COLUMNS;
	MEmove(sizeof(*cb->pss_cat_owner), (PTR) cb->pss_cat_owner, ' ',
	    sizeof($Ycol_ref.pss_schema_name),
	    (PTR) &$Ycol_ref.pss_schema_name);
	$Ycol_ref.pss_tab_name = $3;
	$Ycol_ref.pss_col_name = (char *) NULL;
	    
	$$ = &$Ycol_ref;
    }
/*****************************************************************************
**
** NOTE: SCONST IS NOT ALLOWED IN SCHEMA NAME, EXCEPT IN THE FOLLOWING CASES:
**	
**	REGISTER ... AS LINK FROM SCONST.SCONST
**
**	SELECT ... FROM ... WITH TABLE = SCONST.SCONST
**
** THE FOLLOWING PRODUCTION IS THUS COMMENTED OUT
**
		|	SCONST PERIOD NAME PERIOD BAOP
    {

	$Ycol_ref.pss_flags =
	    PSS_TBL_SPECIFIED | PSS_SCHEMA_SPECIFIED | PSS_ALL_COLUMNS;
	MEmove($1->db_t_count, (PTR) $1->db_t_text, ' ',
	    sizeof($Ycol_ref.pss_schema_name),
	    (PTR) &$Ycol_ref.pss_schema_name);
	$Ycol_ref.pss_tab_name = $3;
	$Ycol_ref.pss_col_name = (char *) NULL;
	    
	$$ = &$Ycol_ref;
    }
**
** END OF COMMENT
**
*****************************************************************************/
		|	SESSION PERIOD generic_ident PERIOD BAOP
    {
	/* session.table.* */

	if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		$3, &psq_cb->psq_error))
	{
	    return(E_DB_ERROR);
	}

	$Ycol_ref.pss_flags =
	    PSS_TBL_SPECIFIED | PSS_SCHEMA_SPECIFIED | PSS_ALL_COLUMNS;
	STRUCT_ASSIGN_MACRO(cb->pss_sess_owner, $Ycol_ref.pss_schema_name);
	$Ycol_ref.pss_tab_name = $3;
	$Ycol_ref.pss_col_name = (char *) NULL;

	$$ = &$Ycol_ref;
    }
;

comment_col:	col_ref
    {
	DB_STATUS	status;

	status = psl_comment_col(cb, psq_cb, $1);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    }
;

long_remark:	IS SCONST
    {
	i4	    err_code;

	if ($2->db_t_count > DBC_L_LONG)
	{
	    i4	    max_len = (i4) DBC_L_LONG;

	    (VOID) psf_error(E_PS0BA1_LONG_REMARK_TOO_LONG, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 1,
			     sizeof(i4), &max_len);
	    return (E_DB_ERROR);
	}
	else
	{
	    $$ = $2;
	}
    }
	    |
    {
	$$ = (DB_TEXT_STRING *) NULL;
    }
;

short_remark:	SHORT_REMARK EQUAL SCONST
    {
	i4	    err_code;

	/* if(1) - temporary fix for compiler warnings till following code is
                  completed */

	if ($3->db_t_count > DBC_L_SHORT)
	{
	    i4	    max_len = (i4) DBC_L_SHORT;

	    (VOID) psf_error(E_PS0BA0_SHORT_REMARK_TOO_LONG, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 1,
			     sizeof(i4), &max_len);
	    return (E_DB_ERROR);
	}
	else
	{
	    $$ = $3;
	}
    }
	    |
    {
	$$ = (DB_TEXT_STRING *) NULL;
    }
;

set_sess_auth_id:	    SETSESSION AUTHORIZATION
    {


	psq_cb->psq_mode = PSQ_SET_SESS_AUTH_ID;
    }
			    eff_user_id_spec
    {
	DB_STATUS	status;

	/*
	** user must have DB_ADMIN privilege in order to issue
	** SET SESSION AUTHORIZATION
	*/

	status = psy_ckdbpr(psq_cb, (u_i4) DBPR_DB_ADMIN);

	if (DB_FAILURE_MACRO(status))
	{
	    i4	err_code;

	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_ERROR	error;
		DB_STATUS	local_stat;
		char	*objname;
		i4		objlength;
		i4	msg_id;

		/*
		** failure to execute SET SESSION AUTHORIZATION due to insufficient
		** privilege must be audited
		*/
		msg_id     = I_SX2033_SET_USER_AUTH;

		if (psq_cb->psq_ret_flag & PSQ_USE_SESSION_USER)
		{
		    objname    = ERx("\"SESSION USER\"");
		    objlength  = sizeof(ERx("\"SESSION USER\""));
		}
		else if (psq_cb->psq_ret_flag & PSQ_USE_SYSTEM_USER)
		{
		    objname    = ERx("\"SYSTEM USER\"");
		    objlength  = sizeof(ERx("\"SYSTEM USER\""));
		}
		else if (psq_cb->psq_ret_flag & PSQ_USE_CURRENT_USER)
		{
		    objname    = ERx("\"CURRENT USER\"");
		    objlength  = sizeof(ERx("\"CURRENT USER\""));
		}
		else if (psq_cb->psq_ret_flag & PSQ_USE_INITIAL_USER)
		{
		    objname    = ERx("\"INITIAL_USER\"");
		    objlength  = sizeof(ERx("\"INITIAL_USER\""));
		}
		/* check for dynamic query parameter */
		else if (cb->pss_defqry == PSQ_PREPARE &&
			 cb->pss_highparm != -1)
		{
		    objname    = ERx("\"DYNAMIC PARAMETER\"");
		    objlength  = sizeof(ERx("\"DYNAMIC PARAMETER\""));
		}
		else
		{
		    objname = psq_cb->psq_user.db_tab_own.db_own_name;
		    objlength  = sizeof(DB_OWN_NAME);
		}

		local_stat = psy_secaudit(FALSE, cb,
			    objname, (DB_OWN_NAME *)NULL,
			    objlength, SXF_E_USER,
			    msg_id, SXF_A_FAIL | SXF_A_SELECT,
			    &error);

		if (local_stat > status)
		    status = local_stat;
	    }

	    (VOID) psf_error(E_PS0354_SETID_INSUF_PRIV, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	    return(status);
	}
    }
;

eff_user_id_spec:	generic_ident
    {
	/* store new user id in PSQ_CB */
	STmove($1, ' ', DB_MAXNAME, (char *) &psq_cb->psq_user);
    }
		|	DBA
    {
	/* will reset the effective user identifier to the value of $DBA */
	STmove(cb->pss_dbaname, ' ', DB_MAXNAME, (char *) &psq_cb->psq_user);
    }
		|	INGRES
    {
	/* will reset the effective user identifier to $ingres */
	MEmove(sizeof(*cb->pss_cat_owner), (PTR)cb->pss_cat_owner, ' ',
		DB_MAXNAME, (PTR) &psq_cb->psq_user);
    }
		|	USER
    {
	/* a rather meaningless query until mofule language is supported */
	psq_cb->psq_ret_flag |= PSQ_USE_CURRENT_USER;
    }
		|	CURRENT_USER
    {
	/* another meaningless query until mofule language is supported */
	psq_cb->psq_ret_flag |= PSQ_USE_CURRENT_USER;
    }
		|	SESSION_USER
    {
	/* this query will NEVER have any effect */
	psq_cb->psq_ret_flag |= PSQ_USE_SESSION_USER;
    }
		|	SYSTEM_USER
    {
	/*
	** will reset the effective user identifier to the identifier of the
	** "real" user
	*/
	psq_cb->psq_ret_flag |= PSQ_USE_SYSTEM_USER;
    }
		|	INITIAL_USER
    {
	/*
	** will reset the effective user identifier to that in effect at
	** session startup
	*/
	psq_cb->psq_ret_flag |= PSQ_USE_INITIAL_USER;
    }
		|	SCONST
    {
	u_i4	    len, save_len, id_len = DB_MAXNAME;
	i4	    leading_blanks;
	char	    *c = (char *) $1->db_t_text;
	DB_STATUS   status;

	/*
	** according to SQL92, we need to strip off leading and trailing blanks
	** from the contents of the string constant and only then may we verify
	** that the remainder represents a valid identifier
	*/

	len = psf_trmwhite((u_i4) $1->db_t_count, c);

	for (leading_blanks = 0; CMspace(c); leading_blanks++, CMnext(c))
	;

	/*
	** we are saving length of the string to be passed to
	** cui_idxlate() so that we can ensure that the entire string
	** was "consumed" by it
	*/
	save_len = len -= leading_blanks;

	status = cui_idxlate((u_char *) c, &len, (u_char *) &psq_cb->psq_user,
			     &id_len, (u_i4) *cb->pss_dbxlate,
			     (u_i4 *) NULL, &psq_cb->psq_error);

	if (save_len != len || DB_FAILURE_MACRO(status))
	{
	    i4	err_code;

	    psf_error(E_PS0359_NOT_A_VALID_AUTH_ID, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) save_len, (PTR) c);

	    return(E_DB_ERROR);
	}

	/* fill the rest of psq_cb->psq_user with blanks */
	if (id_len < DB_MAXNAME)
	{
	    MEfill((DB_MAXNAME - id_len), (u_char) ' ',
		(PTR) ((char *) &psq_cb->psq_user + id_len));
	}
    }
		|	QDATA
    {
	DB_TEXT_STRING	    *str;
	DB_STATUS	    status;
	u_i4		    len, save_len, id_len = DB_MAXNAME;
	i4		    leading_blanks;
	char		    *c;
	DB_DT_ID	    totype;

	/*
	** if the input datatype was nullable, so must be the output datatype
	*/

	totype = ($1->db_datatype < 0) ? -DB_LTXT_TYPE : DB_LTXT_TYPE;

	status = qdata_cvt(cb, psq_cb, $1, totype, (PTR *) &str);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}

	/*
	** according to SQL92, we need to strip off leading and trailing blanks
	** from the contents of the string constant and only then may we verify
	** that the remainder represents a valid identifier
	*/

	c = (char *) str->db_t_text;

	len = psf_trmwhite((u_i4) str->db_t_count, c);

	for (leading_blanks = 0; CMspace(c); leading_blanks++, CMnext(c))
	;

	/*
	** we are saving length of the string to be passed to
	** cui_idxlate() so that we can ensure that the entire string
	** was "consumed" by it
	*/
	save_len = len -= leading_blanks;

	status = cui_idxlate((u_char *) c, &len, (u_char *) &psq_cb->psq_user,
			     &id_len, (u_i4) *cb->pss_dbxlate,
			     (u_i4 *) NULL, &psq_cb->psq_error);

	if (save_len != len || DB_FAILURE_MACRO(status))
	{
	    i4	err_code;

	    psf_error(E_PS0359_NOT_A_VALID_AUTH_ID, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		(i4) save_len, (PTR) c);

	    return(E_DB_ERROR);
	}

	/* fill the rest of psq_cb->psq_user with blanks */
	if (id_len < DB_MAXNAME)
	{
	    MEfill((DB_MAXNAME - id_len), (u_char) ' ',
		(PTR) ((char *) &psq_cb->psq_user + id_len));
	}
    }
	|	    QUESTIONMARK
    {
	/* dynamic parameter marker may only occur when preparing a statement */
	if (cb->pss_defqry != PSQ_PREPARE)
	{
	    i4	err_code;

	    (VOID) psf_error(2306L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		sizeof(cb->pss_lineno), &cb->pss_lineno);
	    return (E_DB_ERROR);
	}

	++cb->pss_highparm;
	if ($Yin_target_clause)
	   ++cb->pss_targparm;
    }
;

/*
** Star and non-relational gateway statements
*/

/*
** Yacc production:  reg_distr_tv - register an object in Star
**
** Statement Syntax:
**	REGISTER [TABLE|VIEW] [<owner>.]<obj_name> [(column_list)]
**		AS LINK|NATIVE [FROM [owner.]table]
**		[WITH node = <nodename>, database = <dbname>]
**	    |	[WITH dbms = <dbmstype>]
**	    |	[WITH node = <nodename>, database = <dbname>, dbms = <dbmstype>;
**
**	REGISTER [TABLE] <obj_name> AS LINK [FROM [owner.]table]
**		WITH REFRESH;
**
**      REGISTER PROCEDURE [<owner>.]<obj_name>
**              AS LINK [FROM [owner.]table]
**              [WITH node = <nodename>, database = <dbname>]
**          |   [WITH dbms = <dbmstype>]
**          |   [WITH node = <nodename>, database = <dbname>,dbms = <dbmstype>];
**
** Return State:
**	Statement Mode = PSQ_REG_LINK or PSQ_REREGISTER
*/
reg_distr_tv:	reg_keywd reg_name link_cols as_link_or_native from_ldb_obj 
			ldb_spec
    {
	DB_STATUS		status;

	/*
	**	Check if distributed or not
	*/
	/* REGISTER TABLE AS LINK|NATIVE is allowed ONLY in distributed */
	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	    err_code;

	    (VOID) psf_error(2086L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		STlength("REGISTER ... LINK"), "REGISTER ... LINK");
	    return (E_DB_ERROR);
	}

	status = psl_rg1_reg_distr_tv(cb, $2, $1, &$Yxlated_qry, psq_cb);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

from_ldb_obj:	    from_ldb_wd internal_ident
    {
	STmove($2, ' ', sizeof(DD_NAME),
	  ((QED_DDL_INFO *) cb->pss_object)->qed_d6_tab_info_p->dd_t1_tab_name);

	cb->pss_distr_sflags |= PSS_LDB_TABLE;

	if ($Yid_type == PSS_ID_SCONST)
	{
	    cb->pss_distr_sflags |= PSS_QUOTED_TBLNAME;
	}
	else if ($Yid_type == PSS_ID_DELIM)
	    cb->pss_distr_sflags |= PSS_DELIM_TBLNAME;
    }
	|
		    from_ldb_wd owner_name PERIOD internal_ident
    {
	DD_2LDB_TAB_INFO	*ldb_tab_info =
	                   ((QED_DDL_INFO *) cb->pss_object)->qed_d6_tab_info_p;
			   
	STmove($2, ' ', sizeof(DD_NAME), ldb_tab_info->dd_t2_tab_owner);
	STmove($4, ' ', sizeof(DD_NAME), ldb_tab_info->dd_t1_tab_name);

	cb->pss_distr_sflags |= PSS_LDB_TABLE;

	if ($Yid_type == PSS_ID_SCONST)
	{
	    cb->pss_distr_sflags |= PSS_QUOTED_TBLNAME;
	}
	else if ($Yid_type == PSS_ID_DELIM)
	    cb->pss_distr_sflags |= PSS_DELIM_TBLNAME;
    }
	|	/* No from clause */
;

from_ldb_wd:	    FROM
    {
	cb->pss_distr_sflags &= ~(PSS_DELIM_OWNNAME|PSS_DELIM_TBLNAME);
    }
;

owner_name:	    internal_ident
    {
	if ($Yid_type == PSS_ID_SCONST)
	{
	    cb->pss_distr_sflags |= PSS_QUOTED_OWNNAME;
	}
	else if ($Yid_type == PSS_ID_DELIM)
	{
	    cb->pss_distr_sflags |= PSS_DELIM_OWNNAME;
	}
	$$ = $1;
    }
;

as_link_or_native:    AS nonkeyword
    {
	i4		err_code;

	/* we are done processing the new object names */
	cb->pss_stmt_flags &= ~PSS_NEW_OBJ_NAME;
	
	if (!STcompare("native", $2))
	{
	    cb->pss_stmt_flags |= PSS_REG_AS_NATIVE;
	}
	else if (STcompare("link", $2))
	{
	    (VOID) psf_error(E_PS1206_REGISTER, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 2, (i4) sizeof(cb->pss_lineno),
			     &cb->pss_lineno, STlength($2), $2);
	    return (E_DB_ERROR);
	}
    }
;

reg_keywd:	    reg_tvp
    {
	/* REGISTER [TABLE|VIEW|PROCEDURE] */

	i4		err_code;
	DB_STATUS	status;

	i4 val1;
	i4 val2;
    	char		trbuf[PSF_MAX_TEXT + 1]; /* last char for `\n' */

        if (ult_check_macro(&cb->pss_trace, 20, &val1, &val2))
        {
	    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
		"Read REGISTER keyword (value %d)\n", $1);
        }

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    /*
	    **	Distributed
	    */
	    psq_cb->psq_mode = PSQ_REG_LINK;
	    status = psl_rg3_reg_tvi(cb, psq_cb);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
	else
	{
	    /* 
	    ** Must be GW register - GW will fail later if its wrong.
	    ** We allow both REGISTER and REGISTER TABLE as 
	    ** identical to GW. (only REGISTER VIEW fails here since GW can't
	    ** register a view)
	    */

	    if ($1 == DD_2OBJ_TABLE || $1== -1)
	    {
	        if (ult_check_macro(&cb->pss_trace, 20, &val1, &val2))
	        {
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"Turning REGISTER [TABLE] into REGISTER IMPORT\n");
	        }

		psq_cb->psq_mode = PSQ_REG_IMPORT;
		$1 = DD_2OBJ_TABLE;
		status = psl_ct10_crt_tbl_kwd(cb, psq_cb,
				&$Ywith_clauses, (i4) 0);
		if (DB_FAILURE_MACRO(status))
		    return (status);
		$Ywith_dups = -1;
		$Ywith_journaling = -1;
	    }
	    else
	    {
		if (ult_check_macro(&cb->pss_trace, 20, &val1, &val2))
		{
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"Generating error on REGISTER VIEW in non-distributed\n");
		}

		(VOID) psf_error(3083L, 0L, PSF_USERERR, &err_code,
			 &psq_cb->psq_error,2,
			(i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
			 (i4) sizeof("VIEW")-1, "VIEW");

		return (E_DB_ERROR);
	    }
	}

	/* we are about to process new object names */
	cb->pss_stmt_flags |= PSS_NEW_OBJ_NAME;

	$$ = $1;
    }
;

reg_name:	    obj_spec
    {
	DB_STATUS		status;

	/* treat as gateway if not STAR session */

	/* test object name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT($1->pss_orig_obj_name, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    status = psl_ct12_crname(cb, psq_cb, $1);
	    if (DB_FAILURE_MACRO(status))
		return(status);

	    status = psl_ct9_new_loc_name(cb, psq_cb, (char *) NULL,
			$1->pss_orig_obj_name, &$Ywith_clauses, &$Yxlated_qry);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}

	$$ = $1;
    }
;

reg_tvp:	    	    REGISTER
    {
	$$ = -1;
    }
	|	    REGISTER TABLE
    {
	$$ = DD_2OBJ_TABLE;
    }
	|	    REGISTER VIEW
    {
	$$ = DD_3OBJ_VIEW;
    }
        |           REGISTER PROCEDURE
    {
        /* flag that this is a procedure and return tye corect object type */
        cb->pss_distr_sflags |= PSS_REGISTER_PROC;
        $$ = DD_5OBJ_REG_PROC;
    }
;

/*
** Yacc production:  create_link	- register an object in Star
**
** Statement Syntax:
**	CREATE LINK [<owner>.]<obj_name> [(column_list)]
**		WITH table = <tablename>
**		[,WITH node = <nodename>, database = <dbname>]
**	    |	[,WITH dbms = <dbmstype>]
**	    |	[,WITH node = <nodename>, database = <dbname>,dbms = <dbmstype>;
**
** Return State:
**	Statement Mode = PSQ_0_CRT_LINK
**
** Note: this is the old (release 5) way of registering a table.  The
** syntax generates a warning. 
*/
create_link:	    crt_lnk_kwd reg_name link_cols 
    {
	/* we are done processing the new object names */
	cb->pss_stmt_flags &= ~PSS_NEW_OBJ_NAME;
    }
		    ldb_spec
    {
	DB_STATUS		status;

	status = psl_rg1_reg_distr_tv(cb, $2, -1,
				&$Yxlated_qry, psq_cb);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

crt_lnk_kwd:	    CRTLINK
    {
	DB_STATUS	status;
	i4		err_code;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (void) psf_error(2086L, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 1,
			     sizeof(ERx("CREATE LINK"))-1, 
			     ERx("CREATE LINK"));
	    return (E_DB_ERROR);
	}

	psq_cb->psq_mode = PSQ_0_CRT_LINK;
	status = psl_rg3_reg_tvi(cb, psq_cb);

	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* we are about to process new object names */
	cb->pss_stmt_flags |= PSS_NEW_OBJ_NAME;
    }
;

link_cols:	    LPAREN link_col_list RPAREN
	|	    /* No column list */
    {
	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4		err_code;
	    
	    (VOID) psf_error(E_PS110D_TBL_NOCOL, 0L, PSF_USERERR, &err_code,
				&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
    }
;

link_col_list:	    col_spec
    {
	DB_STATUS		status;

        if (cb->pss_distr_sflags & PSS_REGISTER_PROC)
        {
            /* opps, column lists are not permitted with the register procedure
            ** statement and this is a register procedure statement.  Better
            ** report a syntax error to the user
            */
            i4             err_code;

            (VOID) psf_error(E_PS091C_NOPARAMS_ALLOWED, 0L, PSF_USERERR,
                             &err_code, &psq_cb->psq_error, 0);
            return (E_DB_ERROR);
        }
	status = psl_rg6_link_col_list($1, cb, psq_cb);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	    link_col_list COMMA col_spec
    {
	DB_STATUS		status;

        if (cb->pss_distr_sflags & PSS_REGISTER_PROC)
        {
            /* opps, column lists are not permitted with the register procedure
            ** statement and this is a register procedure statement.  Better
            ** report a syntax error to the user
            */
            i4             err_code;

            (VOID) psf_error(E_PS091C_NOPARAMS_ALLOWED, 0L, PSF_USERERR,
                             &err_code, &psq_cb->psq_error, 0);
            return (E_DB_ERROR);
        }
	status = psl_rg6_link_col_list($3, cb, psq_cb);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

ldb_spec:
	|	    WITH NULLWORD
    {
	i4		err_code;

	if (psq_cb->psq_mode == PSQ_DIRDISCON)
	{
	    /*
	    ** direct disconnect doesn't allow a with_clause
	    */
	    (VOID) psf_error(2083L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error,0);
	}
    }
	|	    WITH nonkeyword
    {
	DB_STATUS		status;

	status = psl_rg5_ldb_spec(cb, $2, psq_cb->psq_mode, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	    WITH ldb_spec_list
    {
	DB_STATUS		status;

	status = psl_rg5_ldb_spec(cb, (char *) NULL,
	    			psq_cb->psq_mode, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
	
    }
;

ldb_spec_list:	    ldb_spec_item
	|	    ldb_spec_list COMMA ldb_spec_item
;

ldb_spec_item:	    twith_name
	|	    twith_nm_eq_str
	|	    twith_tb_eq_id
;

reg_gateway_tab:    reg_keywd reg_name LPAREN reg_attr_list
		    RPAREN AS IMPORT FROM reg_file_name
		    reg_with_list reg_exit_rtn
    {
	i4		    err_code;
	i4		    colno;
	QEU_CB              *qeu_cb;
	DMU_CB              *dmu_cb;
	DMU_ATTR_ENTRY      **attrs;
	i4             length;
	DB_STATUS	    status;
	i4		    len;
 
	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;

	/*
	** So that we can access the source query text at *pss_bgnstmt in
	** qeu_dbu() in qeus.c, copy it and terminate it with a 0-byte.  Then,
	** use qeu_qtext to point to this string.  This is so the query
	** text can be put into iiqrytext.  Other commands collect the text via
	** pss_open, pss_tadd, and pss_tout, eventually putting it into
	** pss_tstream in the psy_cb & pointing cb->pss_object at the psy_cb;
	** but historically pss_object is already used here to point to a
	** qeu_cb, so we've gotta pass the string via the qeu_cb.  We don't
	** think *pss_bgnstmt is null-terminated, but we want our copy to be
	** so.
	**
	** The iiqrytext buffer must be one byte longer than the actual
	** actual ddl statement;  otherwise STlcopy may access violate
	** when tagging on the concluding '\0'.
	*/ 

	len = cb->pss_nxtchar - cb->pss_bgnstmt;
	status = psf_malloc(cb, &cb->pss_ostream, len + 1, 
	    (PTR *) &qeu_cb->qeu_qtext, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	/* Note STlcopy guarentees terminating \0 in destination string */
	STncpy(qeu_cb->qeu_qtext, (char *) cb->pss_bgnstmt, len);
	qeu_cb->qeu_qtext[ len ] = '\0';

	/* find columns */
	attrs = (DMU_ATTR_ENTRY **) dmu_cb->dmu_attr_array.ptr_address;
	length = 0;

	/* Ensure GW_IMA tables are structure=sortkeyed (b117546) kibro01 */
	if (dmu_cb->dmu_gw_id == DMGW_IMA &&
	    cb->pss_restab.pst_struct != DB_BTRE_STORE)
	{
	    /* Error! - structure must be sortkeyed */
	    (VOID) psf_error(9357L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
    	    return (E_DB_ERROR);
	}

	if (dmu_cb->dmu_gw_id == DMGW_IMA)
	{
	    i4 dummy, dummy2;
	    bool found_vnode_or_server = FALSE;
	    bool found_match;

	    for (dummy = 0; dummy < cb->pss_rsdmno; dummy++)
	    {
		DMU_GWATTR_ENTRY    *gwattr;
		char		    *att_name;

		gwattr = *((DMU_GWATTR_ENTRY **)
			dmu_cb->dmu_gwattr_array.ptr_address + dummy);
		att_name = gwattr->gwat_xbuffer;

		/* If item contains ".", that means it is a Classid */
		if (STindex(att_name,ERx("."),0))
			continue;

		/* Search through GM_atts array */
		found_match = FALSE;
		for (dummy2 = 0; GM_atts[dummy2].name != NULL; dummy2++)
		{
		    if (STbcompare(att_name,0,GM_atts[dummy2].name,0,TRUE)==0)
		    {
			if (GM_atts[dummy2].type == GMA_VNODE ||
			    GM_atts[dummy2].type == GMA_SERVER)
			{
			    if (found_vnode_or_server)
			    {
			        /* Error! - only allowed one of these */
			        (VOID) psf_error(9356L, 0L, PSF_USERERR,
					&err_code, &psq_cb->psq_error, 0);
	    		        return (E_DB_ERROR);
			    }
			    found_vnode_or_server = TRUE;
			}
			found_match = TRUE;
		    }
		}
		if (!found_match)
		{
		    /* Error! - unknown non-classid word */
		    (VOID) psf_error(9355L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 1, (i4) STlen(att_name), att_name);
	    	    return (E_DB_ERROR);
		}
	    }
	}

        /* Make sure there is a location */
        if (!dmu_cb->dmu_location.data_in_size)
        {
	    /* Default location for 'normal' & 'subselect' versions */
	    STmove("$default", ' ', sizeof(DB_LOC_NAME),
	           (char*) dmu_cb->dmu_location.data_address);
            dmu_cb->dmu_location.data_in_size = sizeof(DB_LOC_NAME);
        }


	/* Default if no "rows=" clause is given, is 1000 rows. */
	if (dmu_cb->dmu_gwrowcount == DMGW_NO_ROW_ENTRY)
	    dmu_cb->dmu_gwrowcount = 1000;

	/* b117252/b117253 (kibro01)
	** Check we're not using journaling or update if IMA gateway
	*/
	if (dmu_cb->dmu_gw_id == DMGW_IMA)
	{
	    DMU_CHAR_ENTRY	*char_entry;
	    i4		char_count;
	    i4		ix;
	    DMU_FROM_PATH_ENTRY *from_path;
	    char	*from_ptr;

	    char_entry = (DMU_CHAR_ENTRY *)
		((char *) dmu_cb->dmu_char_array.data_address);
	    char_count = 
		dmu_cb->dmu_char_array.data_in_size/sizeof(DMU_CHAR_ENTRY);

	    for (ix = 0; ix < char_count; ix++)
	    {
		switch (char_entry[ix].char_id)
		{
		    case DMU_GW_UPDT:
			from_path = (DMU_FROM_PATH_ENTRY *)
				dmu_cb->dmu_olocation.data_address;
			from_ptr = from_path->from_buffer;

			if (char_entry[ix].char_value == DMU_C_ON &&
				STbcompare(from_ptr,0,"OBJECTS",0,TRUE) != 0)
			{
			    char *x = "UPDATE";
			    /* Cannot have UPDATE on IMA tables */
			    (VOID) psf_error(9311L, 0L, PSF_USERERR, &err_code,
				&psq_cb->psq_error, 1, (i4) STlen(x), x);
	    		    return (E_DB_ERROR);
			}
			break;
		    case DMU_JOURNALED:
			if (char_entry[ix].char_value == DMU_C_ON)
			{
			    char *x = "JOURNALING";
			    /* Cannot have JOURNALING on IMA tables */
			    (VOID) psf_error(9311L, 0L, PSF_USERERR, &err_code,
				&psq_cb->psq_error, 1, (i4) STlen(x), x);
	    		    return (E_DB_ERROR);
			}
			break;
		    default:
			break;
		}
	    }
	}
    }
;

reg_attr_list:      reg_attr_elem
	|	    reg_attr_list COMMA reg_attr_elem
;

reg_attr_elem:	    newcolname typedesc
    {
	QEU_CB		    *qeu_cb;
	DMU_CB		    *dmu_cb;
	DMU_ATTR_ENTRY	    **attrs;
	i4		    colno;
	DMU_GWATTR_ENTRY    **gwattrs;

	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;
	attrs = (DMU_ATTR_ENTRY **) dmu_cb->dmu_attr_array.ptr_address;
	colno = cb->pss_rsdmno - 1;
	gwattrs =
	    (DMU_GWATTR_ENTRY **)(dmu_cb->dmu_gwattr_array.ptr_address);
 
	/* No extended format; set flag appropriately. */
	(gwattrs[colno])->gwat_flags_mask &= ~DMGW_F_EXTFMT;
    }
	|	    newcolname typedesc IS reg_extfmt
;

reg_extfmt:	    SCONST
    {
	QEU_CB		    *qeu_cb;
	DMU_CB		    *dmu_cb;
	i4		    size_extfmt;
	DMU_GWATTR_ENTRY    *gwattr;

	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;
	gwattr = *((DMU_GWATTR_ENTRY **) dmu_cb->dmu_gwattr_array.ptr_address +
		   cb->pss_rsdmno - 1);
	/* size may not exceed limit */
	if ((size_extfmt = (i4) $1->db_t_count) > (DMU_MAXSIZE_EXTFMT - 1))
	    size_extfmt = DMU_MAXSIZE_EXTFMT - 1;
 
	STncpy (gwattr->gwat_xbuffer, (char *) $1->db_t_text, size_extfmt);
	gwattr->gwat_xbuffer[ size_extfmt ] = '\0';
	gwattr->gwat_xsize = size_extfmt;
	/* This is always the first flag setting, so use "=", not "|=" */
	gwattr->gwat_flags_mask = DMGW_F_EXTFMT;
    }
;

reg_file_name:	    SCONST
    {
	QEU_CB			*qeu_cb;
	DMU_CB			*dmu_cb;
	i4			from_value_size;
	DMU_FROM_PATH_ENTRY	*from_path_ptr;
	i4			err_code;
	i4			val1,val2;
    	char		trbuf[PSF_MAX_TEXT + 1]; /* last char for `\n' */

	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;
 
	from_path_ptr = (DMU_FROM_PATH_ENTRY *)
			 dmu_cb->dmu_olocation.data_address;
	if ((from_value_size = (i4) $1->db_t_count) > DMU_MAXSIZE_FROM)
	{
	    /* size over limit */
	    (VOID) psf_error(9308L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	else
	{
	    from_path_ptr->from_size = from_value_size;
	    if (from_value_size != 0)
	    {
	       STcopy(sconvert($1), from_path_ptr->from_buffer);
	       if (ult_check_macro(&cb->pss_trace, 20, &val1, &val2))
	       {
			psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
				"Register FROM source is '%s'\n", 
					from_path_ptr->from_buffer);
	       }
	    }
	}
    }
;

reg_with_list:	    WITH reg_parm_list
	     |	    /* No WITH clause. This will cause a sensible error 
		    ** later on (missing DBMS type) rather than a generic
		    ** syntax error is WITH was mandatory
		    */

;

reg_parm_list:	    reg_parm_elem
	|	    reg_parm_list COMMA reg_parm_elem
;

reg_parm_elem:	    reg_dbms_or_struct_parm
	|	    reg_key_parm
	|	    reg_rows_parm
	|	    reg_keywd_only_parm
;

reg_dbms_or_struct_parm:    nonkeyword EQUAL nonkey_or_sconst
    {
	i4 val1,val2;
    	char		trbuf[PSF_MAX_TEXT + 1]; /* last char for `\n' */
	/*
	** this is for the keyword parameters: DBMS parameter and STRUCTURE
	** parameter which has no prefix value, UNIQUE
	*/
                            
	i4		err_code;
	QEU_CB		*qeu_cb;
	DMU_CB		*dmu_cb;

	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;

	if (STcompare($1, "dbms") == 0)
	{
            if (ult_check_macro(&cb->pss_trace, 20, &val1, &val2))
            {
	    	psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"Register DBMS value is '%s'\n", $3);
            }

	    /*
	    ** if this is the first parm, parm flag should be OFF if the value
	    ** of flag is ON then issue error message for duplicate parm
	    */
	    if (dmu_cb->dmu_gw_id != DMGW_NONE)	/* duplicate parm found  */
	    {
		(VOID) psf_error(9309L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1,
				 (i4) STtrmwhite($1), $1);
		return (E_DB_ERROR);
	    }
 
	    if (STcompare($3,"vsam") == 0)
	    {
		dmu_cb->dmu_gw_id = DMGW_VSAM;
	    }
	    else if (STcompare($3,"rms") == 0)
	    {
		dmu_cb->dmu_gw_id = DMGW_RMS;
	    }
	    else if (STcompare($3,"ims") == 0)
	    {
		dmu_cb->dmu_gw_id = DMGW_IMS;
	    }
	    else if (STcompare($3,"idmsx") == 0)
	    {
		dmu_cb->dmu_gw_id = DMGW_IDMSX;
	    }
	    else if (STcompare($3,"lg_test") == 0)
	    {
		dmu_cb->dmu_gw_id = DMGW_LG_TEST;
	    }
	    else if (STcompare($3,"dmf_test") == 0)
	    {
		dmu_cb->dmu_gw_id = DMGW_DMF_TEST;
	    }
	    else if (STcompare($3,"ima") == 0)
	    {
		dmu_cb->dmu_gw_id = DMGW_IMA;
	    }
	    else if (STcompare($3,"calpont") == 0)
	    {
		dmu_cb->dmu_gw_id = DMGW_CALPONT;
	    }
	    else if (STcompare($3,"sxa") ==0)
	    {
		/*
		**	C2-Audit Gateway
		*/
		dmu_cb->dmu_gw_id = DMGW_SEC_AUD;
	    }
	    else
	    {
		(VOID) psf_error(9310L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1,
				 (i4) STtrmwhite($3), $3);
		return (E_DB_ERROR);
	    }
	    /*
	    **	Validate the DBMS is valid for this particular server
	    **  we do this here otherwise its not detected until a low-level
	    **  GWF routine which can't be handled too cleanly to the user.
	    **
	    **  An example might be registering an RMS gateway table in
	    **  regular Ingres DBMS
	    */
	    {
		GW_RCB gwfrcb;
		DB_STATUS status;
		gwfrcb.gwr_gw_id=dmu_cb->dmu_gw_id;
		gwfrcb.gwr_type=GWR_CB_TYPE;
		gwfrcb.gwr_length=sizeof(GW_RCB);

		status=gwf_call(GWU_VALIDGW, &gwfrcb);
		if (status==E_DB_WARN)
		{
			/*
			**	Not valid for this server
			*/
			(VOID) psf_error(9324L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1,
				 (i4) STtrmwhite($3), $3);
			return E_DB_ERROR;

		}
		else if (status!=E_DB_OK)
		{
			psf_error(gwfrcb.gwr_error.err_code, 0L,
					PSF_USERERR, &err_code,
					&psq_cb->psq_error, 0);

			return status;
		}
	    }
	}

        /* schang : create a procedure for code sharing */
	else if (STcompare($1, "structure") == 0)
	{
            DB_STATUS                   status;

            if (ult_check_macro(&cb->pss_trace, 20, &val1, &val2))
            {
	    	psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"Register STRUCTURE value is '%s'\n", $3);
            }

	    status = psl_reg_struct(&cb->pss_restab.pst_struct, dmu_cb, $3,
		(i4) DMU_C_OFF, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
        }
	else 
	{
	    (VOID) psf_error(9311L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STtrmwhite($1), $1);
	    return (E_DB_ERROR);
	}
    }
	|	    nonkeyword EQUAL UNIQUE name_or_sconst
    {
	/* this is for the STRUCTURE parameter with prefix value UNIQUE */
	i4		err_code;
	QEU_CB         *qeu_cb;
	DMU_CB         *dmu_cb;

	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;
 
        /* schang : call shared procedure */
	if (STcompare($1, "structure") == 0)
	{
            DB_STATUS                   status;

            status = psl_reg_struct(&cb->pss_restab.pst_struct, dmu_cb, $4,
		(i4) DMU_C_ON, &psq_cb->psq_error);
            if (status != E_DB_OK)
                return (status);
        }
	else
	{
	    (VOID) psf_error(8005L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STtrmwhite($1), $1);
	    return (E_DB_ERROR);
	}
    }
;

reg_key_parm:	    nonkeyword EQUAL LPAREN reg_key RPAREN
    {
	QEU_CB		*qeu_cb;
	DMU_CB		*dmu_cb;
	i4		err_code;

	if (STcompare($1,"key") != 0)
	{
	    (void) psf_error(8005L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, $1, $1);
	    return (E_DB_ERROR);
	}

	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;

	/*
	** 'keys' clause specified, but no columns were specified.
	*/
	if (dmu_cb->dmu_key_array.ptr_in_count == 0)
	{
	    /* duplicate parm found  */
	    (VOID) psf_error(9316L, 0L, PSF_USERERR, &err_code,
	               	     &psq_cb->psq_error, 1,
			     (i4) STlength(ERx("key")), ERx("key"));
	    return (E_DB_ERROR);
	}
        /* 
        ** chash01 (oct-02-2003) this is the place to verify
        **   that multi-column key must be all chars and/or varchar
        **   by going through the list of key components.
        */
        if (dmu_cb->dmu_gw_id == DMGW_RMS)
        {
            DMU_ATTR_ENTRY **att = (DMU_ATTR_ENTRY **) 
                                     dmu_cb->dmu_attr_array.ptr_address;
	    DMU_KEY_ENTRY   **key = (DMU_KEY_ENTRY **) 
                                     dmu_cb->dmu_key_array.ptr_address;
            i4          att_count = dmu_cb->dmu_attr_array.ptr_in_count;
            i4          key_count = dmu_cb->dmu_key_array.ptr_in_count;
            i4          type_abs, i, j, mismatch;

            if (key_count > 1)
            {
                /*
                ** if more than one column in key definition, they needs
                ** to be of the same char/varchar types, to guarantee the
                ** collating sequence (and sort sequence) is the same.
                */
                mismatch = 0;
                for (i = 0; i < key_count; i++)
                {
                    for (j = 0; j < att_count; j++)
                    {
	                if (!MEcmp((char *) &(key[i]->key_attr_name), 
                                   (char *) &(att[j]->attr_name),
		                  sizeof(DB_ATT_NAME)))
                        {
                            type_abs = abs(att[j]->attr_type);
                            switch (type_abs)
                            {
                              case DB_CHR_TYPE:
                              case DB_VCH_TYPE:
                              case DB_CHA_TYPE:
                              case DB_TXT_TYPE:
                                  break;
                              default:
                                  mismatch = 1;
                                  break;
                            }
                            /* 
                            ** once a key column is found in the base table
                            ** column list, break out the inner loop
                            */
                            break;
                        }
                    }
                    /*
                    ** once a non-char type found in multi-column key
                    ** there is no need to continue, break out the loop
                    ** and emit error/warning message.
                    */
                    if (mismatch)
                        break;
                }
                if (j >= att_count)
                {
                    key[i]->key_attr_name.db_att_name[DB_MAXNAME-1] = EOS;
	            _VOID_ psf_error(5302L, 0L, PSF_USERERR, &err_code,
	                         &psq_cb->psq_error, 1,
                                 STtrmwhite(key[i]->key_attr_name.db_att_name),
                                 key[i]->key_attr_name.db_att_name);
	            return (E_DB_ERROR);
                }
                if (mismatch)
                {
                    char colname[DB_MAXNAME];

                    MEcopy(key[i]->key_attr_name.db_att_name,
                           (u_i4)DB_MAXNAME, colname);
                    colname[DB_MAXNAME-1] = EOS;
		    _VOID_ psf_error(W_PS1110_REG_TAB_IDX_MULTI_COL,
                                 0L, PSF_USERERR, &err_code,
                                 &psq_cb->psq_error, 1,
                                 STtrmwhite(colname),
                                 colname);
                }
            }
        }
    }
;

reg_key:	    reg_icols
	|	    reg_key COMMA reg_icols
;

reg_icols:	    col_spec asc_desc
    {
	DB_STATUS		    status;
	i4			    err_code;
	QEU_CB			    *qeu_cb;
	DMU_CB			    *dmu_cb;
	DB_ATT_NAME		    attname;
	DMU_KEY_ENTRY		    **key;
	DMU_KEY_ENTRY		    *keymem;
	DMU_ATTR_ENTRY		    **attrs;
	i4			    colno;
	i4			    keycnt;
	i4			    i;

	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;
 
	keycnt = dmu_cb->dmu_key_array.ptr_in_count;
 
	STmove($1, ' ', sizeof(DB_ATT_NAME),  (char *) &attname);
 
	/* Check for duplicate column names. */
 
	/* check duplicate begin */
	key = (DMU_KEY_ENTRY **) dmu_cb->dmu_key_array.ptr_address;
	for (i = 0; i < keycnt; i++)
	{
	    /* check duplicate against previously entered key value */
	    if (!MEcmp((char *) &attname, (char *) &(*key)->key_attr_name,
		       sizeof(DB_ATT_NAME)))
	    {
		(VOID) psf_error(9307L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1, STlength($1), $1);
		return (E_DB_ERROR);
	    }
	    key++;
	}

	/* validate key value (need a valid column name) */
	attrs = (DMU_ATTR_ENTRY **) dmu_cb->dmu_attr_array.ptr_address;
	colno = cb->pss_rsdmno;
	for (i = 0; i < colno; i++)
	{
	    if (!MEcmp((char *)&attname,
		       (char *)&(attrs[i])->attr_name,
		       sizeof((attrs[i])->attr_name)))
	    {
		break;    /* we have match, a valid key value */
	    }
	}
	if (i >= colno)
	{
	    (VOID) psf_error(9312L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 1,
			     (i4) STtrmwhite($1), $1);
	    return (E_DB_ERROR);		
	 }

	/* Store the column name in the DMU_CB key entry array */
	key = (DMU_KEY_ENTRY **) dmu_cb->dmu_key_array.ptr_address;
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMU_KEY_ENTRY),
			    (PTR *) &keymem, &psq_cb->psq_error);
	key[keycnt]= keymem;
	if (status != E_DB_OK)
	    return (status);
	STRUCT_ASSIGN_MACRO(attname, (key[keycnt])->key_attr_name);

	if ($2 == PSS_ASCENDING)
	    (key[keycnt])->key_order = DMU_ASCENDING;
	else
	    (key[keycnt])->key_order = DMU_DESCENDING;

	dmu_cb->dmu_key_array.ptr_in_count++;

    }
;

reg_rows_parm:	    ROWS EQUAL intconst_p
    {
	/* this is for ROWS keyword parameter */
	QEU_CB         *qeu_cb;
	DMU_CB         *dmu_cb;
	i4        err_code;
 
	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;
 
	    /*
	    ** If this is the first rows parameter, dmu_gwrowcount should be
	    ** DMGW_NO_ROW_ENTRY.  If pst_struct is not DMGW_NO_ROW_ENTRY then
	    ** issue error message for duplicate parameter.
	    */
	    if (dmu_cb->dmu_gwrowcount != DMGW_NO_ROW_ENTRY)
	    {
		/* duplicate parm found  */
		(VOID) psf_error(9309L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1,
				 (i4)4, "ROWS");
		return (E_DB_ERROR);

	    }

/*	    TRdisplay ("pslsgram rows = %d\n",$3); */
	    dmu_cb->dmu_gwrowcount = (i4)$3;
    }
;

reg_keywd_only_parm:	    nonkeyword
    {
	/*
	** this is for the keyword parameters: duplicates, noduplicates,
	** journaling, nojournaling, update, noupdate, recovery, norecovery.
	*/
	QEU_CB		    *qeu_cb;
	DMU_CB		    *dmu_cb;
	i4		    err_code;
	DMU_CHAR_ENTRY	    *chr;
	DMU_CHAR_ENTRY	    *chr_start;
	i4		    val1,val2;
    	char		    trbuf[PSF_MAX_TEXT + 1]; /* last char for `\n' */

	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;
	chr_start = (DMU_CHAR_ENTRY *) dmu_cb->dmu_char_array.data_address;
 
        if (ult_check_macro(&cb->pss_trace, 20, &val1, &val2))
        {
    	    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
		"Register Table read keyword '%s'\n",$1);
			
        }
 
	if (STcompare($1, "duplicates") == 0)
	{
	    /*
	    ** if this is the first duplicates entry, char_value should be
	    ** DMU_C_NOT_SET.  If not, issue error message for duplicate or
	    ** conflicting entry.
	    */
	    chr = chr_start + 2;			/* third entry */
	    if (chr->char_value != DMU_C_NOT_SET)
	    {
		/* duplicate or conflict duplicates/noduplicates parm */
		(VOID) psf_error(9314L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1,
				 (i4) STtrmwhite($1), $1);
		return (E_DB_ERROR);
	    }
	    chr->char_id = DMU_DUPLICATES;
	    chr->char_value = DMU_C_ON;
	    cb->pss_restab.pst_resdup = TRUE;
	    $Ywith_dups = 1;
	}
	else if (STcompare($1, "noduplicates") == 0)
	{
	    /*
	    ** if this is the first duplicates entry, char_value should be
	    ** DMU_C_NOT_SET.  If not, issue error message for duplicate or
	    ** conflicting entry.
	    */
	    chr = chr_start + 2;	/* third entry */
	    if (chr->char_value != DMU_C_NOT_SET)
	    {
		(VOID) psf_error(9314L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1,
				 (i4) STtrmwhite($1), $1);
		return (E_DB_ERROR);
	    }
	    /*
	    ** replace default DUPLICATES value by NODUPLICATES in the third
	    ** entry
	    */
	    chr->char_id = DMU_DUPLICATES;
	    chr->char_value = DMU_C_OFF;   /* disallow duplicates */
	    cb->pss_restab.pst_resdup = FALSE;
	    $Ywith_dups = 0;
	}
	else if (STcompare($1, "journaling") == 0)
	{
	    /*
	    ** if this is the first journaling entry, char_value should be
	    ** DMU_C_NOT_SET.  If not, issue error message for duplicate or
	    ** conflicting entry.
	    */
	    chr = chr_start + 3;	/* fourth entry */
	    if (chr->char_value != DMU_C_NOT_SET)
	    {
		/* duplicate or conflict */
		(VOID) psf_error(9314L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1,
				(i4) STtrmwhite($1), $1);
		return (E_DB_ERROR);
	    }
 
	    chr->char_id = DMU_JOURNALED;
	    chr->char_value = DMU_C_ON;        /* enable journaling */
/*************************DO AT EXIT*************************/
	    cb->pss_restab.pst_resjour = TRUE;
	    $Ywith_journaling = 1;
	}
	else if (STcompare($1, "nojournaling") == 0) /* default parm */
	{
	    /*
	    ** if this is the first journaling entry, char_value should be
	    ** DMU_C_NOT_SET.  If not, issue error message for duplicate or
	    ** conflicting entry.
	    */
	    chr = chr_start + 3;	/* fourth entry */
	    if (chr->char_value != DMU_C_NOT_SET)   /* duplicate or conflict */
	    {
		(VOID) psf_error(9314L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1,
				 (i4) STtrmwhite($1), $1);
		return (E_DB_ERROR);
	    }
	    chr->char_id = DMU_JOURNALED;
	    chr->char_value = DMU_C_OFF;        /* disable journaling */
	    cb->pss_restab.pst_resjour = FALSE;
	    $Ywith_journaling = 0;
	}
	else if (STcompare($1, "noupdate") == 0)
	{
	    /*
	    ** if this is the first update entry, char_value should be
	    ** DMU_C_NOT_SET.  If not, issue error message for duplicate or
	    ** conflicting entry.
	    */
	    chr = chr_start + 5;	/* sixth entry */
	    if (chr->char_value != DMU_C_NOT_SET) /* duplicate or conflict */
	    {
		(VOID) psf_error(9314L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1,
				 (i4) STtrmwhite($1), $1);
		return (E_DB_ERROR);
	    }
	    chr->char_id = DMU_GW_UPDT;
	    chr->char_value = DMU_C_OFF;
	}
	else if (STcompare($1, "recovery") == 0)
	{
	    /*
	    ** if this is the first parm, parm flag should be OFF if the value
	    ** of flag is PARM_ON then issue error message for duplicate or
	    ** conflict parm
	    */
	    chr = (DMU_CHAR_ENTRY *) dmu_cb->dmu_gwchar_array.data_address;
	    if (chr->char_value != DMU_C_NOT_SET) /* duplicate or conflict */
	    {
		/* duplicate or conflict parm found */
		(VOID) psf_error(9314L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1,
				 (i4) STtrmwhite($1), $1);
		return (E_DB_ERROR);
	    }
	    chr->char_id = DMU_GW_RCVR;
	    chr->char_value = DMU_C_ON;
	}
	else if (STcompare($1, "norecovery") == 0) /* default value */
	{
	    /*
	    ** if this is the first parm, parm flag should be OFF if the value
	    ** of flag is PARM_ON then issue error message for duplicate or
	    ** conflict parm
	    */
	    chr = (DMU_CHAR_ENTRY *) dmu_cb->dmu_gwchar_array.data_address;

	    if (chr->char_value != DMU_C_NOT_SET) /* duplicate or conflict */
	    {
		(VOID) psf_error(9314L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1,
				 (i4) STtrmwhite($1), $1);
		return (E_DB_ERROR);
	    }
	    chr->char_id = DMU_GW_RCVR;
	    chr->char_value = DMU_C_OFF;
	}
	else 
	{
	    (VOID) psf_error(8007L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 1,
			     (i4) STtrmwhite($1), $1);
	    return (E_DB_ERROR);
	}
    }
	|	    UPDATE

    {
	QEU_CB		    *qeu_cb;
	DMU_CB		    *dmu_cb;
	i4		    err_code;
	DMU_CHAR_ENTRY    *chr;

	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;

	/*
	** if this is the first update entry, char_value should be
	** DMU_C_NOT_SET.  If not, issue error message for duplicate or
	** conflicting entry.
	*/
	chr = (DMU_CHAR_ENTRY *)
	    (((char *) dmu_cb->dmu_char_array.data_address)
	    + 5 * sizeof(DMU_CHAR_ENTRY));    /* 6th entry */
	if (chr->char_value != DMU_C_NOT_SET) /* duplicate or conflict */
	{
	    (VOID) psf_error(9314L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 1,
			     (i4) sizeof("update"), "update");
	    return (E_DB_ERROR);
	}
	chr->char_id = DMU_GW_UPDT;
	chr->char_value = DMU_C_ON;
    }
;

reg_exit_rtn:
    {
	QEU_CB		*qeu_cb;
	DMU_CB		*dmu_cb;
	DMU_CHAR_ENTRY	*chr;
	i4		err_code;
	bool		keyed;
	bool		unique;
	bool		duplicates;
	i4		storestruct;
	i4	        val1,val2;
    	char		trbuf[PSF_MAX_TEXT + 1]; /* last char for `\n' */

	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;

	/***NOTE:  NEED TO CHECK THAT NO KEY HAS BEEN SPECIFIED AS A VARIANT**/
	/***key=(DMU_KEY_ENTRY **)dmu_cb->dmu_key_array.ptr_address;
	****for each key
	****	find matching attr
	****	    check its gflag value against DMGW_F_VARIANT
	***/ 
	/* DBMS is a required parameter in REGISTER TABLE command */
	if (dmu_cb->dmu_gw_id == DMGW_NONE)
	{
	    (VOID) psf_error(9315L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/* First entry in characteristics array is storage structure */
	chr = (DMU_CHAR_ENTRY *) dmu_cb->dmu_char_array.data_address;

        if (ult_check_macro(&cb->pss_trace, 20, &val1, &val2))
        {
    	    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
		"Register Table gateway attribute list starts at %d (X%p)\n",
		chr,chr);
	}

	/* if structure not set, set it to defaule DB_HEAP_STORE */
	if (chr->char_value == DMU_C_NOT_SET)
	    chr->char_value = DB_HEAP_STORE;
	keyed = (chr->char_value != DB_HEAP_STORE);
	storestruct = chr->char_value;

	/*  If RMS Gateway, disallow "fullkey" structure specifier. */
	if ((dmu_cb->dmu_gw_id == DMGW_RMS) && (storestruct == DB_HASH_STORE))
	{
	    (VOID) psf_error(9323L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 2, STlength("fullkey"),
			     "fullkey", STlength("RMS"), "RMS");
	    return (E_DB_ERROR);
	}

	/* no keys on heap */
	if (chr->char_value == DB_HEAP_STORE
	    &&
	    dmu_cb->dmu_key_array.ptr_in_count != 0)
	{
	    (VOID) psf_error(9317L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 0);
	        return (E_DB_ERROR);
	}
	else if (chr->char_value != DB_HEAP_STORE &&
		 dmu_cb->dmu_key_array.ptr_in_count == 0)
	{
	    /* NOTE this is a warning message */
            /* Schang : just warning is not adequate for RMS gateway */
            /*          It must terminate when structure = keyed     */
            /*          (sortkeyed) specified but not key= phrase.   */
            /*          fix GW bug 40997 */
                       
	    (VOID) psf_error(9318L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 0);
            if (dmu_cb->dmu_gw_id == DMGW_RMS)
	        return (E_DB_ERROR);
            else
	        return (E_DB_OK);
	}

	/* if unique is not set, set it to default of non-unique */
	chr++;
	if (chr->char_value == DMU_C_NOT_SET)
	    chr->char_value = DMU_C_OFF;
	unique = (chr->char_value == DMU_C_ON);

	/*  If duplicates not set, default appropriately for struct type. */
	chr++;
	if (chr->char_value == DMU_C_NOT_SET)
	{
	    if (keyed && unique)
		chr->char_value = DMU_C_OFF;
	    else
		chr->char_value = DMU_C_ON;
	}
	duplicates = (chr->char_value == DMU_C_ON);

	/* if journaled is not set, set it to default of not journaled */
	chr++;
	/*
	**	Make sure this is set to DMU_JOURNALED if not already
	*/
	if ( chr->char_id != DMU_JOURNALED)
		chr->char_id = DMU_JOURNALED;

	if (chr->char_value == DMU_C_NOT_SET)
	    chr->char_value = DMU_C_OFF;

	/* skip gateway (always set) */
	chr++;

	/* if update is not set, set it to default of not updatable */
	chr++;
	/*
	**	Make sure this is set to DMU_GW_UPDT if not already
	*/
	if ( chr->char_id != DMU_GW_UPDT)
		chr->char_id = DMU_GW_UPDT;
	if (chr->char_value == DMU_C_NOT_SET)
	    chr->char_value = DMU_C_OFF;

	/* Now do gwchar entry, recovery */
	/* if recovery is not set, set it to default of no recovery */
	chr = (DMU_CHAR_ENTRY *) dmu_cb->dmu_gwchar_array.data_address;
	if (chr->char_value == DMU_C_NOT_SET)
	    chr->char_value = DMU_C_OFF;
    
	/*
	**  Check for compatible values of structure, uniqueness and duplicates.
	*/

	/*  If heap, disallow either "noduplicates" or "unique" qualifiers. */
	if (!keyed && (!duplicates || unique))
	{
	    (VOID) psf_error(9321L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*  If keyed and unique, disallow duplicates. */
	if (keyed && unique && duplicates)
	{
	    (VOID) psf_error(9322L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	return (E_DB_OK);
    }
;

reg_distr_idx: reg_idx reg_idx_name ON indexrel as_link from_ldb_obj
    {
	DB_STATUS	status;
	i4		err_code;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    (void) psf_error(2086L, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 1,
			     sizeof(ERx("REGISTER INDEX"))-1, 
			     ERx("REGISTER INDEX"));
	    return (E_DB_ERROR);
	}

	status = psl_rg2_reg_distr_idx(cb, $2->pss_orig_obj_name,
	    &$Yxlated_qry, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

reg_gateway_idx:    reg_idx reg_idx_name ON indexrel
		    LPAREN indexcols RPAREN
		    AS IMPORT FROM reg_file_name WITH reg_idx_withopts
    {
	QEU_CB		    *qeu_cb;
	DMU_CB		    *dmu_cb;
	DMU_CHAR_ENTRY	    *chr, *charlim;
	bool		    ssfound = FALSE;
	i4		    sstruct;
	i4                  err_code;
	DB_STATUS	    status;
	i4		    len;
    
	qeu_cb = (QEU_CB *) cb->pss_object;
	dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;

	/*
	** So that we can access the source query text at *pss_bgnstmt in
	** qeu_dbu() in qeus.c, copy it and terminate it with a 0-byte.  Then,
	** use qeu_qtext to point to this string.  This is so the query
	** text can be put into iiqrytext.  Other commands collect the text vis
	** pss_open, pss_tadd, and pss_tout, eventually putting it into
	** pss_tstream in the psy_cb & pointing cb->pss_object at the psy_cb;
	** but historically pss_object is already used here to point to a
	** qeu_cb, so we've gotta pass the string via the qeu_cb.  We don't
	** think *pss_bgnstmt is null-terminated, but we want our copy to be
	** so.
	**
	** The iiqrytext buffer must be one byte longer than the actual
	** actual ddl statement;  otherwise STlcopy may access violate
	** when tagging on the concluding '\0'.
	*/
	len = cb->pss_nxtchar - cb->pss_bgnstmt;
	status = psf_malloc(cb, &cb->pss_ostream, len + 1, 
	    (PTR *) &qeu_cb->qeu_qtext, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	/* Note STlcopy guarentees terminating \0 in destination string */
	STncpy(qeu_cb->qeu_qtext, (char *) cb->pss_bgnstmt, len);
	qeu_cb->qeu_qtext[ len ] = '\0';

        /* Make sure there is a location */
        if (!dmu_cb->dmu_location.data_in_size)
        {
	    /* Default location */
	    STmove("$default", ' ', sizeof(DB_LOC_NAME),
	        (char*) dmu_cb->dmu_location.data_address);
	    dmu_cb->dmu_location.data_in_size = sizeof(DB_LOC_NAME);
        }
        /*
        ** 03-oct-03 (chash01) Here we check that muti-column key will not
        ** have compnents other than char and varchar types. Warning will
        ** be issued for this violation.
        */
        if (dmu_cb->dmu_gw_id == DMGW_RMS)
        {
            DMT_ATT_ENTRY	*attribute;
            DMU_ATTR_ENTRY **idx_att = (DMU_ATTR_ENTRY **)
                                   dmu_cb->dmu_attr_array.ptr_address;

            i4             att_count =
                                   cb->pss_resrng->pss_tabdesc->tbl_attr_count;
            i4             idx_count = dmu_cb->dmu_key_array.ptr_in_count;
            i4 type_abs, i, j, mismatch;

            if (idx_count > 1)
            {
                /*
                ** if more than one column in key definition, they needs
                ** to be of the same char/varchar types, to guarantee the
                ** collating sequence (and sort sequence) is the same.
                */
                mismatch = 0;
                for (i = 0; i < idx_count; i++)
                {
		    /* Used to be an inner loop from 0 to att_count,
		    ** but it always stopped on the 1st iteration. Loop 
		    ** did nothing but cause compiler warning and it has
		    ** now been removed. DNI 30/3/2006 */
                    attribute = pst_coldesc(cb->pss_resrng,
                                                &(idx_att[i]->attr_name));
                    if (attribute)
                    {
                        type_abs = abs(attribute->att_type);
                        switch (type_abs)
                        {
                          case DB_CHR_TYPE:
                          case DB_VCH_TYPE:
                          case DB_CHA_TYPE:
                          case DB_TXT_TYPE:
                              break;
                          default:
                              mismatch = 1;
                              break;
                        }
                    }
                    else
                    {
                        idx_att[i]->attr_name.db_att_name[DB_MAXNAME-1] = EOS;
	                    _VOID_ psf_error(5302L, 0L, PSF_USERERR, &err_code,
	                     &psq_cb->psq_error, 1,
                             STtrmwhite(idx_att[i]->attr_name.db_att_name),
                             idx_att[i]->attr_name.db_att_name);
	                return (E_DB_ERROR);

                    }
                    /*
                    ** once a non char type found in multi-column key
                    ** there is no need to continue, break out the loop
                    ** and emit error/warning message.
                    */
                    if (mismatch)
                        break;
                }
                if (mismatch)
                {
                    char colname[DB_MAXNAME];

                    MEcopy(idx_att[i]->attr_name.db_att_name,
                           (u_i4)DB_MAXNAME, colname);
                    colname[DB_MAXNAME-1] = EOS;
		    psf_error(W_PS1110_REG_TAB_IDX_MULTI_COL,
                                 0L, PSF_USERERR, &err_code,
                                 &psq_cb->psq_error, 1,
                                 STtrmwhite(colname),
                                 colname);
                }
            }

        } 
	/* Find the end of the characteristics array */
	charlim = (DMU_CHAR_ENTRY *)
	    ((char *) dmu_cb->dmu_char_array.data_address
	     + dmu_cb->dmu_char_array.data_in_size);

	/*
	** Check whether storage structure has been specified, if not, specify
	** the session default.
	*/
	for (chr = (DMU_CHAR_ENTRY *) dmu_cb->dmu_char_array.data_address;
	     chr < charlim;
	     chr++
	    )
	{
	    if (chr->char_id == DMU_STRUCTURE)
	    {
		ssfound = TRUE;
		break;
	    }
	}

	if (ssfound == FALSE)
	{
	    /* Two characteristics needed */
	    if (dmu_cb->dmu_char_array.data_in_size >=
		(PSS_MAX_INDEX_CHARS) * sizeof (DMU_CHAR_ENTRY))
	    {
		/* Invalid with clause - too many options */
		(VOID) psf_error(E_PS1103_IDX_TOOMANYOPT, 0L, PSF_USERERR,
                    &err_code, &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	    }

	    chr = (DMU_CHAR_ENTRY *)
		((char *) dmu_cb->dmu_char_array.data_address
		+ dmu_cb->dmu_char_array.data_in_size);
	    chr->char_id = DMU_COMPRESSED;
	    chr->char_value = DMU_C_OFF;
	    chr++;
	    chr->char_id = DMU_STRUCTURE;
	    chr->char_value = cb->pss_idxstruct;
	    dmu_cb->dmu_char_array.data_in_size += sizeof(DMU_CHAR_ENTRY) * 2;
	}

	sstruct = chr->char_value;

	/* Check for legal storage structure */
	if (sstruct == DB_HEAP_STORE || sstruct == DB_SORT_STORE)
	{
	    (VOID) psf_error(5540L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, 
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &dmu_cb->dmu_table_name),
		&dmu_cb->dmu_table_name);
	    return (E_DB_ERROR);
	}
    }
;

reg_idx:	    reg_idx_key
   {
	DB_STATUS	status;

/* schang : change PSQ_INDEX to PSQ_REG_INDEX, this assignment is */
/*	    carried out here instead of inside _index_prefix()    */
/*	    so that we can use this as flag indicating action for */
/*	    registering index or for creating index		  */
								
	/* daveb: treat as gateway unless it's distributed, no error at all */

	psq_cb->psq_mode = PSQ_REG_INDEX;
	cb->pss_object = (PTR) 0;
	cb->pss_save_qeucb = (PTR) 0;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    status = psl_ci2_index_prefix(cb, psq_cb, &$Ywith_clauses, $1);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
	else	/* distributed */
	{
	    status = psl_rg3_reg_tvi(cb, psq_cb);
	}
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

reg_idx_key:        REGISTER INDEX
    {
	$$ = FALSE;
    }
	|	    REGISTER UNIQUE INDEX
    {
	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    i4	err_code;

	    (VOID) psf_error(2033L, 0L, PSF_USERERR, &err_code,
			 &psq_cb->psq_error, 1, sizeof("UNIQUE") +1, "UNIQUE");
	    return (E_DB_ERROR);
	}
	$$ = TRUE;
    }

;

reg_idx_name:	    obj_spec
    {
	DB_STATUS		status;
/* BB_FIX_ME: We can get rid of error PS1101_REG_NOLOC now */

	/* test registered name for reserved name
	 */
	if (PSL_IS_RESERVED_IDENT($1->pss_orig_obj_name, cb, psq_cb, TRUE))
	    return(E_DB_ERROR);

	/* daveb: treat at gateway unless STAR, no error possible */

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    status = psl_ci5_indexlocname(cb, (char *) NULL, $1, 
		&$Ywith_clauses, psq_cb);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
	else	/* distributed */
	{
	    /*
	    ** BB_FIX_ME: Not sure what Star should call.  Decide
	    ** when REGISTER INDEX is finally implemented in Star.
	    */
	}
    }
;

as_link:  	    AS nonkeyword
    {
	/* Star indexes must be registered AS LINK */
	if (STcompare($2, "link"))
	{
	    i4	    err_code;
	    
	    (VOID) psf_error(2033L, 0L, PSF_USERERR, &err_code,
			     &psq_cb->psq_error, 1,STlength($2), $2);
	    return (E_DB_ERROR);
	}
    }
;

reg_idx_withopts:   reg_idx_withopt
	|	    reg_idx_withopts COMMA reg_idx_withopt
;

/*
** AK> have you considered merging it with psl_nm_eq_nm()? And another thing:
** AK> it has been decided that we will disallow specification of the same
** AK> characteristic more than once.  This applies to CREATE TABLE, MODIFY, and
** AK> INDEX.  It would probably make sense to enforce this rule for GW
** AK> statements as well.  And yet another thing, were you planning to replace
** AK> CREATE INDEX error messages with new and improved REGISTER INDEX
** AK> messages?
*/
reg_idx_withopt:    nonkeyword EQUAL nonkeyword
    {
	i4             err_code;
	QEU_CB		    *qeu_cb;
	DMU_CB		    *dmu_cb;
	DMU_CHAR_ENTRY	    *chr;
	i4		    storestruct;

	if (STcompare($1, "structure") == 0)
	{
	    /* Decode storage structure name.  Error if unknown */
	    if (!STcasecmp($3, "keyed"))
	    {
		storestruct = DB_ISAM_STORE;
	    }
	    else if (!STcasecmp($3, "fullkey"))
	    {
		storestruct = DB_HASH_STORE;
	    }
	    else if (!STcasecmp($3, "sortkeyed"))
	    {
		storestruct = DB_BTRE_STORE;
	    }
	    else
	    {
		(VOID) psf_error(E_PS1104_IDX_BADSTRUCT, 0L, PSF_USERERR,
                          &err_code, &psq_cb->psq_error, 1,
                          (i4) STtrmwhite($3), $3);
		return (E_DB_ERROR);    /* non-zero return means error */
	    }

	    qeu_cb = (QEU_CB *) cb->pss_object;
	    dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;

	    /* Put the storage structure info in the characteristics array. */

	    if (dmu_cb->dmu_char_array.data_in_size >=
		PSS_MAX_INDEX_CHARS * sizeof (DMU_CHAR_ENTRY))
	    {
		/* Invalid with clause - too many options */
		(VOID) psf_error(5327L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	    }

	    chr = (DMU_CHAR_ENTRY *) 
		((char *) dmu_cb->dmu_char_array.data_address
		+ dmu_cb->dmu_char_array.data_in_size);

	    chr->char_id = DMU_STRUCTURE;
	    chr->char_value = storestruct;
	    dmu_cb->dmu_char_array.data_in_size += sizeof(DMU_CHAR_ENTRY);

	}
	else
	{
	    (VOID) psf_error(E_PS1105_IDX_WITHINVAL, 0L, PSF_USERERR,
                      &err_code, &psq_cb->psq_error, 1,
                      (i4) STtrmwhite($1), $1);

	    return (E_DB_ERROR);
	}
    }
;

dircon:		    dircon_prefix ldb_spec
    {
	if (psq_cb->psq_mode == PSQ_DIRDISCON)
	{
	    /*
	    ** if "DIRECT DISCONNECT" was entered, return error
	    ** since, if seen here, was entered
	    ** while NOT in "direct connect" mode.)
	    */
	    return(E_DB_ERROR);
	}
    }
;

dircon_prefix:	    nonkeyword nonkeyword
    {
	DB_STATUS		status;

	status = psl_ds1_dircon(psq_cb, $1, $2,
			cb->pss_distrib & DB_3_DDB_SESS);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

dir_exec_immed:     dir_exec_immed_prefix ldb_spec
;

dir_exec_immed_prefix:	    nonkeyword EXECUTE IMMEDIATE SCONST
    {
	DB_STATUS		status;

	status = psl_ds2_dir_exec_immed($1, cb->pss_distrib & DB_3_DDB_SESS,
			sconvert($4), cb, psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

/****************************************************************************
** 
** GENERIC RULES							@RH@
**
** These rules are "generic" in that they are referenced by several
** productions from different statements, but serve a common purpose.
** They include:
**
**	nonkeyword		same as NAME; used to distinguish non-keywords
**				in the grammar
**
**	name_or_sconst		Use for any constant; not valid for identifiers
**
**	generic_ident		any user-defined object
**
**	internal_ident		same as generic_ident, but may also include
**				SCONST
**
**	sconst_ident		same is internal_ident, but doesn't check
**                              length of SCONST, used in WITH-clauses where
**                              need more context to verify length limits.
**
**  auth_ident      same as internal_ident; used to distinguish
**              authorization identifiers
**
**	user_ident		same as auth_ident, but may also include
**				$dba or $ingres
**
**	schema_spec		same as user_ident; used to distinguish
**				schema identifiers
**
**	obj_spec		generic object specification
**	
**	tbl_spec		same as generic_ident; used to distinguish
**				table names
**	
**	col_spec		same as generic_ident; used to distinguish
**				column names
**
*****************************************************************************/

nonkeyword:	    NAME
    {
	char	    *letter;
	/*
	** Translate nonkeywords to lower case unless regular identifiers are 
	** always lowercased
	*/
	if (~*cb->pss_dbxlate & CUI_ID_REG_L)
	{
	    for (letter =  $1; *letter != EOS; CMnext(letter))
	        CMtolower(letter, letter);
	}

	$Yid_type = PSS_ID_NONKEY;
	$$ = $1;
    }
;

nonkey_or_sconst:   NAME
    {
	char	    *letter;
	/*
	** Translate nonkeywords to lower case unless regular identifiers are 
	** always lowercased
	*/
	if (~*cb->pss_dbxlate & CUI_ID_REG_L)
	{
	    for (letter =  $1; *letter != EOS; CMnext(letter))
	        CMtolower(letter, letter);
	}

	$Yid_type = PSS_ID_NONKEY;
	$$ = $1;
    }
	    |       SCONST
    {
	$Yid_type = PSS_ID_SCONST;
	$$ = sconvert($1);
    }
;


name_or_sconst:	    NAME
    {
	$Yid_type = PSS_ID_REG;
	$$ = $1;
    }
	    |	    SCONST
    {
	$Yid_type = PSS_ID_SCONST;
	$$ = sconvert($1);
    }
;

/*
** generic identifier shall be used for any user-defined object;
** generic identifier can be either a NAME or DELIM_IDENT
*/
generic_ident:	    NAME
    {
	$Yid_type = PSS_ID_REG;
	$$ = $1;
    }
             |      DELIM_IDENT
    {
	$Yid_type = PSS_ID_DELIM;
	$$ = $1;
    }
;
/*
** sconst ident is used for cases where either a generic ident or
** a (long) string constant may be used, typically in a WITH-clause
** where later processing will check the length when we have more context.
*/
sconst_ident:     generic_ident
    {
        $$ = $1;
    }
                |   SCONST
    {
	$Yid_type = PSS_ID_SCONST;
        $$ = sconvert($1);
    }
;

/*
** internal ident shall be used for gateway identifiers.
** these may include generic_idents, as well as SCONSTs.
** the latter is use to prevent case translation in all
** environments.
*/
internal_ident:     generic_ident
    {
        $$ = $1;
    }
                |   SCONST
    {
        /* first, make sure the string is not too long */
        if ($1->db_t_count > DB_MAXNAME)
        {
            i4     err_code;
            i4          max_len = DB_MAXNAME;

            (VOID) psf_error(E_PS0353_NAME_STRING_TOO_LONG, 0L, PSF_USERERR,
                &err_code, &psq_cb->psq_error, 2,
                $1->db_t_count, $1->db_t_text,
                sizeof(max_len), &max_len);
            return (E_DB_ERROR);
        }

	$Yid_type = PSS_ID_SCONST;
        $$ = sconvert($1);
    }
;

/*
** Authorization identifier can be an "internal identifier"
**	was "generic ident", but needs SCONST for backwards
**	compatibility
*/
auth_ident: internal_ident
    {
        $$ = $1;
	/* if a single-quoted identifier was used,
	** do some special processing
	*/
	if ($Yid_type == PSS_ID_SCONST)
	{
		char		temp[DB_MAXNAME+1];
		DB_STATUS	status;

		/* if we are storing query text for the catalogs
		** remove/replace single-quotes
		*/
		if (cb->pss_stmt_flags & PSS_TXTEMIT) 
		{
		    status = psl_remove_single_quotes(cb->pss_tchain,
					  $1, &psq_cb->psq_error);
		    if (DB_FAILURE_MACRO(status))
			return(status);
	    	}
		/* Make sure that identifier is not blank bug 79275 */
		if (STzapblank($1, temp) == 0)
		{
		    switch (psq_cb->psq_mode) 
		    {
			case PSQ_CUSER :
		      	    (void) psl_sx_error(3825L, cb, psq_cb);
			    break;
		    	case PSQ_AUSER :
		      	    (void) psl_sx_error(3826L, cb, psq_cb);
			    break;
		    	case PSQ_CAPLID :
		      	    (void) psl_sx_error(3817L, cb, psq_cb);
			    break;
		    	case PSQ_AAPLID :
		      	    (void) psl_sx_error(3818L, cb, psq_cb);
			    break;
		    	case PSQ_KAPLID :
		      	    (void) psl_sx_error(3819L, cb, psq_cb);
			    break;
		    	case PSQ_CGROUP :
		      	    (void) psl_sx_error(3813L, cb, psq_cb);
			    break;
		    	case PSQ_AGROUP :
		      	    (void) psl_sx_error(3814L, cb, psq_cb);
			    break;
		    	case PSQ_KGROUP :
		      	    (void) psl_sx_error(3816L, cb, psq_cb);
			    break;
		    	case PSQ_CREATE_SCHEMA :
		      	    (void) psl_sx_error(3851L, cb, psq_cb);
			    break;
			default :
			    /* Anything I missed */
			    break;
		    }
		    return(E_DB_ERROR);
		}

	}  /* end if (id_type == PSS_ID_SCONST) */

    }
;
/*
** user identifier can be either a "generic_ident," $dba, or $ingres
** 11-mar-93 (andre)
**	VERY IMPORTANT: any non-terminal on the RHS of schema_spec production
**	(currently this means user_ident) must be expanded in-line in the
**	col_ref production.  Any changes made to non-terminals on the RHS of
**	schema_spec production must be propagated to the col_ref production.
**	The goal is to avoid having YACC decide whether a given identifier is a
**	<schema name> in <schema>.<table>.<column> construct or <table name> in
**	<table>.<column construct
*/
/*@FIX_ME@ - Grandfather SCONST user identifiers until 6.6
user_ident:	auth_ident
*/
user_ident:	internal_ident
    {
	DB_STATUS	status;
	i4	        val1,val2;

	/* if a single-quoted identifier was used,
	** do some special processing
	*/
	if ($Yid_type == PSS_ID_SCONST)
	{
	    /* return an error if a single-quoted identifier was used
	    ** AND either
	    ** 	    trace point PS251 is set, OR
	    ** 	    one of the following new 6.5 commands is being used:
	    ** 		COMMENT ON
	    ** 		CREATE/ALTER/DROP USER
	    ** 		CREATE SYNONYM
	    ** 		REFERENTIAL CONSTRAINTS (this is actually caught in
	    ** 		                         the psl_ct19s_constraint())
	    */
	    if (   (psq_cb->psq_mode == PSQ_COMMENT)
		|| (psq_cb->psq_mode == PSQ_CUSER)
		|| (psq_cb->psq_mode == PSQ_AUSER)
		|| (psq_cb->psq_mode == PSQ_KUSER)
		|| (psq_cb->psq_mode == PSQ_CSYNONYM)
		|| (psq_cb->psq_mode == PSQ_ALTERTABLE)
		|| (ult_check_macro(&cb->pss_trace,
				 PSS_NO_SINGLE_QUOTED_IDS, &val1, &val2)))
	    {
		(void) psl_sx_error(2715L, cb, psq_cb);
		return(E_DB_ERROR);
	    }
	
	    /* if we are storing query text for the catalogs
	    ** remove/replace single-quotes
	    */
	    if (cb->pss_stmt_flags & PSS_TXTEMIT) 
	    {
		status = psl_remove_single_quotes(cb->pss_tchain,
						  $1, &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return(status);
	    }
	}  /* end if (id_type == PSS_ID_SCONST) */

	$$ = $1;
    }
	  |	DBA
    {
	$Yid_type = PSS_ID_DBA;
	$$ = cb->pss_dbaname;
    }
	  |	INGRES
    {
	bool		upcase = ((*cb->pss_dbxlate & CUI_ID_REG_U) != 0);

	$Yid_type = PSS_ID_INGRES;
	/*@FIX_ME@  I don't like this -- should use pss_cat_owner? */
	$$ = (upcase ? "$INGRES" : "$ingres");
    }
;

/*
** schema_spec is an alias for user_ident
**
** 11-mar-93 (andre)
**	VERY IMPORTANT: any non-terminal on the RHS of schema_spec production
**	must be expanded in-line in the col_ref production.  Any changes made to
**	schema_spec production or any non-terminals on the RHS of schema_spec
**	production must be propagated to the col_ref production.  The goal is to
**	avoid having YACC decide whether a given identifier is a <schema name>
**	in <schema>.<table>.<column> construct or <table name> in
**	<table>.<column construct
*/
schema_spec:	user_ident
    {
	if ($Yid_type == PSS_ID_DELIM)
	    cb->pss_distr_sflags |= PSS_DELIM_OWNNAME;

	/* remember type of identifier used to represent schema name */
	$Yschema_id_type = $Yid_type;

	$$ = $1;
    }
;

/*
** tbl_spec is an alias for generic_ident
*/
tbl_spec:	generic_ident
    {
	$$ = $1;
    }
;

/*
** col_spec is an alias for generic_ident
*/
col_spec:	generic_ident
    {
	if (PSL_IS_RESERVED_IDENT($1, cb, psq_cb, FALSE))
	    return(E_DB_ERROR);
	
	$$ = $1;
    }
;

/*
** IMPORTANT: I was unable to use obj_spec on the RHS of comment_col because it
**	      would result in reduce/reduce conflict.  If some changes are made
**	      to the definition of what constitutes a valid object
**	      specification, it will have to be propagated to COMMENT_COL
**	      production.
**
** If the statement being parsed is MODIFY, it's possible that the
** alternate keyword set is turned on -- beware.
*/
obj_spec:	    generic_ident
    {
	STmove($1, ' ', sizeof(DB_TAB_NAME), (char *) &$Yobj_spec.pss_obj_name);
	MEfill(sizeof(DB_OWN_NAME), ' ', (PTR) &$Yobj_spec.pss_owner);

	$Yobj_spec.pss_objspec_flags = 0;

	$Yobj_spec.pss_orig_obj_name = $1;

	/* remember type of identifier representing object name */
	$Yobj_spec.pss_obj_id_type = $Yid_type;

	$Yobj_spec.pss_schema_id_type = 0;

	if ($Yid_type == PSS_ID_DELIM)
	{
	    cb->pss_distr_sflags |= PSS_DELIM_TBLNAME;		
	}
	
	$$ = &$Yobj_spec;
    }
	    |	    schema_spec PERIOD generic_ident
    {
	/* If we're in alternate keywords, "schema spec" might be
	** "session." -- if so, take appropriate actions.
	*/
	STmove($3, ' ', sizeof(DB_TAB_NAME), (char *) &$Yobj_spec.pss_obj_name);
	if (STcompare($1,"session") == 0)
	{
	    STRUCT_ASSIGN_MACRO(cb->pss_sess_owner, $Yobj_spec.pss_owner);
	    $Yobj_spec.pss_objspec_flags = 
			PSS_OBJSPEC_EXPL_SCHEMA | PSS_OBJSPEC_SESS_SCHEMA;
	    $Yobj_spec.pss_schema_id_type = PSS_ID_DELIM;
	    if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
			$3, &psq_cb->psq_error))
	    {
		return(E_DB_ERROR);
	    }
	    cb->pss_stmt_flags |= PSS_HAS_DGTT;
	}
	else
	{
	    /* Not session. */
	    STmove($1, ' ', sizeof(DB_OWN_NAME), (char *) &$Yobj_spec.pss_owner);
	    $Yobj_spec.pss_objspec_flags = PSS_OBJSPEC_EXPL_SCHEMA;
	    $Yobj_spec.pss_schema_id_type = $Yschema_id_type;
	}

	/* remember types of identifiers representing schema and object names */
	$Yobj_spec.pss_obj_id_type = $Yid_type;

	$Yobj_spec.pss_orig_obj_name = $3;

	if ($Yid_type == PSS_ID_DELIM)
	{
	    cb->pss_distr_sflags |= PSS_DELIM_TBLNAME;		
	}
	
	$$ = &$Yobj_spec;
    }
	    |	    SESSION PERIOD generic_ident
    {
	/*
	** temporary table references are always spelled SESSION.t, where
	** any reference to SESSION.t is equivalent to a reference to U.t, where
	** U is the implementation-dependent internal schema name in which the
	** declared local temporary table exists.
	*/

	STRUCT_ASSIGN_MACRO(cb->pss_sess_owner, $Yobj_spec.pss_owner);
	STmove($3, ' ', sizeof(DB_TAB_NAME), 
	       $Yobj_spec.pss_obj_name.db_tab_name);

	$Yobj_spec.pss_objspec_flags = 
	    PSS_OBJSPEC_EXPL_SCHEMA | PSS_OBJSPEC_SESS_SCHEMA;

	$Yobj_spec.pss_orig_obj_name = $3;

	/* 
	** remember type of identifier representing object name - to represent
	** "session" schema, delimited identifier must always be used.
	*/
	$Yobj_spec.pss_schema_id_type = PSS_ID_DELIM;
	$Yobj_spec.pss_obj_id_type = $Yid_type;

	if ($Yid_type == PSS_ID_DELIM)
	{
	    cb->pss_distr_sflags |= PSS_DELIM_TBLNAME;		
	}
	
	if (!psl_valid_session_schema_use(psq_cb->psq_mode, cb,
		$Yobj_spec.pss_orig_obj_name, &psq_cb->psq_error))
	{
	    return(E_DB_ERROR);
	}
    /*
	** flag presence, so can tinker with alias id
	** for repeat queries
	*/
	cb->pss_stmt_flags |= PSS_HAS_DGTT;

	$$ = &$Yobj_spec;
    }
;

/*[@yacc_rule@]*//*...*/

%%


/*{
** Name: chkcnst: - Checks whether an expression is equivalent to a constant.
**
** Description:
**      For some SQL statements list elements can be entered as expressions
**	of constants (including scalar functions).
**	This routine checks the subtree to ensure that the represented
**	expression can be considered a constant.
**
** Inputs:
**      Pointer to the root of the subtree.
**
** Outputs:
**	Returns:
**	    Status.
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**	11-feb-87 (stec)
*/
static DB_STATUS
chkcnst(
	PST_QNODE *tp)
{
    DB_STATUS	    status;

    if (tp != (PST_QNODE *) NULL)
    {
	/* check left child */
	status = chkcnst(tp->pst_left);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/* check right child */
	status = chkcnst(tp->pst_right);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/* check self */
	if (tp->pst_sym.pst_type == PST_VAR)
        {
	    return (E_DB_ERROR);
	}
    }

    return (E_DB_OK);
}

/*
** PSL_FATT - find attribute in range table.
** If (fatt_flag & FIND_ONLY)
** {
**     try to find attribute.
**     if not found, just return
**     do not report errors through psf_error
** else
** {
**     if (fatt_flag & ALLOC_NODE)
**     {
**         allocate VAR node
**     }
**     fill in the node
**     do report errors.
** }
**
** History:
**	    unknown (someone)
**		written
**	    24-jul-89 (andre)
**		modified to pass a flag rather than a bool, so that more info
**		can be passed.  Also, remove the line that would set *node to
**		NULL, since sometimes this may result in a perfectly legitimate
**		node being wiped out, and there is no reason at all to do it.
**	    21-sep-89 (andre)
**		For some cases we only want to look for attributes in a subset
**		of relations.  If so, *rel_mask will contain mask of acceptable
**		relations.
**	    07-may-93 (andre)
**		produce a separate "column not found" message if processing a
**		CHECK constraint.
**	26-nov-02 (inkdo01)
**	    Range table expansion (i4 becomes PST_J_MASK).
*/
DB_STATUS
psl_fatt(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	i4		same_scope,
	DB_ATT_NAME 	*att_name,
	PST_QNODE	**node,
	PSS_RNGTAB	**rngvarp,
	i4 		fatt_flag,
	PST_J_MASK	*rel_mask)
{
    DMT_ATT_ENTRY	*attribute;
    DMT_ATT_ENTRY	*t_attribute;
    PST_VAR_NODE	varnode;
    i4		err_code;
    DB_STATUS	        status;
    PSS_RNGTAB		*t_rngvar;
    PSS_RNGTAB		*rngvar;
    i4		        att_c_match_count = 0;
    i4			att_l_match_level = 0;
    i4			i;

    /* for each variable, look up the column name */
    for (i = 0; i < PST_NUMVARS; i++)
    {
	t_rngvar = &cb->pss_auxrng.pss_rngtab[i];
	/* only examine if used */
	if (!t_rngvar->pss_used || t_rngvar->pss_rgno < 0)
	    continue;
	/*
	** If use of mask is specified, only examine the relation if a bit
	** corresponding to it is set in rel_mask
	*/
	if (fatt_flag & JOINREL_MASK    &&
	    !BTtest((i4) t_rngvar->pss_rgno, (char *) rel_mask))
	{
	    continue;
	}
	/* if processing target list, must be at our scope */
	if (same_scope && t_rngvar->pss_rgparent != cb->pss_qualdepth)
	    continue;
	/* In general must be at our scope or greater */
	if (t_rngvar->pss_rgparent > cb->pss_qualdepth)
	    continue;
	/* Look up the attribute */
	t_attribute = pst_coldesc(t_rngvar, att_name);

	/* If attribute found, remember it, the range var, and the scope */
	if (t_attribute != (DMT_ATT_ENTRY *) NULL)
	{
	    /* if first one, remember it */
	    if (att_c_match_count == 0)
	    {
		att_c_match_count++;
		att_l_match_level = t_rngvar->pss_rgparent;
		attribute   = t_attribute;
		rngvar	    = t_rngvar;
		continue;
	    }
	    /* if at higher scope than than current, ignore */
	    if (t_rngvar->pss_rgparent < att_l_match_level)
		continue;
	    /* if at lower scope, use the lower scope */
	    if (t_rngvar->pss_rgparent > att_l_match_level)
	    {
		att_c_match_count = 1;
		att_l_match_level = t_rngvar->pss_rgparent;
		attribute   = t_attribute;
		rngvar	    = t_rngvar;
		continue;
	    }		
	    /* we must be at same level.
	    ** This is a problem only if the range definition differs from
	    ** our current one.
	    */
	    if (MEcmp(rngvar->pss_rgname, t_rngvar->pss_rgname, DB_MAXNAME) ||
		MEcmp(rngvar->pss_tabname.db_tab_name, 
		      t_rngvar->pss_tabname.db_tab_name, DB_MAXNAME))
	    {
		att_c_match_count++;
	    }
	}
    }

    /* Check for attribute not found */
    if (att_c_match_count == 0)
    {
	if (~fatt_flag & FIND_ONLY)
	{
	    if (fatt_flag & JOINREL_MASK)
	    {
		/*
		** we ARE processing join_search condition and the user tried
		** to refer to a column not found in left or right relations
		*/
		(VOID) psf_error(E_PS03A3_COL_NOT_IN_JREL, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2,
		    (i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME, att_name->db_att_name),
		    att_name->db_att_name);
		return(E_DB_ERROR);
	    }
	    else if (cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS)
	    {
		char        command[PSL_MAX_COMM_STRING];
		i4     length;

		psl_command_string(psq_cb->psq_mode, DB_SQL, command, &length);

		_VOID_ psf_error(E_PS0483_CONS_NO_COL, 0L,
		    PSF_USERERR, &err_code, &psq_cb->psq_error, 3,
		    length, command,
		    psf_trmwhite(DB_MAXNAME, att_name->db_att_name),
		    att_name->db_att_name,
		    sizeof(ERx("CHECK")) - 1, ERx("CHECK"));
	    }
	    else
	    {
		(VOID) psf_error(2102L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 2, (i4) sizeof(cb->pss_lineno),
		    &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME, att_name->db_att_name),
		    att_name->db_att_name);
	    }
	}
	return (E_DB_ERROR);
    }

    /* Check for too many attributes - ambiguous attribute */
    if (att_c_match_count > 1)
    {
	if (~fatt_flag & FIND_ONLY)
	{
	    (VOID) psf_error(2101L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, (i4) sizeof(cb->pss_lineno),
		&cb->pss_lineno,
		psf_trmwhite(DB_MAXNAME, att_name->db_att_name),
		att_name->db_att_name);
	}
	return (E_DB_ERROR);
    }
	    
    /*
    ** Search was successful, we found exactly one var. with this
    ** attribute name for this scope.
    */
    *rngvarp = rngvar;

    if (~fatt_flag & FIND_ONLY)
    {
	/* Set up var node for copy into tree */
	varnode.pst_vno = rngvar->pss_rgno;
	varnode.pst_atno.db_att_id = attribute->att_number;
	STRUCT_ASSIGN_MACRO(*att_name, varnode.pst_atname);

	/* Create the node */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_VAR, (char *) &varnode, sizeof(varnode),
	    (DB_DT_ID) attribute->att_type, (i2) attribute->att_prec,
	    (i4) attribute->att_width, (DB_ANYTYPE *) NULL, node,
	    &psq_cb->psq_error,
	    (fatt_flag & ALLOC_NODE) ? (i4) 0 : PSS_NOALLOC);
	if (DB_FAILURE_MACRO(status))
	    return (status);
	(*node)->pst_sym.pst_dataval.db_collID = attribute->att_collID;
    }

    return (E_DB_OK);
}

/*
** psl_subsel	-- verify that the subselect node is legal
**
**  Description:
**	Verify that this is a legal subselect (only one select element).
**	Also, set the data type and length to that of the underlying
**	resdom.
**
**  History
**	27-feb-87 (daved)
**	    written
*/
DB_STATUS
psl_subsel(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PST_QNODE	*subnode)
{
    DB_DATA_VALUE	*d1;
    DB_DATA_VALUE	*d2;
    i4		err_code;

    /* perform check */
    if (subnode->pst_left && subnode->pst_left->pst_left &&
          subnode->pst_left->pst_left->pst_sym.pst_type != PST_TREE)
    {
	(VOID) psf_error(2916L, 0L, PSF_USERERR, &err_code, &psq_cb->psq_error, 1,
	    (i4) sizeof(cb->pss_lineno), &cb->pss_lineno);
	return (E_DB_ERROR);
    }
    d1 = &subnode->pst_sym.pst_dataval;
    d2 = &subnode->pst_left->pst_sym.pst_dataval;
    STRUCT_ASSIGN_MACRO(*d2, *d1);

    cb->pss_stmt_flags |= PSS_SUBINTREE; /* pss_subintree = TRUE */
    
    return (E_DB_OK);
}

/*
** PSL_ORDGROUP - processes group list element consisting of constant value
**	(which must be ordinal select list expression number). Verifies
**	existence of "nth" select list entry and copies to group list in
**	place of constant node.
*/
DB_STATUS psl_ordGroup(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PST_QNODE	*gptr,
	PST_QNODE	*tlist)

{
    i4		targnum;
    PST_QNODE	*cptr = gptr->pst_right;
    PST_QNODE	*tptr;
    PSS_DUPRB	dup_rb;
    DB_STATUS	status;
    bool	found = FALSE;

    if (cptr->pst_sym.pst_dataval.db_datatype == DB_INT_TYPE &&
	cptr->pst_sym.pst_dataval.db_data != NULL)
    switch (cptr->pst_sym.pst_dataval.db_length) {
      case 1:
	targnum = *((i1 *)cptr->pst_sym.pst_dataval.db_data);
	break;

      case 2:
	targnum = *((i2 *)cptr->pst_sym.pst_dataval.db_data);
	break;

      case 4:
	targnum = *((i4 *)cptr->pst_sym.pst_dataval.db_data);
	break;
    }
    else return(E_DB_ERROR);

    /* Got the ordinal number. Now search the target list for it. */
    for (tptr = tlist; tptr && tptr->pst_sym.pst_type == PST_RESDOM;
					tptr = tptr->pst_left)
     if (tptr->pst_sym.pst_value.pst_s_rsdm.pst_rsno == targnum) 
     {
	found = TRUE;
	break;
     }

    if (!found) return(E_DB_ERROR);

    /* If there's an agg in the expression, treat it just like a 
    ** constant - in the manner of the big O. We simply leave the original
    ** ordinal constant in the group by list and it will effectively
    ** do nothing. */
    if (psl_agginExpr(tptr->pst_right))
	return(E_DB_OK);

    if (tptr->pst_right->pst_sym.pst_type == PST_AGHEAD)
    {
       /* b109012, the group by expression contains an aggregate */
       psq_cb->psq_error.err_code = E_PS03AB_AGGR_IN_GROUP_BY;
       return (E_DB_ERROR);
    }

    /* Found the expression - now copy it to replace original constant in
    ** group list. */

    dup_rb.pss_op_mask = 0;
    dup_rb.pss_num_joins = PST_NOJOIN;
    dup_rb.pss_tree_info = (i4 *) NULL;
    dup_rb.pss_mstream = &cb->pss_ostream;
    dup_rb.pss_err_blk = &psq_cb->psq_error;
    dup_rb.pss_tree = tptr->pst_right;
    dup_rb.pss_dup = &gptr->pst_right;

    status = pst_treedup(cb, &dup_rb);

    STRUCT_ASSIGN_MACRO(tptr->pst_sym.pst_dataval, gptr->pst_sym.pst_dataval);
					/* copy dataval to group list */
    return(status);
}

/* PSL_AGGINEXPR - returns TRUE if a PST_AGHEAD is found in the given
**	expression parse tree.
*/
static bool psl_agginExpr(PST_QNODE	*nodep)
{
    if (nodep != (PST_QNODE *) NULL &&
	(nodep->pst_sym.pst_type == PST_AGHEAD || 
	 nodep->pst_sym.pst_type == PST_AOP))
	return(TRUE);

    if (nodep->pst_left && psl_agginExpr(nodep->pst_left))
	return(TRUE);
    else if (nodep->pst_right)
	return(psl_agginExpr(nodep->pst_right));
    else return(FALSE);
}

/*
** PSL_TINGX - returns DBSTATUS E_DB_OK if target list expression matches some 
**	entry in group list. Expressions must match in every way, except that
**	constants may not have to be equal. An enhancement to make Ingres behave
**	like DB/2 would be to allow the select list entry to include the group by
**	expression in some other constant-based expression, but with no other 
**	columns. E.g. select a+b -25 ... group by a+b ...
*/
DB_STATUS psl_tingx(PST_QNODE	*targ,
	PST_QNODE		*groupex,
	bool			top)

{
    bool	started_here = top;	/* TRUE - if current group expression
					** examination started at this recursion
					** level */
    DB_STATUS	status;


    /* The function simply compares the target expression and group list 
    ** expression, node by node. If a mismatch is found, we return to the 
    ** start point of the current examination (where started_here is TRUE).
    ** This will be the top of the target expression, and from there, we restart
    ** the examination one level down (one nesting level deeper) in the group 
    ** expression. */

    if (targ == NULL && groupex == NULL) return(E_DB_OK);
					/* at bottom, and all matched */
    if (targ && targ->pst_sym.pst_type == PST_CONST) return(E_DB_OK);
					/* constants are ok */
    if (targ == NULL || groupex == NULL ||
	targ->pst_sym.pst_type != groupex->pst_sym.pst_type) return(E_DB_ERROR);
					/* simple rejection tests */

    /* Non-null nodes and they're the same type. Now do type-specific checks. */

    switch (targ->pst_sym.pst_type) {
      case PST_BOP:
      case PST_UOP:
      case PST_AND:
      case PST_OR:
	if (targ->pst_sym.pst_value.pst_s_op.pst_opno !=
		groupex->pst_sym.pst_value.pst_s_op.pst_opno) return(E_DB_ERROR);
      case PST_CASEOP:
      case PST_MOP:
      case PST_OPERAND:
      case PST_WHLIST:
      case PST_WHOP:
	/* Check target/group expression recursively. */
	status = psl_tingx(targ->pst_left, groupex->pst_left, FALSE);
	if (status == E_DB_OK) status = psl_tingx(targ->pst_right, 
						groupex->pst_right, FALSE);
	break;

      case PST_VAR:
	if (targ->pst_sym.pst_value.pst_s_var.pst_vno ==
		groupex->pst_sym.pst_value.pst_s_var.pst_vno &&
	    targ->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id ==
		groupex->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id)
	 status = E_DB_OK;
	else status = E_DB_ERROR;
	break;

      case PST_CONST:
	status = E_DB_OK;
	break;

      default:
	status = E_DB_ERROR;
	break;
    }	/* end of node type switch */

    /* Ok so far. Just return computed status. */

    return(status);

}	/* end of psl_tingx */

/*
** PSL_TING  - boolean returning OK if target list exists in group by list
*/
DB_STATUS
psl_ting(
	PST_QNODE	*targ,
	PST_QNODE	*group)
{
    DB_STATUS		    status = E_DB_OK;
    register PST_QNODE	    *ptr;

    if (targ == (PST_QNODE*) NULL || targ->pst_sym.pst_type == PST_AGHEAD)
	status = E_DB_OK;
    /* check var nodes */
    else if (targ->pst_sym.pst_type == PST_VAR)
    {
	status = E_DB_ERROR;
	for (ptr = group; ptr && ptr->pst_sym.pst_type == PST_RESDOM &&
		status == E_DB_ERROR; ptr = ptr->pst_left)
	{
	    if (ptr->pst_right->pst_sym.pst_type == PST_VAR &&
		targ->pst_sym.pst_value.pst_s_var.pst_vno ==
		ptr->pst_right->pst_sym.pst_value.pst_s_var.pst_vno 
		&&
		targ->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id ==
		ptr->pst_right->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id
	    )
		status = E_DB_OK;
	}
    }
    else if (targ->pst_left || targ->pst_right)
    {
	/* for each target list element, ensure that it is in group list. If
	** target element is NOT a simple column reference, make a quick pass
	** through the group list looking for a group expression. They require
	** trickier validation than column reference group elements. */
	if (targ->pst_sym.pst_type != PST_RESDOM)
					/* !RESDOM, !VAR - must be expression */
	{
	    for (ptr = group; ptr && ptr->pst_sym.pst_type == PST_RESDOM;
						ptr = ptr->pst_left)
	     if (ptr->pst_right->pst_sym.pst_type != PST_VAR &&
		psl_tingx(targ, ptr->pst_right, TRUE) == E_DB_OK) return(E_DB_OK);

	    /* If we get here, there was no match for the target entry amongst the
	    ** group by list. Last chance is to check if it is a "constant" 
	    ** expression (constants and aggregates). */
	    return(psl_constx(targ, group));
	}
	
	/* Target node is RESDOM, so we're still going down the list. Recurse on
	** next RESDOM, then recurse on actual target expression. */
	status = psl_ting(targ->pst_left, group);
	if (status == E_DB_OK)
	    status = psl_ting(targ->pst_right, group);
    }
    return (status);
}

/*
** psl_constx()	- search expression for constants and aggregates ONLY. 
**
** Description: Given expression doesn't match anything in group by list. Last
**		chance is to assure that it is an expression involving only
**		constants and aggregates.
**
** Input:
**		expr - PST_QNODE ptr to subtree being checked.
**		group - root of RESDOMs of group by list
**
** Output:
**	None
**
** Returns:
**	status of search (E_DB_OK means expression is ok)
**
** History:
**	28-oct-99 (inkdo01)
**	    Written.
*/

DB_STATUS
psl_constx(
	PST_QNODE	*expr,
	PST_QNODE	*group)

{
    PST_QNODE	*varp, *ptr;
    DB_STATUS	status = E_DB_OK;

    /* Recursively descend the parse tree, looking for operators, constants 
    ** or PST_AGHEADs. Anything else is illegal. */

    switch (expr->pst_sym.pst_type) {

      case PST_AGHEAD:
      case PST_CONST:
	return(E_DB_OK);
      case PST_VAR:
	/* If a column is in the expression, it better also be in the 
	** group by list. */
	status = E_DB_ERROR;
	for (ptr = group; ptr && ptr->pst_sym.pst_type == PST_RESDOM;
		ptr = ptr->pst_left)
	 if ((varp = ptr->pst_right)->pst_sym.pst_type == PST_VAR &&
		expr->pst_sym.pst_value.pst_s_var.pst_vno ==
		 varp->pst_sym.pst_value.pst_s_var.pst_vno &&
		expr->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id ==
		 varp->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id)
	 {
	    status = E_DB_OK;
	    break;
	 }
	return(status);
      default:
	if (expr->pst_left) status = psl_constx(expr->pst_left, group);
	if (status != E_DB_OK) return(status);
	if (expr->pst_right) return(psl_constx(expr->pst_right, group));
	return(E_DB_OK);
    }

}

/*
** psl_find_node()  - find a node of specified type in a tree.
**
** Description: Given a pointer to a tree, find a node of specified type.
**		Once the first node has been located, search will be terminated.
** Input:
**	node	- root of a tree
**	type    - node type
**
** Output:
**	None
**
** Returns:
**	pointer to a node of a specified type if one was found; NULL otherwise
**
** History:
**	05-16-90 (andre)
**	    written
*/
PST_QNODE *
psl_find_node(
	PST_QNODE   *node,
	i4	    type)
{
    PST_QNODE	*p;

    if (node == (PST_QNODE *) NULL || node->pst_sym.pst_type == type)
    {
	p = node;
    }
    else if ((p = psl_find_node(node->pst_left, type)) == (PST_QNODE *) NULL)
    {
	p = psl_find_node(node->pst_right, type);
    }

    return(p);
}

/* PSL_HCHECK - make sure that vars in having include atts in the group
**	by or in different scope. Ignore subselects and aggregates.
*/
DB_STATUS
psl_hcheck(
	PSS_SESBLK	*cb,
	PST_QNODE	*having,
	PST_QNODE	*group,
	PST_J_MASK	*fromlist)
{
    register PST_QNODE	    *ptr;
    ADI_OPINFO	            opinfo;
    ADF_CB		    *adf_scb = (ADF_CB*) cb->pss_adfcb;
    DB_STATUS		    status = E_DB_OK;
    bool		    leftdone = FALSE, rightdone = FALSE;

    if (having == (PST_QNODE*) NULL)
	return (status);
    /* step over aggregates and subselects, they are checked elsewhere */
    if (having->pst_sym.pst_type == PST_AGHEAD ||
	having->pst_sym.pst_type == PST_SUBSEL)
	return (status);

    /* Next, check for comparison predicates involving atomic columns (i.e.,
    ** NOT column expressions). */

    if ((having->pst_sym.pst_type == PST_BOP ||
	having->pst_sym.pst_type == PST_UOP))
    {
	status = adi_op_info(adf_scb, having->pst_sym.pst_value.pst_s_op.pst_opno, &opinfo);
	if (status != E_DB_OK)
	    return(status);
	if (opinfo.adi_optype == ADI_COMPARISON)
	{
	    /* Got a comparison (not AND, OR, NOT), check for VAR on either side. */
	    if (having->pst_left->pst_sym.pst_type == PST_VAR)
	    {
		status = psl_hcheckvar(having->pst_left, group, fromlist);
		if (status != E_DB_OK) return(status);
		leftdone = TRUE;
	    }
	    else if (having->pst_left->pst_sym.pst_type == PST_CONST) leftdone = TRUE;
	    if (having->pst_right && having->pst_right->pst_sym.pst_type == PST_VAR)
	    {
		status = psl_hcheckvar(having->pst_right, group, fromlist);
		if (status != E_DB_OK) return(status);
		rightdone = TRUE;
	    }
	    if (having->pst_right && having->pst_right->pst_sym.pst_type == PST_CONST)
		rightdone = TRUE;
	}
    }

    /* Switch the having node type to perform the various checks. */
    switch (having->pst_sym.pst_type) {

      case PST_AND:
      case PST_OR:
	if (status = psl_hcheck(cb, having->pst_right, group, fromlist))
		return(status);
      case PST_NOT:
	return(psl_hcheck(cb, having->pst_left, group, fromlist));
      case PST_BOP:
	/* To get here, this must be a binary or unary comparison. Call
	** psl_tingx with right and/or left subtree to find matching expressions 
	** in the group list. */
	if (!rightdone)
	{
	    for (ptr = group; ptr && ptr->pst_sym.pst_type == PST_RESDOM;
						ptr = ptr->pst_left)
	     if (ptr->pst_right->pst_sym.pst_type != PST_VAR &&
		(status = psl_tingx(having->pst_right, ptr->pst_right, TRUE)) 
			== E_DB_OK) break;	/* got a match */

	    /* Last chance is to check for aggregate/constant expression. */
	    if (status != E_DB_OK) return(psl_constx(having->pst_right, group));
	}
      case PST_UOP:
	if (!leftdone) 
	{
	    for (ptr = group; ptr && ptr->pst_sym.pst_type == PST_RESDOM;
						ptr = ptr->pst_left)
	     if (ptr->pst_right->pst_sym.pst_type != PST_VAR &&
		(status = psl_tingx(having->pst_left, ptr->pst_right, TRUE)) 
			== E_DB_OK) break;	/* got a match */
	}
	/* Last chance is to check for aggregate/constant expression. */
	if (status != E_DB_OK) status = psl_constx(having->pst_left, group);
	return(status);
    }

    return(E_DB_ERROR);		/* we shouldn't really get to here */
}


/* PSL_HCHECKVAR - for "having" comparisons involving only VARs, verify the
**	VAR here. Expressions are handled in psl_hcheck.
*/
DB_STATUS
psl_hcheckvar(
	PST_QNODE	*having,
	PST_QNODE	*group,
	PST_J_MASK	*fromlist)
{
    DB_STATUS		    status = E_DB_OK;
    register PST_QNODE	    *ptr;

    /* check var nodes */
    if (having->pst_sym.pst_type == PST_VAR)
    {
	status = E_DB_ERROR;
	for (ptr = group; ptr && ptr->pst_sym.pst_type == PST_RESDOM &&
		status == E_DB_ERROR; ptr = ptr->pst_left)
	{
	    if (ptr->pst_right->pst_sym.pst_type == PST_VAR &&
		having->pst_sym.pst_value.pst_s_var.pst_vno ==
		ptr->pst_right->pst_sym.pst_value.pst_s_var.pst_vno 
	        &&
		having->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id ==
		ptr->pst_right->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id
	    )
		status = E_DB_OK;
	}
	/* if attribute is not in group by list, check for correlated */
	/* if not in our from list, assume it is correlated */
	if (status != E_DB_OK)
	    if (BTtest(having->pst_sym.pst_value.pst_s_var.pst_vno, 
		       (char *) fromlist)
		 == 0)
		status = E_DB_OK;
    }
    return (status);
}

/*
** This routine processes subtrees hanging off of resdom nodes of the
** tree generated for positioned update. It searches recursively for
** PST_VAR nodes and converts them into PST_CURVAL nodes. Conversion
** must not be done in place, because of different node size. New nodes
** have to be allocated.
**
**  28-jul-1987 (stec)
**	written.
**  04-may-88 (stec)
**	Allocate new nodes instead of converting in place.
**  15-feb-88 (stec)
**	Change error handling.
**  02-apr-93 (andre)
**	(fix for bug 42691)
**	psl_curval() gets called in the course of processing UPDATE CURSOR to
**	replace VAR nodes found in the subtree rooted in RESDOM with CURVAL
**	nodes.  Obviously, there is no requirement that only nodes which
**	appeared in FOR UPDATE clause may be used on the RHS of assignment
**	in UPDATE CURSOR.  Consequently, it is a very bad idea to call
**	psq_ccol().  Instead, we shall quietly create a CURVAL node using the
**	attribute number found in the VAR node.
**	
**	And the other reason why it is a lousy idea is that psy_qrymod() may now
**	actually do something to the query tree before psl_curval gets called
**	which means that if the cursor was defined on a view, then names of
**	attributes found in the tree will be those of attributes of the view's
**	underlying base table and not of the view (which means that even if you
**	find a matching name, the chances that the attribute number is correct
**	may be rather remote.)
*/
DB_STATUS
psl_curval(
	PSS_SESBLK  *cb,
	PSQ_CB	    *psq_cb,
	PSC_CURBLK  *cursor,
	PST_QNODE   **tree)
{
    DB_STATUS		    status;
    PST_CRVAL_NODE	    curval;
    PST_QNODE		    *node;

    node = *tree;
    if (node->pst_left != (PST_QNODE *) NULL)
    {
	status = psl_curval(cb, psq_cb, cursor, &node->pst_left);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
    if (node->pst_right != (PST_QNODE *) NULL)
    {
	status = psl_curval(cb, psq_cb, cursor, &node->pst_right);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }

    if (node->pst_sym.pst_type == PST_VAR)
    {
	DB_DATA_VALUE	    *dataval = &node->pst_sym.pst_dataval;
	
	STRUCT_ASSIGN_MACRO(cursor->psc_blkid, curval.pst_cursor);
	curval.pst_curcol.db_att_id =
	    node->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id;

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CURVAL, (char *) &curval,
	    sizeof(curval), dataval->db_datatype, dataval->db_prec,
	    dataval->db_length, (DB_ANYTYPE *) NULL, tree, &psq_cb->psq_error,
	    (i4) 0);

	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}
    }

    return (E_DB_OK);
}

/*
**  psl_shareable    -	determines Query Plan shareability based on ownership
**			of tables/views used in an SQL repeat query. It is
**			required that all object be DBA owned or be catalogs.
**			(29-jan-91 andre) this function may also be called to
**			help determine shareability of QUEL repeat queries.
**
**  25-jan-1988 (stec)
**	Written.
**  19-oct-88 (stec)
**	Change criteria for shareable QPs (include catalogs).
**  12-dec-89 (andre)
**	As a result of the changes introduced by the FIPS project, queries will
**	be considered shareable if all objects are owned by the DBA, are
**	catalogs, OR are explicitly qualified.
**  29-jan-91 (andre)
**	Add support for trace point ps132.
**  15-jun-92 (barbara)
**	Sybil merge: Star comments
**	13-mar-92 (barbara)
**	    To fix bug 42625 (Star shared query plans even after distributed
**	    table had been reregistered), save away table ids of a given
**	    shareable repeat query by calling psl_rptqry_tblids().  Added
**	    new parameters psq_cb and qry_info.
**  30-nov-92 (teresa)
**      fixed uninitialized variable first_ldb_desc.
**  11-oct-93 (swm)
**	Bug #56448
**	Made psf_display() portable. The old psf_display() took a variable
**	number of variable-sized arguments. It could not be re-written as
**	a varargs function as this practice is outlawed in main line code.
**	The problem was solved by invoking a varargs function, TRformat,
**	directly.
**	The psf_display() function has now been deleted, but for flexibilty
**	psf_display has been #defined to TRformat to accomodate future
**	change.
**	All calls to psf_display() changed to pass additional arguments
**	required by TRformat:
**	    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1, ...)
**	this emulates the behaviour of the old psf_display() except that
**	the trbuf must be supplied.
*/
DB_STATUS
psl_shareable(
	PSQ_CB	   		*psq_cb,
	PSS_SESBLK 		*cb,
	bool	    		*shareable,
	DB_SHR_RPTQRY_INFO	**qry_info)
{
    PSS_USRRANGE	*rngtab = (cb->pss_lang == DB_SQL) ? &cb->pss_auxrng
							   : &cb->pss_usrrange;
    register PSS_RNGTAB *rngvar, *lim;
    bool		ps132;
    DD_2LDB_TAB_INFO	*ldb_tab_info;
    DD_LDB_DESC		*first_ldb_desc = NULL;
    DD_LDB_DESC		*ldb_desc;
    char		trbuf[PSF_MAX_TEXT + 1]; /* last char for `\n' */

    /* determine if trace point PS132 has been set */
    {
	i4		val1=0, val2=0;

	ps132 = ult_check_macro(&cb->pss_trace, 4, &val1, &val2);
    }

    /* Assume the query is shareable. */
    *shareable = TRUE;

    /* scan all variables in the range table */
    for (rngvar = rngtab->pss_rngtab, lim = rngtab->pss_rngtab + PST_NUMVARS;
	 rngvar < lim;
	 rngvar++
	)
    {
	/* skip empty entries in the range table */
	if (!rngvar->pss_used || rngvar->pss_rgno == -1)
	    continue;

	/* validate non-empty entry */
	if (~rngvar->pss_var_mask & PSS_EXPLICIT_QUAL
	    &&
	    MEcmp((PTR) &rngvar->pss_ownname, (PTR) &cb->pss_dba,
	    sizeof(DB_TAB_OWN))
	    &&
	    !(rngvar->pss_tabdesc->tbl_status_mask &
		(DMT_CATALOG|DMT_EXTENDED_CAT))
	   )
	{
	    /*
	    ** One non-dba owned entry that is not a catalog and is not
	    ** explicitly qualified is enough to make the query non-shareable.
	    */

	    if (ps132)
	    {
		if (*shareable)	    
		{
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\nRepeat query is not shareable\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"because it involves table(s) which are neither catalogs\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"nor are owned by the DBA, and were not explicitly qualified.\n");
	    
		    *shareable = FALSE;

		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"These tables are:\n\n");
		}

		psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"****'%t' owned by '%t'\n",
			    sizeof(DB_TAB_NAME), &rngvar->pss_tabname,
			    sizeof(DB_OWN_NAME), &rngvar->pss_ownname);
	    }
	    else
	    {
		*shareable = FALSE;

		/*
		** if trace point ps132 has not been set, then, once we know
		** that the query is not sahreable, there is no reason to look
		** at the rest of range table entries
		*/
		return (E_DB_OK);
	    }
	}

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    /* Query is not currently shareable if multi-site */

	    ldb_tab_info = &rngvar->pss_rdrinfo->rdr_obj_desc->dd_o9_tab_info;

	    if (first_ldb_desc == (DD_LDB_DESC *) NULL)
	    {
		/* Save away first LDB description */
		first_ldb_desc = &ldb_tab_info->dd_t9_ldb_p->dd_i1_ldb_desc;
		continue;
	    }

	    /* Compare site */
	    ldb_desc = &ldb_tab_info->dd_t9_ldb_p->dd_i1_ldb_desc;
	    *shareable = psq_same_site(first_ldb_desc, ldb_desc);

	    if (*shareable == FALSE)
		return(E_DB_OK);
	}
    }

    /* scan result range var in the range table */
    rngvar = &rngtab->pss_rsrng;
    if (rngvar->pss_used && rngvar->pss_rgno != -1)
    {
	/* Check this entry */
	if (~rngvar->pss_var_mask & PSS_EXPLICIT_QUAL
	    &&
	    MEcmp((PTR) &rngvar->pss_ownname, (PTR) &cb->pss_dba,
	    sizeof(DB_TAB_OWN))
	    &&
	    !(rngvar->pss_tabdesc->tbl_status_mask &
		(DMT_CATALOG|DMT_EXTENDED_CAT))
	   )
	{
	    /*
	    ** One non-dba owned entry that is not a catalog and is not
	    ** explicitly qualified is enough to make the query non-shareable.
	    */

	    if (ps132)
	    {
		/*
		** Note that in order to get this far, either *shareable == TRUE
		** or trace point ps132 was set
		*/
		if (*shareable)	    
		{
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\nRepeat query is not shareable\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"because it involves a table which is neither a catalog\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"nor is owned by the DBA, and was not explicitly qualified.\n");
	    
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"This table is:\n\n");
		}

		psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"****'%t' owned by '%t'\n",
			    sizeof(DB_TAB_NAME), &rngvar->pss_tabname,
			    sizeof(DB_OWN_NAME), &rngvar->pss_ownname);
	    }

	    *shareable = FALSE;
	}

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    /* Query is not currently shareable if multi-site */

	    ldb_tab_info = &rngvar->pss_rdrinfo->rdr_obj_desc->dd_o9_tab_info;

	    if (first_ldb_desc != (DD_LDB_DESC *) NULL)
	    {
		/* Compare site */
		ldb_desc = &ldb_tab_info->dd_t9_ldb_p->dd_i1_ldb_desc;
		*shareable = psq_same_site(first_ldb_desc, ldb_desc);

		if (*shareable == FALSE)
		    return(E_DB_OK);
	    }
	}
    }

    if (cb->pss_distrib & DB_3_DDB_SESS)
    {
	DB_STATUS		status;

	/* allocate memory for DB_SHR_RPTQRY_INFO structure */
	status = psf_malloc(cb, &cb->pss_ostream,
	    (i4) sizeof(DB_SHR_RPTQRY_INFO), (PTR *) qry_info,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Initialize text fields (these are only used by QUEL). */
	(*qry_info)->db_qry_len = 0;
	(*qry_info)->db_qry = (u_char *) NULL;

	/* Build a list of table ids of tables used in the query. */

	status = psl_rptqry_tblids(cb, &cb->pss_auxrng, &cb->pss_ostream,
	    psq_cb->psq_mode, &(*qry_info)->db_num_tblids,
	    &(*qry_info)->db_tblids, &psq_cb->psq_error);

    	if (DB_FAILURE_MACRO(status))
	    return(status);

    }

    return (E_DB_OK);
}

/*
**  psl_backpatch - patches statement pointers.
**
**  Description:
**  psl_backpatch patches pst_next, pst_true and pst_false pointers
**  in statement nodes. The idea is that the last stmt in a stmt chain
**  has to point to the next stmt at the higher level (i.e. the next
**  statement in the stmt chain of the parent. The very first stmt that
**  this routine is going to be called with is always going to be PST_DECVAR
**  since by definition it is at the top of the tree. The statement tree
**  after patching should reflect the flow of control. OPC will map this
**  tree into a serious of actions to be executed by QEF. The mapping is
**  pretty much 1:1. In case of the WHILE statement, the last statements
**  in the statement chains hanging off of the node need to point to the
**  IF node representing the WHILE. The only exception is the case where
**  a statement was followed by an ENDLOOP, in this case its pst_next ptr
**  needs to be patched to the next statement that follows the corresponding
**  IF (respresenting WHILE stmt) node.
**
**  Inputes:
**
**
**  Outputs:
**
**
**  Returns:
**	None.
**
**  Side effects:
**	Modifies tree pointers.
**
**  8-jul-88 (stec)
**	Written.
**  11-feb-91 (andre)
**	The following changes wre made as a part of the fix for bug 35659:
**	    1) fix blocks created for ENDLOOP statements immediately following
**	       IF...ENDIF statement will be processed BEFORE processing the BODY
**	       of the WHILE statement;
**	    2) if the IF statement block is followed by ENDLOOP statement block,
**	       use ENDLOOP->pst_next rather than IF->pst_next to patch pointers
**	       inside the IF statement body
**  21-Feb-96 (mckba01)
**	Fix for 66715, For WHILE stmts must check pst_next for ENDLOOP
**	statement, if present make WHILE.pst_next = ENDLOOP.pst_next
**	Then remove the ENDLOOP stmt.
**	25-sep-98 (inkdo01)
**	    Added FOR loop support.
*/
VOID
psl_backpatch(
	PST_STATEMENT   *stmt,
	PST_STATEMENT   *patch)
{
    bool    last = FALSE;
    register PST_STATEMENT   *s;

    /* Return if there's nothing to do */
    if (stmt == (PST_STATEMENT *) NULL)
	return;

    /* Scan the stmt list at this level looking
    ** for the last one to patch; process recursively
    ** IF and WHILE stmts encountered.
    */
    for (s = stmt; last == FALSE; s = s->pst_next)
    {
	if (s->pst_next == (PST_STATEMENT *) NULL)
	{
	    last = TRUE;
	    s->pst_next = patch;
	}

	if (s->pst_type == PST_IF_TYPE)
	{
	    PST_STATEMENT	*next_stmt;

	    /*
	    ** usually, pst_next will point at the next statement; however, if
	    ** there was an ENDLOOP immediately following IF...ENDIF, pst_next
	    ** of the IF statement block will point to the ENDLOOP statement
	    ** block which will contain the address of the next statement;
	    */

	    if(!last && s->pst_next->pst_type == PST_ENDLOOP_TYPE)
	    {
		/* 
		** ENDLOOP is guaranteed to be the last statement in the
		** innermost block.
		**
		** Our algorithm amounts to "pushing" ENDLOOP into the body of
		** the IF statement which it follows (so the result would be
		** undistinguishable from the case when ENDLOOP was the last
		** statement in both TRUE and FALSE branches of the IF
		** statement, except that we would realize that any current
		** block statements following ENDLOOP are unreachable)
		**
		*/

		next_stmt = s->pst_next->pst_next;
		last = TRUE;
		
		/* now remove ENDLOOP block from the chain of statements */
		s->pst_next = patch;
	    }
	    else
	    {
		next_stmt = s->pst_next;
	    }

	    /* Remember to patch the last stmts in an IF's
	    ** pst_true and pst_false stmt lists.
	    */

	    /* If null stmt block patch manually */
	    if (s->pst_specific.pst_if.pst_true == (PST_STATEMENT *) NULL)
	    {
		s->pst_specific.pst_if.pst_true = next_stmt;
	    }
	    else
	    {
		(VOID) psl_backpatch(s->pst_specific.pst_if.pst_true,
		    next_stmt);
	    }

	    /* If null stmt block just patch manually */
	    if (s->pst_specific.pst_if.pst_false == (PST_STATEMENT *) NULL)
	    {
		s->pst_specific.pst_if.pst_false = next_stmt;
	    }
	    else
	    {
		(VOID) psl_backpatch(s->pst_specific.pst_if.pst_false,
		    next_stmt);
	    }
	}
	else if (s->pst_type == PST_WH_TYPE || s->pst_type == PST_RP_TYPE)
	{
	    PSS_LOOP 	    *wnode = (PSS_LOOP *) s->pst_opf;
	    PSS_FIXSTMT	    *fix,
			    *last_fix = (PSS_FIXSTMT *) &wnode->pss_fixq;
	    i4		    stype = s->pst_type;

	    /* Fix up the statement node */
	    s->pst_type = PST_IF_TYPE;
	    s->pst_opf = (PTR) NULL;

	    /*  #66715:
	     *  IF a loop stmt is immediately followed by an endloop
	     *  .pst_next will now contain an ENDLOOP statement to
	     *  point to the correct next statement
	     */

             if(!last && s->pst_next->pst_type == PST_ENDLOOP_TYPE)
	     {
	         last = TRUE;

	         /* now remove ENDLOOP block from the chain of statements */
	         s->pst_next = s->pst_next->pst_next;
	     }


	    /* Remember to patch the last stmts in a WHILE/REPEAT's
	    ** pst_true and pst_false stmt lists.
	    */


	    /* If null stmt block patch manually */
	    if (s->pst_specific.pst_if.pst_true == (PST_STATEMENT *) NULL)
	    {
		/* This case indicates that ENDLOOP was the first stmt,
		** (see cdbp_stmtlst defn), so instead of pointing at itself
		** we will make it point at the next stmt.
		*/
		s->pst_specific.pst_if.pst_true = s->pst_next;
	    }
	    else if (stype == PST_WH_TYPE)
	    {
		/*
		** For a WHILE statement fix all ENDLOOP statements which
		** immediately followed IF...ENDIF statements (they are recorded
		** as entries in the fix queue, and the pss_flags field in this
		** entries has PSS_FIX_EARLY set) BEFORE processing the body of
		** the WHILE statement.  This is required since
		** ENDLOOP->pst_next will be used to patch the last statements
		** in the TRUE and FALSE branches of the IF statement.  This is
		** done as a part of the fix for bug #35659
		*/
		for (fix = (PSS_FIXSTMT *) wnode->pss_fixq.q_next;
		     fix != last_fix;
		     fix = (PSS_FIXSTMT *) fix->pss_queue.q_next
		    )
		{
		    if (fix->pss_flags & PSS_FIX_EARLY)
		    {
			*(fix->pss_stmt_ptr) = s->pst_next;
		    }
		}

		if (stype == PST_WH_TYPE)
		    (VOID) psl_backpatch(s->pst_specific.pst_if.pst_true, s);
	    }

	    /* pst_false stmt block always null; patch manually */
	    if (s->pst_specific.pst_if.pst_false == (PST_STATEMENT *) NULL)
	    {
		s->pst_specific.pst_if.pst_false = s->pst_next;
	    }

	    /* For a loop stmt fix all stmts followed by ENDLOOP (they are
	    ** recorded as entries in the fix queue).
	    ** Traverse the fix queue and initialize all
	    ** listed statements with proper value of pst_next ptr.
	    */
	    for (fix = (PSS_FIXSTMT *) wnode->pss_fixq.q_next;
		 fix != last_fix;
		 fix = (PSS_FIXSTMT *) fix->pss_queue.q_next
		)
	    {
		/* if we haven't fixed it already, do it now */
		if (~fix->pss_flags & PSS_FIX_EARLY)
		{
		    *(fix->pss_stmt_ptr) = s->pst_next;
		}
	    }

	    /* This fixq has been fixed */
	    (VOID) QUinit(&wnode->pss_fixq);
	}
	else if (s->pst_type == PST_FOR_TYPE)
	{
	    PSS_LOOP 	    *wnode = (PSS_LOOP *) s->pst_opf;
	    PSS_FIXSTMT	    *fix,
			    *last_fix = (PSS_FIXSTMT *) &wnode->pss_fixq;
	    PST_STATEMENT   *ifstmtp = 
				s->pst_specific.pst_for.pst_forhead->pst_next;
	    i4		    stype = s->pst_type;

	    /* Fix up the statement node */
	    s->pst_opf = (PTR) NULL;

	    /*  #66715:
	     *  IF a loop stmt is immediately followed by an endloop
	     *  .pst_next will now contain an ENDLOOP statement to
	     *  point to the correct next statement
	    */

            if(!last && s->pst_next->pst_type == PST_ENDLOOP_TYPE)
	    {
	        last = TRUE;

	        /* now remove ENDLOOP block from the chain of statements */
	        s->pst_next = s->pst_next->pst_next;
	    }

	    /* Fix the FOR's IF's pst_false and if's next must exit the loop. */
	    ifstmtp->pst_specific.pst_if.pst_false = s->pst_next;
	    ifstmtp->pst_next = s->pst_next;

	    /* If 1st stmt in FOR-loop is ENDLOOP, just skip it all. */
	    if (ifstmtp->pst_specific.pst_if.pst_true == (PST_STATEMENT *)NULL)
		s->pst_specific.pst_for.pst_forhead = s->pst_next;
	    else
	    {
		/*
		** For a loop statement fix all ENDLOOP statements which
		** immediately followed IF...ENDIF statements (they are recorded
		** as entries in the fix queue, and the pss_flags field in this
		** entries has PSS_FIX_EARLY set) BEFORE processing the body of
		** the loop statement.  This is required since
		** ENDLOOP->pst_next will be used to patch the last statements
		** in the TRUE and FALSE branches of the IF statement.  This is
		** done as a part of the fix for bug #35659
		*/
		for (fix = (PSS_FIXSTMT *) wnode->pss_fixq.q_next;
		     fix != last_fix;
		     fix = (PSS_FIXSTMT *) fix->pss_queue.q_next
		    )
		{
		    if (fix->pss_flags & PSS_FIX_EARLY)
		    {
			*(fix->pss_stmt_ptr) = s->pst_next;
		    }
		}

		/* Recurse to patch stmtlist statements and direct last 
		** stmt in loop back to select's QTREE. */
		(VOID) psl_backpatch(ifstmtp->pst_specific.pst_if.pst_true, 
			s->pst_specific.pst_for.pst_forhead);
	    }


	    /* For a loop stmt fix all stmts followed by ENDLOOP (they are
	    ** recorded as entries in the fix queue).
	    ** Traverse the fix queue and initialize all
	    ** listed statements with proper value of pst_next ptr.
	    */
	    for (fix = (PSS_FIXSTMT *) wnode->pss_fixq.q_next;
		 fix != last_fix;
		 fix = (PSS_FIXSTMT *) fix->pss_queue.q_next
		)
	    {
		/* if we haven't fixed it already, do it now */
		if (~fix->pss_flags & PSS_FIX_EARLY)
		{
		    *(fix->pss_stmt_ptr) = s->pst_next;
		}
	    }

	    /* This fixq has been fixed */
	    (VOID) QUinit(&wnode->pss_fixq);
	}
    }
}   

/*
**  PSL_AGFCN  - return TRUE if an AGHEAD node found.
**
**  Description:
**	Tree is checked through recursive calls for
**	presence of an AGHEAD node.
**
**  Inputes:
**	node	    root of the subtree to be checked.
**
**  Outputs:
**	None.
**
**  Returns:
**	TRUE if AGHEAD node found, FALSE otherwise.
**
**  Side effects:
**	None.
**
**  21-oct-88 (stec)
**	Written.
*/
bool
psl_agfcn(
	PST_QNODE *node)
{
    if (node == (PST_QNODE *) NULL)
	return (FALSE);

    /* look at current node */
    if (node->pst_sym.pst_type == PST_AGHEAD)
	return (TRUE);

    /* look at both children */
    if ((node->pst_left && psl_agfcn(node->pst_left))
	||
	(node->pst_right && psl_agfcn(node->pst_right))
       )
    {
	return (TRUE);
    }

    return (FALSE);
}   

/*
**  psl_up - Checks updatability of a tree in a declare cursor
**	     statement.
**
**  Description:
**	This routine checks whether a tree representing a define
**	cursor query should reslut in creation of an updateable
**	cursor.
**	    Cursor is updateable unless:
**		- data is to be sorted with duplicates removed
**		- distinct/unique have been specified at the outermost
**		  level
**		- UNION is specified for outermost level.
**		- the count of range vars at the outermost scope is
**		  not one.
**		- the count of range vars at the outermost scope is
**		  one and the range var represent nonmergeable view
**		  and it is not updateable (UNION view).
**		- index is the target relation
**		- there are aggregates in the target list
**		
**	
**
**  Inputes:
**	    hdr		    query tree header
**	    flag	    ptr to boolean flag
**			    which may already be set
**			    to indicate updateability
**	    reason	    reason if nonupdateable
**
**  Outputs:
**	    flag	    ptr to boolean flag
**			    indicating updateability
**			    of the cursor
**			    (TRUE means nonupdateable)
**	    reason
**
**  Returns:
**	None.
**
**  Side effects:
**
**  17-oct-88 (stec)
**	Written.
**  02-dec-88 (stec)
**	Change the way aggregate test is done; do not check
**	cb->pss_agintree, since this may or may not be set,
**	just check the target list.
*/
VOID
psl_up(
	PSS_SESBLK		*cb,
	PSS_USRRANGE		*rngtab,
	register PST_QTREE	*hdr,
	bool			*flag,
	i4			*reason)
{
    register PST_QNODE	*rt = hdr->pst_qtree;

    /* no reason given yet */
    *reason = 0;

    /* See if already nonupdatable */
    if (*flag)
    {
	*reason = 1;
	return;
    }

    /* Check if distinct specified */
    if (rt->pst_sym.pst_value.pst_s_root.pst_dups
	    == PST_NODUPS)
    {
	*reason = 2;
	*flag = TRUE;
	return;
    }

    /* Check if union */
    if (rt->pst_sym.pst_value.pst_s_root.pst_union.pst_next
	    != (PST_QNODE *) NULL)
    {
	*reason = 3;
	*flag = TRUE;
	return;
    }

    /* Check if one range var in the target list */
    if (rt->pst_sym.pst_value.pst_s_root.pst_tvrc != 1)
    {
	*reason = 4;
	*flag = TRUE;
	return;
    }
    else
    {
	i4	i = -1;
	register PSS_RNGTAB *rngvar, *lim;

	i = BTnext(i, (char *) &rt->pst_sym.pst_value.pst_s_root.pst_tvrm,
		   PST_NUMVARS);

	for (rngvar = &rngtab->pss_rngtab[0],
	     lim = &rngtab->pss_rngtab[PST_NUMVARS];
	     rngvar < lim;
	     rngvar++
	    )
	{
	    if (!rngvar->pss_used || rngvar->pss_rgno != i)
		continue;

	    if (rngvar->pss_tabdesc->tbl_status_mask & DMT_VIEW)
	    {
		*reason = 5;
		*flag = TRUE;
		return;
	    }
	}
    }

    /* Check if index */
    if (cb->pss_resrng &&
	cb->pss_resrng->pss_tabdesc->tbl_status_mask & DMT_IDX)
    {
	*reason = 6;
	*flag = TRUE;
	return;
    }

    /* check for aggregate functions in the target list */
    if ((i4)psl_agfcn(rt->pst_left))
    {
	*reason = 7;
	*flag = TRUE;
	return;
    }
}

/*
**  psl_crsopen - Executes code shared by a number of semantic
**		  routines.
**
**  Description:
**	Executes code related to the cursor open request. This code
**	is executed from a number of places, so it is is a good
**	idea to encapsulate it in a routine.
**	
**
**  Inputes:
**	cb		    session ctrl blk
**	psq_cb		    psf request block
**	crblk		    cursor control block ptr
**	tree		    pointer to tree header
**	for_rdonly	    boolean indicating presence
**			    of FOR READONLY clause
**	updcollst	    pointer to subtree representing
**			    list of updateable columns
**	nonupdt		    boolean indicator set to TRUE
**			    if we already know that query
**			    is not updateable
**	num_joins	    number of joins found in the query tree so far
**
**  Outputs:
**	cb		    session ctrl blk
**	    .pss_resrng	    set to NULL if query not updateable
**	psq_cb		    psf request block
**	    .psq_error	    describes nature of problem if error
**			    encountered.
**	crblk		    cursor control block
**	    .psc_delall	    indicates whether cursor deleteable
**	    .psc_forupd	    indicates whether cursor updateable
**	    .psc_lang	    set to current query language
**	    .psc_tbl_descr_queue
**			    list of descriptions of table/views over which the
**			    cursor is defined
**		.psc_tbl_mask
**			    copy of the relstat
**		.psc_flags  initialized to indicate that we haven't checked for
**			    existence of rules on this table/view
**	    
**	tree		    pointer to tree header
**	    .pst_updtmode   may be altered if FOR READONLY spec'd
**  
**  Returns:
**	status
**
**  Side effects:
**	Qrymod process may alter the tree.
**	Header of the tree may be altered.
**	Memory may be allocated.
**
**  16-nov-88 (stec)
**	Written.
**  24-apr-89 (neil)
**	Added initialization in support for rules and cursors.
**  08-sep-89 (andre)
**	receive number of joins found in the tree so far as an argument.
**  08-mar-93 (andre)
**	if a user has not specified either FOR UPDATE, FOR READONLY, or ORDER BY
**	and the <query expression> is updatable, the cursor will support UPDATE
**	of all columns.  In our unending quest for improved concurrency, we will
**	notify OPF that the user has NOT explicitly specified FOR UPDATE so that
**	we will be acquiring shared locks on pages read through the cursor
**	until/unless the user tries to UPDATE/DELETE through it.
**  06-apr-93 (andre)
**	removed code initializing psc_rchecked, psc_tbl_mask, psc_rules, and
**	psc_stmt_rules.  The first became a bit (PSC_RULES_CHECKED) over
**	PSC_TBL_DESCR.psc_flags while the rest have migrated into PSC_TBL_DESCR
**
**	before calling psy_qrymod(), allocate and populate a PSC_TBL_DESCR
**	structure for the table/view on which a cursor has been defined and
**	insert it into psc_tbl_descr_queue
**  31-dec-93 (andre)
**	(fix for bug 57384:)
**	if the cursor is being opened without specifying FOR READONLY, ORDER BY,
**	or FOR UPDATE, we may still allow user to perform updated through it - 
**	however, it is wrong for PSF to tell OPC that the cursor will be used 
**	for DEFERRED update since this will break lots of existing applications
**	+ if the user intended to do DEFERRED update, it is not unreasonable to
**	expect him to say FOR [DEFERRED] UPDATE
*/
DB_STATUS
psl_crsopen(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PSC_CURBLK	*crblk,
	PST_QTREE	*tree,
	bool		for_rdonly,
	PST_QNODE	*updcollst,
	bool		nonupdt,
	PST_J_ID	num_joins)
{
    DB_STATUS		status;
    register PST_QNODE	*qnode;
    i4		err_code;
    i4		qrymod_resp_mask;
    PSC_UPDM		updtmask;
    PSC_COLMAP		updcolmap;

    if (!cb->pss_resrng)
    {
	/* Force readonly ('select constant' statement) */
	for_rdonly = TRUE;
    }

    updtmask = 0;	/* initialize mask to read only */

    if (for_rdonly == TRUE)
    {
	/* FOR READONLY specified at cursor open time */
	tree->pst_updtmode = PST_READONLY;

	/* no result table for READ ONLY case */
	cb->pss_resrng = 0;
    }
    else if (tree->pst_updtmode != PST_READONLY)
    {
	/*
	** FOR UPDATE clause has been specified (or at least ORDER BY has not
	** been specified and the query appeared updatable so far in which case
	** tree->pst_updtmode pst_updtmode would be set to PST_UNSPECIFIED)
	** indicate update request in the cursor control block (this
	** automatically implies request for delete privileges).
	*/
	crblk->psc_forupd = TRUE;
	updtmask |= (PST_UP | PST_DL);
    }
    else
    {
	/*Set the config.dat entry value if cursor mode is not specified */
       	if( Psf_srvblk->psf_flags & PSF_DFLT_READONLY_CRSR)
       	{
         	tree->pst_updtmode = PST_READONLY;
		cb->pss_resrng = 0;
       	}
	else
	{
	/* no update requested
	** but consider cursor deleteable
	*/
		updtmask |= PST_DL;
	}
    }

    if (updtmask & PST_UP)
    {
	i4			colno;
	i4			count;
	PST_RSDM_NODE	*resdom;
	register DB_DATA_VALUE *dt;

	/* Initialize "for update" column map. */
	(VOID) MEfill(sizeof (PSC_COLMAP), (u_char) 0, 
	    (PTR) &updcolmap);

	/* Create the hash table for descriptions of updateable
	** columns for this cursor. 
	*/
	for (qnode = updcollst, count = 0;
	     qnode && qnode->pst_sym.pst_type == PST_RESDOM;
	     qnode = qnode->pst_left
	    )
	{
	    count++;
	    (VOID) BTset((i4) qnode->
		pst_right->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id,
		(char *) &updcolmap);

	    /* This column needs to have update permissions checked on it. */
	    qnode->pst_sym.pst_value.pst_s_rsdm.pst_rsupdt = TRUE;
	}

	status = psq_cltab(crblk, count, &cb->pss_memleft, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Run down the updateable col list, and add them
	** to the cursor control block. This must be done before
	** QRYMOD is done, because column descriptions will be
	** referenced from within UPDATE statements and
	** we want to keep user's perspective here.
	*/
	for (qnode = updcollst;
	    qnode && qnode->pst_sym.pst_type == PST_RESDOM;
	    qnode = qnode->pst_left)
	{
	    resdom = &qnode->pst_sym.pst_value.pst_s_rsdm;
	    dt = &qnode->pst_sym.pst_dataval;
	     colno =
	      qnode->pst_right->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id;

	    status = psq_clent(colno, (DB_ATT_NAME *) resdom->pst_rsname,
		dt->db_datatype, dt->db_length, dt->db_prec, crblk,
		&cb->pss_memleft, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}

	/* Now add our mini-target list of updateable columns
	** to the main target list (to be removed after
	** execution of qrymod).
	*/
	(VOID) pst_tlprpnd(updcollst, tree->pst_qtree);
    }

    if (updtmask & (PST_UP | PST_DL))
    {
	PSC_TBL_DESCR	    *crs_tbl_descr;

	/*
	** Store name of the table and its owner in the cursor control block.
	** Name should be stored in the cursor control block independent
	** of the mode in which cursor is opened. These names are retrieved
	** for storage before querymod is run so that "delete" and
	** "update" actions which compare them with the names spec'd
	** in those stmnts can return an error message naming the object
	** specified by the user rather than the name of underlying base
	** table (if object is a view).
	*/
	STRUCT_ASSIGN_MACRO(cb->pss_resrng->pss_tabname,	
	    crblk->psc_tabnm);
	STRUCT_ASSIGN_MACRO(cb->pss_resrng->pss_ownname,
	    crblk->psc_ownnm);

	/*
	** allocate, populate, and insert a PSC_TBL_DESCR structure describing
	** the object on which the cursor was defined
	*/
	status = psf_umalloc(cb, crblk->psc_stream, sizeof(*crs_tbl_descr),
	    (PTR *) &crs_tbl_descr, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	STRUCT_ASSIGN_MACRO(cb->pss_resrng->pss_tabid,
			    crs_tbl_descr->psc_tabid);
	crs_tbl_descr->psc_tbl_mask =
	    cb->pss_resrng->pss_tabdesc->tbl_status_mask;
	    
	crs_tbl_descr->psc_row_lvl_usr_rules =
	crs_tbl_descr->psc_row_lvl_sys_rules =
	crs_tbl_descr->psc_stmt_lvl_usr_rules =
	crs_tbl_descr->psc_stmt_lvl_sys_rules =
	crs_tbl_descr->psc_row_lvl_usr_before_rules =
	crs_tbl_descr->psc_row_lvl_sys_before_rules =
	crs_tbl_descr->psc_stmt_lvl_usr_before_rules =
	crs_tbl_descr->psc_stmt_lvl_sys_before_rules = (PST_STATEMENT *) NULL;

	crs_tbl_descr->psc_flags = 0;
	QUinsert(&crs_tbl_descr->psc_queue, crblk->psc_tbl_descr_queue.q_prev);
    }

    status = psy_qrymod(tree->pst_qtree, cb, psq_cb, &num_joins,
	&qrymod_resp_mask);
    if (DB_FAILURE_MACRO(status))
    {
	return (status);
    }

    if (psq_cb->psq_pnode != (PTR)NULL)
    {
	/* Assign the qrymod audit information from session pointer. */

	PST_PROCEDURE *pnode = (PST_PROCEDURE *)psq_cb->psq_pnode;

	pnode->pst_stmts->pst_audit = cb->pss_audit;
	psq_cb->psq_pnode = 0;
    }
    cb->pss_audit = (PTR)NULL;

    if (updtmask & PST_UP)
    {
	PST_QNODE	 *treenode;

	/*
	** Now set the internal update map representing attribute
	** numbers of base relation(s).
	**
	** EXTRA! EXTRA! READ ALL ABOUT IT...
	**  - psy_protect() could have determined that a user does not possess
	**    UPDATE privilege on some attribute(s) appearing in the FOR UPDATE
	**    list and indicate it by resetting pst_rsupdt in the appropriate
	**    RESDOM node.  In a departure from the way things used to work
	**    before, rather than returning an error in such case, we will
	**    simply remember that a user may not update that particular column
	**    by resetting the corresponding bit in psc_updmap
	**  - if a right subtree of a RESDOM node representing an attribute
	**    EXPLICITLY named in the FOR UPDATE does not consist of a PST_VAR
	**    node, we will continue to report an error; however, if the user
	**    has not specified none of FOR UPDATE, ORDER BY, or FOR READONLY,
	**    then we will assume that the cursor can be used for updating
	**    attributes of the cursor's underlying table unless proven
	**    otherwise.  In this second scenario, if a right subtree of a
	**    RESDOM node does not consist of a PST_VAR node, we will simply
	**    remember that this attribute may not be updated
	*/
	for (qnode = updcollst;
	     qnode && qnode->pst_sym.pst_type == PST_RESDOM;
	     qnode = qnode->pst_left
	    )
	{
	    /* Check if updateable columns are really updateable */
	    if (qnode->pst_right->pst_sym.pst_type == PST_VAR)
	    {
		if (qnode->pst_sym.pst_value.pst_s_rsdm.pst_rsupdt)
		{
		    (VOID) BTset((i4) qnode->pst_right->
			pst_sym.pst_value.pst_s_var.pst_atno.db_att_id,
			(char *) &crblk->psc_iupdmap);
		}
		else
		{
		    /*
		    ** we need to find the number of the attribute of the table
		    ** or view on which the cursor is based and reset the
		    ** corresponding bit in updcolmap (which will be copied into
		    ** psc_updmap)
		    */
		    PSC_RESCOL	    *nonupdt_col;
		    DB_ATT_NAME	    att_name;

		    MEcopy((PTR) qnode->pst_sym.pst_value.pst_s_rsdm.pst_rsname,
			DB_MAXNAME, (PTR) &att_name);
			
		    nonupdt_col = psq_ccol(crblk, &att_name);
		    if (nonupdt_col == (PSC_RESCOL *) NULL)
		    {
			/* something is very wrong */
			psq_cb->psq_error.err_code = E_PS0002_INTERNAL_ERROR;
			return(E_DB_SEVERE);
		    }
		    
		    /*
		    ** remember that this attribute may not be updated because
		    ** the user lacks UPDATE privilege
		    */
		    BTclear((i4) nonupdt_col->psc_attid.db_att_id,
			(char *) &updcolmap);
		}
	    }
	    else
	    {
		/*
		** if a cursor has been EXPLICITLY declared FOR UPDATE of an
		** attribute of a view which is not a simple attribute (i.e. it
		** is based on an expression), we will report an error.
		** If however, the user has omitted FOR UPDATE/READONLY
		** altogether or has specified FOR UPDATE without a <column name
		** list>, we simply need to remember that the user may not
		** update this attribute
		*/
		if (   tree->pst_updtmode != PST_UNSPECIFIED
		    && ~cb->pss_stmt_flags & PSS_IMPL_COL_LIST_IN_DECL_CURS)
		{
		    (VOID) psf_error(2224L, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 3,
			sizeof(cb->pss_lineno), &cb->pss_lineno,
			psf_trmwhite(DB_MAXNAME,
			    cb->pss_crsr->psc_blkid.db_cur_name),
			cb->pss_crsr->psc_blkid.db_cur_name,
			psf_trmwhite(DB_MAXNAME,
			    qnode->pst_sym.pst_value.pst_s_rsdm.pst_rsname),
			qnode->pst_sym.pst_value.pst_s_rsdm.pst_rsname);
		    return (E_DB_ERROR);
		}
		else
		{
		    /*
		    ** find a PSC_RESCOL structure describing this attribute of
		    ** a view and set a bit in psc_expmap to remember that this
		    ** attribute cannot be updated because it is not a simple
		    ** attribute
		    */
		    PSC_RESCOL	    *nonupdt_col;
		    DB_ATT_NAME	    att_name;

		    MEcopy((PTR) qnode->pst_sym.pst_value.pst_s_rsdm.pst_rsname,
			DB_MAXNAME, (PTR) &att_name);
			
		    nonupdt_col = psq_ccol(crblk, &att_name);
		    if (nonupdt_col == (PSC_RESCOL *) NULL)
		    {
			/* something is very wrong */
			psq_cb->psq_error.err_code = E_PS0002_INTERNAL_ERROR;
			return(E_DB_SEVERE);
		    }
		    
		    BTset((i4) nonupdt_col->psc_attid.db_att_id,
			(char *) &crblk->psc_expmap);

		    /*
		    ** while at it, reset the corresponding bit in updcolmap
		    ** since the user will never be able to update
		    ** that attribute
		    */
		    BTclear((i4) nonupdt_col->psc_attid.db_att_id,
			(char *) &updcolmap);
		}
	    }
	}

	treenode = qnode;

	/* Remove the update columns list from the target list, i.e.,
	** restore the target list to the original shape.
	*/
	for (qnode = tree->pst_qtree;
	     qnode->pst_left != updcollst;
	     qnode = qnode->pst_left
	    )
	;

	qnode->pst_left = treenode;
    }

    /* Verify updateablity/deleteability of the query. */
    if (updtmask & PST_UP)
    {
	i4		reason;
	i4		mask;
	i4		mask2;

	mask = cb->pss_resrng->pss_tabdesc->tbl_status_mask;
	mask2 = cb->pss_resrng->pss_tabdesc->tbl_2_status_mask;

	/*
	** Make sure base table is updateable; if a non-extended
	** catalog, catalog update privilege must be on.
	** If security catalog session must have security privilege
	*/
        if (mask2 & DMT_READONLY)
        {
            (VOID) psf_error(E_US14E6_5350_READONLY_TBL_ERR, 0L, PSF_USERERR,
                         &err_code, &psq_cb->psq_error, 0);
            return(E_DB_ERROR);
        }

	else if ( ( (mask & DMT_CATALOG || mask2 & DMT_TEXTENSION)
	    && ~mask & DMT_EXTENDED_CAT
	    && !(cb->pss_ses_flag & PSS_CATUPD)
	   )
	   ||
	   ((mask & DMT_SECURE) &&
	    !(cb->pss_ustat & DU_USECURITY)))
	{
	    /*
	    ** if the user has explicitly specified FOR UPDATE, report error,
	    ** otherwise (i.e. user has omitted FOR UPDATE/READONLY), simply
	    ** remember that the user may neither UPDATE nor DELETE through this
	    ** cursor
	    */
	    if (tree->pst_updtmode == PST_UNSPECIFIED)
	    {
		nonupdt = TRUE;
	    }
	    else
	    {
		i4 local_status;
		DB_ERROR	    e_error;

		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    local_status = psy_secaudit(FALSE, cb,
			    (char *)&cb->pss_resrng->pss_tabname,
			    &cb->pss_resrng->pss_tabdesc->tbl_owner,
			    sizeof(DB_TAB_NAME), 
			    SXF_E_TABLE,
			    I_SX2020_PROT_REJECT, 
			    SXF_A_FAIL|SXF_A_DELETE, 
			    &e_error);

		    if (local_status > status)
			status = local_status;
		}

		/* process security_alarms */
		local_status = psy_do_alarm_fail(cb, 
				cb->pss_resrng, PSQ_DELETE, &e_error);
		if (local_status > status)
		    status = local_status;
		(VOID) psf_error(2107L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 2, sizeof(cb->pss_lineno), 
				&cb->pss_lineno,
		    psf_trmwhite(sizeof(DB_TAB_NAME),
			(char *) &cb->pss_resrng->pss_tabname),
		    &cb->pss_resrng->pss_tabname);
		return (E_DB_ERROR);
	    }
	}

	(VOID) psl_up(cb, &cb->pss_auxrng, tree, &nonupdt, &reason);

	if (nonupdt && tree->pst_updtmode != PST_UNSPECIFIED)
	{
	    /* Report the error - then exit. */
	    psl_nonupdt_err(psq_cb, cb, reason, &err_code);
	    return (E_DB_ERROR);
	}

	if (nonupdt)
	{
	    /*
	    ** at this point this can only happen if the user omitted FOR
	    ** UPDATE/READONLY
	    ** reset updtmask; code below will take care of resetting
	    ** appropriate fields in the tree header
	    */
	    updtmask = 0;
	}

	/*
	** If this point in code is reached and updtmask != 0, the query is
	** updateable; it is also deletable because the requirements are the
	** same.
	*/
    }
    else if (updtmask & PST_DL)
    {
	i4		reason;
	i4		mask;
	i4		mask2;

	mask = cb->pss_resrng->pss_tabdesc->tbl_status_mask;
	mask2 = cb->pss_resrng->pss_tabdesc->tbl_2_status_mask;

	/* Make sure base table is deleteable; if a non-extended
	** catalog, catalog update privilege must be on.
	** if security catalog session must have security privilege active
	*/
        if (mask2 & DMT_READONLY)
        {
            (VOID) psf_error(E_US14E6_5350_READONLY_TBL_ERR, 0L, PSF_USERERR,
                         &err_code, &psq_cb->psq_error, 0);
            return(E_DB_ERROR);
        }

	else if (  ( (mask & DMT_CATALOG || mask2 & DMT_TEXTENSION)
	    && ~mask & DMT_EXTENDED_CAT
	    && !(cb->pss_ses_flag & PSS_CATUPD)
	   )
	   ||
	   ((mask & DMT_SECURE) &&
	    !(cb->pss_ustat & DU_USECURITY)))
	{
	    updtmask &= ~PST_DL;
	}
	else
	{
	    (VOID) psl_up(cb, &cb->pss_auxrng, tree, &nonupdt, &reason);

	    if (nonupdt)
	    {
		updtmask &= ~PST_DL;
	    }
	}
    }

    /* set pst_numjoins */
    tree->pst_numjoins = num_joins;

    /* If the query turns out to be deleteable/updateable
    ** we need to append a TID node to the target list.
    */
    if (updtmask & (PST_UP | PST_DL) )
    {
	PST_VAR_NODE	tidvar;
	PST_RSDM_NODE	rsdm;
	PST_QNODE	*rsdmnode;
	PST_QNODE	*tidnode;

	tidvar.pst_vno = cb->pss_resrng->pss_rgno;
	tidvar.pst_atno.db_att_id = 0;	    /* tid is always column 0 */
	STmove(((*cb->pss_dbxlate & CUI_ID_REG_U) ? "TID" : "tid"),
		' ', DB_MAXNAME, tidvar.pst_atname.db_att_name);

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_VAR, (char *) &tidvar, sizeof(tidvar),
	    DB_TID8_TYPE, (i2) 0, (i4) DB_TID8_LENGTH, (DB_ANYTYPE *) NULL,
	    &tidnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);	    /* non-zero return means error */
	}

	/* Set up a resdom result domain representing a tid. */
	rsdm.pst_rsno = 0;
	rsdm.pst_rsupdt = FALSE;
	rsdm.pst_rsflags = 0; /* no PST_RS_PRINT */
	MEcopy((PTR)&tidvar.pst_atname.db_att_name, DB_MAXNAME,
		(PTR)&rsdm.pst_rsname);

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL, tidnode,
	    PST_RESDOM, (PTR) &rsdm, sizeof(rsdm), DB_TID8_TYPE, (i2) 0, 
	    (i4) DB_TID8_LENGTH, (DB_ANYTYPE *) NULL, &rsdmnode, 
	    &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);	/* non-zero return means error */
	}

	/* Prepend the tid node to the target list */
	(VOID) pst_tlprpnd(rsdmnode, tree->pst_qtree);

	if (updtmask & PST_UP)
	{
	    /* Remember the updateable columns in the cursor control block */
	    STRUCT_ASSIGN_MACRO(updcolmap, crblk->psc_updmap);
	}

	tree->pst_delete = crblk->psc_delall;

	/*
	** if a user failed to specify FOR UPDATE/READONLY or ORDER BY, and it
	** looks like the user will be able to UPDATE/DELETE through this
	** cursor, we need to set tree->pst_updtmode to indicate DIRECT UPDATE +
	** we need to tell OPC that the user has not explicitly specified 
	** FOR UPDATE;
	** NOTE: that if the user has not explicitly specified FOR UPDATE, we 
	** 	 will allow only DIRECT update through it; doing otherwise would
	**	 break pre-6.5 applications and seems like an all-around bad 
	**	 idea (bug 57384 was filed to that effect)
	*/
	if (tree->pst_updtmode == PST_UNSPECIFIED)
	{
	    tree->pst_mask1 |= PST_IMPLICIT_CURSOR_UPDATE;
	    tree->pst_updtmode = PST_DIRECT;
	    if (cb->pss_stmt_flags & PSS_SCROLL)
		cb->pss_stmt_flags |= PSS_KEYSET;
	}
    }
    else
    {   /* For read only */
	tree->pst_delete = FALSE;		/* tree header */
	tree->pst_updtmode = PST_READONLY;	/* tree header */
	tree->pst_restab.pst_resvno = -1;	/* tree header */
	crblk->psc_delall = FALSE;		/* cursor ctrl block */
	crblk->psc_forupd = FALSE;		/* cursor ctrl block */
	/*
	** Clear out "for update" column map.
	*/
	(VOID) MEfill(sizeof (PSC_COLMAP), (u_char) 0, 
	    (PTR) &crblk->psc_iupdmap);
    }

    /* Modify the query tree header */
    status = pst_modhdr(cb, psq_cb, tree->pst_updtmode, tree);
    if (DB_FAILURE_MACRO(status))
    {
	return (status);
    }

    /* Copy the cursor id from the cursor control block to here */
    STRUCT_ASSIGN_MACRO(crblk->psc_blkid, tree->pst_cursid);

    /*
    ** remember the language using which the cursor was defined; will be mighty
    ** useful in determining whether any permission checking is needed when 
    ** processing UPDATE WHERE CURRENT OF <cursor> (if a cursor was declared
    ** using SQL, we are guaranteed that the user can SELECT from the table/view
    ** on which the cursor is defined whereas if the cursor was defined in QUEL,
    ** we may have to determine whether the user possesses RETRIEVE on columns
    ** appearing on the RHS of assignment; psc_lang is also used during DELETE
    ** CURSOR processing
    */
    crblk->psc_lang = psq_cb->psq_qlang;

#ifdef	xDEBUG
    {
	i4 val1;
	i4 val2;

	if (ult_check_macro(&cb->pss_trace, 13, &val1, &val2))
	{
	    (VOID) pst_display("\n\nCursor `%t' characteristics for:\n\t%s\n",
		psf_trmwhite(DB_MAXNAME, cb->pss_crsr->psc_blkid.db_cur_name),
		cb->pss_crsr->psc_blkid.db_cur_name, cb->pss_bgnstmt);
	    if (tree->pst_delete == FALSE)
		(VOID) pst_display("\n\ttree header: delete = FALSE");
	    else
		(VOID) pst_display("\n\ttree header: delete = TRUE");
	    if (tree->pst_updtmode == PST_DIRECT)
		(VOID) pst_display("\n\ttree header: updtmode = DIRECT UPDATE");
	    else if (tree->pst_updtmode == PST_DEFER)
		(VOID) pst_display("\n\ttree header: updtmode = DEFERRED UPDATE");
	    else
		(VOID) pst_display("\n\ttree header: updtmode = READ ONLY");
	    (VOID) pst_display("\n\ttree header: pst_restab.pst_resvno = %d",
		tree->pst_restab.pst_resvno);
	    if (crblk->psc_delall == FALSE)
		(VOID) pst_display("\n\tPSF cursor control block: delall = FALSE");
	    else
		(VOID) pst_display("\n\tPSF cursor control block: delall = TRUE");
	    if (crblk->psc_forupd == FALSE)
		(VOID) pst_display("\n\tPSF cursor control block: forupd = FALSE");
	    else
		(VOID) pst_display("\n\tPSF cursor control block: forupd = TRUE");

	    (VOID) psq_crdump(psq_cb, cb);
	}
    }
#endif

    return (E_DB_OK);
}

/*
**  psl_crskeyflag - flag key columns for updateable scrollable cursors
**
**  Description:
**
**	Flag columns in the first primary key or index we find that is
**	unique and is covered by the result set. Return an error if none
**	such is found.
**
**  Inputs:
**	    cb		ptr to session control block
**	    tree	query tree fragment
**
**  Outputs:
**
**  Returns:
**	    DB_STATUS
**
**  History:
**
**	24-may-2007 (toumi01)
**	    Created.
*/
i4
psl_crskeyflag(
	PSS_SESBLK	*cb,
	PST_QTREE	*tree)
{
	DB_STATUS	status = E_DB_OK;
	DB_ERROR	err_blk;
	i4		err_code, err_num;
	PST_QNODE	*resdomp;
	RDF_CB		rdfcb, *rdf_cb = &rdfcb;
	RDR_RB		*rdf_rb = &rdf_cb->rdf_rb;
	RDR_INFO	*rdrinfo;
	DMT_IDX_ENTRY	*idx_entry;
	i4		i, j, count, keys_set;

	/* call RDF to get key info about the cursor's base table */
	pst_rdfcb_init(rdf_cb, cb);
	rdf_rb->rdr_types_mask = RDR_RELATION | RDR_ATTRIBUTES |
	    RDR_BLD_PHYS | RDR_INDEXES | RDR_BY_NAME;
	MEcopy(tree->pst_restab.pst_resname.db_tab_name, DB_MAXNAME,
	    rdf_rb->rdr_name.rdr_tabname.db_tab_name);
	MEcopy(tree->pst_restab.pst_resown.db_own_name, DB_MAXNAME,
	    rdf_rb->rdr_owner.db_own_name);
	rdf_rb->rdr_rec_access_id = NULL;
	rdf_cb->rdf_info_blk = NULL;

	status = rdf_call(RDF_GETDESC, (PTR)rdf_cb);

	if (DB_FAILURE_MACRO(status))
	{
	    if (rdf_cb->rdf_error.err_code == E_RD0002_UNKNOWN_TBL)
	    {
		(VOID) psf_error(E_PS0903_TAB_NOTFOUND, 
		    rdf_cb->rdf_error.err_code, PSF_INTERR,
		    &err_code, err_blk, 1,
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &tree->pst_restab.pst_resname.db_tab_name),
		    &tree->pst_restab.pst_resname.db_tab_name);
	    }
	    else
	    {
		(VOID)psf_rdf_error(RDF_GETDESC, &rdf_cb->rdf_error, &err_blk);
	    }
	    return(status);
	}

	rdrinfo = rdf_cb->rdf_info_blk;

	/* flag primary key columns */
	count = keys_set = 0;
	/* only a unique key is a candidate for keyset flagging */
	if (rdrinfo->rdr_keys &&
	    rdrinfo->rdr_rel->tbl_status_mask & DMT_UNIQUEKEYS)
	    count = rdrinfo->rdr_keys->key_count;
	if (count)
	{
	    for ( i = 0; i < count; i++ )
	    {
		for (resdomp = tree->pst_qtree->pst_left;
		    resdomp != (PST_QNODE *) NULL &&
		    resdomp->pst_sym.pst_type == PST_RESDOM;
		    resdomp = resdomp->pst_left)
		{
		    if (resdomp->pst_right &&
			resdomp->pst_right->pst_sym.pst_type == PST_VAR &&
			rdrinfo->rdr_keys->key_array[i] ==
			resdomp->pst_right->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id)
		    {
			resdomp->pst_sym.pst_value.pst_s_rsdm.pst_rsflags
			    |= PST_RS_KEYSET;
			keys_set++;
		    }
		}
	    }
	}

	/* result set didn't include all key cols? skip it! */
	if (keys_set > 0 && keys_set < count)
	{
	    keys_set = 0;
	    for (resdomp = tree->pst_qtree->pst_left;
		resdomp != (PST_QNODE *) NULL &&
		resdomp->pst_sym.pst_type == PST_RESDOM;
		resdomp = resdomp->pst_left)
	    {
		resdomp->pst_sym.pst_value.pst_s_rsdm.pst_rsflags
		    &= ~PST_RS_KEYSET;
	    }
	}

	/* try flagging index key columns if primary key not usable */
	count = 0;
	if (rdrinfo->rdr_indx)
	{
	    idx_entry = rdrinfo->rdr_indx[0];
	    count = rdrinfo->rdr_no_index;
	    i = 0;
	}
	/* loop over indexes until we get a good one or run out */
	while (count > 0 && keys_set == 0 && i < count )
	{
	    for ( ; i < count; i++ )
	    {
		bool ix_usable = FALSE;

		/* only use ix if all columns are in result set */
		for ( j = 0; idx_entry[i].idx_attr_id[j] != 0; j++ )
		{
		    ix_usable = TRUE;
		    for (resdomp = tree->pst_qtree->pst_left;
			resdomp != (PST_QNODE *) NULL &&
			resdomp->pst_sym.pst_type == PST_RESDOM;
			resdomp = resdomp->pst_left)
		    {
			if (resdomp->pst_right &&
			    resdomp->pst_right->pst_sym.pst_type == PST_VAR &&
			    idx_entry[i].idx_attr_id[j] ==
			    resdomp->pst_right->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id)
				break;
		    }
		    if (resdomp == (PST_QNODE *) NULL ||
			resdomp->pst_sym.pst_type != PST_RESDOM)
			ix_usable = FALSE;
		}
		/* make sure ix is unique */
		if (ix_usable == TRUE)
		{
		    RDF_CB	ixrdfcb, *ixrdf_cb = &ixrdfcb;
		    RDR_RB	*ixrdf_rb = &ixrdf_cb->rdf_rb;

		    STRUCT_ASSIGN_MACRO(rdfcb, ixrdfcb);
		    MEcopy(idx_entry[i].idx_name.db_tab_name, DB_MAXNAME,
			ixrdf_rb->rdr_name.rdr_tabname.db_tab_name);
		    ixrdf_rb->rdr_rec_access_id = NULL;
		    ixrdf_cb->rdf_info_blk = NULL;
		    status = rdf_call(RDF_GETDESC, (PTR)ixrdf_cb);
		    if (DB_FAILURE_MACRO(status))
		    {
			if (ixrdf_cb->rdf_error.err_code ==
			    E_RD0002_UNKNOWN_TBL)
			{
			    (VOID) psf_error(E_PS0903_TAB_NOTFOUND, 
				ixrdf_cb->rdf_error.err_code, PSF_INTERR,
				&err_code, err_blk, 1,
				psf_trmwhite(sizeof(DB_TAB_NAME), 
				(char *) &idx_entry[i].idx_name.db_tab_name),
				&idx_entry[i].idx_name.db_tab_name);
			}
			else
			{
			    (VOID)psf_rdf_error(RDF_GETDESC,
				&ixrdf_cb->rdf_error, &err_blk);
			}
			return(status);
		    }
		    if (!(ixrdf_cb->rdf_info_blk->rdr_rel->tbl_status_mask
			    & DMT_UNIQUEKEYS))
			ix_usable = FALSE;
		    status = rdf_call(RDF_UNFIX, (PTR)ixrdf_cb);
		    if (DB_FAILURE_MACRO(status))
		    {
			(VOID)psf_rdf_error(RDF_UNFIX, &ixrdf_cb->rdf_error,
			    &err_blk);
			return(status);
		    }
		}
		/* we have a unique index in result set so flag it */
		if (ix_usable == TRUE)
		{
		    for ( j = 0; idx_entry[i].idx_attr_id[j] != 0; j++ )
		    {
			for (resdomp = tree->pst_qtree->pst_left;
			    resdomp != (PST_QNODE *) NULL &&
			    resdomp->pst_sym.pst_type == PST_RESDOM;
			    resdomp = resdomp->pst_left)
			{
			    if (resdomp->pst_right &&
				resdomp->pst_right->pst_sym.pst_type == PST_VAR &&
				idx_entry[i].idx_attr_id[j] ==
				resdomp->pst_right->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id)
			    {
				resdomp->pst_sym.pst_value.pst_s_rsdm.pst_rsflags
				    |= PST_RS_KEYSET;
				keys_set++;
			    }
			}
		    }
		}
		/* we only need to flag one index */
		if (keys_set > 0)
		    break;
	    }
	}

	/* unfix the RDF cache entry */
	{
	    status = rdf_call(RDF_UNFIX, (PTR)rdf_cb);
	    if (DB_FAILURE_MACRO(status))
	    {
		(VOID)psf_rdf_error(RDF_UNFIX, &rdf_cb->rdf_error, &err_blk);
		return(status);
	    }
	}

	/* if no unique key/ix then can't have scrollable updateable cursor */
	if (keys_set == 0)
	{
	    status = E_DB_ERROR;
	}

	return(status);
}

/*
**  psl_nonupdt_err - display error for attempt to use nonupdateable
**	cursor for update.
**
**  Description:
**	Cursor was opened for update, or as SCROLLABLE KEYSET, both
**	implying the need to be updateable. This function uses the reason
**	code to display appropriate error message.
**
**  Inputes:
**	    cb		    ptr to session control block
**	    psq_cb	    ptr to request control block
**	    reason	    code indicating why cursor is non-updateable
**	    err_code	    ptr to returned err_code
**
**  Outputs:
**
**  Returns:
**
**  History:
**
**	10-apr-2007 (dougi)
**	    Abstracted from psl_crsopen() to allow messages to be displayed
**	    from different contexts (regular FOR UPDATE cursor and SCROLL
**	    KEYSET cursor).
*/
i4
psl_nonupdt_err(
	PSQ_CB	*psq_cb,
	PSS_SESBLK *cb,
	i4	reason,
	i4	*err_code)
{


    /* Switch the reason code and issue the error. */
	    switch (reason)
	    {
	    case 1:
		/* Nonupdateability discovered during parsing (syntax check). */
		(VOID) psf_error(2925L, 0L, PSF_USERERR,
		    err_code, &psq_cb->psq_error, 0);
		break;
	    case 2:
		/* Error if duplicates removed at the outermost scope. */
		(VOID) psf_error(2219L, 0L, PSF_USERERR, err_code, 
		    &psq_cb->psq_error, 2, sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME,
			cb->pss_crsr->psc_blkid.db_cur_name),
		    cb->pss_crsr->psc_blkid.db_cur_name);
		break;
	    case 3:
		/* Error if UNION at the outermost scope. */
		(VOID) psf_error(2220L, 0L, PSF_USERERR, err_code, 
		    &psq_cb->psq_error, 2, sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME,
			cb->pss_crsr->psc_blkid.db_cur_name),
		    cb->pss_crsr->psc_blkid.db_cur_name);
		break;
	    case 4:
		/* Error if other than one range var at the outermost scope. */
		(VOID) psf_error(2203L, 0L, PSF_USERERR, err_code, 
		    &psq_cb->psq_error, 2, sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME,
			cb->pss_crsr->psc_blkid.db_cur_name),
		    cb->pss_crsr->psc_blkid.db_cur_name);
		break;
	    case 5:
		/* Error if the only range var is a non-mergeable view. */
		(VOID) psf_error(2221L, 0L, PSF_USERERR, err_code, 
		    &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),&cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME,
			cb->pss_crsr->psc_blkid.db_cur_name),
		    cb->pss_crsr->psc_blkid.db_cur_name);
		break;
	    case 6:
		/* Error if index */
		(VOID) psf_error(2222L, 0L, PSF_USERERR, err_code,
		    &psq_cb->psq_error, 2, sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME,
			cb->pss_crsr->psc_blkid.db_cur_name),
		    cb->pss_crsr->psc_blkid.db_cur_name);
		break;
	    case 7:
		/* Error if aggregate in target list */
		(VOID) psf_error(2223L, 0L, PSF_USERERR, err_code, 
		    &psq_cb->psq_error, 2, sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(DB_MAXNAME,
			cb->pss_crsr->psc_blkid.db_cur_name),
		    cb->pss_crsr->psc_blkid.db_cur_name);
		break;
	    }

}

/*
**  psl_do_insert - complete building a tree for the insert, check for possible
**                  errors, build query header, if necessary
**
**  Description:
**	This procedure will
**	1) check that all mandatory columns (in the user-specified table, as
**	   well as the underlying base table, if the user-specified table is a
**	   view,
**	2) Mark QP as shareable, if appropriate,
**	3) invoke qrymod() to replace all views in the tree,
**	4) Make sure that the underlying table is updatable, and
**	5) invoke pst_header() to build the query header
**
**  Inputes:
**	    cb		    ptr to session control block
**	    psq_cb	    ptr to request control block
**	    root_node	    ptr to the root node of the query
**	    shareable_qp    ptr to indicator if the QP is shareable
**	    tree	    addr of the ptr to the tree header to be constructed
**	    isdbp	    indicator if the statement is a part of dbproc
**	    num_joins	    number of joins in the query
**	    xlated_qry	    Info on query site, etc.
**	    qry_info	    Address of pointer to table_id information to be
**				allocated by psl_shareable().
**
**  Outputs:
**	    *tree	    will point to the query header
**	    *shareable_qp   will indicate if the QP is shareable
**
**  Returns:
**	    E_DB_OK	    query tree has been build successfully
**	    E_DB_ERROR	    got some problems.
**
**  Side effects:
**	    will allocate memory for the header
**
**  22-may-89 (andre)     
**	Written.
**  08-sep-89 (andre)
**	pass number of joins to be stored in the header
**  15-jun-92 (barbara)
**	Sybil merge.  Star comments:
**	19-mar-92 (barbara)
**	    Pass in qry_info pointer for psl_shareable to use to store table
**	    info for repeat queries (part of fix for bug 42625) and xlated_qry.
**  15-oct-92 (rblumer)
**	make sure NOT NULL <no default> is treated as a mandatory column.
**  25-jan-93 (rblumer)
**	Move mandatory column checks (for both tables and views) to new routine
**	psl_check_defaults, and call that function from here.  That routine
**	will also generate nodes for default columns, instead of postponing
**	it to compile time (OPF). 
**  17-may-95 (dilma04)
**      Add table status checks and error handling when attempting to perform
**      INSERT against a READONLY table. 
*/
DB_STATUS
psl_do_insert(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PST_QNODE	*root_node,
	bool		*shareable_qp,
	PST_QTREE	**tree,
	i4		isdbp,
	PST_J_ID	num_joins,
	PSS_Q_XLATE	*xlated_qry,
	DB_SHR_RPTQRY_INFO	**qry_info)
{
    DB_TAB_NAME		    view_name;
    PST_QNODE		    *node;
    i4			    insert_into_view;
    DB_STATUS		    status;
    i4		    err_code;
    register PSS_RNGTAB	    *resrng = cb->pss_resrng;
    PST_PROCEDURE	    *pnode;
    i4		    mask;
    i4                 mask2;
    i4                 qrymod_resp_mask;

    /*
    ** Check the target list to see if there are any
    ** resdoms with pst_ttargtype of PST_USER, if so
    ** convert them to PST_ATTNO.
    */
    for (node = root_node->pst_left;
	 node != (PST_QNODE *) NULL && node->pst_sym.pst_type == PST_RESDOM;
	 node = node->pst_left)
    {
	if (node->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype == PST_USER)
	{
	    node->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype = PST_ATTNO;
	}
    }

    /* For repeat queries we must determine if the query is shareable.
    ** We already know that this is an SQL query, so the only criterion
    ** to be checked out is whether all relations/views are DBA owned or
    ** are catalogs.
    */
    if (cb->pss_defqry == PSQ_DEFQRY)
    {
	status = psl_shareable(psq_cb, cb, shareable_qp, qry_info);
	if (status != E_DB_OK)
	{
	    return (status);
	}
    }

    /* If inserting into a view save view name for error reporting */

    if (insert_into_view = resrng->pss_tabdesc->tbl_status_mask & DMT_VIEW)
    {
	STRUCT_ASSIGN_MACRO(resrng->pss_tabname, view_name);
    }

    /* Apply qrymod (views, permits, & integrities) */
    status = psy_qrymod(root_node, cb, psq_cb, &num_joins, &qrymod_resp_mask);
    if (status != E_DB_OK)
    {
	return (status);
    }

    /* make sure all mandatory columns have been specified,
    ** and build default CONST nodes for any columns that haven't been specified
    */
    status = psl_check_defaults(cb, resrng, root_node,
				insert_into_view, &view_name, 
				&psq_cb->psq_error);
    if DB_FAILURE_MACRO(status)
	return(status);
    
    mask = resrng->pss_tabdesc->tbl_status_mask;
    mask2 = resrng->pss_tabdesc->tbl_2_status_mask;

    /* Make sure base table is updateable;
    ** In case of an index or a non-extended catalog
    ** catalog update privilege must be on.
    ** In case of security catalog make sure 
    ** session has security privilege active
    ** Bug 34079, since 6.0 you were never supposed to be 
    ** able to update a secondary index.  Fixed it so 
    ** the same error is returned whether you have update 
    ** syscat or not (jennifer)
    **
    ** if PSS_REPAIR_SYSCAT and PSS_CATUPD are set in cb->pss_ses_flag,
    ** allow UPDATE on indexes which are non-extended catalogs
    */
    if (mask & DMT_IDX)
    {
	if (!(   mask & DMT_CATALOG && ~mask & DMT_EXTENDED_CAT
	      && cb->pss_ses_flag & PSS_CATUPD
	      && cb->pss_ses_flag & PSS_REPAIR_SYSCAT
	     )
	   )
	{
	    _VOID_ psf_error(2106L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &resrng->pss_tabname),
		&resrng->pss_tabname);
	    return(E_DB_ERROR);
	}
    }
    else if (((mask & DMT_CATALOG || mask2 & DMT_TEXTENSION)
	     && ~mask & DMT_EXTENDED_CAT
	     && !(cb->pss_ses_flag & PSS_CATUPD))
	     ||
	     ((mask & DMT_SECURE) &&
	       !(cb->pss_ustat & DU_USECURITY)))
    {
		i4 local_status;
		DB_ERROR	    e_error;

		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    local_status = psy_secaudit(FALSE, cb,
			    (char *)&resrng->pss_tabname,
			    &resrng->pss_tabdesc->tbl_owner,
			    sizeof(DB_TAB_NAME), 
			    SXF_E_TABLE,
			    I_SX2020_PROT_REJECT, 
			    SXF_A_FAIL|SXF_A_INSERT, 
			    &e_error);

		    if (local_status > status)
			status = local_status;
		}

		/* process security_alarms */
		local_status = psy_do_alarm_fail(cb, 
				resrng, PSQ_APPEND, &e_error);
		if (local_status > status)
		    status = local_status;

	_VOID_ psf_error(2107L, 0L, PSF_USERERR, &err_code,
	    &psq_cb->psq_error, 2, sizeof(cb->pss_lineno), &cb->pss_lineno,
	    psf_trmwhite(sizeof(DB_TAB_NAME), (char *) &resrng->pss_tabname),
	    &resrng->pss_tabname);
	return (E_DB_ERROR);
    }
    else if (mask2 & DMT_READONLY)
    {
        (VOID) psf_error(E_US14E6_5350_READONLY_TBL_ERR, 0L, PSF_USERERR, 
                         &err_code, &psq_cb->psq_error, 0);
         return(E_DB_ERROR);
    } 

    /* Create the query tree header */
    status = pst_header(cb, psq_cb, PST_UNSPECIFIED, (PST_QNODE *) NULL,
			root_node, tree, &pnode,
			(isdbp) ? 0 : PST_0FULL_HEADER, xlated_qry);
    if (status != E_DB_OK)
    {
	return (status);
    }

    /* set pst_numjoins.  $Yjoin_id contains the highest join id */
    (*tree)->pst_numjoins = num_joins;

    
    /* Fix the root in QSF */
    if (pnode != (PST_PROCEDURE *) NULL)
    {
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) pnode, &psq_cb->psq_error);
    }

    return(status);
}

/*********************************************************************/

DB_STATUS
psl_p_tlist(
	PST_QNODE	**tlist,
	PSS_YYVARS	*yyvarsp,
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb)
{
    register PST_QNODE	    *last_resdom = (PST_QNODE *) NULL;
    register PST_QNODE	    *rsdmnode;
    i4			    reset = FALSE;
    i4		    err_code;
    char		    emptycol[DB_MAXNAME];
    bool		    got_last=FALSE;
    
    (VOID) MEfill(DB_MAXNAME, ' ', (PTR) emptycol);

    cb->pss_stmt_flags |= PSS_PARSING_TARGET_LIST;
    for (rsdmnode = *tlist; rsdmnode != (PST_QNODE *) NULL;
	 rsdmnode = rsdmnode->pst_left)
    {
	PST_SYMBOL	*sym = &rsdmnode->pst_right->pst_sym;

	/*
	** Note that if the right child of a RESDOM is a PST_VAR_NODE, target
	** element must be one of the following:
	** 1) <column name> 
	**    (sym->pst_dataval.db_data==NULL &&
	**    !CMspace(sym->pst_value.pst_s_var.pst_atname.db_att_name))
	** 2) [<schema name>.]<table name>.<column name>
	**    (sym->pst_dataval.db_data!=NULL &&
	**     !CMspace(sym->pst_value.pst_s_var.pst_atname.db_att_name))
	** 3) [<schema name>.]<table name>.* 
	**    (sym->pst_dataval.db_data!=NULL &&
	**    CMspace(sym->pst_value.pst_s_var.pst_atname.db_att_name))
	** 4) plain ol' *
	**    (sym->pst_dataval.db_data==NULL &&
	**    CMspace(sym->pst_value.pst_s_var.pst_atname.db_att_name))
	**
	** Cases (3) and (4) will be handled here.  Cases (1) and (2) will
	** be handled (along with all other possible right children of a
	** a RESDOM) psl_p_telem()
	*/

	/*
	** When we process a target list consisting of "*", we create a VAR node
	** with blank attribute name and pst_dataval.db_data == NULL
	*/
	if (sym->pst_type == PST_VAR  &&
	    CMspace(sym->pst_value.pst_s_var.pst_atname.db_att_name) &&
	    (sym->pst_value.pst_s_var.pst_atno.db_att_id == PST_STAR_SEEN) &&
	    sym->pst_dataval.db_data == NULL)
	{
	    PST_J_MASK			flist_map;
	    i4				rgno;
	    PST_VAR_NODE		var;
	    register DMT_ATT_ENTRY	**attribute;
	    PST_QNODE			*varnode, *last;
	    PST_QNODE			*rsdm = rsdmnode->pst_left;
	    PSS_RNGTAB			*rngvar;
	    register i4		i;
	    DB_STATUS		status;
	    DB_DT_ID		att_type;
	    i4			att_width;

	    MEcopy((char *)&yyvarsp->flists[cb->pss_qualdepth], sizeof(PST_J_MASK),
				(char *)&flist_map);
	    cb->pss_rsdmno--;   /*
				** pss_rsdmno was incremented for this dummy
				** RESDOM.  Now we undo it.
				*/
	    
	    /*
	    ** list all attributes
	    **
	    ** make sure that we list columns of tables in the same order as the
	    ** tables have appeared in the FROM-list
	    */

	    for (rgno = -1, got_last = FALSE;
	         (rgno = BTnext(rgno, (char *) &flist_map, PST_NUMVARS)) != -1;
		)
	    {
		rngvar = yyvarsp->rng_vars[rgno];

		var.pst_vno = rngvar->pss_rgno;
		
		/* Start at first attribute */
		for (i = 0, attribute = rngvar->pss_attdesc + 1;
		     i < rngvar->pss_tabdesc->tbl_attr_count;
		     i++, attribute++)
		{
		    if ((*attribute)->att_flags & DMT_F_HIDDEN)
			continue;

		    /* Set up var node for copy into tree */
		    var.pst_atno.db_att_id = (*attribute)->att_number;
		    STRUCT_ASSIGN_MACRO((*attribute)->att_name, var.pst_atname);

		    if ((cb->pss_defqry == PSQ_PREPARE ||
                        psq_cb->psq_mode == PSQ_VIEW) &&
                	rngvar != NULL &&
                	rngvar->pss_inner_rel.pst_j_mask != 0 &&
                	rngvar->pss_var_mask & PSS_INNER_RNGVAR &&
                	(*attribute)->att_type > 0 )
		    {
                	att_type = -(*attribute)->att_type;
			att_width = (*attribute)->att_width+1;
		    }
		    else
		    {
                	att_type = (*attribute)->att_type;
			att_width = (*attribute)->att_width;
		    }


		    /* Create the PST_VAR_NODE */
		    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			(PST_QNODE *) NULL, PST_VAR, (char *) &var, sizeof(var),
			(DB_DT_ID) (*attribute)->att_type,
			(i2) (*attribute)->att_prec,
			(i4) (*attribute)->att_width, (DB_ANYTYPE *) NULL,
			&varnode, &psq_cb->psq_error, (i4) 0);
		    if (DB_FAILURE_MACRO(status))
			return (status);
		    varnode->pst_sym.pst_dataval.db_collID =
						(*attribute)->att_collID;

		    /* Create the corresponding result domain node */
		    status = pst_adresdom((char *) &(*attribute)->att_name, 
			rsdm, varnode, cb, psq_cb, &rsdm);
		    if (DB_FAILURE_MACRO(status))
			return (status);

		    if (!got_last)
		    {
			/* remember the bottom element of the new resdom chain*/
			last = rsdm;
			got_last=TRUE;
		    }
		    
		    /* if (check_tuple_width)
		    {
			/* 
			** add width of this attribute to the width of the tuple
			** if, prior to entering this loop, we have determined 
			** that we need to verify that the width of the tuple 
		        tuple_width += (*attribute)->att_width;
		    }*/
		}	/* end of columns in table */
	    }	/* end of tables in flist_map */

	    /*
	    ** To prevent problems with "select * X" where X != "from"
	    ** we have to check whether rsdmnode exists.
	    */
	    if (rsdm == (PST_QNODE *) NULL)
	    {
		(VOID) psf_error(2104L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, (i4) sizeof(cb->pss_lineno),
		    &cb->pss_lineno);
		return (E_DB_ERROR);
	    }

	    /*
	    ** now we need to make sure that the top element of the new
	    ** chain of RESDOMs is properly linked into the existing chain
	    */
	    if (last_resdom != (PST_QNODE *) NULL)
	    {
		last_resdom->pst_left = rsdm;
		if (i != 1)
		{
		    /*
		    ** if number of attributes is different from 1, and this
		    ** RESDOM node was not the top node in the chain, resdom
		    ** numbers will have to be reset
		    */
		    reset = TRUE;
		}
	    }
	    else
	    {
		/*
		** var.* was the last element of the target list (the
		** corresponding RESDOM node was the first node in the chain of
		** RESDOMs representing the target list)
		*/
		*tlist = rsdm;
	    }
	    
	    /*
	    ** remember the last resdom node of the new chain as the last
	    ** node processed; 
	    */
	    last_resdom = /* rsdmnode = */ last;
	}	/* end of "select *, ..." */
	
	else if (sym->pst_type == PST_VAR		&&
	    sym->pst_dataval.db_data != NULL 	&&
	    MEcmp((PTR)(sym->pst_value.pst_s_var.pst_atname.db_att_name), 
		(PTR)emptycol, DB_MAXNAME) == 0  &&
	    (sym->pst_value.pst_s_var.pst_atno.db_att_id == PST_STAR_SEEN)
	   )
	{
	    i4		err_code;
	    PST_VAR_NODE	var;
	    DMT_ATT_ENTRY	**attribute;
	    register i4	i;
	    PST_QNODE		*varnode;
	    /*
	    ** rsdm is set to the left child of the current resdom  node to
	    ** ensure that the new RESDOM chain is linked properly into the
	    ** target list
	    */
	    PST_QNODE		*rsdm = rsdmnode->pst_left;
	    PST_QNODE		*last;
	    char		tabname[sizeof(DB_TAB_NAME) + 1];
	    PSS_TBL_REF		*tbl_ref;
	    PSS_RNGTAB		*rngtab;
	    DB_STATUS		status;
	    DB_DT_ID		att_type;
	    i4			att_width;

            reset = TRUE;            /* any "x.*" requires reset */         
	    tbl_ref = (PSS_TBL_REF *) sym->pst_dataval.db_data;
	    MEcopy((PTR) &tbl_ref->pss_tab_name, sizeof(DB_TAB_NAME),
	           (PTR) tabname);
	    tabname[sizeof(DB_TAB_NAME)] = '\0';
	    (VOID) STtrmwhite(tabname);

	    /* need to look for range var at proper scope */

	    /* Look for an already-existing range var of this name */
	    status = pst_slook(&cb->pss_auxrng, cb, tbl_ref->pss_schema_name,
		tabname, &rngtab, &psq_cb->psq_error, TRUE);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }

	    /* If not found, error - table not in from list */
	    if (rngtab == (PSS_RNGTAB *) NULL)
	    {
		/* table not found */
		(VOID) psf_error(2118L, 0L, PSF_USERERR, &err_code,
				 &psq_cb->psq_error, 1, STlength(tabname),
				 tabname);
		return (E_DB_ERROR);
	    }

	    cb->pss_rsdmno--;		/* account for a dummy RESDOM */
	    /* Start at first attribute */
	    got_last=FALSE;
	    for (i = 0, attribute = rngtab->pss_attdesc + 1;
		 i < rngtab->pss_tabdesc->tbl_attr_count;
		 i++, attribute++)
	    {
		/*
		** Skip hidden attributes (makes x.* and * consistent)
		*/
	        if ((*attribute)->att_flags & DMT_F_HIDDEN)
			continue;

		/* Set up var node for copy into tree */
		var.pst_vno = rngtab->pss_rgno;
		var.pst_atno.db_att_id = (*attribute)->att_number;
		STRUCT_ASSIGN_MACRO((*attribute)->att_name, var.pst_atname);

                if ((cb->pss_defqry == PSQ_PREPARE ||
                        psq_cb->psq_mode == PSQ_VIEW) &&
                    rngtab != NULL &&
                    rngtab->pss_inner_rel.pst_j_mask != 0 &&
                    rngtab->pss_var_mask & PSS_INNER_RNGVAR &&
                    (*attribute)->att_type > 0 )
		{
                    att_type = -(*attribute)->att_type;
		    att_width = (*attribute)->att_width+1;
		}
		else
		{
                    att_type = (*attribute)->att_type;
		    att_width = (*attribute)->att_width;
		}

		/* Create the PST_VAR_NODE */
		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		    (PST_QNODE *) NULL, PST_VAR, (char *) &var, sizeof(var),
		    att_type, (i2) (*attribute)->att_prec, att_width,
		    (DB_ANYTYPE *) NULL, &varnode, &psq_cb->psq_error, (i4) 0);
		if (DB_FAILURE_MACRO(status))
		    return (status);
		varnode->pst_sym.pst_dataval.db_collID =
						(*attribute)->att_collID;

		/* Create the corresponding result domain node */
		status = pst_adresdom((char *) &(*attribute)->att_name,
		    rsdm, varnode, cb, psq_cb, &rsdm);
		if (DB_FAILURE_MACRO(status))
		    return (status);

		if (!got_last)
		{
		    /* remember the bottom element of the new resdom chain*/
		    last = rsdm;
		    got_last=TRUE;
		}
	    }

	    /*
	    ** now we need to make sure that the top element of the new
	    ** chain of RESDOMs is properly linked into the existing chain
	    */
	    if (last_resdom != (PST_QNODE *) NULL)
	    {
		last_resdom->pst_left = rsdm;
		if (i != 1)
		{
		    /*
		    ** if number of attributes is different from 1, and this
		    ** RESDOM node was not the top node in the chain, resdom
		    ** numbers will have to be reset
		    */
		    reset = TRUE;
		}
	    }
	    else
	    {
		/*
		** var.* was the last element of the target list (the
		** corresponding RESDOM node was the first node in the chain of
		** RESDOMs representing the target list)
		*/
		*tlist = rsdm;
	    }
	    
	    /*
	    ** remember the last resdom node of the new chain as the last
	    ** node processed; 
	    */
	    last_resdom = /* rsdmnode = */ last;
	}
	else
	{
	    PSS_RNGTAB  *rngtable = NULL;
	    DB_STATUS	status;
	    i4		save_type = sym->pst_type;
	    
	    status = psl_p_telem(cb, psq_cb, &rsdmnode->pst_right, yyvarsp,
				&rngtable, (i4)0);

	    if (DB_FAILURE_MACRO(status))
	    {
		return(status);
	    }
	    
	    last_resdom = rsdmnode;

	    /*
	    ** Now we need to change some fields inside the RESDOM node.
	    ** 1) if (type of the right child changed from PST_VAR to PST_CONST
	    **        AND (RESDOM represents a local dbproc variable OR
	    **	           user has not explicitly named the RESDOM)
	    **	     )
	    **	  {
	    **	      reset pst_rsname to all blanks.
	    **	  }
	    ** 2) if RESDOM represents a local dbproc variable
	    **	  {
	    **	      invoke pst_parm_resolve();
	    **	  }
	    **	  else
	    **	  {
	    **	      reset RESDOM's db_datavalue (except for db_data) to that
	    **	      of its right child.
	    **	  }
	    */

	    if (save_type == PST_VAR				    &&
	        rsdmnode->pst_right->pst_sym.pst_type == PST_CONST  &&
		(rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype ==
		     PST_LOCALVARNO ||
		 rsdmnode->pst_sym.pst_type == PST_RESDOM
		)
	       )
	    {
		MEfill(sizeof(DB_ATT_NAME), (u_char) ' ',
		    (PTR) rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_rsname);
	    }

	    if (rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype ==
		     PST_LOCALVARNO)
	    {
		status = pst_parm_resolve(cb, psq_cb, rsdmnode);
		if (DB_FAILURE_MACRO(status))
		{
		    return(status);
		}
	    }
	    else 
	    {
		/*
		** Note that the right subtree may have contained PST_VAR(s), so
		** we would have no idea as to its datavalue
		*/

		DMT_ATT_ENTRY		coldesc;

		status = pst_rsdm_dt_resolve(rsdmnode->pst_right, &coldesc,
		    cb, psq_cb);
		if (DB_FAILURE_MACRO(status))
		    return(status);

		rsdmnode->pst_sym.pst_dataval.db_datatype = coldesc.att_type;
		rsdmnode->pst_sym.pst_dataval.db_length   = coldesc.att_width;
		rsdmnode->pst_sym.pst_dataval.db_prec     = coldesc.att_prec;
		rsdmnode->pst_sym.pst_dataval.db_collID   = coldesc.att_collID;

		if ((cb->pss_defqry == PSQ_PREPARE || psq_cb->psq_mode == PSQ_VIEW) &&
		    rngtable != NULL &&
		    rngtable->pss_inner_rel.pst_j_mask != 0 &&
		    rsdmnode->pst_sym.pst_dataval.db_datatype > 0 &&
		    rngtable->pss_var_mask & PSS_INNER_RNGVAR)
		{
		    rsdmnode->pst_sym.pst_dataval.db_datatype = 
			- (rsdmnode->pst_sym.pst_dataval.db_datatype);
		    rsdmnode->pst_sym.pst_dataval.db_length++;
		}
	    }

	    /*
	    ** pst_type may have been set to PSS_2RESDOM if the user has
	    ** explicitly named the RESDOM
	    */
	    rsdmnode->pst_sym.pst_type = PST_RESDOM;
	}
    }
    /* If we have to reset resdom numbers, we'll do it here */
    if (reset)
    {
	register i4	    i;

	for (rsdmnode = *tlist, i = cb->pss_rsdmno;
	     i > 0;
	     i--, rsdmnode = rsdmnode->pst_left)
	{
	    rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_rsno = i;

	    /*
	    ** Note that if RESDOM represents local dbproc variable, pst_ntargno
	    ** would be reset and no longer needs to be equal to pst_rsno
	    */
	    if (rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype !=
		     PST_LOCALVARNO)
	    {
		rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_ntargno = i;
	    }
	}
    }
    cb->pss_stmt_flags &= ~PSS_PARSING_TARGET_LIST;
    return(E_DB_OK);
}

/**********************************************************************/
/*
** Name: psl_p_telem - process prototype target list tree elements including
**		       PST_VAR nodes representing column references of form
**		       [[<schema>.]<table>.]<column>
** Description:
**
**	This routine re-scans a target list, doing type resolution.
**	Since SQL puts the result list before the FROM list, when the
**	result list (target list) is parsed, we may not have complete
**	type information (or any type information at all).  This routine
**	walks a target list tree node, performing type resolution.
**	Operator nodes are handled by walking the children and applying
**	type resolution to the operator.  Constants and sequence operators
**	have known type already, so there's nothing to do.
**
**	VAR nodes are the most interesting.  If it's a qualified
**	table.column reference, we verify that the table name is in
**	the FROM list, and extract and apply column type info.
**	If it's an unqualified name, it might be a DB procedure variable,
**	or an unqualified column name;  we dig around to resolve the
**	name reference, and then apply the proper type.
**
**	A similar sort of type-deferral is done when parsing CHECK
**	constraints defined as part of a CREATE TABLE, or ALTER TABLE
**	ADD COLUMN.  (i.e. not alter table add constraint.)  The
**	CHECK predicate may refer to columns not yet (fully) defined,
**	so a prototype tree is build and later handed here for resolution.
**	To distinguish this case from the normal call, the
**	PSS_RESOLVING_CHECK_CONS flag is set in pss_stmt_flags.
**
**	This is where we apply "i4 tid" compatability.  Tids have been
**	i4 for forever, until release 3 when they became i8 (at least
**	outside of DMF).  Even though everyone knows you're not supposed
**	to materialize tids into a user app, everyone does it, including
**	QBF.  It would be nice to allow older client binaries running
**	e.g. over Ingres-Net to still work, since most tids still look
**	like i4's.  (The current exception being partitioned tables.)
**	If the i4 tid compatability flag is on, and we're doing a pure
**	select (not insert/select or create/select), and we're not in a
**	database procedure, and we're in the outermost subquery nesting
**	level, make tids look like i4's instead of i8.  (All the conditions
**	are intended to only hack tids that actually return to the
**	client, not tids that are unmaterialized or only materialized
**	into database procedures.)  This way, we won't confuse the
**	presumably older-version client with our i8 type information.
**
** Input:
**	cb			PSS_SESBLK Parser session block
**	psq_cb			Query parse control block
**	node			PST_QNODE ** Ptr to pointer to tree node
**	yyvarsp			Pointer to yacc state information
**	rngtable		PSS_RNGTAB ** an output
**
** Output:
**	rngtable		If VAR encountered, set to range table
**				entry for the column-ref's table.  Pass
**				NULL if caller doesn't care.
**
** Returns:
**
** Side effects:
**
** History:
**	...
**
**	11-feb-93 (andre)
**	    add support for referencing a TID of a base table through an
**	    updatable views based on that table.
**	07-may-93 (andre)
**	    psl_p_telem() may now be called to process a prototype tree built to
**	    represent <search condition> of a CHECK constraint specified inside
**	    CREATE TABLE statement
**	27-may-93 (rblumer)
**	    added a case for AND, OR, and NOT nodes, now that this function is
**	    used for CHECK constraints, too.
**	03-feb-95 (forky01)
**	    Add check for SELECT COUNT(*) to have FROM list. Fixes bug 66610.
**	20-Apr-1999 (shero03)
**	    Support PST_MOP (3 & 4 operands)
**	3-sep-99 (inkdo01)
**	    Add support of case function.
**	11-mar-02 (inkdo01)
**	    Added sequence support.
**	3-Feb-2005 (schka24)
**	    Added i4 tid hack; add routine description; changed call sequence
**	    (unnecessarily, as it turned out, but it's shorter this way).
**	4-july-05 (inkdo01)
**	    Transform COUNT(expr) to COUNT(*) if expr is not nullable. This 
**	    allows reduction in number of COUNTs to be done in the face of 
**	    multiple AVG expressions (SIR 114788).
**	12-aug-05 (inkdo01)
**	    Unmodify parse tree in the case of avg() on date/decimal types.
**	30-Aug-2005 (schka24)
**	    Extend i4-tid hack to sum(int), since we're now forcing sum
**	    to return an i8 in the FI definitions.  Pre-r3 clients don't
**	    know what to do with i8's, so for those clients, make sum
**	    in the result list look like i4 again.
**	1-nov-05 (inkdo01)
**	    Add Star dbs into Karl's hack for i4 sums.
**	04-nov-05 (toumi01)
**	    Hack the hack for avg(x) to sum(x)/count(x) tranformation
**	    for the decimal datatype, to fix precision/scale. This is
**	    because the scale for sum(x) is that of the operand, but
**	    it is that value plus one for avg(x).
**	    Pass PST_XFORM_AVG down to operands via the xform_avg
**	    function argument and use this to set PSS_XFORM_AVG to be
**	    used when we create the operand node.
**	    While doing this change noticed and removed redundant test
**	    "if (aop_node->pst_left)".
**	14-nov-05 (toumi01)
**	    Adjust Star test for hack for i4 sums to take into account other
**	    conditions before decrementing pst_sym.pst_dataval.db_length.
**	23-mar-06 (dougi)
**	    Verify that "count(expr)" being converted to "count(*)" isn't
**	    based on column that's inner to an outer join.
**	12-dec-06 (gupsh01)
**	    Sum and Avg operations are not supported for ANSI date/time types,
**	    it is valid only for interval types.
*/
DB_STATUS
psl_p_telem(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PST_QNODE	**node,
	PSS_YYVARS	*yyvarsp,
        PSS_RNGTAB      **rngtable,
	i4		xform_avg)
{
    PST_J_MASK	    *from_list_stack = &yyvarsp->flists[0];
    PST_SYMBOL	    *sym;
    DB_STATUS	    status = E_DB_OK;
    i4	    	    err_code;
        
    if (*node == (PST_QNODE *) NULL)
    {
	return(E_DB_OK);
    }
    
    sym = &(*node)->pst_sym;

    if (((sym->pst_type == PST_UOP) || (sym->pst_type == PST_BOP)) &&
	(sym->pst_value.pst_s_op.pst_flags & PST_XFORM_AVG))
	xform_avg = TRUE;

    switch (sym->pst_type)
    {
	case PST_CONST:
	case PST_COP:
	case PST_SEQOP:
	{
	    break;
	}
	case PST_BOP:
	{
	    /*
	    ** here we will call psl_p_telem() recursively to process both
	    ** children of a PST_BOP before doing type resolution
	    */
	    if ((*node)->pst_left)
		status = psl_p_telem(cb, psq_cb, &(*node)->pst_left, yyvarsp,
				rngtable, xform_avg);
	    if (status != E_DB_OK)
	    {
		return(status);
	    }

	    /* If this is a "/" introduced for the transformation of 
	    ** "avg(x)" to "float8(sum(x)) / count(x)" AND "x" is date
	    ** date type, the whole expression is turned back into "avg(x)". */
	    if ((*node)->pst_sym.pst_value.pst_s_op.pst_flags & PST_XFORM_AVG)
	    {
		DB_DT_ID	dtype = abs((*node)->pst_left->
					pst_sym.pst_dataval.db_datatype);

		if ((dtype == DB_ADTE_TYPE) ||
		    (dtype == DB_TMWO_TYPE) ||
		    (dtype == DB_TMW_TYPE)  ||
		    (dtype == DB_TME_TYPE)  ||
		    (dtype == DB_TSWO_TYPE) ||
		    (dtype == DB_TSW_TYPE)  ||
		    (dtype == DB_TSTMP_TYPE)) 
	        {
		    /* Avg operation is not supported for these types */
		    (VOID) psf_error(9362, 0L, PSF_INTERR,
		        &err_code, &psq_cb->psq_error, 0);
		    return(E_DB_ERROR);
	        }

		if ((dtype == DB_DTE_TYPE) ||
		    (dtype == DB_INDS_TYPE) ||
		    (dtype == DB_INYM_TYPE))
		{
		    *node = (*node)->pst_left;	/* skip the whole xform */
		    (*node)->pst_left->pst_sym.pst_value.pst_s_op.
						pst_opno = ADI_AVG_OP;
						/* update AOP under AGHEAD */

		    /* Redo type res to locate AVG fi stuff. */
		    status = pst_node(cb, &cb->pss_ostream, (*node)->
			pst_left->pst_left, (*node)->pst_left->pst_right, 
			PST_AOP, (char *) NULL, 0, DB_NODT, (i2) 0, (i4) 0, 
			(DB_ANYTYPE *) NULL, &(*node)->pst_left, 
			&psq_cb->psq_error, PSS_TYPERES_ONLY);

		    if (status != E_DB_OK)
		    {
			return(status);
		    }
		    break;
		}
	    }

	    if ((*node)->pst_right)
	       status = psl_p_telem(cb, psq_cb, &(*node)->pst_right, yyvarsp,
				 rngtable, xform_avg);
	    if (status != E_DB_OK)
	    {
		return(status);
	    }

	    /*
	    ** we use a hack to represent ternary functions: 2-nd and third args
	    ** are represented by children of a dummy PST_CONST node hanging off
	    ** pst_right ptr of the PST_BOP node.
	    */
	    if (   (*node)->pst_right->pst_sym.pst_type == PST_CONST
		&& (*node)->pst_right->pst_left  != (PST_QNODE *) NULL
		&& (*node)->pst_right->pst_right != (PST_QNODE *) NULL
	       )
	    {
		PST_QNODE	    *dummy = (*node)->pst_right;

		/*
		** a ternary function masquerading as a binary.  2-nd and 3-rd
		** parameters are represented by left and right children of a
		** dummy PST_CONST node.  We have already dealt with the first
		** parameter, now handle the remaining two
		*/
		
		/* Process the 2-nd arg */
	        if (dummy->pst_left)
		   status = psl_p_telem(cb, psq_cb, &dummy->pst_left, yyvarsp,
		       rngtable, xform_avg);
		if (status != E_DB_OK)
		{
		    return(status);
		}

		/* Process the 3-rd arg */
	        if (dummy->pst_right)
		    status = psl_p_telem(cb, psq_cb, &dummy->pst_right, yyvarsp,
		        rngtable, xform_avg);
		if (status != E_DB_OK)
		{
		    return(status);
		}

		/*
		** perform additional processing for ternary functions
		** for the time being it consists of verifying that function is
		** DECIMAL(), validating specified precision and scale, and
		** combining precision and scale inside the node describing
		** precision (i.e. the second argument)
		*/
		status = psl_3ary_func_extra_proc(
		    (i4) sym->pst_value.pst_s_op.pst_opno,
		    dummy->pst_left, dummy->pst_right,
		    &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return(status);

		/* We no longer need the dummy PST_CONST node */
		(*node)->pst_right = dummy->pst_left;
	    }
	    else
	    {
		/*
		** a truly binary function
		** 
		** perform additional processing for binary functions
		** for the time being it consists of checking types of second
		** attribute passed to several of binary functions or, if
		** function was DECIMAL(), of validating specified precision,
		** determining scale and combining precision and scale inside
		** the node describing precision
		*/
		status = psl_2ary_func_extra_proc(cb,
		    (i4) sym->pst_value.pst_s_op.pst_opno,
		    (*node)->pst_left, (*node)->pst_right,
		    &psq_cb->psq_error);
		if (DB_FAILURE_MACRO(status))
		    return(status);
	    }
	    
	    /* Finally we are ready to perform type reslolution */
	    status = pst_node(cb, &cb->pss_ostream, (*node)->pst_left,
	        (*node)->pst_right, PST_BOP, (char *) NULL, 0, DB_NODT, (i2) 0,
		(i4) 0, (DB_ANYTYPE *) NULL, node, &psq_cb->psq_error,
		PSS_TYPERES_ONLY);

	    if (status != E_DB_OK)
	    {
		return(status);
	    }
	    break;
	}
	case PST_UOP:
	{
	    /* First we process the left child */
	    if ((*node)->pst_left)
		status = psl_p_telem(cb, psq_cb, &(*node)->pst_left, yyvarsp,
				rngtable, xform_avg);
	    if (status != E_DB_OK)
	    {
		return(status);
	    }

	    /* If this is a "float8()" introduced for the transformation of 
	    ** "avg(x)" to "float8(sum(x)) / count(x)" AND "x" is either
	    ** decimal or date type, the "float8" is removed for the decimal
	    ** case, and the whole transform is reversed for the date case. */
	    if ((*node)->pst_sym.pst_value.pst_s_op.pst_flags & PST_XFORM_AVG)
	    {
		DB_DT_ID	dtype = abs((*node)->pst_left->
					pst_sym.pst_dataval.db_datatype);

		if ((dtype == DB_DEC_TYPE) || (dtype == DB_DTE_TYPE) || 
			(dtype == DB_INYM_TYPE) || (dtype == DB_INDS_TYPE))
		{
		    *node = (*node)->pst_left;	/* skip the float8() */
		    break;
		}
		if ( dtype == DB_ADTE_TYPE || dtype == DB_TME_TYPE || 
		     dtype == DB_TMWO_TYPE || dtype == DB_TMW_TYPE || 
		     dtype == DB_TSW_TYPE  || dtype == DB_TSWO_TYPE ||
		     dtype == DB_TSTMP_TYPE )
		{
		    (VOID) psf_error(9362, 0L, PSF_INTERR,
				&err_code, &psq_cb->psq_error, 0);
		    return(E_DB_ERROR);
		}
	    }

	    /*
	    ** additional processing for unary functions.  For the time
	    ** being, it will consist of setting default precision and scale
	    ** for specified argument to decimal() function (now that we
	    ** know what that argument is)
	    */
	    status = psl_1ary_func_extra_proc(cb,
		(i4) sym->pst_value.pst_s_op.pst_opno, (*node)->pst_left,
		&(*node)->pst_right, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return(status);

	    if (sym->pst_value.pst_s_op.pst_opno == ADI_DEC_OP)
	    {
		/* Our opnode has just become a BOP */
		sym->pst_type = PST_BOP;
	    }

	    /* now call pst_node() to perform type resolution */
	    status = pst_node(cb, &cb->pss_ostream, (*node)->pst_left,
	        (*node)->pst_right, sym->pst_type,
		(char *) &(*node)->pst_sym.pst_value.pst_s_op,
		sizeof(PST_OP_NODE), DB_NODT, (i2) 0, (i4) 0,
		(DB_ANYTYPE *) NULL, node, &psq_cb->psq_error,
		PSS_TYPERES_ONLY);

	    if (status != E_DB_OK)
	    {
		return(status);
	    }
	    break;
	}
	case PST_MOP:
	{
	    PST_QNODE	*lqnode;
	    /*
	    ** here we will call psl_p_telem() recursively to process all
	    ** children of a PST_MOP before doing type resolution
	    */
	    lqnode = *node;
	    while (lqnode)
	    {
	        if (lqnode->pst_right)
	           status = psl_p_telem(cb, psq_cb, &lqnode->pst_right,
				 yyvarsp, rngtable, xform_avg);
	        if (status != E_DB_OK)
	        {
		    return(status);
	        }
		lqnode = lqnode->pst_left;
	    }

	    /*  Currently there is no other processing for 3rd or 4th operands */
	    
	    /* Finally we are ready to perform type reslolution */
	    status = pst_node(cb, &cb->pss_ostream, (*node)->pst_left,
	        (*node)->pst_right, PST_MOP, (char *) NULL, 0, DB_NODT, (i2) 0,
		(i4) 0, (DB_ANYTYPE *) NULL, node, &psq_cb->psq_error,
		PSS_TYPERES_ONLY);

	    if (status != E_DB_OK)
	    {
		return(status);
	    }
	    break;
	}
	case PST_AGHEAD:
	{
	    PST_QNODE		*aop_node;
	    PST_QNODE           *var_node;
	    YYAGG_NODE_PTR	*agglist_elem;

	    /*
	    ** PST_AGHEAD nodes should not happen if we are resolving a
	    ** prototype tree built to represent <search condition> of a CHECK
	    ** constraint specified inside CREATE TABLE statement
	    */
	    if (cb->pss_stmt_flags & PSS_RESOLVING_CHECK_CONS)
	    {
		(VOID) psf_error(E_PS0002_INTERNAL_ERROR, 0L, PSF_INTERR,
		    &err_code, &psq_cb->psq_error, 0);
		return(E_DB_ERROR);
	    }


	    /*
	    ** AGHEAD will have AOP as a left child.  AOP may or may not have a
	    ** left child.  First we will process AOP's left child, then we will
	    ** perform type resolution on AOP, and finally we will copy AOP's
	    ** db_dataval into AGHEAD's db_dataval.
	    */
	    /* process AOP's left child, if any */
	    aop_node = (*node)->pst_left;
	    if (aop_node->pst_left != (PST_QNODE *) NULL)
	    {
		status = psl_p_telem(cb, psq_cb, &aop_node->pst_left,
				     yyvarsp, rngtable, xform_avg);
		if (status != E_DB_OK)
		{
		    return(status);
		}
	    }

	    /*
	    ** With the advent of binary staistical aggregate functions, AOP may
	    ** also have a right child to resolve. We do that here.
	    */
	    if (aop_node->pst_right != (PST_QNODE *) NULL)
	    {
		status = psl_p_telem(cb, psq_cb, &aop_node->pst_right,
				     yyvarsp, rngtable, xform_avg);
		if (status != E_DB_OK)
		{
		    return(status);
		}
	    }

	    /* COUNT(expr) becomes COUNT(*) when "expr" is not nullable and
	    ** COUNT is not DISTINCT. */
	    if (aop_node->pst_sym.pst_value.pst_s_op.pst_opno == ADI_CNT_OP
	      && aop_node->pst_sym.pst_value.pst_s_op.pst_distinct == PST_NDISTINCT
	      && aop_node->pst_left->pst_sym.pst_dataval.db_datatype > 0
	      && psl_aop_nooj(aop_node->pst_left, yyvarsp))
	    {
		aop_node->pst_sym.pst_value.pst_s_op.pst_opno = ADI_CNTAL_OP;
		aop_node->pst_left = (PST_QNODE *) NULL;
	    }

	    /* SELECT COUNT(*) must have a from list */
	    if ( aop_node->pst_sym.pst_value.pst_s_op.pst_opno == ADI_CNTAL_OP
	      && ( BTcount((char *)&from_list_stack[cb->pss_qualdepth],
			PST_NUMVARS) == 0))
	    {
		(VOID) psf_error(2440L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, sizeof(cb->pss_lineno),
		    &cb->pss_lineno);
		return(E_DB_ERROR);
	    }

	    /*
	    ** now call pst_node() to perform type resolution on AGHEAD's left
	    ** child
	    */

	    {
		int		pss_flags = PSS_TYPERES_ONLY;
		/*
		** if this is an avg(x) to sum(x)/count(x) transformation then
		** we have to adjust the result precision - tell pst_node that
		*/
		if (xform_avg == TRUE)
		    pss_flags |= PSS_XFORM_AVG;
		status = pst_node(cb, &cb->pss_ostream, aop_node->pst_left,
		    aop_node->pst_right, PST_AOP, (char *) NULL, 0, DB_NODT,
		    (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, &aop_node,
		    &psq_cb->psq_error, pss_flags);
	    }

	    if (status != E_DB_OK)
	    {
		return(status);
	    }
	    (*node)->pst_left = aop_node;

	    /* If this AOP is sum(int), and it's not from the avg transform,
	    ** and it's really in the result list and not in some other
	    ** context like an insert/select or a DBP, and we're in i4-tid
	    ** compatibility mode (meaning that we have an old-fashioned
	    ** client that doesn't understand i8's), reset the sum result
	    ** length back to i4.  Normally sum(int) is forced to i8 so
	    ** that we can do maximum CSE elimination with avg's.
	    **
	    ** If the compatibility hack applies, reduce i8's to i4's,
	    ** watching out for nullables...
	    */
	    if ((cb->pss_parser_compat & PSQ_I4_TIDS ||
		 cb->pss_distrib & DB_3_DDB_SESS)
	      && aop_node->pst_sym.pst_value.pst_s_op.pst_opno == ADI_SUM_OP
	      && (aop_node->pst_sym.pst_value.pst_s_op.pst_flags & PST_AVG_AOP) == 0
	      && ! yyvarsp->isdbp
	      && abs(aop_node->pst_sym.pst_dataval.db_datatype) == DB_INT_TYPE
	      && cb->pss_qualdepth == 1
	      && (psq_cb->psq_mode == PSQ_RETRIEVE || psq_cb->psq_mode == PSQ_DEFCURS)
	      && (cb->pss_stmt_flags & PSS_PARSING_INSERT_SUBSEL) == 0 )
		aop_node->pst_sym.pst_dataval.db_length -= 4;

	    /* Finally copy db_dataval from AOP to AGHEAD */
	    STRUCT_ASSIGN_MACRO(aop_node->pst_sym.pst_dataval,
				(*node)->pst_sym.pst_dataval);

	    (*node)->pst_sym.pst_dataval.db_data = (PTR) NULL;
	    
	    /*
	    ** we had to wait until now before checking for illegal use of
	    ** aggregates in where_clause and appending AGGHEAD to the
	    ** appropriate AGGHEAD list
	    */
	    if ((var_node = psl_find_node(aop_node, PST_VAR)) !=
		    (PST_QNODE *) NULL
		&&
	        BTtest(var_node->pst_sym.pst_value.pst_s_var.pst_vno,
		       (char *) &yyvarsp->illegal_agg_relmask))
	    {
		(VOID) psf_error(2930L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, sizeof(cb->pss_lineno),
		    &cb->pss_lineno);
		return (E_DB_ERROR);
	    }

	    /* allocate a new element of AGGHEAD list */
	    status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(YYAGG_NODE_PTR),
		(PTR *) &agglist_elem, &psq_cb->psq_error);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }
	    agglist_elem->agg_node = *node;

	    /* insert it into approprite AGGHEAD list */
	    psl_insert_into_agg_list(var_node, agglist_elem, 
				&yyvarsp->agg_list_stack[0],
				     cb->pss_qualdepth, from_list_stack);
	    break;
	}
	case PST_VAR:
	{
	    register DB_ATT_NAME    *colname =
					&sym->pst_value.pst_s_var.pst_atname;

	    /*
	    ** PST_VAR nodes found in a prototype tree representing <search
	    ** condition> of a CHECK constraint specified inside CREATE TABLE
	    ** statement are handled differently from those in a prototype tree
	    ** representing <target list>
	    */
	    if (cb->pss_stmt_flags & PSS_RESOLVING_CHECK_CONS)
	    {
		QEU_CB			*qeu_cb = (QEU_CB *) cb->pss_object;
		DMU_CB			*dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;
		i4			col_id;
		PST_CREATE_INTEGRITY	*crt_integ;
		DB_COLUMN_BITMAP	*integ_cols;
		DMU_ATTR_ENTRY		**attrs, *cur_attr;
		PST_VAR_NODE		varnode;

		col_id = psl_find_column_number(dmu_cb, colname);

		if (col_id == -1)
		{
		    /* attribute with specified name not found */
		    char        command[PSL_MAX_COMM_STRING];
		    i4	length;
		    
		    psl_command_string(psq_cb->psq_mode, DB_SQL,
			command, &length);

		    if (psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN)
		    {
		    /* 
		    ** the following ugly logic gets triggered when a 
		    ** check constraint expression which accompanies a column 
		    ** defined with an "alter table add column" statement
		    ** references a column other than the one being added. 
		    ** This is illegal in a column constraint. The ugly
		    ** part is that we can only recognize this condition
		    ** based upon the failure of the PST_VAR resolution 
		    ** call. And it fails because for architectural reasons,
		    ** the list of other columns in the table is not 
		    ** currently available.
		    */
			char	    *tabname;
			DMU_ATTR_ENTRY	**attrs = (DMU_ATTR_ENTRY **) 
			    dmu_cb->dmu_attr_array.ptr_address;

			/*
			** column-level constraint can only be specified using
			** CREATE TABLE statement, so look in dmu_cb for info.
			*/
		    
			tabname = dmu_cb->dmu_table_name.db_tab_name;
			colname = (DB_ATT_NAME *)attrs[0];

			_VOID_ psf_error(E_PS0472_COL_CHECK_CONSTRAINT, 0L,
			    PSF_USERERR, &err_code, &psq_cb->psq_error,
			    3, length, command,
			    psf_trmwhite(sizeof(DB_ATT_NAME), 
			    colname->db_att_name), colname->db_att_name,
			    psf_trmwhite(sizeof(DB_TAB_NAME), tabname), 
			    tabname);
			return(E_DB_ERROR);
		    }
		
		    _VOID_ psf_error(E_PS0483_CONS_NO_COL, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 3,
			length, command,
			psf_trmwhite(sizeof(DB_ATT_NAME), colname->db_att_name),
			colname->db_att_name,
			sizeof(ERx("CHECK")) - 1, ERx("CHECK"));
		    return (E_DB_ERROR);
		}

		/*
		** set the bit corresponding to this attribute in the attribute
		** map inside DB_INTEGRITY
		*/
		crt_integ =
		    &cb->pss_cur_cons_stmt->pst_specific.pst_createIntegrity;
		integ_cols = &crt_integ->pst_integrityTuple->dbi_columns;

		BTset(col_id, (char *) integ_cols);

		/*
		** now that we know the number, type, length, etc. of the
		** attribute, place that info into PST_VAR node
		*/
		attrs = (DMU_ATTR_ENTRY **) dmu_cb->dmu_attr_array.ptr_address;
		cur_attr = attrs[col_id - 1];

		varnode.pst_vno = 0;
		varnode.pst_atno.db_att_id = col_id;
		STRUCT_ASSIGN_MACRO((*colname), varnode.pst_atname);

		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		    (PST_QNODE *) NULL, PST_VAR, (char *) &varnode,
		    sizeof(varnode), (DB_DT_ID) cur_attr->attr_type,
		    (i2) cur_attr->attr_precision, (i4) cur_attr->attr_size,
		    (DB_ANYTYPE *) NULL, node, &psq_cb->psq_error, PSS_NOALLOC);

		if (DB_FAILURE_MACRO(status))
		    return(status);
		(*node)->pst_sym.pst_dataval.db_collID =
						cur_attr->attr_collID;

		/* there is no more to be done for this node */
		break;
	    }
	    
	    /*
	    ** colname->db_att_name is guaranteed to be non-blank (i.e. we are
	    ** dealing with [var.]cname since the cases when it would be blank
	    ** would have been handled elsewhere
	    **
	    ** if db_data was set to NULL, attribute name was not qualified
	    ** by variable name.
	    */
	    if (sym->pst_dataval.db_data == NULL)
	    {
		PST_QNODE	        *newnode = (PST_QNODE *) NULL;
		DB_STATUS		status;
		PST_J_MASK		*from_list =
					    &from_list_stack[cb->pss_qualdepth];
		PSS_RNGTAB		*rngvar = NULL;
		bool			found = FALSE;
		PSS_DECVAR		*var;

		if (yyvarsp->isdbp)
		{
		    /* Search for the variable; innermost scope first. */
		    for (var = (PSS_DECVAR *) yyvarsp->dbpinfo->pss_varq.q_next;
			 var != (PSS_DECVAR *) &yyvarsp->dbpinfo->pss_varq;
			 var = (PSS_DECVAR *) var->pss_queue.q_next
			)
		    {
			if (var->pss_out)
			    continue;

			if (MEcmp((PTR) colname, (PTR) &var->pss_varname,
			    sizeof(var->pss_varname)) == 0
			   )
			{
			    found = TRUE;
			    break;
			}
		    }
		}

		/*
		** For each range entry look for attribute in relation in
		** the FROM list.  If there is no FROM list, do not bother
		** to call psl_fatt()
		*/

		if (BTcount((char *)from_list, PST_NUMVARS) == 0)
		{
		    /* If column was not found but there is a var */
		    if (yyvarsp->isdbp && found)
		    {
			/*
			** Fill in a CONST node.  We may have to allocate
			** additional space to hold the data value.
			*/
			PST_CNST_NODE	cconst;

			/* Parm or local variable */
			cconst.pst_tparmtype = PST_LOCALVARNO;
			cconst.pst_parm_no = var->pss_no;
			cconst.pst_pmspec  = PST_PMNOTUSED;
			cconst.pst_cqlang = DB_SQL;
			cconst.pst_origtxt = (char *) NULL;
			status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
			    sizeof(cconst), var->pss_dbdata.db_datatype,
			    (i2) var->pss_dbdata.db_prec,
			    (i4) var->pss_dbdata.db_length, 
			    (DB_ANYTYPE *) var->pss_dbdata.db_data,
			    node, &psq_cb->psq_error, PSS_NOALLOC);
			if (DB_FAILURE_MACRO(status))
			    return (status);
		    }
		    else
		    {
			(VOID) psf_error(2103L, 0L, PSF_USERERR, &err_code,
			    &psq_cb->psq_error, 2,
			    (i4) sizeof(cb->pss_lineno),
			    &cb->pss_lineno,
			    psf_trmwhite(DB_MAXNAME, colname->db_att_name),
			    colname->db_att_name);
			return (E_DB_ERROR);
		    }
		}
		else
		{
		    if (!found)	/* there must be a column */
		    {
			/* find attribute */
			status = psl_fatt(cb, psq_cb, TRUE, colname, node,
			    &rngvar, (i4) 0, (PST_J_MASK *) NULL);
			if (DB_FAILURE_MACRO(status))
			    return (status);
		    }    
		    else			/* there is a var */
		    {
			/* There is a local var and we do not want any error
			** messages to be send to user yet.
			*/

			/* find if there is also an attribute (check only)*/
			status = psl_fatt(cb, psq_cb, TRUE, colname, node,
			    &rngvar, FIND_ONLY, (PST_J_MASK *) NULL);

			if (DB_FAILURE_MACRO(status))
			{
			    /* Column was not found, therefore
			    ** create a CNST node for the var.
			    */
			    PST_CNST_NODE	cconst;

			    /* Parm or local variable */
			    cconst.pst_tparmtype = PST_LOCALVARNO;
			    cconst.pst_parm_no = var->pss_no;
			    cconst.pst_pmspec  = PST_PMNOTUSED;
			    cconst.pst_cqlang = DB_SQL;
			    cconst.pst_origtxt = (char *) NULL;
			    status = pst_node(cb, &cb->pss_ostream,
				(PST_QNODE *) NULL, (PST_QNODE *) NULL,
				PST_CONST, (char *) &cconst, sizeof(cconst),
				var->pss_dbdata.db_datatype,
				(i2) var->pss_dbdata.db_prec,
				(i4) var->pss_dbdata.db_length, 
				(DB_ANYTYPE *) var->pss_dbdata.db_data, node,
				&psq_cb->psq_error, PSS_NOALLOC);
			    if (DB_FAILURE_MACRO(status))
				return (status);
			}
			else
			{
			    /* Column was found, reexecute call to psl_fatt,
			    ** this time create a var node for the column.
			    */
			    status = psl_fatt(cb, psq_cb, TRUE, colname,
				node, &rngvar, (i4) 0, (PST_J_MASK *) NULL);
			    if (DB_FAILURE_MACRO(status))
				return (status);
			}
		    }
		    if (rngtable != NULL)
                        *rngtable = rngvar;
		}
	    }
	    else	/* [<schema>.]var.cname has been specified */
	    {
		char			tabname[sizeof(DB_TAB_NAME) + 1];
		PSS_TBL_REF		*tbl_ref;
		PSS_RNGTAB		*rngtab;
		DMT_ATT_ENTRY		*attribute;
		PST_VAR_NODE		varnode;
		DB_STATUS		status;
		DMT_ATT_ENTRY		tid_att;

		tbl_ref = (PSS_TBL_REF *) sym->pst_dataval.db_data;
		MEcopy((PTR) &tbl_ref->pss_tab_name, sizeof(DB_TAB_NAME),
		       (PTR) tabname);
		tabname[sizeof(DB_TAB_NAME)] = '\0';
		(VOID) STtrmwhite(tabname);
		
		/* need to look for range var at proper scope */

		/* Look for an already-existing range var of this name */
		status = pst_slook(&cb->pss_auxrng, cb, 
		    tbl_ref->pss_schema_name, tabname, &rngtab, 
		    &psq_cb->psq_error, TRUE);
		if (status != E_DB_OK)
		{
		    return (status);
		}

		/* If not found, error- table not in from list */
		if (rngtab == (PSS_RNGTAB *) NULL)
		{
		    /* table not found */
		    (VOID) psf_error(2118L, 0L, PSF_USERERR, &err_code,
			       &psq_cb->psq_error, 1, STlength(tabname),
			       tabname);
		    return (E_DB_ERROR);
		}
		if (rngtable != NULL)
		    *rngtable = rngtab;

		STRUCT_ASSIGN_MACRO(sym->pst_value.pst_s_var.pst_atname,
				    varnode.pst_atname);
		/* Look up the attribute */
		attribute = pst_coldesc(rngtab, &varnode.pst_atname);

		/* Check for attribute not found */
		if (attribute == (DMT_ATT_ENTRY *) NULL)
		{
		    DB_ATT_NAME	    tid;

		    MEmove((sizeof("tid") - 1),
			(PTR)((*cb->pss_dbxlate & CUI_ID_REG_U) ?
			      "TID" : "tid"), ' ',
			sizeof(tid), (PTR) &tid);

		    /*
		    ** if rngtab represents a view V and column name was TID, we
		    ** will fabricate an attribute entry for V.TID and remember
		    ** that TID attribute of V was referenced;
		    ** at qrymod time, if the V is updatable, we will translate
		    ** the reference to V.TID to the the reference to TID of V's
		    ** underlying base table, otherwise, an error will be issued
		    */
		    if (   rngtab->pss_tabdesc->tbl_status_mask & DMT_VIEW
			&& !MEcmp((PTR) &tid, (PTR) &varnode.pst_atname,
				sizeof(tid)))
		    {
			rngtab->pss_var_mask |= PSS_TID_REFERENCE;
			
			attribute = &tid_att;
			psl_bld_tid_descr(attribute, cb);
		    }
		    else
		    {
			(VOID) psf_error(2100L, 0L, PSF_USERERR, 
			    &err_code, &psq_cb->psq_error, 4,
			    (i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
			    psf_trmwhite(sizeof(DB_TAB_NAME),
					 (char *) &rngtab->pss_tabname),
			    &rngtab->pss_tabname,
			    psf_trmwhite(sizeof(DB_OWN_NAME),
					 (char *) &rngtab->pss_ownname),
			    &rngtab->pss_ownname, 
			    psf_trmwhite(sizeof(DB_ATT_NAME),
					 (char *) &varnode.pst_atname),
			    &varnode.pst_atname);
			return (E_DB_ERROR);
		    }
		}
			
		/* Set up var node for copy into tree */
		varnode.pst_vno = rngtab->pss_rgno;
		varnode.pst_atno.db_att_id = attribute->att_number;

		/* Create the node */
		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		    (PST_QNODE *) NULL, PST_VAR, (char *) &varnode,
		    sizeof(varnode), (DB_DT_ID) attribute->att_type,
		    (i2) attribute->att_prec, (i4) attribute->att_width,
		    (DB_ANYTYPE *) NULL, node, &psq_cb->psq_error, PSS_NOALLOC);
		if (status != E_DB_OK)
		{
		    return (status);
		}
		(*node)->pst_sym.pst_dataval.db_collID =
						attribute->att_collID;
	    }	    /* var.cname */
	    /* See if we want to apply i4-tid hackery */
	    if (cb->pss_parser_compat & PSQ_I4_TIDS)
	    {
		/* Only if (*node) is still a VAR, and is a tid column,
		** and it's a real outermost select result-list.
		** Note that psq_mode gets tricked out in several cases,
		** but all but one are DB proc things.  The one exception is
		** insert as select, which we need to check for -- luckily
		** the select production sets a flag before whacking psq_mode.
		*/
		if (! yyvarsp->isdbp
		  && (*node)->pst_sym.pst_type == PST_VAR
		  && (*node)->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id == DB_IMTID
		  && (*node)->pst_sym.pst_dataval.db_datatype == DB_TID8_TYPE
		  && cb->pss_qualdepth == 1
		  && (psq_cb->psq_mode == PSQ_RETRIEVE || psq_cb->psq_mode == PSQ_DEFCURS)
		  && (cb->pss_stmt_flags & PSS_PARSING_INSERT_SUBSEL) == 0)
		    (*node)->pst_sym.pst_dataval.db_length = DB_TID_LENGTH;
	    }
	    break;
	}	/* case PST_VAR */

	case PST_CASEOP:
	{
	    PST_QNODE	**whlistpp;

	    /* For the "case" function, loop over each PST_WHLIST on the case
	    ** chain, and recurse. At the end, call pst_node to do type resolution. */

	    for (whlistpp = &(*node)->pst_left; (*whlistpp) != (PST_QNODE *) NULL;
		whlistpp = &(*whlistpp)->pst_left)
	    {
		status = psl_p_telem(cb, psq_cb, &(*whlistpp)->pst_right,
				yyvarsp, rngtable, xform_avg);
		if (status != E_DB_OK) 
		{
		    return(status);
		}
	    }

	    /* Resolve the source expression (if this is simple case). */
	    if ((*node)->pst_right)
	    {
		status = psl_p_telem(cb, psq_cb, &(*node)->pst_right,
				 yyvarsp, rngtable, xform_avg);
		if (status != E_DB_OK) return(status);
	    }

	    status = pst_node(cb, &cb->pss_ostream, (*node)->pst_left,
	        (*node)->pst_right, sym->pst_type,
		(char *) &(*node)->pst_sym.pst_value.pst_s_op,
		sizeof(PST_OP_NODE), DB_NODT, (i2) 0, (i4) 0,
		(DB_ANYTYPE *) NULL, node, &psq_cb->psq_error,
		PSS_TYPERES_ONLY);

	    if (status != E_DB_OK) 
	    {
		return(status);
	    }
	    break;
	}	/* case PST_CASEOP */
 
	case PST_AND:
	case PST_OR:
	case PST_NOT:
	case PST_WHOP:
	{
	    /* recursively process the rest of the tree
	    ** (note that this works even if one of the children is NULL).
	    ** Note also that we assume the node doesn't need to be
	    ** type-resolved, and don't call pst_node here.
	    */
	    if ((*node)->pst_left)
	       status = psl_p_telem(cb, psq_cb, &(*node)->pst_left, yyvarsp,
				 rngtable, xform_avg);
	    if (status != E_DB_OK)
	    {
		return(status);
	    }

	    if ((*node)->pst_right)
	       status = psl_p_telem(cb, psq_cb, &(*node)->pst_right, yyvarsp,
				 rngtable, xform_avg);
	    if (status != E_DB_OK)
	    {
		return(status);
	    }
	    break;
	}
	default:
	    /* should never happen */
	    (void) psf_error(E_PS0002_INTERNAL_ERROR, 0L, PSF_INTERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return(E_DB_ERROR);

    }	    /* end switch */
    return(E_DB_OK);
}

/*
** Name: psl_aop_nooj	- check for columns from inner tables of outer joins
**
** Description:
**	Checks the contents of a "count(expr)" to determine if the expression
**	has a column that is inner to an OJ. It will then be nullable and the
**	count can't be converted to a count(*).
**	for the type.
**
** Input:
**	nodep		ptr to expr subtree
**	yyvarsp		ptr to YACC locals (including rng_vars array)
**
** Output:
**
** Returns:
**	TRUE - if the expression isn't based on inner columns of OJs
**	FALSE - otherwise
**
** Side effects:
**	none
**
** History:
**	23-mar-06 (dougi)
**	    Written for count(expr) to count(*) optimization.
**	28-apr-06 (dougi)
**	    rngtable was wrong. Uses yyvarsp to address rng_vars array
**	    which really does contain range entries.
*/
static bool
psl_aop_nooj(
	PST_QNODE	*nodep,
	PSS_YYVARS	*yyvarsp)

{
    PSS_RNGTAB	*rngentry;
    bool	retval = TRUE;


    /* Switch, looking for PST_VARs to test for OJs, and recurse
    ** on the rest. */

    switch(nodep->pst_sym.pst_type) {
      case PST_VAR:
	rngentry = yyvarsp->rng_vars[nodep->pst_sym.pst_value.
				pst_s_var.pst_vno];
	if (!rngentry || BTcount((char *)&rngentry->pss_inner_rel, 
		(i4)BITS_IN(PST_J_MASK)) != 0)	/* col is from OJ inner */
	    return(FALSE);
	else return(TRUE);

      default:
	if (nodep->pst_left)
	    retval = psl_aop_nooj(nodep->pst_left, yyvarsp);
	if (retval && nodep->pst_right)
	    retval = psl_aop_nooj(nodep->pst_right, yyvarsp);
	return(retval);
    }

}

/*
**  psl_set_jrel - set the inner and outer relation masks for a given join_id
**		   given masks representing inner and outer relations and the
**		   join id.
**
**  Description:
**	This procedure will set join_id-th bit in the
**	pss_outer_rel/pss_inner_rel masks of relations marked in
**	outer_rels/inner_rels masks.
**
**  Inputs:
**	    rng_tab	    address of the first element of the range table
**	    inner_rels	    mask representing inner relations of this join
**	    outer_rels 	    mask representing outer relations of this join
**	    join_id	    join id
**	    rng_vars	    ptr to an array of ptrs to range table entries.
**			    i-th element of this array points to range var with
**			    range number equal to i.  Otherwise, it is set to
**			    NULL.
**
**  Outputs:
**	    None
**
**  Returns:
**	    None
**
**  Side effects:
**	    (join_id)-th bit will be set in the pss_outer_rel/pss_inner_rel
**	    mask for all relations represented by outer_rels/inner_rels
**
**  22-may-89 (andre)     
**	Written.
**	9-june-99 (inkdo01)
**	    Don't set pss_inner_rel for topmost inner joins (SIR 94906).
**	13-sep-00 (inkdo01)
**	    Remove above change - 94906 is being fixed elsewhere.
**	26-nov-02 (inkdo01)
**	    Expansion of range table changes inner/outer_rels to PST_J_MASK.
**	 8-sep-03 (hayke02)
**	    Remove the test for two vars in rel_mask/inner_rels for full
**	    joins. This now allows nested full joins to have nullability set
**	    correctly for the attributes in all full joined vars. This
**	    change fixes bug 110869.
*/
VOID
psl_set_jrel(
	PSS_RNGTAB		*rng_tab,
	PST_J_MASK		*inner_rels,
	PST_J_MASK		*outer_rels,
	i4			join_id,
	register PSS_RNGTAB	**rng_vars,
	DB_JNTYPE               join_type)
{
    register i4	    i;
    register char	    *rel_mask;

    if (inner_rels)
     for (i = -1, rel_mask = (char *) inner_rels;
         (i = BTnext(i, rel_mask, PST_NUMVARS)) != -1;
	)
    {
	BTset(join_id, (char *) &rng_vars[i]->pss_inner_rel);
        if (((join_type == DB_LEFT_JOIN) || (join_type == DB_RIGHT_JOIN)
            && (BTcount(rel_mask, PST_NUMVARS) == 1))
            ||
            (join_type == DB_FULL_JOIN))
            rng_vars[i]->pss_var_mask |= PSS_INNER_RNGVAR;
    }

    if (outer_rels)
     for (i = -1, rel_mask = (char *) outer_rels;
         (i = BTnext(i, rel_mask, PST_NUMVARS)) != -1;
	)
    {
	BTset(join_id, (char *) &rng_vars[i]->pss_outer_rel);
    }

    return;
}

/*{
** Name: psl_check_key	- Check datatype for keyability
**
** Description:
**      This routine returns E_DB_OK if a datatype can be used as a key.
**	If the datatype cannot (or if it cannot tell), the routine returns
**	E_DB_ERROR.
**
**	A datatype is keyable if it doesn't have the AD_NOKEY attribute.  Also,
**	to be a key, an attribute must be sortable (! AD_NOSORT) for the modify
**	to work. 
**
** Inputs:
**      cb                              The PSF session control block -- used to
**					generate errors and to obtain the adf
**					session control block (pss_adfcb).
**      att_type                        Attribute type to be checked.
**
** Outputs:
**      err_blk				filled if a disastrous ADF error occurs.
**
**	Returns:
**	    DB_STATUS
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**      31-Oct-1989 (fred)
**          Created for Predator/Terminator II/Phoenix -- Large object support.
**	18-mar-91 (andre)
**	    changed interface to accept error block ptr instead of psq_cb;
**	    psq_error was the only field of psq_cb which we were using anyway.
**	28-jun-1996 (shero03)
**	    Added support for RTree - ensure there is a nbr(obj, BOX) function
[@history_template@]...
*/
DB_STATUS
psl_check_key(
	PSS_SESBLK	    *cb,
	DB_ERROR	    *err_blk,
	DB_DT_ID	    att_type)
{	
    ADF_CB		    *adf_scb = (ADF_CB *) cb->pss_adfcb;
    i4			    dt_bits;
    DB_STATUS		    status;
    i4		    err_code;
    
    status = adi_dtinfo(adf_scb, att_type, &dt_bits);
    if (status)
    {
	(VOID) psf_error(E_PS0C05_BAD_ADF_STATUS,
	    adf_scb->adf_errcb.ad_errcode, PSF_INTERR, &err_code,
	    err_blk, 0);
	return (E_DB_ERROR);
    }
    else if (dt_bits & (AD_NOKEY | AD_NOSORT))
    {
	/* Caller will pick & supply his/her/its own error */
	return(E_DB_ERROR);
    }

    return(E_DB_OK);
}

/*
** psl_syn_info_msg()	- print a message notifying the user that the name
**			  supplied by him was that of a synonym
**
** History:
**	...
**	22-may-93 (andre)
**	    upcase (a bool) was being assigned a result of &'ing a u_i4
**	    field and long constant.  On machines where bool is char, this
**	    assignment will not produce the expected result
*/
VOID
psl_syn_info_msg(
	PSS_SESBLK	*sess_cb,
	PSS_RNGTAB	*rngvar,
	PSS_OBJ_NAME	*obj_spec,
	i4		owned_by,
	i4		qry_len,
	char		*qry,
	DB_ERROR	*err_blk)
{
    PTR		owner;
    i4	err_code;
    i4		len = sizeof(DB_OWN_NAME);
    bool	upcase = ((*sess_cb->pss_dbxlate & CUI_ID_REG_U) != 0);

    if (rngvar->pss_var_mask & PSS_EXPLICIT_QUAL)
    {
	/* if name was explicitly qualified, use owner name */
	owner = (PTR) &obj_spec->pss_owner;    
    }
    else if (owned_by & PSS_USR_OBJ)
    {
	owner = (PTR) &sess_cb->pss_user;
    }
    else if (owned_by & PSS_DBA_OBJ)
    {
	owner = (PTR) &sess_cb->pss_dba.db_tab_own;
    }
    else	    /* owner must have been $ingres */
    {
	/*@FIX_ME@ Should use pss_cat_owner? */
	owner = (upcase ? (PTR) "$INGRES" : (PTR) "$ingres");
	len   = sizeof("$ingres");
    }

    (VOID) psf_error(I_PS0451_SYN_WAS_SPECIFIED, 0L, PSF_USERERR,
	&err_code, err_blk, 5, qry_len, qry,
	psf_trmwhite(sizeof(DB_TAB_NAME), (char *) &obj_spec->pss_obj_name),
	&obj_spec->pss_obj_name,
	psf_trmwhite(len, owner), owner,
	psf_trmwhite(sizeof(DB_TAB_NAME), (char *) &rngvar->pss_tabname),
	&rngvar->pss_tabname,
	psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &rngvar->pss_ownname),
	&rngvar->pss_ownname);
}

/*
** psl_comment_col()	- process name of the column on which a comment is being
**			  created.  Column will always be qualified by the table
**			  name and, possibly, by the owner name.
**
**  Input:
**	sess_cb				    PSF session CB
**	  pss_auxrng			    range table
**	  pss_user			    current user
**	psq_cb				    PSF control block
**	  psq_mode			    query mode
**	col_ref				    description of a <column reference>
**	  pss_schema_name		    schema name (used to be owner name)
**	  pss_tab_name			    table name
**	  pss_col_name			    column name
**	  pss_flags			    useful info
**	    PSS_TBL_OR_CORR_NAME_SPECIFIED  table name (but no schema name)
**					    was specified
**	    PSS_TBL_SPECIFIED		    table name was specified (along
**					    with schema name)
**	    PSS_SCHEMA_SPECIFIED	    schema name was specified
**	    PSS_ALL_COLUMNS		    [schema.]tbl.* was specified
**
**  Output:
**	psq_cb
**	    psq_error	    filled in if an error is encountered
**
**  somewhere, somehow (andre)
**	written
**  25-sep-92 (andre)
**	instead of receiving owner, table, and column names, we will receive a
**	(PSS_COR_REF *).  This is done oin conjunction with introduction of
**	col_ref production
*/
DB_STATUS
psl_comment_col(
	PSS_SESBLK	*sess_cb,
	PSQ_CB		*psq_cb,
	PSS_COL_REF	*col_ref)
{
    PSY_COL	    *psy_col;
    PSS_RNGTAB      *resrange;
    DB_STATUS       status;
    i4		    rngvar_info;
    DB_TAB_NAME	    comment_tbl;

    /*
    ** make sure that table name was specified
    */
    if (!(col_ref->pss_flags &
	      (PSS_TBL_OR_CORR_NAME_SPECIFIED | PSS_TBL_SPECIFIED)))
    {
	psl_yerror(3, sess_cb, psq_cb);
	return(E_DB_ERROR);
    }

    STmove(col_ref->pss_tab_name, ' ', sizeof(DB_TAB_NAME),
	(char *) &comment_tbl);

    if (~col_ref->pss_flags & PSS_SCHEMA_SPECIFIED)
    {
	status = psl_rngent(&sess_cb->pss_auxrng, -1, "", &comment_tbl, sess_cb,
	    FALSE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
	    &rngvar_info);
	if (status == E_DB_INFO)
	{
	    status = E_DB_OK;
	    if (!psl_valid_session_schema_use(psq_cb->psq_mode, sess_cb,
		(char *)&comment_tbl, &psq_cb->psq_error))
	    {
		return(E_DB_ERROR);
	    }
	}
    }
    else
    {
	status = psl_orngent(&sess_cb->pss_auxrng, -1, "",
	    &col_ref->pss_schema_name, &comment_tbl, sess_cb, FALSE, &resrange,
	    psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info);
    }

    if (DB_FAILURE_MACRO(status))
    {
	return(status);
    }

    if (MEcmp((PTR) &resrange->pss_ownname, (PTR) &sess_cb->pss_user,
	      sizeof(DB_OWN_NAME)))
    {
	i4	    err_code;
	DB_ERROR    e_error;

	/*
	** let user know if name supplied by the user was resolved to a
	** synonym
	*/
	if (rngvar_info & PSS_BY_SYNONYM)
	{
	    PSS_OBJ_NAME	    obj_spec;

	    /* set up obj_spec for calling psl_syn_info_msg */
	    STRUCT_ASSIGN_MACRO(comment_tbl, obj_spec.pss_obj_name);

	    if (~col_ref->pss_flags & PSS_SCHEMA_SPECIFIED)
	    {
		MEfill(sizeof(DB_OWN_NAME), ' ', (PTR) &obj_spec.pss_owner);
		obj_spec.pss_objspec_flags = 0;
	    }
	    else
	    {
		STRUCT_ASSIGN_MACRO(col_ref->pss_schema_name,
		    obj_spec.pss_owner);
		obj_spec.pss_objspec_flags = PSS_OBJSPEC_EXPL_SCHEMA;
	    }

	    obj_spec.pss_orig_obj_name = col_ref->pss_tab_name;

	    psl_syn_info_msg(sess_cb, resrange, &obj_spec, rngvar_info,
		sizeof("COMMENT") - 1, "COMMENT", &psq_cb->psq_error);
	}
	/*
	** must audit failure to comment
	*/
	if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	{
	    status = psy_secaudit(FALSE, sess_cb, resrange->pss_tabname.db_tab_name,
		    &resrange->pss_ownname, sizeof(resrange->pss_tabname),
		    SXF_E_TABLE, I_SX2039_TBL_COMMENT,
		    SXF_A_FAIL | SXF_A_CONTROL, 
		    &e_error);
	}

	/*
	** user definitely may not add/change a comment on someone else's
	** table
	*/
	(VOID) psf_error(E_PS0424_ILLEGAL_TBL_REF, 0L, PSF_USERERR,
	    &err_code, &psq_cb->psq_error, 3,
	    sizeof("COMMENT") - 1, "COMMENT",
	    psf_trmwhite(sizeof(DB_TAB_NAME), (char *) &resrange->pss_tabname),
	    &resrange->pss_tabname,
	    psf_trmwhite(sizeof(DB_OWN_NAME), (char *) &resrange->pss_ownname),
	    &resrange->pss_ownname);

	return(E_DB_ERROR);
    }

    /* store table name for later use */
    STRUCT_ASSIGN_MACRO(resrange->pss_tabname,
			((PSY_CB *) sess_cb->pss_object)->psy_tabname[0]);

    status = psf_malloc(sess_cb, &sess_cb->pss_ostream, (i4) sizeof(PSY_COL), 
	(PTR *) &psy_col, &psq_cb->psq_error);
    if (status != E_DB_OK)
    {
	return (status);
    }

    /* Normalize the attribute name for later use */
    STmove(col_ref->pss_col_name, ' ', sizeof(DB_ATT_NAME),
	   (char *) &psy_col->psy_colnm);

    /*
    ** Attach element to the list.
    */
    (VOID) QUinsert((QUEUE *) psy_col,
	(QUEUE *) &((PSY_CB *) sess_cb->pss_object)->psy_colq);

    sess_cb->pss_resrng = resrange;

    return(E_DB_OK);
}

/*
** psl_insert_into_agg_list() -	attach preallocated AGGHEAD list element to the
**				appropriate AGGHEAD list.
** Description:		Since we now may allow correlated aggregates
**			(restrictions may be found in YYVARS.H comment for
**			illegal_agg_relmask), we no longer can blindly attach
**			newly built AGGHEAD node to the current AGGHEAD list.
**			Instead, we need to determine the scope of relation (if
**			any) referenced inside the AGGHEAD.  In case of
**			COUNT(*), there is no relation, so we will attach
**			AGGHEAD to the current AGGHEAD list, otherwise we will
**			consult masks representing relations at various scopes
**			and attach the newly built AGGHEAD node to the
**			appropriate AGGHEAD list.
** Input:
**	var_node	var_node found in the tree rooted in AGGHEAD node; this
**			node contains info which will enable us to determine
**			which relation is referenced in the AGGHEAD;
**	agglist_elem	preallocated AGGHEAD list element to be inserted into
**			appropriate AGGHEAD list;
**	agg_list_stack	stack of AGGHEAD lists at higher scopes, if any
**	cur_scope	current scope
**	rel_list	list of masks representing relations used at various
**			scopes
** Output:
**	the new element will be inserted into the appropriate list in
**	agg_list_stack 
** Returns:
**	None
**
** History:
**	17-may-90 (andre)
**	    written
*/
VOID
psl_insert_into_agg_list(
	PST_QNODE	*var_node,
	YYAGG_NODE_PTR	*agglist_elem,
	YYAGG_NODE_PTR	**agg_list_stack,
	i4		cur_scope,
	PST_J_MASK	*rel_list)
{
    YYAGG_NODE_PTR      **agg_list;

    /*
    ** we need to determine to which of the AGGHEAD lists the new
    ** AGGHEAD node must be attached; this is done by determining the scope of
    ** the relation referenced in the VAR node.  Note that we never need to
    ** worry about scope 0, since SELECT doesn't use it, and for DELETE and
    ** UPDATE it would be illegal to correlate to relations at scope 0 (i.e.
    ** relations being updated/deleted from) anyway.
    */

    agg_list = agg_list_stack + cur_scope;	    /* assume current scope */

    if (var_node != (PST_QNODE *) NULL)	    /* could happen with COUNT(*) */
    {
	i4     var_no = var_node->pst_sym.pst_value.pst_s_var.pst_vno;
	i4	scope;

	for (scope = cur_scope;
	     (scope > 0 && !BTtest(var_no, (char*) (rel_list + scope)));
	     scope--)
	;

	if (scope < cur_scope)
	{
	    agg_list = agg_list_stack + scope;
	}
    }

    /* insert preallocated element into the appropriate list */
    agglist_elem->agg_next = *agg_list;
    *agg_list = agglist_elem;
}

/*
** Name: psl_for_cond	this procedure builds the condition expression evaluated
**			after the select is executed for each iteration of a
**			for loop. Specifically, the expression is:
**			  (iirowcount > 0)
** Input:
**	sess_cb		    PSF session CB
**	psq_cb		    PSF request block
**	dbpinfo		    internal structure used to maintain info about the
**			    dbproc being parsed
**
** Output:
**	condition	    points to pst_condition in the IF node being 
**			    constructed
**
** Returns:
**	    E_DB_OK, E_DB_ERROR
**
** Side effects:   memory will be allocated; 
**
** History:
**	    24-aug-98 (inkdo01)
**		written.
*/
DB_STATUS
psl_for_cond(
	PSS_SESBLK	*sess_cb,
	PSQ_CB		*psq_cb,
	PSS_DBPINFO	*dbpinfo,
	PST_QNODE	**condition)
{
    DB_STATUS		    status;
    PST_QNODE		    *rownode, *constnode;
    PST_CNST_NODE	    rowcnt, const0;
    PST_OP_NODE		    gtop;
    i2			    zero = 0;
    /*
    ** Create a constant node for system variable "iirowcount".
    */
    rowcnt.pst_tparmtype = PST_LOCALVARNO;
    rowcnt.pst_parm_no = 0;
    rowcnt.pst_pmspec = PST_PMNOTUSED;
    rowcnt.pst_cqlang = DB_SQL;
    rowcnt.pst_origtxt = (char *) NULL;
    status = pst_node(sess_cb, &sess_cb->pss_ostream, (PST_QNODE *) NULL,
	(PST_QNODE *) NULL, PST_CONST, (char *) &rowcnt,
	sizeof (PST_CNST_NODE), DB_INT_TYPE, 0, 4,
	(DB_ANYTYPE *) NULL, &rownode, &psq_cb->psq_error, (i4) 0);
    if (status != E_DB_OK)
    {
	return (status);
    }
	
    /*
    ** Create a constant node for 0 to compare to iirowcount.
    */
    const0.pst_tparmtype = PST_USER;
    const0.pst_parm_no = 0;
    const0.pst_pmspec = PST_PMNOTUSED;
    const0.pst_cqlang = DB_SQL;
    const0.pst_origtxt = (char *) NULL;
    status = pst_node(sess_cb, &sess_cb->pss_ostream, (PST_QNODE *) NULL,
	(PST_QNODE *) NULL, PST_CONST, (char *) &const0,
	sizeof (PST_CNST_NODE), DB_INT_TYPE, 0, 2,
	(DB_ANYTYPE *) &zero, &constnode, &psq_cb->psq_error, (i4) 0);
    if (status != E_DB_OK)
    {
	return (status);
    }

    /*
    ** Create binary operation node to implement the comparison.
    */
    gtop.pst_opno = ADI_GT_OP;
    gtop.pst_opmeta = PST_NOMETA;
    gtop.pst_isescape = PST_DOESNT_APPLY;

    status = pst_node(sess_cb, &sess_cb->pss_ostream, rownode, constnode,
	    PST_BOP, (char *) &gtop, sizeof(gtop), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, condition, &psq_cb->psq_error, 0);

    if (DB_FAILURE_MACRO(status))
	return (status);


    return(E_DB_OK);
}

/*
** Name: psl_ifkwd -	this procedure will perform processing incidental to IF
**			and ELSEIF keywords encountered as a part of processing
**			[CREATE] PROCEDURE statement.
** Input:
**	sess_cb		    PSF session CB
**	psq_cb		    PSF request block
**	dbpinfo		    internal structure used to maintain info about the
**			    dbproc being parsed
**
** Output:
**	if_stmt_node	    will point to the newly allocated IF statement node
**
** Returns:
**	    E_DB_OK, E_DB_ERROR
**
** Side effiects:   memory will be allocated; some fields in dbpinfo block will
**		    be changed
**
** History:
**	    11-jun-90 (andre)
**		borrowed from the cdbp_ifkwd production.
**	    25-mar-91 (andre)
**		use the newly defined function, psl_init_dbp_stmt(), to allocate
**		and initialize the IF statement block.
*/
DB_STATUS
psl_ifkwd(
	PSS_SESBLK	*sess_cb,
	PSQ_CB		*psq_cb,
	PSS_DBPINFO	*dbpinfo,
	PST_STATEMENT	**if_stmt_node)
{
    DB_STATUS		    status;
    PSS_IFSTMT		    *pss_if;

    /* Allocate statement node. */
    status = psl_init_dbp_stmt(sess_cb, dbpinfo, psq_cb->psq_mode = PSQ_IF,
	PST_IF_TYPE, if_stmt_node, &psq_cb->psq_error);
    if (DB_FAILURE_MACRO(status))
	return (status);

    dbpinfo->pss_flags |= PSS_INCOND;

    /* Allocate PSS_IFSTMT node. */
    status = psf_malloc(sess_cb, &sess_cb->pss_ostream, sizeof(PSS_IFSTMT),
	(PTR *) &pss_if, &psq_cb->psq_error);
    if (DB_FAILURE_MACRO(status))
	return (status);

    pss_if->pss_stmt = *if_stmt_node;

    /* Push onto the IF queue */
    (VOID) QUinsert((QUEUE *) pss_if, &dbpinfo->pss_ifq);

    return(E_DB_OK);
}

/*
** psl_thenkwd	-   process THEN keyword appearing inside a dbproc.
**
** Input:
**	dbpinfo		structure describing a dbproc being parsed
** Output:
**	none
** Returns:
**	none
**
** History:
**	11-jun-90 (andre)
**	    copied from the cdbp_thenkwd production
**	25-mar-91 (andre)
**	    removed code setting dbpinfo->pss_patch since it gets set to the
**	    address of pst_true when the statement block representing IF or
**	    ELSEIF gets built
*/
VOID
psl_thenkwd(
	PSS_DBPINFO     *dbpinfo)
{
    /*
    ** dbpinfo->pss_patch gets set to the address of pst_true when the
    ** statement block representing IF or ELSEIF gets built
    */

    dbpinfo->pss_flags &= ~PSS_INCOND;

    return;
}

/*
** psl_elsekwd	-   process ELSE keyword appearing inside a dbproc.
**
** Input:
**	dbpinfo		structure describing a dbproc being parsed
** Output:
**	none
** Returns:
**	none
**
** History:
**	11-jun-90 (andre)
**	    copied from the cdbp_elsekwd production
*/
VOID
psl_elsekwd(
	PSS_DBPINFO     *dbpinfo)
{
    PST_STATEMENT *s;

    s = ((PSS_IFSTMT *) dbpinfo->pss_ifq.q_next)->pss_stmt;
    dbpinfo->pss_patch = &s->pst_specific.pst_if.pst_false;

    return;
}

/*
** psl_ifstmt()	    -	wrap up processing of the IF statement inside a dbproc.
**
** Input:
**	if_node		node representing IF statement
**	condition	root of the condition tree
**	if_action	root of the tree representing action to be taken if
**			condition evaluates to TRUE
**	else_action	root of the tree representing action to be taken if
**			condition evaluates to FALSE
**	dbpinfo		structure describing a dbproc being parsed
** Output:
**	none
** Returns:
**	none
**
** History:
**	11-jun-90 (andre)
**	    borrowed from cdbp_ifstmt production
**	25-mar-91 (andre)
**	    set dbpinfo->pss_patch to NULL so that if ENDLOOP occurs immediately
**	    following ENDIF, a new ENDLOOP statement block will be generated
**	20-sep-92 (andre)
**	    we can no longer assume that the description of the IF statement
**	    will be on top of the stack.  If the IF statement involved some
**	    ELSEIFs, their descriptions will be left on the stack until we
**	    finish processing of the whole IF statement.  Accordingly, here we
**	    will keep popping off the stack descriptions of statements until
**	    that associated with the IF statement is reached
*/
VOID
psl_ifstmt(
	PST_STATEMENT	    *if_node,
	PST_QNODE	    *condition,
	PST_STATEMENT	    *if_action,
	PST_STATEMENT	    *else_action,
	PSS_DBPINFO	    *dbpinfo)
{
    PSS_IFSTMT      *pss_if;
    
    if_node->pst_specific.pst_if.pst_condition = condition;
    if_node->pst_specific.pst_if.pst_true = if_action;
    if_node->pst_specific.pst_if.pst_false = else_action;

    /*
    ** Pop descriptions of statements until that of the IF statement is reached
    */
    do
    {
	pss_if = (PSS_IFSTMT *) QUremove(dbpinfo->pss_ifq.q_next);
    } while (pss_if->pss_stmt != if_node);

    /*
    ** set dbpinfo->pss_patch to NULL so that if ENDLOOP occurs
    ** immediately following ENDIF, a new ENDLOOP statement block will be
    ** generated
    */
    dbpinfo->pss_patch = (PST_STATEMENT **) NULL;
    
    return;
}

/*
** Name:	psl_simple_compare
**
** Description:	this function performs the semantic action associated with
**		productions where an expression is compared with an expression
**		which doesn't involve a subselect.  This function will not
**		handle BETWEEN and IN (list) type comparisons.
**		It will handle 	comparisons of 2 select_expr's
**		(including select_expr [NOT] IN select_expr), comparisons with
**		NULL and comparisons involving LIKE
**
** Input:
**	sess_cb			PSF session CB
**	    .pss_ostream	stream used to allocate memory
**	operand1		tree representing a value being compared;
**	operand2		for comparisons with NULL, this argument will be
**				set to NULL; for comparisions involving LIKE,
**				this will be set to the string with which a
**				column must be compared (if parsing a database
**				procedure, this may also be a dbproc parameter)
**	operator		comparison operator
**	is_escape		indicates whether the escape character was
**				specified, or even relevant; can be one of
**				PST_DOESNT_APPLY (for comparisons with NULL),
**				PST_NO_ESCAPE, or PST_HAS_ESCAPE
**	escape_char		escape character, if one was specified (i.e. if
**				is_escape == PST_HAS_ESCAPE)
**	in_join_search		TRUE <==> processing a join search condition
**	in_target_clause	TRUE <==> processing a select list
**	join_info		ptr to structure describing outer joins (if any)
**				encountered so far
**
** Output:
**	treeinfo		will contain addr of a pointer to a structure
**				consisting of:
**	    pss_tree		pointer to the new tree and
**	    pss_mask		initialized mask field
**	err_blk			may be filled in if an error occurs
**
** Side effects:
**	will allocate memory
**
** Returns:
**	E_DB_OK, E_DB_ERROR
**
** History:
**	10-31-90 (andre)
**	    written
**	15-oct-92 (rblumer)
**	    if parsing a constraint, don't do type resolution yet
**	02-may-93 (andre)
**	    changed function scope to static (it is used only in this file)
**
**	    we will avoid type resolution only if CHECK constraint was specified
**	    inside CREATE TABLE statement
**	    
**	    replaced err_blk with psq_cb since we need to access psq_mode and
**	    psq_cb->psq_error gives us the error block
**	10-sep-99 (inkdo01)
**	    Added target list check to nores_flag set, for case functions.
*/
static DB_STATUS
psl_simple_compare(
	PSS_SESBLK	*sess_cb,
	PST_QNODE	*operand1,
	PST_QNODE	*operand2,
	ADI_OP_ID	operator,
	i4		is_escape,
	char		escape_char,
	PSS_TREEINFO	**treeinfo,
	bool		in_join_search,
	bool		in_target_clause,
	PSS_JOIN_INFO	*join_info,
	PSQ_CB		*psq_cb)
{
    PST_OP_NODE	    opnode;
    DB_STATUS	    status;
    DB_ERROR        *err_blk = &psq_cb->psq_error;
    i4		    nores_flag;

    status = psf_malloc(sess_cb, &sess_cb->pss_ostream, sizeof(PSS_TREEINFO),
	     (PTR *) treeinfo, err_blk);
    if (DB_FAILURE_MACRO(status))
    {
	return (status);
    }

    opnode.pst_opno = operator;
    opnode.pst_opmeta = PST_NOMETA;

    if ((opnode.pst_isescape = (i1) is_escape) == PST_HAS_ESCAPE)
    {
	opnode.pst_escape = escape_char;
    }

    /*
    ** don't do type resolution if parsing a check constraint specified as a
    ** part of CREATE TABLE statement, as we may not know the type of the column
    ** (e.g. if it hasn't been defined yet). Also, if in target list (since
    ** predicates may now appear inside case functions in select list.
    */
    if (   in_target_clause
	||  (	sess_cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
	     && ( ( psq_cb->psq_mode == PSQ_CREATE) || 
	     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
    {
	nores_flag = PSS_NORES;
    }
    else
    {
	nores_flag = 0;
    }

    status = pst_node(sess_cb, &sess_cb->pss_ostream, operand1, operand2,
	(operand2 == (PST_QNODE *) NULL) ? PST_UOP : PST_BOP,
	(char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	(DB_ANYTYPE *) NULL, &(*treeinfo)->pss_tree, err_blk, nores_flag);

    if (DB_FAILURE_MACRO(status))
    {
	return (status);
    }

    if (operand1 != (PST_QNODE *) NULL && operand2 != (PST_QNODE *) NULL &&
	!(psl_validate_collation_mix(operand1->pst_sym.pst_dataval.db_collID,
	operand2->pst_sym.pst_dataval.db_collID)))
    {
	i4	err_code;
	(VOID) psf_error(6427L, 0L, PSF_USERERR, &err_code, err_blk, 0);
	return (E_DB_ERROR);
    }

    if (((*treeinfo)->pss_tree->pst_sym.pst_type != PST_CONST) &&
        (in_join_search))
    {
	/*
	** If we are processing a join_search condition, set the joinid
	** field appropriately.  It has been initialized to PST_NOJOIN in
	** pst_node().
	*/
	(*treeinfo)->pss_tree->pst_sym.pst_value.pst_s_op.pst_joinid =
		join_info->pss_join[join_info->depth].join_id;
    }

    (*treeinfo)->pss_mask = (i4) 0;

    return(E_DB_OK);
}

/*
** Name:	psl_subsel_compare
**
** Description:	this function performs the semantic action associated with
**		productions where an expression is compared with a subselect.
**
** Input:
**	sess_cb			PSF session CB
**	    .pss_ostream	stream used to allocate memory
**	expr			tree representing the expression being compared
**				(may be NULL if processing EXISTS predicate)
**	subsel			tree representing the subselect being compared
**	operator		comparison operator
**	meta_op			modifier for the above operator
**	in_join_search		TRUE <==> processing a join search condition
**	join_info		ptr to structure describing outer joins (if any)
**				encountered so far
**	subsel_illegal		TRUE <==> subselect is illegal in this context
**	err_msgno		number of the error message to display if
**				subsel_illegal
**	psq_cb			ptr to PSF request block
**
** Output
**	sess_cb
**	    pss_flattening_flags
**				flag field used to collect information needed 
**				for determining whether the query being parsed 
**				should be flattened
**	        PSS_ALL_IN_TREE	will be set if the query involved a comparison
**				with "ALL (subselect)"; this will cause the
**				query to not be flattened
**		PSS_SINGLETON_SUBSELECT
**				will be set if this subselect is a singleton 
**				subselect; if we were told to avoid flattening 
**				queries involving singleton subselects, will 
**				remind us to tell OPF to not flatten this query
**
**	treeinfo		will contain addr of a pointer to a structure
**				consisting of:
**	    pss_tree		pointer to the new tree and
**	    pss_mask		initialized mask field
**	psq_cb.
**	    psq_error		filled in if an error occurs
**
** Side effects:
**	will allocate memory
**
** Returns:
**	E_DB_OK, E_DB_ERROR
**
** History:
**	10-31-90 (andre)
**	    written
**	27-nov-90 (andre)
**	    if this predicate involves ALL (or it was "NOT IN" which got
**	    translated into "!= ALL" - of course, here we cannot tell the
**	    difference), we will decide if this fact should figure in
**	    determining if the query tree is to be flattened
**	29-sep-92 (andre)
**	    if a predicate involved a singleton subselect, set
**	    PSS_SINGLETON_SUBSELECT in sess_cb->pss_flattening_flags.
**	15-oct-92 (rblumer)
**	    if parsing a constraint, don't do type resolution yet
**	02-may-93 (andre)
**	    avoid type resolution only if processing CHECK constraint specified
**	    as a part of CREATE TABLE statement
**
**	    changed function scope to static
**	15-nov-93 (andre)
**	    PSS_SINGLETON_SUBSELECT got moved from pss_stmt_flags to 
**	    pss_flattening_flags
**
**	    PSS_ALL_IN_TREE got moved from PSS_YYVARS.qry_mask to 
**	    sess_cb->pss_flattening_flags.  
**
**	    removed qry_mask from the arg list as it is no longer needed (at 
**	    least for now)
*/
static DB_STATUS
psl_subsel_compare(
	PSS_SESBLK	*sess_cb,
	PST_QNODE	*expr,
	PST_QNODE	*subsel,
	ADI_OP_ID	operator,
	i4		meta_op,
	PSS_TREEINFO	**treeinfo,
	bool		in_join_search,
	PSS_JOIN_INFO	*join_info,
	bool		subsel_illegal,
	i4		err_msgno,
	PSQ_CB		*psq_cb)
{
    PST_OP_NODE	opnode;
    DB_STATUS	status;
    i4		nores_flag;

    if (subsel_illegal)
    {
	i4	    err_code;

	/*
	** Not allowed in conditions in DB proc control statements or CREATE
	** RULE statments.
	*/
	(VOID) psf_error(err_msgno, 0L, PSF_USERERR, &err_code,
	    &psq_cb->psq_error, 1,
	    sizeof(sess_cb->pss_lineno), &sess_cb->pss_lineno);
	return (E_DB_ERROR);
    }

    /*
    ** expr will be set to NULL for EXISTS predicate, in which case we should
    ** not call psl_subsel(), as it will return an error if the target list of
    ** the subselect involved more than one RESDOM
    */
    if (expr != (PST_QNODE *) NULL)
    {
	if (status = psl_subsel(sess_cb, psq_cb, subsel))
	{
	    return (status);
	}
    }

    status = psf_malloc(sess_cb, &sess_cb->pss_ostream, sizeof(PSS_TREEINFO),
	     (PTR *) treeinfo, &psq_cb->psq_error);
    if (DB_FAILURE_MACRO(status))
    {
	return (status);
    }

    opnode.pst_opno = operator;
    opnode.pst_opmeta = meta_op;
    opnode.pst_isescape = PST_DOESNT_APPLY;

    /*
    ** don't do type resolution if parsing a check constraint specified as a
    ** part of CREATE TABLE statement, as we may not know the type of the column
    ** (e.g. if it hasn't been defined yet)
    */
    if (   sess_cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
	&& ( ( psq_cb->psq_mode == PSQ_CREATE) || 
	     ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) )
    {
	nores_flag = PSS_NORES;
    }
    else
    {
	nores_flag = 0;
    }

    if (expr != NULL)	    /* will be true except for the EXISTS predicate */
    {
	status = pst_node(sess_cb, &sess_cb->pss_ostream, expr, subsel, PST_BOP,
	    (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &(*treeinfo)->pss_tree, &psq_cb->psq_error,
	    nores_flag);
    }
    else
    {
	status = pst_node(sess_cb, &sess_cb->pss_ostream, subsel,
	    (PST_QNODE *) NULL, PST_UOP, (char *) &opnode, sizeof(opnode),
	    DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
	    &(*treeinfo)->pss_tree, &psq_cb->psq_error, nores_flag);
    }

    if (DB_FAILURE_MACRO(status))
    {
	return (status);
    }

    if (((*treeinfo)->pss_tree->pst_sym.pst_type != PST_CONST) &&
        (in_join_search))
    {
	/*
	** If we are processing a join_search condition, set the joinid
	** field appropriately.  It has been initialized to PST_NOJOIN in
	** pst_node().
	*/
	(*treeinfo)->pss_tree->pst_sym.pst_value.pst_s_op.pst_joinid =
		join_info->pss_join[join_info->depth].join_id;
    }

    (*treeinfo)->pss_mask = PSS_SUBSEL_IN_TREE;

    if (meta_op == PST_ALL_SUBSELECT)
    {
	/*
	** setting PSS_ALL_IN_TREE in sess_cb->pss_flattening_flags eventually 
	** results in PSF telling OPF to NOT flatten the query tree.  However, 
	** we need to disregard presense of ALL if the following holds:
	**	- "comparsion" is ADI_NE_OP (!= or <>) AND
	**	- both subtrees of the opnode represent non-nullable expressions
	**	  (recall that for non-nullable expressions,
	**	   PSQ_QNODE.pst_sym.pst_dataval.db_datatype > 0)
	** In this case OPF will decide to do equi-join, and that is exactly
	** what should happen
	*/

	if (   operator != ADI_NE_OP
	    || expr->pst_sym.pst_dataval.db_datatype < 0
	    || subsel->pst_sym.pst_dataval.db_datatype < 0)
	{
	    /*
	    ** Remember that query contains ALL, so the tree will not be
	    ** flattened
	    */
	    sess_cb->pss_flattening_flags |= PSS_ALL_IN_TREE;
	}
    }
    else if (meta_op == PST_ONE_SUBSELECT)
    {
	/* remember that a query involved a singleton subselect */
	sess_cb->pss_flattening_flags |= PSS_SINGLETON_SUBSELECT;
    }

    return(E_DB_OK);
}

/*
** Name:    psl_repeat_qry_id - translate or define a repeat query id
**
** Description: Given the front-end object id and a BE id, this function will
**		call QSO_TRANS_OR_DEFINE to either define a new translation or
**		find an existing one to enable sharing of repeat query QEPs
**
** Input:
**	psq_cb			request CB
**	    psq_cursid		BE query id; it may be overwritten if it is
**				determined that a QEP for this query is already
**				in memory
**	sess_cb			sesion CB
**	fe_id			pointer to front-end query id
**	header			query header
**	    pst_info		pointer to q query info structure
**	qry_info		Additional information about the repeat query
**				which was just parsed.  At least for now, this
**				will only be used for QUEL repeat queries to
**				verify that the query whose existing QEP is a
**				candidate for sharing and the current query are,
**				in fact, identical (it is a bit crude, but
**				hopefully effective); for now this will be
**				disregarded for SQL queries
**	    db_qry_len		length of text
**	    db_qry		slightly massaged query text
**	    db_num_tblids	number of table ids in the following list
**	    db_tblids		ORDERED list of ids of tables used in the query
**
** Output:
**	psq_cb
**	    psq_cursid		may be reset if an existing translation for this
**				FE id is found
**	sess_cb
**	    pss_ostream		stream may be closed if an existing translation
**				for this FE id is found
**	header			the following apply only if we are NOT reusing
**				an existing query plan or if none was found:
**	    pst_mask1		will be OR'd with PST_SHAREABLE_QRY if the query
**				was determined to be shareable and no
**				translation was found
**	    pst_info		structure will be allocated and initialized 
**		pst_1_usage	PST_SHR_RPTQRY will be set
**		pst_1_info
**		    pst_shr_rptqry  will point at a structure providing
**				    additional information which will be used
**				    when determining shareability of the QEP for
**				    this query
**
** Returns:
**	E_DB_{OK, ERROR}
**
** Side effects:
**	memory may be allocated (for PST_QRYHDR_INFO);
**	can close sess_cb->ps_ostream if we determined that some existing QEP
**	should be used.
**
** History:
**	21-jan-91 (andre)
**	    plagiarized from define_query: production as a part of adding
**	    support for shareable QUEL repeat queries
**	25-jan-91 (andre)
**	    Modified interface to receive additional query information
**	    describing the current query.  At least for now, this will only
**	    be used for QUEL repeat queries to verify that the query whose
**	    existing QEP is a candidate for sharing and the current query are,
**	    in fact, identical (it is a bit crude, but hopefully effective)
**	    Also pass a pointer to the query tree header
**	08-may-91 (rog)
**	    If neither of the queries had a table_id list associated with it, do
**	    not compare them.  (fix for bug 37410)
**	15-jun-92 (barbara)
**	    Sybil merge.  Star comment:
**	    12-mar-92 (barbara)
**		Imported this function into the Star line to fix bug 42625
**		(Star was improperly sharing repeat query plans).
**	11-oct-93 (swm)
**	    Bug #56448
**	    Declared trbuf for psf_display() to pass to TRformat.
**	    TRformat removes `\n' chars, so to ensure that psf_scctrace()
**	    outputs a logical line (which it is supposed to do), we allocate
**	    a buffer with one extra char for NL and will hide it from TRformat
**	    by specifying length of 1 byte less. The NL char will be inserted
**	    at the end of the message by psf_scctrace().
** 4-mar-1996 (angusm)
**      If repeat qry contains global temp tables, include the unique
**      session id so that other sessions executing this query are not
**      bound to the same global temporary (bug 74863)
*/
DB_STATUS
psl_repeat_qry_id(
	PSQ_CB			*psq_cb,
	PSS_SESBLK		*sess_cb,
	DB_CURSOR_ID		*fe_id,
	PST_QTREE		*header,
	DB_SHR_RPTQRY_INFO	*qry_info)
{
    QSF_RCB	    qsf_rb;
    i4	    err_code;
    DB_STATUS	    status;
    char	    *p;
    char	    trbuf[PSF_MAX_TEXT + 1]; /* last char for `\n' */

    qsf_rb.qsf_type = QSFRB_CB;
    qsf_rb.qsf_ascii_id = QSFRB_ASCII_ID;
    qsf_rb.qsf_length = sizeof(qsf_rb);
    qsf_rb.qsf_owner = (PTR)DB_PSF_ID;
    qsf_rb.qsf_sid = sess_cb->pss_sessid;
    qsf_rb.qsf_feobj_id.qso_type = QSO_ALIAS_OBJ;
    qsf_rb.qsf_feobj_id.qso_lname = sizeof(DB_CURSOR_ID) + sizeof(i4);

	MEfill(sizeof(qsf_rb.qsf_feobj_id.qso_name), 0,
						qsf_rb.qsf_feobj_id.qso_name);

    (VOID)MEcopy((PTR) fe_id, sizeof(DB_CURSOR_ID),
	(PTR) qsf_rb.qsf_feobj_id.qso_name);

    p = (char *) qsf_rb.qsf_feobj_id.qso_name + sizeof(DB_CURSOR_ID);
    I4ASSIGN_MACRO(sess_cb->pss_udbid, *(i4 *) p);

    qsf_rb.qsf_obj_id.qso_type = QSO_QP_OBJ;
    qsf_rb.qsf_obj_id.qso_lname = sizeof(DB_CURSOR_ID);
    (VOID)MEcopy((PTR) &psq_cb->psq_cursid, sizeof(DB_CURSOR_ID),
	(PTR) qsf_rb.qsf_obj_id.qso_name);
    /*
	** extend length of alias and master ids: add 'session id'
	*/
	if (sess_cb->pss_stmt_flags & PSS_HAS_DGTT)
	{
		PTR     off = NULL;
		sess_cb->pss_stmt_flags &= ~PSS_HAS_DGTT;
		off = qsf_rb.qsf_feobj_id.qso_name + sizeof(DB_CURSOR_ID);
		MEcopy((PTR)&sess_cb->pss_sess_owner,
		sizeof(sess_cb->pss_sess_owner), off);
		p = (char *) qsf_rb.qsf_feobj_id.qso_name + sizeof(DB_CURSOR_ID)
			+ sizeof(sess_cb->pss_sess_owner);
		I4ASSIGN_MACRO(sess_cb->pss_udbid, *(i4 *) p);
		qsf_rb.qsf_feobj_id.qso_lname = sizeof(qsf_rb.qsf_feobj_id.qso_name);
	}

    /*
    ** if QEP exists and we are processing a QUEL query, we need to look at a
    ** part of QEP object, so we set lk_state to QSO_SHLOCK
    */
    qsf_rb.qsf_lk_state =
	(sess_cb->pss_lang == DB_SQL && ~sess_cb->pss_distrib & DB_3_DDB_SESS)
	? QSO_FREE : QSO_SHLOCK;

    status = qsf_call(QSO_TRANS_OR_DEFINE, &qsf_rb);

    if (DB_FAILURE_MACRO(status))
    {
	(VOID) psf_error(E_PS0379_QSF_T_OR_D_ERR,
	    qsf_rb.qsf_error.err_code, PSF_INTERR,
	    &err_code, &psq_cb->psq_error, 0);
	return (status);
    }	

    if (qsf_rb.qsf_t_or_d == QSO_WASTRANSLATED)
    {
	/* we don't do anything special for SQL */
	if (   sess_cb->pss_lang == DB_SQL
	    && ~sess_cb->pss_distrib & DB_3_DDB_SESS
	    )
	{
	    psq_cb->psq_mode = PSQ_QRYDEFED;
	}
	else
	{
	    /*
	    ** if processing a QUEL query we need to examine a copy of
	    ** DB_SHR_RPTQRY_INFO structure in the existing QEP; if it matches
	    ** qry_info, we can reuse the existing query plan
	    */

	    DB_SHR_RPTQRY_INFO		*info_p;

	    /* first get the root of the QSF object */
	    status = qsf_call(QSO_INFO, &qsf_rb);

	    if (DB_FAILURE_MACRO(status))
	    {
		DB_STATUS	stat;

		(VOID) psf_error(E_PS0A0A_CANTGETINFO,
		    qsf_rb.qsf_error.err_code, PSF_INTERR,
		    &err_code, &psq_cb->psq_error, 0);

		/*
		** QEP object was locked by QSO_TRANS_OR_DEFINE - unlock it
		** before returning error
		*/
		stat = qsf_call(QSO_UNLOCK, &qsf_rb);

		if (DB_FAILURE_MACRO(stat))
		{
		    (VOID) psf_error(E_PS0D1C_QSF_UNLOCK,
		        qsf_rb.qsf_error.err_code, PSF_INTERR, &err_code,
			&psq_cb->psq_error, 0);
		    if (stat > status)
			status = stat;
		}

		return(status);
	    }
	    
	    /*
	    ** make info_p point at PST_SHR_RPTQRY_INFO structure in the
	    ** existing QEP
	    */

	    info_p = ((QEF_QP_CB *) qsf_rb.qsf_root)->qp_shr_rptqry_info;

	    /*
	    ** all of the following must hold in order for us to reuse the
	    ** existing query plan:
	    ** 
	    **	    - info_p must be non-null
	    **	    - number of characters in the query text stored with the QEP
	    **	      must be the same as the number of characters in the text
	    **	      stored for this query
	    **	    - number of table ids stored with the QEP must be the same
	    **	      as the number of ids stored for this query
	    **	    - table ids stored with the QEP must be the same as the ids
	    **	      stored for this query
	    **	    - text stored with the QEP must be the same as the text
	    **	      stored for this query
	    */
	    if (info_p == (DB_SHR_RPTQRY_INFO *) NULL)
	    {
		i4	val1=0, val2=0;

		if (ult_check_macro(&sess_cb->pss_trace, 4, &val1, &val2))
		{
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\nQUEL repeat query cannot use existing QEP because the QEP does not\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"contain information required to determine if it can be shared.\n");
		}
	    }
	    /* will compare the lists only if they are of the same size AND are
	    ** not empty (fix for bug 37410)
	    */
	    else if (info_p->db_num_tblids != qry_info->db_num_tblids ||
		     (info_p->db_num_tblids != 0
		      &&
		      MEcmp((PTR) info_p->db_tblids, (PTR) qry_info->db_tblids,
		            (info_p->db_num_tblids * sizeof(DB_TAB_ID)))
		     )
		    )
	    {
		i4	    val1=0, val2=0;

		if (ult_check_macro(&sess_cb->pss_trace, 4, &val1, &val2))
		{
		    DB_TAB_ID   *qry_curid, *qep_curid;
		    i4		qry_idno, qep_idno;

		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\nQUEL repeat query cannot use existing \
QEP because its list of table IDs\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"is different from that associated with the QEP.\n");

		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\n\nTable IDs for the current query    \
Table IDs associated with the QEP\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\n");

		    for (qry_idno  = qry_info->db_num_tblids,
			 qry_curid = qry_info->db_tblids,
		         qep_idno  = info_p->db_num_tblids,
			 qep_curid = info_p->db_tblids;

			 (qry_idno > 0 && qep_idno > 0);

			 qry_idno--, qry_curid++, qep_idno--, qep_curid++
			)
		    {
			psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
				"(%8d,%8d)                 (%8d,%8d)\n",
			    qry_curid->db_tab_base, qry_curid->db_tab_index,
			    qep_curid->db_tab_base, qep_curid->db_tab_index);
		    }

		    /*
		    ** if there were more ids in the list associated with the
		    ** query
		    */
		    for (; qry_idno > 0; qry_idno--, qry_curid++)
		    {
			psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
				"(%8d,%8d)\n",
			    qry_curid->db_tab_base, qry_curid->db_tab_index);
		    }

		    /*
		    ** if there were more ids in the list associated with the
		    ** QEP
		    */
		    
		    for (; qep_idno > 0; qep_idno--, qep_curid++)
		    {
			psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
				"                                    (%8d,%8d)\n",
			    qep_curid->db_tab_base, qep_curid->db_tab_index);
		    }

		}
	    }
	    else if (   (~sess_cb->pss_distrib & DB_3_DDB_SESS)
		     && 
			(info_p->db_qry_len != qry_info->db_qry_len
	                 ||
			 MEcmp((PTR) info_p->db_qry, (PTR) qry_info->db_qry,
			   info_p->db_qry_len))
		    )
	    {
		i4	val1=0, val2=0;

		if (ult_check_macro(&sess_cb->pss_trace, 4, &val1, &val2))
		{
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\nQUEL repeat query cannot use existing QEP because its text\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"is different from that associated with the QEP.\n");

		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\n    Text of the query being parsed:\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\n<<<\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"%t\n", qry_info->db_qry_len, qry_info->db_qry);
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			">>>\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\n    Text of the query associated with the QEP:\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\n<<<\n");
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"%t\n", info_p->db_qry_len, info_p->db_qry);
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			">>>\n");

		}
	    }
	    else
	    {
		psq_cb->psq_mode = PSQ_QRYDEFED;
	    }

	    /* QEP object was locked by QSO_TRANS_OR_DEFINE - unlock it now */
	    status = qsf_call(QSO_UNLOCK, &qsf_rb);

	    if (DB_FAILURE_MACRO(status))
	    {
		(VOID) psf_error(E_PS0D1C_QSF_UNLOCK, qsf_rb.qsf_error.err_code,
		    PSF_INTERR, &err_code, &psq_cb->psq_error, 0);
		return(status);
	    }
	}

	if (psq_cb->psq_mode == PSQ_QRYDEFED)
	{
	    /* OK to use existing QEP */
	    (VOID)MEcopy((PTR) qsf_rb.qsf_obj_id.qso_name,
		sizeof(DB_CURSOR_ID), (PTR) &psq_cb->psq_cursid);

	    /* The generated tree is useless, because shared QEP
	    ** mechanism will be used, so close the QTREE memory stream
	    ** to delete memory.
	    */
	    status = psf_mclose(sess_cb, &sess_cb->pss_ostream, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	    sess_cb->pss_ostream.psf_mstream.qso_handle = (PTR) NULL;

	    {
		i4	val1=0, val2=0;

		if (ult_check_macro(&sess_cb->pss_trace, 4, &val1, &val2))
		{
		    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\nRepeat query is shareable - will use existing QEP.\n");
		}
	    }
	}
    }
    else
    {
	/*
	** no QEP was found;
	** for SQL we will simply OR PST_SHAREABLE_QRY into header->pst_mask1;
	** for QUEL we need to allocate and initialize PST_QRYHDR_INFO structure
	** and set header->pst_info to point to it to enable PSF to determine if
	** some other query with the same FE object id can reuse the query plan
	** + we will OR PST_SHAREABLE_QRY into header->pst_mask1
	*/
	header->pst_mask1 |= PST_SHAREABLE_QRY;

	if (sess_cb->pss_lang == DB_QUEL
	    ||
	    sess_cb->pss_distrib & DB_3_DDB_SESS)
	{
	    /*
	    ** PST_QRYHDR_INFO structure was allocated by pst_header(); now
	    ** check for possible conflict in its usage
	    */
	    if (PST_1_INFO_USED(header))
	    {
		(VOID) psf_error(E_PS0522_QRYHDR_INFO_CONFLICT, 0L,
		    PSF_INTERR, &err_code, &psq_cb->psq_error, 0);
		return(E_DB_ERROR);
	    }

	    header->pst_info->pst_1_usage = PST_SHR_RPTQRY;
	    header->pst_info->pst_1_info.pst_shr_rptqry = qry_info;
	}

	{
	    i4	val1=0, val2=0;

	    if (ult_check_macro(&sess_cb->pss_trace, 4, &val1, &val2))
	    {
		psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
			"\nRepeat query is shareable - will build a new QEP\
.\n");
	    }
	}
    }

    return(E_DB_OK);
}

/* Name:    psl_qeucb - allocate QEU_CB and initialize its header
**
** Description:
**	Open a memory stream, allocate QEU_CB and initialize its header, and
**	place it at the root of the QSF object.
**
** Input:
**	sess_cb			PSF session CB
**	    pss_ostream		memory stream from which QEU_CB will be
**				allocated
**	    pss_dbid		database id for this session
**	    pss_sessid		session id
**	operation		opcode to store in QEU_CB
**
** Output:
**	sess_cb
**	    pss_object		will contain address of the newly allocated
**				QEU_CB
**	err_blk			filled in if an error occured.
**
** Returns:
**	E_DB_{OK, ERROR}
**
** Side effects:
**	will allocate memory
**
** History:
**	06-mar-91 (andre)
**	    written;
**	04-aug-93 (andre)
**	    zero-fill QEU_CB to ensure that some newly added QEU_CB fields are
**	    not left uninitialized.
*/
DB_STATUS
psl_qeucb(
	PSS_SESBLK	*sess_cb,
	i4		operation,
	DB_ERROR	*err_blk)
{
    DB_STATUS	    status;
    QEU_CB	    *qeu_cb;
    
    status = psf_mopen(sess_cb, QSO_QP_OBJ, &sess_cb->pss_ostream, err_blk);
    if (status != E_DB_OK)
	return (status);

    status = psf_malloc(sess_cb, &sess_cb->pss_ostream, sizeof(QEU_CB),
	&sess_cb->pss_object, err_blk);
    if (status != E_DB_OK)
	return (status);

    status = psf_mroot(sess_cb, &sess_cb->pss_ostream, sess_cb->pss_object, err_blk);
    if (status != E_DB_OK)
	return (status);

    MEfill(sizeof(QEU_CB), (u_char) 0, sess_cb->pss_object);
    
    qeu_cb = (QEU_CB *) sess_cb->pss_object;

    /* Fill in the control block header */
    qeu_cb->qeu_length	    = sizeof(QEU_CB);
    qeu_cb->qeu_type	    = QEUCB_CB;
    qeu_cb->qeu_owner	    = (PTR)DB_PSF_ID;
    qeu_cb->qeu_ascii_id    = QEUCB_ASCII_ID;
    qeu_cb->qeu_db_id	    = sess_cb->pss_dbid;
    qeu_cb->qeu_d_id	    = sess_cb->pss_sessid;
    qeu_cb->qeu_eflag	    = QEF_EXTERNAL;
    qeu_cb->qeu_mask	    = 0;

    /* Give QEF the opcode */
    qeu_cb->qeu_d_op	= operation;

    return(E_DB_OK);
}

/*
** Name: psl_init_dbp_stmt() - allocate and initialize a database procedure
**			       statement block
**
** Description: allocate and initialize a database procedure statement block
**		any additional statement-specific initialization must be
**		performed by the caller
**
** Input:
**	sess_cb		    session control block
**	    pss_ostream	    memory stream to use for allocating statement node
**	    pss_lineno	    current line number (STMT.pst_lineno)
**	dbpinfo		    dbproc info structure
**	    pss_link	    pointer to the last REACHABLE statement block
**			    allocated so far
**	    pss_patch	    patch address (may be NULL if we are parsing a
**			    statement immediately following IF...ENDIF
**	qmode		    mode of the statement (STMT.pst_node)
**	type		    type of the statement (STMT.pst_type)
**	err_blk		    error block
**
** Output:
**	*stmt		    pointer to a newly allocated and initialized
**			    statement block (if the statement type is
**			    PST_ENDLOOP and dbpinfo->pss_patch was not null, new
**			    statement block will not be allocated)
**	dbpinfo
**	    pss_link	    will be reset if a new statement block was allocated
**			    and the statement was REACHABLE and was not ENDLOOP
**	    pss_last_stmt   if a new statement block is allocated, this pointer
**			    will be reset to point at it
**	    pss_patch	    patch address may be reset for the new statement
**	err_blk		    will be filled in if an error occurs
**
** Returns:
**	E_DB_{OK, ERROR}
**
** Side effects:    may allocate memory
**
** History:
**
**	07-feb-91 (andre)
**	    written
**	30-oct-92 (rblumer)
**	    initialize structure to zero's after mallocing it, so new fields 
**          get initialized; also replaces several lines of NULL assignments.
**	08-apr-93 (andre)
**	    rules will be collected in four distinct lists: user- and
**	    system-generated row-level rules and user- and system-generated
**	    statement-level rules.  pst_after_stmt will point at coalesced
**	    row-level rules and pst_statementEndRules will point at coalesced
**	    statement-level rules.  Row-level and statement-level rules will
**	    also be coalesced for the benefit of OPF
**	17-sep-93 (robf)
**          Save audit information for QT statements.
**	25-sep-98 (inkdo01)
**	    Add FOR-loop support.
**	29-may-06 (dougi)
**	    Assign pss_stmtno to pst_lineno.
*/
DB_STATUS
psl_init_dbp_stmt(
	PSS_SESBLK	*sess_cb,
	PSS_DBPINFO	*dbpinfo,
	i4		qmode,
	i4		type,
	PST_STATEMENT	**stmt,
	DB_ERROR	*err_blk)
{
    DB_STATUS	    status;

    *stmt = (PST_STATEMENT *) NULL;

    /*
    ** processing for ENDLOOP is different from all other statements in that if
    ** dbpinfo->pss_patch is set, then ENDLOOP statement block need not be
    ** allocated since we simply need to remember to "fix" the pointer whose
    ** address is found in pss_patch
    */
    if (type == PST_ENDLOOP_TYPE &&
	dbpinfo->pss_patch != (PST_STATEMENT **) NULL)
    {
	return(E_DB_OK);
    }
    else
    {
	PST_STATEMENT	    *s;

	status = psf_malloc(sess_cb, &sess_cb->pss_ostream, sizeof(PST_STATEMENT),
	    (PTR *) stmt, err_blk);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	MEfill(sizeof(PST_STATEMENT), (u_char) 0, (PTR) *stmt);

	s = dbpinfo->pss_last_stmt = *stmt;

	s->pst_mode = qmode;

#ifdef xDEBUG
	s->pst_lineno = sess_cb->pss_lineno;
#endif
	s->pst_lineno = sess_cb->pss_stmtno;
	if (type == PST_IP_TYPE || type == PST_QT_TYPE)
	{
	    /*
	    ** Assign row-level and statement-level rules from saved rule lists 
	    */

	    /*
	    ** make pst_after_stmt point at user-defined row-level rules and
	    ** then append system-generated row-level rules to the end of the
	    ** list
	    */
	    s->pst_after_stmt = sess_cb->pss_row_lvl_usr_rules;
	    psy_rl_coalesce(&s->pst_after_stmt, sess_cb->pss_row_lvl_sys_rules);

	    /*
	    ** make pst_statementEndRules point at user-defined statement-level
	    ** rules and then append system-generated statement-level rules to
	    ** the end of the list
	    */
	    s->pst_statementEndRules = sess_cb->pss_stmt_lvl_usr_rules;
	    psy_rl_coalesce(&s->pst_statementEndRules,
		sess_cb->pss_stmt_lvl_sys_rules);

	    /*
	    ** do the same with all the "before" rules.
	    */
	    s->pst_before_stmt = sess_cb->pss_row_lvl_usr_before_rules;
	    psy_rl_coalesce(&s->pst_before_stmt, 
				sess_cb->pss_row_lvl_sys_before_rules);

	    s->pst_before_statementEndRules = 
				sess_cb->pss_stmt_lvl_usr_before_rules;
	    psy_rl_coalesce(&s->pst_before_statementEndRules,
				sess_cb->pss_stmt_lvl_sys_before_rules);
	    /*
	    ** finally, unless we are processing PREPARE (which would never
	    ** happen in 6.5, but maybe later), append statement-level
	    ** rules to the end of the list of row-level rules
	    */
	    if (sess_cb->pss_defqry != PSQ_PREPARE)
	    {
		psy_rl_coalesce(&s->pst_after_stmt, s->pst_statementEndRules);
	    }
	}
	else
	{
	    s->pst_after_stmt =
	    s->pst_statementEndRules = (PST_STATEMENT *) NULL;
	}

	switch (s->pst_type = type)
	{
	    case PST_QT_TYPE:
	    {
		s->pst_audit=sess_cb->pss_audit;
		sess_cb->pss_audit=NULL;
		break;
	    }
	    case PST_IP_TYPE:
	    {
		STRUCT_ASSIGN_MACRO(dbpinfo->pss_ptuple.db_owner,
				    s->pst_specific.pst_iproc.pst_ownname);
		STRUCT_ASSIGN_MACRO(dbpinfo->pss_ptuple.db_dbpname,
				    s->pst_specific.pst_iproc.pst_procname);
		break;
	    }
	    case PST_CMT_TYPE:
	    {
		s->pst_specific.pst_commit.pst_unused = '\0';
		break;
	    }
	    case PST_RBK_TYPE:
	    {
		s->pst_specific.pst_rollback.pst_unused = '\0';
		break;
	    }
	    case PST_FOR_TYPE:
	    {
		s->pst_specific.pst_for.pst_forhead = (PST_STATEMENT *)NULL;
		break;
	    }
	    case PST_IF_TYPE:
	    case PST_WH_TYPE:
	    case PST_RP_TYPE:
	    {
		s->pst_specific.pst_if.pst_condition = (PST_QNODE *) NULL;
		s->pst_specific.pst_if.pst_true =
		    s->pst_specific.pst_if.pst_false = (PST_STATEMENT *) NULL;

		dbpinfo->pss_patch = &s->pst_specific.pst_if.pst_true;

		break;
	    }
	}

	/*
	** ENDLOOP statement is used only internally by PSF, so there is no
	** reason to attach it to the linked list of statements used by OPF;
	** also, if this statement is not reachable, do not attach it to the
	** linked list of statements used by OPF (to save the cost of optimizing
	** it)
	*/
	if (type != PST_ENDLOOP_TYPE &&
	    dbpinfo->pss_unreachable_stmt_lvl == 0)
	{
	    if (dbpinfo->pss_link != (PST_STATEMENT *) NULL)
	    {
		dbpinfo->pss_link->pst_link = s;
	    }

	    dbpinfo->pss_link = s;
	}

	if (type != PST_IF_TYPE && type != PST_WH_TYPE && type != PST_RP_TYPE)
	{
	    /* for IF, ELSEIF, and WHILE, pss_patch was set above */
	    dbpinfo->pss_patch = &s->pst_next;
	}
    }

    return(E_DB_OK);
}

/*
** Name: psl_add_grantee() - add a name to a grantee list
**
** Description: add a grantee name (can be user, group, or role name) to a
**		grantee list unless the name has already been added to the list.
**
** Input:
**	sess_cb		    session control block
**	    pss_ostream	    memory stream to use for allocating statement node
**	    pss_object	    pointer to a PSY_CB structure
**	grantee_name	    NULL-terminated name to be added to the grantee list
**	grantee_type	    type of identifier used to express grantee name
**
** Output:
**	err_blk		    will be filled in if an error occurs
**
** Returns:
**	E_DB_{OK, ERROR}
**
** Side effects:    may allocate memory
**
** History:
**
**	13-jun-91 (andre)
**	    written
**	17-aug-93 (andre)
**	    made function static
**
**	    added grantee_type to the interface
**
**	    added code to remember whether the grantee name has been expressed 
**	    as a regular identifier
*/
static DB_STATUS
psl_add_grantee(
	PSS_SESBLK	*sess_cb,
	char		*grantee_name,
	PSS_ID_TYPE     grantee_type,
	DB_ERROR	*err_blk)
{
    PSY_CB		*psy_cb = (PSY_CB *) sess_cb->pss_object;
    PSY_USR		*psy_usr;
    bool		found = FALSE;
    DB_STATUS		status;
    DB_OWN_NAME		name_buf;

    /* Normalize the user name */
    STmove(grantee_name, ' ', sizeof(DB_OWN_NAME), (char *) &name_buf);

    /*
    ** Check if grantee specified for the first time.
    */
    for (psy_usr = (PSY_USR *) psy_cb->psy_usrq.q_next;
	 psy_usr != (PSY_USR *) &psy_cb->psy_usrq;
	 psy_usr = (PSY_USR *) psy_usr->queue.q_next
	)
    {
	if (MEcmp((PTR) &name_buf, (PTR) &psy_usr->psy_usrnm,
	    sizeof(psy_usr->psy_usrnm)) == 0
	   )
	{
	    found = TRUE;

	    /*
	    ** remember whether the grantee name was expressed using a regular
	    ** identifier
	    */
	    if (   ~psy_usr->psy_usr_flags & PSY_REGID_USRSPEC 
		&& grantee_type == PSS_ID_REG)
	    {
		psy_usr->psy_usr_flags |= PSY_REGID_USRSPEC;
	    }

	    break;
	}
    }

    /*
    ** Store only if not found. No need to keep duplicates.
    */
    if (!found)
    {
	/* Allocate memory for a user entry */
	status = psf_malloc(sess_cb, &sess_cb->pss_ostream, (i4) sizeof(PSY_USR), 
	    (PTR *) &psy_usr, err_blk);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	/*
	** Copy user name to user entry.
	*/
	STRUCT_ASSIGN_MACRO(name_buf, psy_usr->psy_usrnm);

	psy_usr->psy_usr_flags = 0;

	/*
	** remember whether the grantee name was expressed using a regular
	** identifier
	*/
	if (grantee_type == PSS_ID_REG)
        {
	    psy_usr->psy_usr_flags |= PSY_REGID_USRSPEC;
        }

	/*
	** Attach element to the list.
	*/
	(VOID) QUinsert((QUEUE *) psy_usr, (QUEUE *) &psy_cb->psy_usrq);
    }

    return(E_DB_OK);
}

/*
** Name:    psl_cdbp_typedesc - semantic action for cdbp_typedesc production
**
** Description:
**
**	Perform the semantic action associated with cdbp_typedesc production.
**	Primarily, this envolves storing encoded column specification in the
**	dbproc descriptor
**
** Input parameters:
**	sess_cb		    PSF session CB
**	dbpinfo		    dbproc descriptor
**	type_name	    dbproc variable type as specified by the user
**	num_len_prec_vals   indicator of whether length and/or precision have
**			    been specified
**	    0		    neither length nor precision have been specified
**	    1		    length but no precision has been specified
**	    2		    both length and precision have been specified
**	len_prec	    array containing length and precision, if they were
**			    specified (num_len_prec_vals contains the size of
**			    this array)
**	null_def	    indicator of whether the variable has a default, is
**			    nullable and/or system_maintained (code which must
**			    be executed if the last one is true is yet to be
**			    written)
**	psq_cb		    PSF request CB
**
** Output
**	dbpinfo
**	    pss_curvar	    descriptor for the current dbproc variable will have
**			    been filled in
**	psq_cb
**	    psq_error	    filled in if an error occurs
**
** Returns:
**	E_DB_{OK, ERROR}
**
** Side effects:
**	none
**
** History:
**
**	04-nov-91 (andre)
**	    plagiarized from typedesc: production
**	04-mar-93 (rblumer)
**	    change parameter to psf_adf_error to be psq_error
**	10-jan-94 (andre)
**	    (fix for bug 58020)
**	    if provided,nullability/defaultability specification for a dbproc
**	    parameter or variable must be one of:
**		WITH NULL
**		NOT NULL
**		NOT NULL WITH DEFAULT
**		NOT NULL NOT DEFAULT
*/
DB_STATUS
psl_cdbp_typedesc(
	PSS_SESBLK	*sess_cb,
	PSS_DBPINFO	*dbpinfo,
	char		*type_name,
	i4		num_len_prec_vals,
	i4		*len_prec,
	i4		null_def,
	PSQ_CB		*psq_cb)
{
    ADF_CB		*adf_scb = (ADF_CB *) sess_cb->pss_adfcb;
    DB_STATUS		status;
    DB_DATA_VALUE	dt_dv;
    i4		err_code;
    i4			adi_flags = 0;

    /*
    ** make sure that the nullability/defaultability specification, if 
    ** explicitly provided by the user, is valid.  It must be one of
    ** 		WITH NULL	(default if the user specified nothing)
    **		NOT NULL
    **		NOT NULL WITH DEFAULT
    **		NOT NULL NOT DEFAULT
    */
    if (   null_def != PSS_TYPE_NULL
	&& null_def != PSS_TYPE_NOT_NULL
	&& null_def != (PSS_TYPE_NOT_NULL | PSS_TYPE_DEFAULT)
	&& null_def != (PSS_TYPE_NOT_NULL | PSS_TYPE_NDEFAULT))
    {
	/* 
	** different messages will be generated depending on whether an invalid 
	** nullability/defaultability specification was provided for a parameter
	** or a variable
	*/
	i4		err_number = (psq_cb->psq_mode == PSQ_CREDBP)
					? E_PS048B_NULDEF_SPEC_IN_DBPPARM
					: E_PS048C_NULDEF_SPEC_IN_DBPVAR;

	(VOID) psf_error(err_number, 0L, PSF_USERERR, &err_code, 
	    &psq_cb->psq_error, 1,
	    psf_trmwhite(sizeof(dbpinfo->pss_curvar->pss_varname),
		(char *) &dbpinfo->pss_curvar->pss_varname),
	    (PTR) &dbpinfo->pss_curvar->pss_varname);
	
	return(E_DB_ERROR);
    }

    /*
    ** set up nullability; since this is SQL, either "with null" or
    ** nothing specified means that the column will be nullable; otherwise
    ** it's not nullable
    */
    if (null_def & PSS_TYPE_NULL)
    {   /* with null or nothing specified */
	adi_flags |= ADI_F1_WITH_NULL;
    }

    status = adi_encode_colspec(adf_scb, type_name, num_len_prec_vals,
	len_prec, adi_flags, &dt_dv);

    if (status != E_DB_OK)
    {
	(VOID) psf_error(2402L, 0L, PSF_USERERR, &err_code,
	    &psq_cb->psq_error, 1, STtrmwhite(type_name), type_name);

	if (adf_scb->adf_errcb.ad_errclass == ADF_USER_ERROR)
	    psf_adf_error(&adf_scb->adf_errcb, &psq_cb->psq_error, sess_cb);

	return(status);
    }

    dbpinfo->pss_curvar->pss_dbdata.db_data     = (PTR) NULL;
    dbpinfo->pss_curvar->pss_dbdata.db_prec     = dt_dv.db_prec;
    dbpinfo->pss_curvar->pss_dbdata.db_length   = dt_dv.db_length;
    dbpinfo->pss_curvar->pss_dbdata.db_datatype = dt_dv.db_datatype;
    dbpinfo->pss_curvar->pss_default = 0;

    /* Set up defaultibility; this really indicates
    ** whether adc_getempty is to be called.
    **
    ** NOTE: user-defined defaults for procedures have not been implemented yet.
    */
    /* set up defaultibility and system maintained */
    if (!(null_def & PSS_TYPE_NDEFAULT))
    {   
	/* defaults enabled */
	dbpinfo->pss_curvar->pss_default = 1;
    }

    return(E_DB_OK);
}

/*
**  psl_send_setqry - Build QEF_RCB to be passed to QEF for a SET query to be
**		      sent to LDB
**
**  Description:
**	This function will allocate QEF_RCB and initialize it for QEF to pass a
**	SET query to LDB.
**
**  Inputes:
**	sess_cb		    ptr to PSF session control block
**	str_2_send	    NULL-terminated string to be sent
**	err_blk		    error block
**
**  Outputs:
**	sess_cb->pss_object points to initialized QEF_RCB.
**  
**  Returns:
**	E_DB_OK	    -- allocated and initialized QEF_RCB successfully
**	E_DB_ERROR  -- error trying to allocate memory; quit
**
**  Side effects:
**	Will allocate memory
**
**  19-apr-89 (andre)
**	Written.
**  15-jun-92 (barbara)
**	Imported unchanged from 6.4 Star grammar.
**  4-dec-92 (barbara)
**	If call to QEF fails, error has already been reported.  PSF
**	must set psq_error (or SCF will complain); however, we want to
**	avoid PSF retry so we also set PSQ_REDO to pretend we are already
**	in server retry.
*/
DB_STATUS
psl_send_setqry(
	PSS_SESBLK	*sess_cb,
	char		*str_2_send,
	PSQ_CB		*psq_cb)
{
    QEF_RCB		*qef_rcb;
    DD_PACKET		*pkt;
    DB_STATUS           status;
    DB_ERROR		*err_blk = &psq_cb->psq_error;

    /* Allocate QEF control block for set decimal */
    status = psf_mopen(sess_cb, QSO_QP_OBJ, &sess_cb->pss_ostream, err_blk);
    if (status != E_DB_OK)
	return (E_DB_ERROR);

    status = psf_malloc(sess_cb, &sess_cb->pss_ostream, sizeof(QEF_RCB),
			&sess_cb->pss_object, err_blk);

    if (DB_FAILURE_MACRO(status))
    {
	return (status);
    }
    
    status = psf_mroot(sess_cb, &sess_cb->pss_ostream, sess_cb->pss_object, err_blk);
	
    if (status != E_DB_OK)
    {
	return (E_DB_ERROR);
    }

    /* Fill in the QEF control block */
    qef_rcb = (QEF_RCB *) sess_cb->pss_object;
    qef_rcb->qef_length = sizeof(QEF_RCB);
    qef_rcb->qef_type = QEFRCB_CB;
    qef_rcb->qef_owner = (PTR)DB_PSF_ID;
    qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
    qef_rcb->qef_sess_id = sess_cb->pss_sessid;
    qef_rcb->qef_eflag = QEF_EXTERNAL;
    qef_rcb->qef_modifier = QEF_MSTRAN;
    qef_rcb->qef_cb = (QEF_CB *) NULL;
    qef_rcb->qef_r3_ddb_req.qer_d1_ddb_p = (DD_DDB_DESC *) NULL;
    qef_rcb->qef_r3_ddb_req.qer_d2_ldb_info_p = (DD_1LDB_INFO *) NULL;
    qef_rcb->qef_r3_ddb_req.qer_d4_qry_info.qed_q2_lang = DB_SQL;
    
    status = psf_malloc(sess_cb, &sess_cb->pss_ostream, sizeof(DD_PACKET), (PTR *) &pkt,
			err_blk);

    if (DB_FAILURE_MACRO(status))
    {
	return (status);
    }

    pkt->dd_p1_len = STlength(str_2_send);
    pkt->dd_p3_nxt_p = (DD_PACKET *) NULL;
    
    status = psf_malloc(sess_cb, &sess_cb->pss_ostream, (i4) pkt->dd_p1_len,
			(PTR *) &pkt->dd_p2_pkt_p, err_blk);
	
    if (DB_FAILURE_MACRO(status))
    {
	return (status);
    }

    MEcopy((PTR) str_2_send, pkt->dd_p1_len, (PTR) pkt->dd_p2_pkt_p);

    qef_rcb->qef_r3_ddb_req.qer_d4_qry_info.qed_q4_pkt_p = pkt;
    
    status = qef_call(QED_SET_FOR_RQF, ( PTR ) qef_rcb);

    if (DB_FAILURE_MACRO(status))
    {
	err_blk->err_code = E_PS0001_USER_ERROR;

	/*
	** Make it appear as if query is already in retry so that psq_call
	** won't retry this failed statement.
	*/
	psq_cb->psq_flag |= PSQ_REDO;
    }

    return(status);
}

/*
** Name:    psl_grantee_type_to_str - convert grantee type to string
**
** Description: given grantee type, generate corresponding text string
**
** Input:
**	grantee_type	    grantee type; one of DBGR_DEFAULT,
**			    DBGR_USER, DBGR_GROUP, or DBGR_APLID
**
** Output:
**	str		    string corresponding to the grantee type;
**			    NULL if unknown grantee type was passed
**			    
**	str_len		    length of string pointed to by str
**
** Returns:
**	none
**
** Side effects:
**	none
**
** History:
**
**	07-feb-92 (andre)
**	    written
**	19-jul-92 (andre)
**	    we will no longer expect to see grantee type of DBGR_PUBLIC here
**	    since PUBLIC will be allowed as one of user authorization
**	    identifiers
**	24-nov-93 (robf)
**	    Add by_word param which makes BY... be generated instead of
**	    TO..., used with security alarms, made public.
*/
VOID
psl_grantee_type_to_str(
	i4	grantee_type,
	char	**str,
	i4	*str_len,
	bool	by_word)
{
    switch (grantee_type)
    {
	case DBGR_DEFAULT:
	{
	    if(by_word)
	    {
	        *str = " by ";
	        *str_len = sizeof(" by ") - 1;
	    }
	    else 
	    {
	        *str = " to ";
	        *str_len = sizeof(" to ") - 1;
	    }
	    break;
	}
	case DBGR_USER:
	{
	    if(by_word)
	    {
	        *str = " by user ";
	        *str_len = sizeof(" by user ") - 1;
	    }
	    else
	    {
	        *str = " to user ";
	        *str_len = sizeof(" to user ") - 1;
	    }
	    break;
	}
	case DBGR_GROUP:
	{
	    if(by_word)
	    {
	        *str = " by group ";
	        *str_len = sizeof(" by group ") - 1;
	    }
	    else
	    {
	        *str = " to group ";
	        *str_len = sizeof(" to group ") - 1;
	    }
	    break;
	}
	case DBGR_APLID:
	{
	    if(by_word)
	    {
	        *str = " by role ";
	        *str_len = sizeof(" by role ") - 1;
	    }
	    else
	    {
	        *str = " to role ";
	        *str_len = sizeof(" to role ") - 1;
	    }
	    break;
	}
	default:
	{
	    /* this is very bad */
	    *str = (char *) NULL;
	    *str_len = 0;
	    break;
	}
    }

    return;
}

/*
** Name:    psl_valid_session_schema_use -  determine whether use of SESSION
**					    as the schema name is valid
**
** Description:
**	use of SESSION as the schema name is NOT valid when processing one of
**	the following:
**	    - COMMENT
**	    - CREATE DBEVENT
**	    - CREATE INDEX
**	    - CREATE INTEGRITY
**	    - CREATE PERMIT
**	    - CREATE RULE
**	    - CREATE TABLE [AS SELECT]  (handled elsewhere)
**	    - CREATE SYNONYM
**	    - CREATE VIEW
**	    - CREATE SECURITY_ALARM
**	    - CREATE PROCEDURE
**	    - SELECT/INSERT/DELETE/UPDATE inside a dbproc
**	    - DROP DBEVENT
**	    - DROP PROCEDURE
**	    - DROP INTEGRITY
**	    - DROP PERMIT
**	    - DROP SECURITY_ALARM
**	    - EXECUTE PROCEDURE
**	    - GRANT
**	    - REGISTER BEVENT
**	    - REMOVE DBEVENT
**	    - RAISE DBEVENT
**	    - REVOKE
**	    - SAVE
**	    - SET JOURNALING
**	    - SET LOCKMODE
**	    - DROP {VIEW|INDEX|SYNONYM}	(handled elsewhere)
**	    
**	If use of SESSION is illegal, this function will produce an appropriate
**	message and return FALSE; otherwise it will return TRUE
**
** Input:
**	qmode			    query mode
**	sess_cb			    PSF session CB
**	    pss_qualdepth	    if > 0, we are processing a subselect
**	    pss_dbp_flags	    flags related to processing a dbproc
**		PSS_DBPROC	    if set, we are processing a dbproc
**		
**	    pss_stmt_flags	    flags related to processing of the current
**				    statement
**		PSS_NEW_OBJ_NAME    processing new object name as a pat of
**				    CREATE {TABLE, PROCEDURE, RULE, etc.}
**				    statement
**	obj_name		    name of object as specified by the user
** Output:
**	err_blk			    will be filled in if use of SESSION schema
**				    name was deemed invalid
**
** Return:
**	TRUE if use of SESSION schema name appears to be valid; FALSE otherwise
**
** Side effects:
**	none
**
** Exceptions:
**	none
**
** History:
**
**	27-may-92 (andre)
**	    written
**	25-sep-92 (andre)
**	    changed datatype of obj_name to (char *)
**	20-apr-2004 (gupsh01)
**	    Add alter table alter column to this list.
**	15-Aug-2006 (jonj)
**	    One may now create indexes on Session Temp tables,
**	    (create index blah_index on session.blah)
**	    but may not prefix any index name with "SESSION.".
*/
static bool
psl_valid_session_schema_use(
	i4		qmode,
	PSS_SESBLK	*sess_cb,
	char		*obj_name,
	DB_ERROR	*err_blk)
{
    char	    *stmt;
    i4		    stmt_len = 0;
    bool	    err = FALSE;
    i4	    err_no;

    stmt = uld_psq_modestr(qmode);
    stmt_len = STlength(stmt);
    switch (qmode)
    {
	case PSQ_COMMENT:
	{
	    err = TRUE;
	    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;
	    
	    break;
	}
	case PSQ_EVENT:
	{
	    err = TRUE;
	    err_no = E_PS0BD7_SESSION_EV_ILLEGAL;

	    break;
	}
	case PSQ_INDEX:
	{
	    /* 
	    ** One may create an index on a Session Temp,
	    ** but may not prefix any index name with "SESSION."
	    */
	    if ( sess_cb->pss_stmt_flags & PSS_NEW_OBJ_NAME )
	    {
		err = TRUE;
		err_no = E_PS0BD8_SESSION_INDEX_ILLEGAL;
	    }

	    break;
	}
	case PSQ_INTEG:
	{
	    err = TRUE;
	    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;
	
	    break;
	}
	case PSQ_PROT:
	{
	    err = TRUE;
	    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;

	    break;
	}
	case PSQ_RULE:
	{
	    err = TRUE;
	    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;

	    break;
	}
	case PSQ_CREATE:
	{
	    /*
	    ** use of SESSION in the new object name is handled in
	    ** psl_ct12_crname()
	    */
	    break;
	}
	case PSQ_CSYNONYM:
	{
	    /*
	    ** use of SESSION in the new object name is handled in
	    ** psl_ct12_crname()
	    */

	    if (~sess_cb->pss_stmt_flags & PSS_NEW_OBJ_NAME)
	    {
		err = TRUE;
		err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;
	    }
	    
	    break;
	}
	case PSQ_VIEW:
	{
	    /*
	    ** use of SESSION in the new object name is handled in
	    ** psl_ct12_crname()
	    */

	    if (~sess_cb->pss_stmt_flags & PSS_NEW_OBJ_NAME)
	    {
		err = TRUE;
		stmt = obj_name;
		stmt_len = STlength(obj_name);
		err_no = E_PS0BD4_TTBL_NOT_IN_VIEW;
	    }
	    
	    break;
	}
	case PSQ_CALARM:
	{
	    err = TRUE;
	    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;

	    break;
	}
	case PSQ_CREDBP:
	{
	    err = TRUE;
	    err_no = E_PS0BD9_SESSION_DBP_ILLEGAL;

	    break;
	}
	case PSQ_CSEQUENCE:
	{
	    err = TRUE;
	    err_no = E_PS0BDA_SESSION_SEQ_ILLEGAL;

	    break;
	}
	case PSQ_ASEQUENCE:
	{
	    err = TRUE;
	    err_no = E_PS0BDA_SESSION_SEQ_ILLEGAL;

	    break;
	}
	case PSQ_DELETE:
	case PSQ_REPLACE:
	case PSQ_APPEND:
	case PSQ_RETRIEVE:
	{
	    /* DGTT's may not be used in DML statements inside a dbproc */
	    if (sess_cb->pss_dbp_flags & PSS_DBPROC)
	    {
		err = TRUE;
		stmt = obj_name;
		stmt_len = STlength(obj_name);
		err_no = E_PS0BD5_TTBL_NOT_IN_DBP;
	    }

	    break;
	}
	case PSQ_EVDROP:
	{
	    err = TRUE;
	    err_no = E_PS0BD7_SESSION_EV_ILLEGAL;

	    break;
	}
	case PSQ_DRODBP:
	{
	    err = TRUE;
	    err_no = E_PS0BD9_SESSION_DBP_ILLEGAL;

	    break;
	}
	case PSQ_DSEQUENCE:
	{
	    err = TRUE;
	    err_no = E_PS0BDA_SESSION_SEQ_ILLEGAL;

	    break;
	}
	case PSQ_DSTINTEG:
	{
	    err = TRUE;
	    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;
	
	    break;
	}
	case PSQ_DSTPERM:
	{
	    PSY_CB	*psy_cb = (PSY_CB *) sess_cb->pss_object;

	    err = TRUE;

	    switch (psy_cb->psy_grant)
	    {
		case PSY_TDROP:
		{
		    stmt = "DROP PERMIT";
		    stmt_len = sizeof("DROP PERMIT") - 1;
		    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;
		    break;
		}
		case PSY_EVDROP:
		{
		    stmt = "DROP PERMIT ON DBEVENT";
		    stmt_len = sizeof("DROP PERMIT ON DBEVENT") - 1;
		    err_no = E_PS0BD7_SESSION_EV_ILLEGAL;
		    break;
		}
		case PSY_PDROP:
		{
		    stmt = "DROP PERMIT ON PROCEDURE";
		    stmt_len = sizeof("DROP PERMIT ON PROCEDURE") - 1;
		    err_no = E_PS0BD9_SESSION_DBP_ILLEGAL;
		    break;
		}
		case PSY_SQDROP:
		{
		    stmt = "DROP PERMIT ON SEQUENCE";
		    stmt_len = sizeof("DROP PERMIT ON SEQUENCE") - 1;
		    err_no = E_PS0BDA_SESSION_SEQ_ILLEGAL;
		    break;
		}
		default:
		{
		    stmt = "DROP PERMIT ON UNKNOWN";
		    stmt_len = sizeof("DROP PERMIT ON UNKNOWN") - 1;
		    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;
		    break;
		}
	    }

	    break;
	}
	case PSQ_KALARM:
	{
	    err = TRUE;
	    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;

	    break;
	}
	case PSQ_CALLPROC:
	{
	    err = TRUE;
	    err_no = E_PS0BD9_SESSION_DBP_ILLEGAL;

	    break;
	}
	case PSQ_GRANT:
	{
	    PSY_CB	*psy_cb = (PSY_CB *) sess_cb->pss_object;

	    err = TRUE;

	    switch (psy_cb->psy_grant)
	    {
		case PSY_TGRANT:
		{
		    stmt = "GRANT";
		    stmt_len = sizeof("GRANT") - 1;
		    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;
		    break;
		}
		case PSY_PGRANT:
		{
		    stmt = "GRANT ON PROCEDURE";
		    stmt_len = sizeof("GRANT ON PROCEDURE") - 1;
		    err_no = E_PS0BD9_SESSION_DBP_ILLEGAL;
		    break;
		}
		case PSY_EVGRANT:
		{
		    stmt = "GRANT ON DBEVENT";
		    stmt_len = sizeof("GRANT ON DBEVENT") - 1;
		    err_no = E_PS0BD7_SESSION_EV_ILLEGAL;
		    break;
		}
		case PSY_SQGRANT:
		{
		    stmt = "GRANT ON SEQUENCE";
		    stmt_len = sizeof("GRANT ON SEQUENCE") - 1;
		    err_no = E_PS0BDA_SESSION_SEQ_ILLEGAL;
		    break;
		}
		default:
		{
		    stmt = "GRANT ON UNKNOWN";
		    stmt_len = sizeof("GRANT ON UNKNOWN") - 1;
		    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;
		    break;
		}
	    }

	    break;
	}
	case PSQ_REVOKE:
	{
	    PSY_CB	*psy_cb = (PSY_CB *) sess_cb->pss_object;

	    err = TRUE;

	    switch (psy_cb->psy_grant)
	    {
		case PSY_TREVOKE:
		{
		    stmt = "REVOKE";
		    stmt_len = sizeof("REVOKE") - 1;
		    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;
		    break;
		}
		case PSY_PREVOKE:
		{
		    stmt = "REVOKE ON PROCEDURE";
		    stmt_len = sizeof("REVOKE ON PROCEDURE") - 1;
		    err_no = E_PS0BD9_SESSION_DBP_ILLEGAL;
		    break;
		}
		case PSY_EVREVOKE:
		{
		    stmt = "REVOKE ON DBEVENT";
		    stmt_len = sizeof("REVOKE ON DBEVENT") - 1;
		    err_no = E_PS0BD7_SESSION_EV_ILLEGAL;
		    break;
		}
		case PSY_SQREVOKE:
		{
		    stmt = "REVOKE ON SEQUENCE";
		    stmt_len = sizeof("REVOKE ON SEQUENCE") - 1;
		    err_no = E_PS0BDA_SESSION_SEQ_ILLEGAL;
		    break;
		}
		default:
		{
		    stmt = "REVOKE ON UNKNOWN";
		    stmt_len = sizeof("REVOKE ON UNKNOWN") - 1;
		    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;
		    break;
		}
	    }

	    break;
	}
	case PSQ_EVREGISTER:
	{
	    err = TRUE;
	    err_no = E_PS0BD7_SESSION_EV_ILLEGAL;

	    break;
	}
	case PSQ_EVDEREG:
	{
	    err = TRUE;
	    err_no = E_PS0BD7_SESSION_EV_ILLEGAL;

	    break;
	}
	case PSQ_EVRAISE:
	{
	    err = TRUE;
	    err_no = E_PS0BD7_SESSION_EV_ILLEGAL;

	    break;
	}
	case PSQ_SAVE:
	{
	    err = TRUE;
	    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;
	
	    break;
	}
	case PSQ_SJOURNAL:
	{
	    err = TRUE;
	    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;

	    break;
	}
	case PSQ_SLOCKMODE:
	{
	    err = TRUE;
	    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;

	    break;
	}
	case PSQ_ALTERTABLE:
	case PSQ_ATBL_ADD_COLUMN:
	case PSQ_ATBL_ALTER_COLUMN:
	case PSQ_ATBL_DROP_COLUMN:
	{
	    err = TRUE;
	    err_no = E_PS0BD2_NOT_SUPP_ON_TEMP;

	    break;
	}
    }

    if (err)
    {
	i4	    err_code;

	(VOID) psf_error(err_no, 0L, PSF_USERERR, &err_code, err_blk, 1,
	    stmt_len, stmt);
    }
	
    return(!err);
}

/*
** Name:    psl_reg_struct --  semantic for gateway register table structure
**
** Description:	    This function implements the semantic actions for
**		    the production
**                  reg_dbms_or_struct_parm : NAME EQUAL NAME
**                                       | NAME EQUAL UNIQUE NAME
** 
**
** Input:
**      dmu_cb     -- pointer to DMU_CB structure
**      ssname     -- pointer to the NAME after EQUAL [UNIQUE]
**      dmu_c_flag -- flag telling if the structure object is unique
**
** Output:
**      pst_struct -- set to indicate type of storage.
**      err_blk    -- set if error.
**	
** Returns:
**	E_DB_{OK, ERROR}
**
** History:
**      22-jun-92 (schang)
**          add the above documentation. Created for 06-15-92 integration.
*/
static DB_STATUS
psl_reg_struct(
	i4	    *pst_struct,
	DMU_CB	    *dmu_cb,
	char	    *ssname,
	i4	    dmu_c_flag,
	DB_ERROR    *err_blk)
{
    i4  err_code;
    i4	     storestruct;
    DMU_CHAR_ENTRY  *chr;

    /*
    ** If this is the first structure parameter, pst_struct should be
    ** 0L.  If pst_struct is non-NULL then issue error message for
    ** duplicate parameter.
    */
    if (*pst_struct != 0L)
    {
        /* duplicate parm found  */
	(VOID) psf_error(9309L, 0L, PSF_USERERR, &err_code, err_blk, 1,
			 (i4) sizeof("structure") - 1, "structure");
	return (E_DB_ERROR);
    }

    /* First entry in characteristics array is storage structure */
    chr = (DMU_CHAR_ENTRY *) dmu_cb->dmu_char_array.data_address;
 
    /*
    ** statements for decoding compressed storage structure are deleted,
    ** as no storage structure is compressed in REGISTER TABLE command
    */
    if (!STcasecmp(ssname, "keyed"))
    {
        storestruct = DB_ISAM_STORE;
    }
    else if (!STcasecmp(ssname, "fullkey"))
    {
        storestruct = DB_HASH_STORE;
    }
    else if (!STcasecmp(ssname, "sortkeyed"))
    {
        storestruct = DB_BTRE_STORE;
    }
    else if (!STcasecmp(ssname, "none"))
    {
    /* schang : if unique, then specifying "none" is an error */
        if (dmu_c_flag == DMU_C_ON)
        {
            (VOID) psf_error(9321L, 0L, PSF_USERERR, &err_code, err_blk, 0);
	    return (E_DB_ERROR);
        }
        else
        {
	    storestruct = DB_HEAP_STORE;
	}
    }
    else
    {
        (VOID) psf_error(8002L, 0L, PSF_USERERR, &err_code, err_blk, 1,
	    (i4) STtrmwhite(ssname), ssname);
        return (E_DB_ERROR);
    }

    chr->char_value = storestruct;
    *pst_struct = (i4) storestruct;

    /*
    ** replace default NOUNIQUENESS by UNIQUENESS in the second entry
    ** of characteristics array
    */
    chr++;
    chr->char_id = DMU_UNIQUE;
    chr->char_value = dmu_c_flag;
    return(E_DB_OK);   
}

/*
** Name: psl_tbl_ref - process <table name> found in a <column reference>
**
** Description:
**	This function will determine whether <table name> or <correlation name>
**	specified in <column reference> is valid.  The rules are a bit more
**	complicated than they used to be before we added support for
**	<schema>.<table>.<column>.  For more details, take a look at pst_slook()
**	    
** Input:
**	psq_cb			PSF query CB
**	    psq_mode		mode of a query
**	sess_cb			PSF session CB
**	col_ref			structure describing column reference
**	in_target_clause	TRUE if we are parsing a target clause
**	cur_scope		TRUE if we are only interested in rabge vars at
**				current scope
**	tbl_refs		address of array of <table reference>
**				descriptions
**
** Output
**	psq_cb
**	    psq_error		filled in if an error occurred
**	*tbl_refs		if a new description had to be allocated,
**				*tbl_refs will contains its address
**	rngtab			will contain address of a range variable
**				corresponding to the specified <table reference>
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**
**	25-sep-92 (andre)
**	    written
**	30-mar-93 (rblumer)
**	    added check for PSS_PARSING_CHECK_CONS, in addition
**	    to in_target_clause
**	02-may-93 (andre)
**	    avoid looking for a range variable if processing CHECK constraint
**	    specified as a part of CREATE TABLE statement
**	04-may-93 (andre)
**	    if range variable was not found while processing CHECK constraint
**	    specified in ALTER TABLE statement, produce an appropriate message
**	06-may-93 (andre)
**	    (this undoes changes mentioned in (30-mar-93 (rblumer)) and
**	    (02-may-93 (andre)))
**	    if processing CHECK constraint specified inside CREATE TABLE, verify
**	    that the <table reference> refers to the table being created;
**	    there is no reason to build a PSS_TBL_REF structure since all
**	    <column reference>s MUST refer to the table being created
*/
static DB_STATUS
psl_tbl_ref(
	PSQ_CB		*psq_cb,
	PSS_SESBLK	*sess_cb,
	PSS_COL_REF	*col_ref,
	i4		in_target_clause,
	i4		cur_scope,
	PSS_TBL_REF	**tbl_refs,
	PSS_RNGTAB	**rngtab)
{
    DB_STATUS		status;
    i4		err_code;
    DB_OWN_NAME		*schema_name;
    bool		bad_tbl_ref = FALSE;

    /* Just plain syntax error if in EXECUTE PROCEDURE target list */
    if (psq_cb->psq_mode == PSQ_CALLPROC)
    {
	(VOID) psf_error(E_US0986_2438_EXEC_COL, 0L, PSF_USERERR,
	    &err_code, &psq_cb->psq_error, 1,
	    STtrmwhite(col_ref->pss_tab_name), col_ref->pss_tab_name);
	return (E_DB_ERROR);
    }

    schema_name = (col_ref->pss_flags & PSS_SCHEMA_SPECIFIED)
	? &col_ref->pss_schema_name : (DB_OWN_NAME *) NULL;

    if (in_target_clause)
    {
	DB_TAB_NAME		tab_name;
	PSS_TBL_REF		*tbl_ref;

	if (tbl_ref = *tbl_refs)
	{
	    /* list of <table reference> descriptions is non-empty */
	    STmove(col_ref->pss_tab_name, ' ', sizeof(DB_TAB_NAME), 
		(char *) &tab_name);
	
	    for (; tbl_ref; tbl_ref = tbl_ref->pss_next)
	    {
		/* 
		** we are looking for a perfect match, i.e. if the <column
		** reference> passed by the caller involved <schema name>, we
		** will look for an element with non-NULL 
		** tbl_ref->pss_schema_name and *tbl_ref->pss_schema_name equal
		** to *schema_name + of course, table names must match
		*/
		if (   (   (!schema_name && !tbl_ref->pss_schema_name)
		    	|| (schema_name && tbl_ref->pss_schema_name 
			    && !MEcmp((PTR) schema_name, 
				      (PTR) tbl_ref->pss_schema_name,
				      sizeof(*schema_name)))
		       )
		    && !MEcmp((PTR) &tab_name, (PTR) &tbl_ref->pss_tab_name,
			    sizeof(tab_name))
		   )
		{
		    break;
		}
	    }
        }

	if (!tbl_ref)
	{
	    /* need to allocate a new <table reference> description */

	    status = psf_malloc(sess_cb, &sess_cb->pss_ostream, sizeof(PSS_TBL_REF),
		(PTR *) &tbl_ref, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return(status);

	    if (schema_name)
	    {
		status = psf_malloc(sess_cb, &sess_cb->pss_ostream, sizeof(DB_OWN_NAME),
		    (PTR *) &tbl_ref->pss_schema_name, &psq_cb->psq_error);
		if (status != E_DB_OK)
		    return(status);
		
		STRUCT_ASSIGN_MACRO(*schema_name, *tbl_ref->pss_schema_name);
	    }
	    else
	    {
		tbl_ref->pss_schema_name = (DB_OWN_NAME *) NULL;
	    }
	    
	    tbl_ref->pss_next = *tbl_refs;
	    *tbl_refs = tbl_ref;
	    STmove(col_ref->pss_tab_name, ' ', sizeof(DB_TAB_NAME), 
		(char *) &tbl_ref->pss_tab_name);
	}

	/*
	** This is not very clean, but it doesn't look like it could
	** cause any problems.
	*/
	*rngtab = (PSS_RNGTAB *) tbl_ref;
    }
    else if (   sess_cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
	     && ( ( psq_cb->psq_mode == PSQ_CREATE) || 
	          ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) )
    {
	/*
	** processing CHECK constraint specified inside CREATE TABLE; make sure
	** that the <table reference> refers to the table being created
	*/
	QEU_CB		*qeu_cb = (QEU_CB *) sess_cb->pss_object;
	DMU_CB		*dmu_cb = (DMU_CB *) qeu_cb->qeu_d_cb;
	DB_TAB_NAME	tab_name;

	STmove(col_ref->pss_tab_name, ' ', sizeof(DB_TAB_NAME), 
	    (char *) &tab_name);

	/*
	** if <table reference> consists of <table name>, it must be the same
	** as that of the table being created;
	** otherwise, if <table reference> is of format <schema name>.<table
	** name>, <schema name> must be the same as the name of the schema to
	** which the new table will belong (for 6.5, this is the same as the
	** table owner) and <table name> must be the same as the name of the
	** table being created
	*/
	if (   !MEcmp((PTR) &tab_name, (PTR) &dmu_cb->dmu_table_name,
		    sizeof(tab_name))
	    && (   !schema_name
		|| !MEcmp((PTR) schema_name, (PTR) &dmu_cb->dmu_owner,
			sizeof(*schema_name))
	       )
	   )
	{
	    *rngtab = (PSS_RNGTAB *) NULL;
	}
	else
	{
	    /* we got ourselves a bad <table reference> */
	    bad_tbl_ref = TRUE;
	}
    }
    else
    {
	/* need to look for range var at proper scope */

	/* 
	** Look for an already-existing range var corresponding to this
	** <table reference>
	*/
	status = pst_slook(&sess_cb->pss_auxrng, sess_cb, schema_name,
	    col_ref->pss_tab_name, rngtab, &psq_cb->psq_error, 
	    (bool) cur_scope);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/*
	** If not found, error - <qualifier> (table/correlation name or
	** schema.table) does not correspond to any <table reference> within
	** whose scope the <column reference> appeared
	*/
	if (*rngtab == (PSS_RNGTAB *) NULL)
	{
	    bad_tbl_ref = TRUE;
	}
    }


    if (bad_tbl_ref)
    {
# ifndef DOUBLEBYTE
	char	qualifier[2 * DB_MAXNAME + CMbytecnt(".")];
# else
	u_char	qualifier[2 * DB_MAXNAME + 1];
# endif /* #ifndef DOUBLEBYTE */
	i4	qual_len;

	if (schema_name)
	{
	    i4	schema_len;

	    schema_len = cus_trmwhite((u_i4) sizeof(*schema_name),
		(char *) schema_name);
	    MEcopy((PTR) schema_name, schema_len, (PTR) qualifier);
	    CMcpychar((u_char *)".", (qualifier + schema_len));
	    qual_len = schema_len + CMbytecnt(".");
	}
	else
	{
	    qual_len = 0;
	}

	{
	    i4	tbl_len;
	    
	    tbl_len = STlength(col_ref->pss_tab_name);

	    MEcopy((PTR) col_ref->pss_tab_name, tbl_len,
		(PTR) (qualifier + qual_len));

	    qual_len += tbl_len;
	}
	
	(VOID) psf_error(E_PS0461_BAD_COL_REF_QUAL, 0L, PSF_USERERR,
	    &err_code, &psq_cb->psq_error, 1,
	    (i4) qual_len, (PTR) qualifier);

	return (E_DB_ERROR);
    }

    return(E_DB_OK);
}

/*
** Name: psl_dbproc_param - process parameter of procedure
**
** Description:
**	This function generates a node representing one dbproc parameter.
**	    
** Input:
**	name			NAME of parameter
**	argument		argument value
**	is_byref       		is this being passed byref
**	result			pointer to result
**
** Output
**	*result			generated node
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**
**	26-oct-92 (jhahn)
**	    written
*/
static DB_STATUS
psl_dbproc_param(
	PSQ_CB		*psq_cb,
	PSS_SESBLK	*cb,
	char		*name,
	PST_QNODE	*argument,
	bool		is_byref,
	PST_QNODE	**result)
{
    DB_STATUS	    status;
    PST_RSDM_NODE	    resdom;
    
    /* Allocate and return a resdon node with "arg_val" as right child */
    STmove(name, ' ', sizeof(resdom.pst_rsname), (char *)resdom.pst_rsname);
    /* pst_rsno and pst_ntargno are set in list construction above */
    resdom.pst_rsupdt  = FALSE;	/* Unused */
    resdom.pst_rsflags = 0; /* no PST_RS_PRINT - Unused */
    if (is_byref)
	resdom.pst_ttargtype = PST_BYREF_DBPARAMNO;
    else
	resdom.pst_ttargtype = PST_DBPARAMNO;
    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL, argument,
		      PST_RESDOM, (char *)&resdom, sizeof(PST_RSDM_NODE),
		      argument->pst_sym.pst_dataval.db_datatype,
		      argument->pst_sym.pst_dataval.db_prec,
		      argument->pst_sym.pst_dataval.db_length,
		      (DB_ANYTYPE *)NULL,
		      result, &psq_cb->psq_error, (i4) 0);
    if (status != E_DB_OK)
	return (status);
    return (E_DB_OK);

} /* end psl_dbproc_param */

/*
** Name: psl_mfunc_param - process parameter of procedure
**
** Description:
**	This function generates a node representing one parameter of a 
**	multivariate function.
**	    
** Input:
**	argument		argument value
**	argument_num		which argument is this?
**	result			pointer to result
**
** Output
**	*result			generated node
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**
**	20-apr-1999 (shero03)
**	    written based on dbproc_param
*/
static DB_STATUS
psl_mfunc_param(
	PSQ_CB		*psq_cb,
	PSS_SESBLK	*cb,
	PST_QNODE	*argument,
	PST_QNODE	**result)
{
    DB_STATUS		status;
    
    /* Allocate and return a resdon node with "arg_val" as right child */
    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *)NULL, argument,
		      PST_OPERAND, (char *)NULL, 0,
		      argument->pst_sym.pst_dataval.db_datatype,
		      argument->pst_sym.pst_dataval.db_prec,
		      argument->pst_sym.pst_dataval.db_length,
		      (DB_ANYTYPE *)NULL,
		      result, &psq_cb->psq_error, PSS_NORES);
    if (status != E_DB_OK)
	return (status);
    return (E_DB_OK);

} /* end psl_mfunc_param */


/*
** Name: psl_usr_func - semantic action for CURRENT_USER, USER, SESSION_USER,
**			SYSTEM_USER, and INITIAL_USER
**
** Description:
**	This functions implements the semantic action for constant functions
**	CURRENT_USER, USER, SESSION_USER, SYSTEM_USER, and INITIAL_USER.
**	First we call ADF to get the right function instance, then we build a
**	query tree node for the function
**
** Input:
**	fname		NULL-terminated function name
**	sess_cb		PSF session CB
**	in_join_cond	TRUE if processing a join condition; FALSE otherwise
**	join_info	addr of a structure describing joins, if any, contained
**			in this query
**			
** Output:
**	*newnode	will point at a newly allocated query tree node
**	err_blk
**	    err_code	filled in if an error occurred
**
** Side effects:
**	will allocate memory
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**	02-dec-92 (andre)
**	    written
*/
static DB_STATUS
psl_usr_func(
	     char	    *fname,
	     PSS_SESBLK	    *sess_cb,
	     bool	    in_join_cond,
	     PSS_JOIN_INFO  *join_info,
	     PST_QNODE	    **newnode,
	     DB_ERROR	    *err_blk)
{
    PST_OP_NODE	    opnode;
    DB_STATUS	    status;
    ADI_OP_NAME	    funcname;
    ADI_OP_ID	    opid;
    ADF_CB	    *adf_scb = (ADF_CB*) sess_cb->pss_adfcb;
    i4	    err_code;

    STmove(fname, '\0', sizeof(ADI_OP_NAME), (char *) &funcname);
    status = adi_opid(adf_scb, &funcname, &opid);
    if (status != E_DB_OK)
    {
	(VOID) psf_error(E_PS0C05_BAD_ADF_STATUS, adf_scb->adf_errcb.ad_errcode,
	    PSF_INTERR, &err_code, err_blk, 0);
	return (E_DB_ERROR);
    }

    opnode.pst_opno = opid;
    opnode.pst_opmeta = PST_NOMETA;
    opnode.pst_isescape = PST_DOESNT_APPLY;

    status = pst_node(sess_cb, &sess_cb->pss_ostream, (PST_QNODE *) NULL,
	(PST_QNODE *) NULL, PST_COP, (char *) &opnode, sizeof(opnode),
	DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, newnode,
	err_blk, (i4) 0);

    if (status != E_DB_OK)
    {
	return (status);
    }
    else if (in_join_cond)
    {
	/*
	** If we are processing a join_search condition, set the joinid field
	** appropriately.  It has been initialized to PST_NOJOIN in pst_node().
	*/
	(*newnode)->pst_sym.pst_value.pst_s_op.pst_joinid =
		join_info->pss_join[join_info->depth].join_id;
    }

    return(E_DB_OK);

} /* end psl_usr_func */

/*
** Name: psl_debug - an entry point on which to break for debugging
**
** Description:
**	This routine can be called in xDEBUG blocks for debugging purposes
**	
** Input:
**	(none)
**
** Output
**	(none)
**
** Returns:
**	(none)
**
** History:
**
**	24-nov-92 (ralph)
**	    written
*/
void psl_debug()
{
    return;
}

/*
** Name: psl_reserved_ident   -	make sure a new object name is NOT reserved
**				for internal use
**				(i.e. does NOT start with a dollar sign).
**
** Description:
**	Part of the name space for identifiers is reserved for internal use 
**	(for system-generated names).  This function looks at object names
**	that users are trying to create, and if the name is part of the
**	reserved name space, it will produce a message and return FALSE; 
**	otherwise it will return TRUE.
**	   This function is called in the few productions that are used for
**	new object names: obj_spec, auth_ident, col_spec, constraint_name,
**	and cdbp_varname. The PSS_NEW_OBJ_NAME bit in pss_stmt_flag must be
**	set for this routine to print and error and return TRUE.
**	
**	   Currently, the reserved name space is all names starting with
**	a dollar sign ('$').  This reserved space does not conflict with
**      the SQL92 name space in any way, as the dollar sign is not valid 
**	in SQL92 identifiers (not even in delimited identifiers).
**	It also follows existing INGRES internal names like $ingres and $dba.
**
**	The following commands can create an object, and have been changed to
**	set PSS_NEW_OBJ_NAME as necessary:
**
**	    - CREATE DBEVENT
**	    - CREATE GROUP
**	    - CREATE INDEX
**	    - CREATE PROCEDURE (incl. parameters and local variables)
**	    - CREATE ROLE
**	    - CREATE RULE
**	    - CREATE SCHEMA
**	    - CREATE TABLE [AS SELECT] (incl. new column names)
**	    - CREATE SYNONYM
**	    - CREATE USER
**	    - CREATE VIEW
**	    - DECLARE GLOBAL TEMP TABLE [AS SELECT]
**	    
**	Star commands
**	    - CREATE LINK (old version of REGISTER AS LINK)
**	    - CREATE TABLE
**	    - REGISTER .. AS IMPORT
**	    - REGISTER .. AS LINK
**	    - REGISTER INDEX    .. AS LINK
**	    - REGISTER PROCEDURE.. AS LINK
**	    
** Input:
**	name		    identifier to check
**	sess_cb		    ptr to PSF session CB
**	    pss_stmt_flags    stmt-level flags; looks for PSS_NEW_OBJ_NAME
**	    pss_lang	      query language (SQL or QUEL)
**	psq_cb		    parser control block
**	    psq_mode	    query mode
**	    psq_info	    info about execute immediate statements
**	      pst_execflags   special flags for execute immed statements
**	      		        PST_SYSTEM_GENERATED => system-generated
**	      		        	command and $ names are allowed
**	force_check	    TRUE  => name is definitely for a new object, 
**					so don't allow name starting with $
**			    FALSE => name MAY be a new object,
**					check for PSS_NEW_OBJ_NAME bit
** Output
**	psq_cb		    parser control block
**          psq_error	    will be filled in if an error occurs
**
** Returns:
**	TRUE  - name is reserved, so this function prints out an error message
**		and caller should return an error
**	FALSE - name is NOT reserved, caller may proceed as usual
**
** History:
**
**	26-nov-92 (rblumer)
**	    written
**	30-mar-93 (rblumer)
**	    changed to look at PSS_NEW_OBJ_NAME bit, and to allow '$' names
**	    for system-generated commands.
**	13-apr-93 (andre)
**	    do not check names on dbproc recreate.  Presumably, all the required
**	    checking was done at CREATE PROCEDURE time.  This helps us deal
**	    with the case when we are recreating a system-generated dbproc.
**	23-apr-93 (rblumer)
**	    change CREATE USER check to compare against pss_cat_owner, instead
**	    of DB_INGRES_NAME, in order to use correct upper- or lower-case.
**	12-Sep-2004 (schka24)
**	    Allow upgradedb to generate $identifiers, mostly so that it
**	    can reapply un-named (ie system named) ref constraints.
*/
static i4
psl_reserved_ident(
		   char		*name,
		   PSS_SESBLK	*sess_cb,
		   PSQ_CB	*psq_cb,
		   i4		force_check)
{
    char    command[PSL_MAX_COMM_STRING];
    i4 length;
    i4 err_code;

    /*
    ** if recreating a dbproc, don't check;
    ** checking was done at CREATE PROCEDURE time
    */
    if (   sess_cb->pss_dbp_flags & PSS_DBPROC
	&& sess_cb->pss_dbp_flags & PSS_RECREATE)
    {
	return(FALSE);
    }

    /* names beginning with '$' are reserved for internally-generated objects.
    ** 
    ** Thus, if the current name begins with a '$'
    **     AND this is a new object name
    **     AND this command is not a system-generated command
    **     AND it's not upgradedb
    ** print an error and return TRUE.
    ** 
    ** Note that DROP, MODIFY, other commands can still reference these $names.
    ** 
    ** Make an exception for upgradedb so that it can reapply system
    ** named referential constraints.
    */
    if ((CMcmpcase(name, ERx("$")) == 0)
	&& (force_check || (sess_cb->pss_stmt_flags & PSS_NEW_OBJ_NAME))
	&& ((psq_cb->psq_info == (PST_INFO *) NULL)
	    || (~psq_cb->psq_info->pst_execflags & PST_SYSTEM_GENERATED))
	&& (sess_cb->pss_ses_flag & PSS_RUNNING_UPGRADEDB) == 0
	)
    {
	/* make an exception for the CREATE USER command:
	** don't print error for $ingres,
	** as CREATEDB uses it create the $ingres user
	*/
	if ((psq_cb->psq_mode == PSQ_CUSER)
	    && (MEcmp(name, 
		      sess_cb->pss_cat_owner->db_own_name, DB_MAXNAME) == 0))
	    return(FALSE);

	psl_command_string(psq_cb->psq_mode, 
			   sess_cb->pss_lang, command, &length);

	_VOID_ psf_error(E_PS047B_RESERVED_IDENT, 0L, PSF_USERERR,
			 &err_code, &psq_cb->psq_error, 2,
			 length, command,
			 psf_trmwhite(DB_MAXNAME, name), name);
	return (TRUE);
    }
    return (FALSE);

}  /* end psl_reserved_ident */


/*
** Name: psl_set_function   -	handle aggregate functions
**
** Description:
**	Allocate and initialize an operator node for the function passed in,
**	then take the expression node and other info passed in and build both
**	an aggregate operator node and an aggregate head node.
**	
**	If this is a COUNT or ANY aggregate, also check for correlated
**	attributes in subselect & tell OPF not to flatten the query, if found.
**	    
** Input:
**	sess_cb		    ptr to PSF session CB
**	    pss_lang	    query language (SQL or QUEL)
**	psq_cb		    parser control block
**	    psq_mode	    query mode
**	yyvarsp		    yacc state variable;
**				many, many fields are used
**	func_name	    name of set aggregate function
**	distinct	    one of PST_DISTINCT, PST_NDISTINCT, or PST_DONTCARE
**	count_or_any	    whether this is a COUNT or ANY aggregate;
**			        used to decide whether to check for
**			        correlated attributes
**	expr1_node	    1st expression to apply aggregate to
**	expr2_node	    2nd expression to apply aggregate to (binary OLAPs)
**
** Output
**	agndnodep	    aggregate head node, to be put into query tree
**	psq_cb		    parser control block
**          psq_error	        will be filled in if an error occurs
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**
**	29-dec-92 (rblumer)
**	    written
**	27-may-93 (rblumer)
**	    add check to return an error if parsing a CHECK
**	    constraint, as aggregates are not allowed in a CHECK constraint.
**	    Modify to handle rest of aggregates, too (avg_min_max_sum).
**	20-sep-99 (inkdo01)
**	    Add support of PST_BDISTINCT for non-resword aggregates and added 
**	    2nd expression node parm for binary OLAP agg funcs.
**	30-june-05 (inkdo01)
**	    Replace "avg(x)" by "float8(sum(x)) / count(x)" to allow CX
**	    optimization to compute sum, count once each.
**	12-aug-05 (inkdo01)
**	    Add PST_XFORM_AVG flag to "div", "float8()" to allow later 
**	    detection of non-supported datatypes.
**	22-aug-05 (inkdo01)
**	    Add PST_AVG_AOP flag to "sum", "count" to help opa fix.
*/
static DB_STATUS
psl_set_function(
		 PSS_SESBLK	*sess_cb,
		 PSQ_CB		*psq_cb,
		 PSS_YYVARS	*yyvarsp,
		 char		*func_name,
		 i4		distinct,
		 i4		count_or_any,
		 PST_QNODE	*expr1_node,
		 PST_QNODE	*expr2_node,
		 PST_QNODE	**aghdnodep)
{
    PST_OP_NODE  operator;
    PST_QNODE	 *agopnode;
    PST_QNODE	 *aghdnode;
    PST_RT_NODE	 aghead;
    DB_STATUS	 status;
    ADI_OP_NAME	 adi_funcname;
    ADI_OP_ID	 opid;
    ADF_CB	 *adf_scb = (ADF_CB*) sess_cb->pss_adfcb;
    i4	 err_code;
    PST_J_ID	joinid;
    bool	avg = FALSE;

    if (distinct == PST_BDISTINCT) distinct = PST_NDISTINCT;
				/* empty set quantifier is same as ALL */
    /* aggregates are not allowed in CHECK constraints
     */
    if (sess_cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS)
    {
	(void) psf_error(E_PS0471_CHECK_CONSTRAINT, 0L, PSF_USERERR,
			 &err_code, &psq_cb->psq_error, 1,
			 sizeof(ERx("CREATE/ALTER TABLE"))-1,
			 ERx("CREATE/ALTER TABLE"));
	return (E_DB_ERROR);
    }

    /* Sequence operators are not allowed in aggregates. */
    if (psl_seqop_search(expr1_node) || psl_seqop_search(expr2_node))
    {
	(void)psf_error(6319L, 0L, PSF_USERERR,
	    &err_code, &psq_cb->psq_error, 0);
	return (E_DB_ERROR);    /* non-zero return means error */
    }

    /* Mark this SELECT stmnt as non-updatable */
    if (sess_cb->pss_qualdepth == 1)
    {
	yyvarsp->nonupdt = TRUE;
    }

    if (yyvarsp->aggr_allowed & PSS_STMT_AGG_ALLOWED)
	yyvarsp->aggr_allowed |= PSS_AGG_ALLOWED;

    /* Allocate the aggregate operator node 
     */
    STmove(func_name, '\0', sizeof(ADI_OP_NAME), adi_funcname.adi_opname);
    status = adi_opid(adf_scb, &adi_funcname, &opid);
    if (status != E_DB_OK)
    {
	(VOID) psf_error(E_PS0D1D_BAD_FUNC_NAME,
			 adf_scb->adf_errcb.ad_errcode, PSF_INTERR, &err_code,
			 &psq_cb->psq_error, 0);
	return (E_DB_ERROR);
    }

    if (opid == ADI_AVG_OP)
    {
	/* Replace avg by sum and set flag so we can complete
	** the transform later. */
	avg = TRUE;
	opid = ADI_SUM_OP;
    }
    operator.pst_opno     = opid;
    operator.pst_retnull  = (count_or_any) ? FALSE : TRUE;
    operator.pst_opmeta   = PST_NOMETA;
    operator.pst_isescape = PST_DOESNT_APPLY;
    operator.pst_distinct = distinct;
    operator.pst_flags 	  = 0;

    status = pst_node(sess_cb, &sess_cb->pss_ostream, 
		      expr1_node, expr2_node,
		      PST_AOP, (char *) &operator, sizeof(operator), 
		      DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, 
		      &agopnode, &psq_cb->psq_error,
		      (yyvarsp->in_target_clause) ? PSS_NORES : (i4) 0);

    if (status != E_DB_OK)
	return (status);

    if (BTtest(yyvarsp->qual_depth, yyvarsp->qual_type))
    {
	/*
	 ** If we are processing a join_search condition, set the joinid
	 ** field appropriately.  It has been initialized to PST_NOJOIN in
	 ** pst_node().
	 */
	joinid = agopnode->pst_sym.pst_value.pst_s_op.pst_joinid =
	    yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id;
    }
    else joinid = PST_NOJOIN;

    aghead.pst_union.pst_next  = 0;
    aghead.pst_dups   = PST_ALLDUPS;
    aghead.pst_mask1 = 0x0;
    /* Allocate the aghead node */
    status = pst_node(sess_cb, &sess_cb->pss_ostream, agopnode, (PST_QNODE*) NULL, 
		      PST_AGHEAD, (PTR) &aghead,
		      sizeof(PST_RT_NODE), agopnode->pst_sym.pst_dataval.db_datatype,
		      agopnode->pst_sym.pst_dataval.db_prec,
		      agopnode->pst_sym.pst_dataval.db_length, (DB_ANYTYPE *) NULL,
		      &aghdnode, &psq_cb->psq_error, (i4) 0);
    if (status != E_DB_OK)
    {
	return (status);
    }

    if (avg)
    {
	PST_QNODE	*cntopnode, *f8opnode, *divopnode, *expr1copy;
	PST_QNODE	*aghd1node;
	PSS_DUPRB	dup_rb;
	DB_ERROR	err_blk;

	/* Add parse tree nodes for count(expr1), float8(sum()) and
	** division of float8(sum()) by count(). But first, copy 
	** sum subtree to stick under count. */

	dup_rb.pss_tree = expr1_node;
	dup_rb.pss_dup = &expr1copy;
	dup_rb.pss_1ptr = NULL;
	dup_rb.pss_op_mask = 0;
	dup_rb.pss_num_joins = PST_NOJOIN;
	dup_rb.pss_tree_info = (i4 *) NULL;
	dup_rb.pss_mstream = &sess_cb->pss_ostream;
	dup_rb.pss_err_blk = &err_blk;

	status = pst_treedup(sess_cb, &dup_rb);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* Make it count(*) if count expr is not nullable and count
	** is NOT distinct. */
	if (!(yyvarsp->in_target_clause) &&
	    expr1copy->pst_sym.pst_dataval.db_datatype > 0 &&
	    operator.pst_distinct == PST_NDISTINCT)
	{
	    operator.pst_opno = ADI_CNTAL_OP;
	    expr1copy = (PST_QNODE *) NULL;
	}
	else operator.pst_opno = ADI_CNT_OP;
	operator.pst_retnull = FALSE;	/* cuz it's count */
	status = pst_node(sess_cb, &sess_cb->pss_ostream, expr1copy,
			(PST_QNODE *) NULL, PST_AOP, (char *)&operator,
			sizeof(operator), DB_NODT, (i2)0, (i4)0,
			(DB_ANYTYPE *) NULL, &cntopnode, &psq_cb->psq_error,
			(yyvarsp->in_target_clause) ? PSS_NORES : (i4) 0);
	if (status != E_DB_OK)
	    return (status);
	cntopnode->pst_sym.pst_value.pst_s_op.pst_joinid = joinid;
	cntopnode->pst_sym.pst_value.pst_s_op.pst_flags |= PST_AVG_AOP;
	agopnode->pst_sym.pst_value.pst_s_op.pst_flags |= PST_AVG_AOP;

	/* Stick AGHEAD on top of count. */
	aghead.pst_union.pst_next  = 0;
	aghead.pst_dups   = PST_ALLDUPS;
	status = pst_node(sess_cb, &sess_cb->pss_ostream, cntopnode, (PST_QNODE*) NULL, 
		      PST_AGHEAD, (PTR) &aghead,
		      sizeof(PST_RT_NODE), agopnode->pst_sym.pst_dataval.db_datatype,
		      agopnode->pst_sym.pst_dataval.db_prec,
		      agopnode->pst_sym.pst_dataval.db_length, (DB_ANYTYPE *) NULL,
		      &aghd1node, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	    return (status);

	operator.pst_opno = ADI_F8_OP;
	operator.pst_retnull = TRUE;
	status = pst_node(sess_cb, &sess_cb->pss_ostream, aghdnode,
			(PST_QNODE *) NULL, PST_UOP, (char *)&operator,
			sizeof(operator), DB_NODT, (i2)0, (i4)0,
			(DB_ANYTYPE *) NULL, &f8opnode, &psq_cb->psq_error,
			(yyvarsp->in_target_clause) ? PSS_NORES : (i4) 0);
	if (status != E_DB_OK)
	    return (status);
	f8opnode->pst_sym.pst_value.pst_s_op.pst_joinid = joinid;
	f8opnode->pst_sym.pst_value.pst_s_op.pst_flags |=
						PST_XFORM_AVG;

	operator.pst_opno = ADI_DIV_OP;
	operator.pst_retnull = TRUE;
	status = pst_node(sess_cb, &sess_cb->pss_ostream, f8opnode,
			aghd1node, PST_BOP, (char *)&operator,
			sizeof(operator), DB_NODT, (i2)0, (i4)0,
			(DB_ANYTYPE *) NULL, &divopnode, &psq_cb->psq_error,
			(yyvarsp->in_target_clause) ? PSS_NORES : (i4) 0);
	if (status != E_DB_OK)
	    return (status);
	divopnode->pst_sym.pst_value.pst_s_op.pst_joinid = joinid;
	divopnode->pst_sym.pst_value.pst_s_op.pst_flags |=
						PST_XFORM_AVG;

	aghdnode = divopnode;		/* return modified expr */
    }

    /* 
    ** check if count() or any() was found in the target list of a correlated
    ** subselect.  If so, and if yyvarsp->mult_corr_attrs.depth has not been
    ** previously set, we will set it to the current pss_qualdepth and start
    ** looking for correlated attributes.  If we find correlated attributes
    ** from at least 2 different relations within this subselect, we will
    ** indicate to the OPF that the query should not be flattened.  We will
    ** not be looking for multiple correlated references if 
    ** sess_cb->pss_flattening_flags indicates that we have already found an 
    ** occurrence
    */
    if (count_or_any &&
        ~sess_cb->pss_flattening_flags & PSS_MULT_CORR_ATTRS   &&
	yyvarsp->in_target_clause			&&
	yyvarsp->mult_corr_attrs.depth == -1	&&
	sess_cb->pss_qualdepth > 1)
    {
	yyvarsp->mult_corr_attrs.depth = sess_cb->pss_qualdepth;
	yyvarsp->mult_corr_attrs.found = FALSE;
	yyvarsp->mult_corr_attrs.rgno = -1;
    }
	
    *aghdnodep = aghdnode;

    return(E_DB_OK);
    
}  /* end psl_set_function */

/*
** Name: psl_vrule_tree_convert - call psl_vrule_subtree() to replace references
**				  to the attributes of the view with references
**				  to the attributes of its underlying base table
**				  in a rule tree
**
** Description:
**	This function will pass a (previously pumped through qrymod) copy of a
**	tree of the view on which a rule is being defined to psy_vrule_subtree()
**	to replace references to the attributes of the view with references to
**	the attributes of its underlying base table in a rule tree
**
** Input:
**	rootnode	    root node of the rule tree
**	    pst_left	    if non-NULL, points at the tree describing
**			    attributes to be passed to the dbproc fired by the
**			    rule
**	    pst_right	    if non-NULL, points at the rule qualification tree
**	vtree		    root of the view tree
**	sess_cb		    PSF sesion CB
**
** Output:
**	err_blk		    will be filled in if an error occurs
**
** Side effects:
**	memory will be allocated
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**	04-jan-93 (andre)
**	    written
*/
static DB_STATUS
psl_vrule_tree_convert(
	PST_QNODE	*rootnode,
	PST_QNODE	*vtree,
	PSS_SESBLK	*sess_cb,
	DB_ERROR	*err_blk)
{
    PSS_DUPRB	    dup_rb;
    DB_STATUS	    status;

    dup_rb.pss_op_mask = PSS_MAP_VAR_TO_RULEVAR;
    dup_rb.pss_num_joins = PST_NOJOIN;
    dup_rb.pss_tree_info = (i4 *) NULL;
    dup_rb.pss_mstream = &sess_cb->pss_ostream;
    dup_rb.pss_err_blk = err_blk;
    
    if (rootnode->pst_left)
    {
	PST_QNODE	*resdom;
	
	/* non-empty parameter tree */
	for (resdom = rootnode->pst_left;
	     (resdom && resdom->pst_sym.pst_type == PST_RESDOM);
	     resdom = resdom->pst_left
	    )
	{
	    status = psl_vrule_subtree(sess_cb, &resdom->pst_right, vtree, &dup_rb);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
    }

    if (rootnode->pst_right)
    {
	/* non-empty qualification tree */
	status = psl_vrule_subtree(sess_cb, &rootnode->pst_right, vtree, &dup_rb);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
    
    return(E_DB_OK);
}

/*
** Name: psl_vrule_subtree - replace references to the attributes of the
**			     view with references to the attributes of its
**			     underlying base table in a subtree
**
** Description:
**	This function will use a (previously pumped through qrymod) copy of a
**	tree of the view on which a rule is being defined to replace references
**	to the attributes of the view with references to the attributes of its
**	underlying base table in a subtree.
**	In particular, for each PST_RULEVAR node in the subtree, we will find a
**	subtree in the view tree corresponding to that attribute of the view and
**	make a copy of it replacing PST_VAR nodes with PST_RULEVAR nodes.  The
**	resulting 
**
** Input:
**	subtree 	    address of a pointer to the root of a subtree to
**			    copy
**	vtree		    root of the view tree
**	dup_rb		    address of a pre-initialized control block to be
**			    passed to pst_treedup()
**
** Output:
**	dup_rb
**	    pss_err_blk	    will be filled in if an error occurs
**
** Side effects:
**	memory will be allocated
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**	04-jan-93 (andre)
**	    written
**      25-feb-93 (andre)
**          rule could reference a TID node of updatable view; in that case we
**          just want to leave it alone since a node corresponding to a TID of
**          an updatable view is identical to the node represeting TID of the
**          view's base table (and well it should be since references to a TID
**          of a view get translated to references to TID of the view's
**          underlying base table.)
*/
static DB_STATUS
psl_vrule_subtree(
	PSS_SESBLK	*cb,
	PST_QNODE	**subtree,
	PST_QNODE	*vtree,
	PSS_DUPRB	*dup_rb)
{
    DB_STATUS	    status;

    if (*subtree == (PST_QNODE *) NULL)
	return(E_DB_OK);

    if ((*subtree)->pst_sym.pst_type == PST_RULEVAR)
    {
	PST_QNODE	    *resdom;
	PST_QNODE	    *copy;
	i4		    attno =
			     (*subtree)->pst_sym.pst_value.pst_s_rule.pst_rltno;
	
	/*
	** do not translate references to the TID of a base table through an
	** updatable view defined over it
	*/
	if (attno == 0)
	    return(E_DB_OK);

	/*
	** find subtree in the view target list that corresponds to this
	** attribute of the view
	*/
	for (resdom = vtree->pst_left;
	     resdom->pst_sym.pst_value.pst_s_rsdm.pst_rsno != attno;
	     resdom = resdom->pst_left
	    )
	;

	/*
	** now we need to duplicate a subtree pointed to by resdom->pst_right
	** taking care to replace every occurrence of PST_VAR with a
	** PST_RULEVAR; the result will replace *subtree
	*/
	dup_rb->pss_tree = resdom->pst_right;
	dup_rb->pss_dup = &copy;
	dup_rb->pss_1ptr = (PTR) *subtree;

	status = pst_treedup(cb, dup_rb);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* overwrite reference to the attribute of the view */
	*subtree = copy;

	return(E_DB_OK);
    }

    if ((*subtree)->pst_left)
    {
	status = psl_vrule_subtree(cb, &(*subtree)->pst_left, vtree, dup_rb);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }

    if ((*subtree)->pst_right)
    {
	status = psl_vrule_subtree(cb, &(*subtree)->pst_right, vtree, dup_rb);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
    
    return(E_DB_OK);
}

/*
** Name: psl_bld_tid_descr - build a DMT_ATT_ENTRY entry describing a generic
**			     TID attribute
** Description:
**	Given a ptr to a DMT_ATT_ENTRY structure, populate it to describe a
**	generic TID attribute
**
** Input:
**	attribute	address of a DMT_ATT_ENTRY to populate
**
** Output:
**	attribute	populated DMT_ATT_ENTRY structure
**
** Side effects:
**	none
**
** Returns:
**	none
**
** History:
**	11-feb-93 (andre)
**	    written for CHECK OPTION project
**	08-apr-93 (ralph)
**	    DELIM_IDENT:  Use appropriate case for "tid"; pass in sess cb
**	12-feb-04 (inkdo01)
**	    Change to show 8-byte TID.
*/
static void
psl_bld_tid_descr(
	    DMT_ATT_ENTRY	*attribute,
	    PSS_SESBLK		*cb)
{
    MEmove((sizeof("tid") - 1),
	(PTR)((*cb->pss_dbxlate & CUI_ID_REG_U) ? "TID" : "tid"),
	' ',
	sizeof(attribute->att_name), (PTR) &attribute->att_name);
    attribute->att_number = 0;
    attribute->att_offset = 0;
    attribute->att_type = DB_TID8_TYPE;
    attribute->att_width = DB_TID8_LENGTH;
    attribute->att_prec = 0;
    attribute->att_flags = 0;
    attribute->att_key_seq_number = 0;
    attribute->att_defaultID.db_tab_base =
	attribute->att_defaultID.db_tab_index = 0;
    attribute->att_default = 0;

    return;
}

/*
** Name: psl_1ary_func_extra_proc - perform additional processing for unary
**				    functions
**
** Description:
**	If DECIMAL() function was called with 1 argument, figure out the correct
**	precision and scale and build a PST_CONST node describing precision and
**	scale
**
** Input:
**	sess_cb		    PSF session CB
**	    pss_ostream	    stream to be used to allocate PST_CONST node
**	    pss_adfcb	    ADF session CB
**	op_id		    operator id for the function
**	arg1		    node describing the argument passed to the function
**
** Output:
**	prec_scale	    if the function was decimal(), node describing
**			    default precision and scale for the specified
**			    argument
**	err_blk		    filled in if an error occurs
**
** Side effects:
**	memory may be allocated
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**	04-may-93 (andre)
**	    plagiarized from scalar_function production to get rid of duplicate
**	    code in psl_p_telem()
**	20-jul-2004 (gupsh01)
**	    Added case to handle I8 to decimal conversion.
*/
static DB_STATUS
psl_1ary_func_extra_proc(
	    PSS_SESBLK	    *sess_cb,
	    i4		    op_id,
	    PST_QNODE	    *arg1,
	    PST_QNODE	    **prec_scale,
	    DB_ERROR	    *err_blk)
{
    switch (op_id)
    {
	case ADI_DEC_OP:
	{
	    DB_STATUS		status;
	    PST_CNST_NODE	cconst;
	    DB_DT_ID		type;
	    i4			len;
	    i2			ps;
	    i4		err_code;

	    type = arg1->pst_sym.pst_dataval.db_datatype;
	    len  = arg1->pst_sym.pst_dataval.db_length - ((type < 0) ? 1 : 0);

	    switch (abs(type))
	    {
		case DB_FLT_TYPE:
		case DB_DEC_TYPE:
		case DB_MNY_TYPE:
		    ps = DB_PS_ENCODE_MACRO(AD_FP_TO_DEC_PREC,
			AD_FP_TO_DEC_SCALE);
		    break;

		case DB_INT_TYPE:
		    switch (len)
		    {
			case 1:
			    ps = DB_PS_ENCODE_MACRO(AD_I1_TO_DEC_PREC,
				AD_I1_TO_DEC_SCALE);
			    break;
			case 2:
			    ps = DB_PS_ENCODE_MACRO(AD_I2_TO_DEC_PREC,
				AD_I2_TO_DEC_SCALE);
			    break;
			case 4:
			    ps = DB_PS_ENCODE_MACRO(AD_I4_TO_DEC_PREC,
				AD_I4_TO_DEC_SCALE);
			    break;
			case 8:
			    ps = DB_PS_ENCODE_MACRO(AD_I8_TO_DEC_PREC,
				AD_I8_TO_DEC_SCALE);
			    break;
		    }
		    break;

		default:
		{
		    ADI_DT_NAME		dt_name;

		    /* can't default precision/scale for this datatype */
		    status = adi_tyname((ADF_CB *)sess_cb->pss_adfcb,
			abs(type), &dt_name);

		    (VOID) psf_error(E_PS0C80_NO_DEFLT_ON_DT, 0L, PSF_USERERR,
			&err_code, err_blk, 1,
			psf_trmwhite(sizeof(ADI_DT_NAME), (char *) &dt_name), 
			&dt_name);
		    return (E_DB_ERROR);
		}
	    }

	    /*
	    ** Now we have the default precision and scale; build a const
	    ** node and put prec_scale in as an i2
	    */
	    cconst.pst_tparmtype = PST_USER;
	    cconst.pst_parm_no = 0;
	    cconst.pst_pmspec  = PST_PMNOTUSED;
	    cconst.pst_cqlang = DB_SQL;
	    cconst.pst_origtxt = (char *) NULL;
	    status = pst_node(sess_cb, &sess_cb->pss_ostream,
		(PST_QNODE *) NULL, (PST_QNODE *) NULL, PST_CONST, (char *)
		&cconst, sizeof(cconst), DB_INT_TYPE, (i2) 0, (i4) 2,
		(DB_ANYTYPE *) &ps, prec_scale, err_blk, (i4) 0);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }

	    break;
	}
	default:
	{
	    break;
	}
    }
    
    return(E_DB_OK);
}

/*
** Name: psl_2ary_func_extra_proc - perform additional processing for binary
**				    functions
**
** Description:
**	If DECIMAL() function was called with 2 arguments, figure out the
**	correct scale and encode precision and scale in the PST_CONST node
**	representing precision (specified by the user).
**	For ascii(), text(), char() and varchar(), ascertain that the second
**	argument is an integer constant
**
** Input:
**	sess_cb		    PSF session CB
**	    pss_ostream	    stream to be used to allocate PST_CONST node
**	    pss_adfcb	    ADF session CB
**	op_id		    operator id for the function
**	arg1		    node describing the first argument
**	arg2		    node describing the second argument
**
** Output:
**	arg2		    if processing DECIMAL() function, both precision and
**			    scale will be encoded in this node that formerly
**			    contained only the precision
**	err_blk		    filled in if an error occurs
**
** Side effects:
**	may change the value inside the node representing the second argument
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**	04-may-93 (andre)
**	    plagiarized from scalar_function production to get rid of duplicate
**	    code in psl_p_telem()
**	21-apr-1999 (shero03)
**	    add substring 
**	20-jul-2004 (gupsh01)
**	    Added case for supporting bigint to decimal conversion.
**	27-Jul-2007 (kiria01) b118856
**	    Check that PST_CONST node is of tparmtype PST_USER before asserting
**	    literal constant and dereferencing the pst_dataval.
*/
static DB_STATUS
psl_2ary_func_extra_proc(
	    PSS_SESBLK	    *sess_cb,
	    i4		    op_id,
	    PST_QNODE	    *arg1,
	    PST_QNODE	    *arg2,
	    DB_ERROR	    *err_blk)
{
    i4		err_code;

    switch (op_id)
    {
		/*
		** The second argument of the two argument version of
		** ascii(), text(), char() or varchar() functions have to
		** be an integer constant.
		*/
	case ADI_ASCII_OP:
	case ADI_TEXT_OP:
	case ADI_CHAR_OP:
	case ADI_VARCH_OP:
	{
	    if (   arg2->pst_sym.pst_type != PST_CONST
		|| abs(arg2->pst_sym.pst_dataval.db_datatype) != DB_INT_TYPE)
	    {
		(VOID) psf_error(E_PS0C90_MUSTBE_CONST_INT, 0L,
		    PSF_USERERR, &err_code, err_blk, 0);
		return (E_DB_ERROR);
	    }

	    break;
	}
        case ADI_SUBSTRING_OP:
	{
    	    if (abs(arg2->pst_sym.pst_dataval.db_datatype) != DB_INT_TYPE)
	    {
	        (VOID) psf_error(E_PS0C91_MUSTBE_NUMERIC, 0L, PSF_USERERR,
		    &err_code, err_blk, 
		    (i4) sizeof("SUBSTRING")-1, "SUBSTRING", sizeof(i4), (i4)1);
	        return (E_DB_ERROR);
	    }

	    break;
	}
	case ADI_DEC_OP:
	{
	    DB_STATUS		status;
	    DB_DT_ID		type;
	    i4			plen;
	    i4			len;
	    PTR			pdata;
	    i2			ps;

	    /* precision must be a const node */
	    if (arg2->pst_sym.pst_type != PST_CONST ||
	           arg2->pst_sym.pst_value.pst_s_cnst.pst_tparmtype != PST_USER)
	    {
		(VOID) psf_error(E_PS0C81_MUST_BE_CONST, 0L, PSF_USERERR,
		    &err_code, err_blk, 0);
		return (E_DB_ERROR);
	    }

	    type  = arg2->pst_sym.pst_dataval.db_datatype;
	    plen  = arg2->pst_sym.pst_dataval.db_length - ((type < 0) ? 1 : 0);
	    pdata = arg2->pst_sym.pst_dataval.db_data;

	    /* must be an i2 with valid precision */
	    if (    abs(type) != DB_INT_TYPE  ||  plen != 2
		||  *(i2 *)pdata < 1  ||  *(i2 *)pdata > DB_MAX_DECPREC)
	    {
		(VOID) psf_error(E_PS0C82_BAD_PRECISION, 0L, PSF_USERERR,
		    &err_code, err_blk, 0);
		return (E_DB_ERROR);
	    }

	    /* check input type and get default scale based on it */
	    type = arg1->pst_sym.pst_dataval.db_datatype;
	    len  = arg1->pst_sym.pst_dataval.db_length - ((type < 0) ? 1 : 0);

	    switch (abs(type))
	    {
		case DB_FLT_TYPE:
		case DB_DEC_TYPE:
		case DB_MNY_TYPE:
		{
		    ps = DB_PS_ENCODE_MACRO(*(i2 *)pdata, AD_FP_TO_DEC_SCALE);
		    break;
		}

		case DB_INT_TYPE:
		{
		    switch (len)
		    {
			case 1:
			    ps = DB_PS_ENCODE_MACRO(*(i2 *)pdata,
				AD_I1_TO_DEC_SCALE);
			    break;
			case 2:
			    ps = DB_PS_ENCODE_MACRO(*(i2 *)pdata,
				AD_I2_TO_DEC_SCALE);
			    break;
			case 4:
			    ps = DB_PS_ENCODE_MACRO(*(i2 *)pdata,
				AD_I4_TO_DEC_SCALE);
			    break;
			case 8:
			    ps = DB_PS_ENCODE_MACRO(*(i2 *)pdata,
				AD_I8_TO_DEC_SCALE);
			    break;
		    }
		    break;
		}

		default:
		{
		    ADI_DT_NAME		dt_name;

		    /* can't default precision/scale for this datatype */
		    status = adi_tyname((ADF_CB *)sess_cb->pss_adfcb, 
					abs(type), &dt_name);

		    (VOID) psf_error(E_PS0C80_NO_DEFLT_ON_DT, 0L, PSF_USERERR,
			&err_code, err_blk, 1,
			psf_trmwhite(sizeof(ADI_DT_NAME), (char *) &dt_name), 
			&dt_name);
		    return (E_DB_ERROR);
		}
	    }

	    /*
	    ** store precision and scale back in const node representing the
	    ** second argument
	    */
	    *(i2 *)pdata = ps;

	    break;
	}
	default:
	{
	    break;
	}
    }
    
    return(E_DB_OK);
}

/*
** Name: psl_3ary_func_extra_proc - perform additional processing for ternary
**				    functions
**
** Description:
**	Verify that the function was DECIMAL() (since this is the only ternary
**	function supported so far), validate precision and scale speicfied by
**	the user, and encode them in the node representing precision (the second
**	argument.)
**
** Input:
**	op_id		    operator id for the function
**	arg2		    node describing the second argument
**	arg3		    node describing the third argument
**
** Output:
**	arg2		    if processing DECIMAL() function, both precision and
**			    scale will be encoded in this node that formerly
**			    contained only the precision
**	err_blk		    filled in if an error occurs
**
** Side effects:
**	may change the value inside the node representing the second argument
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**	06-may-93 (andre)
**	    plagiarized from scalar_function production to get rid of duplicate
**	    code in psl_p_telem()
**	20-Apr-1999 (shero03)
**	    Support PST_MOP (3 & 4 operands)
**	27-Jul-2007 (kiria01) b118856
**	    Check that PST_CONST node is of tparmtype PST_USER before asserting
**	    literal constant and dereferencing the pst_dataval.
*/
static DB_STATUS
psl_3ary_func_extra_proc(
	    i4		    op_id,
	    PST_QNODE	    *arg2,
	    PST_QNODE	    *arg3,
	    DB_ERROR	    *err_blk)
{
    i4	    err_code;
    
    if (op_id == ADI_DEC_OP)
    {
	DB_DT_ID	    type;
	i4		    len;
	PTR		    pdata;
	PTR		    sdata;

	/* 2-nd and 3-rd args must be const nodes */
	if (arg2->pst_sym.pst_type != PST_CONST ||
		arg2->pst_sym.pst_value.pst_s_cnst.pst_tparmtype != PST_USER ||
	    arg3->pst_sym.pst_type != PST_CONST ||
		arg3->pst_sym.pst_value.pst_s_cnst.pst_tparmtype != PST_USER)
	{
	   (VOID) psf_error(E_PS0C81_MUST_BE_CONST, 0L, PSF_USERERR,
		    &err_code, err_blk, 0);
	   return (E_DB_ERROR);
	}

	type = arg2->pst_sym.pst_dataval.db_datatype;
	len =  arg2->pst_sym.pst_dataval.db_length - ((type < 0) ? 1 : 0);
	pdata = arg2->pst_sym.pst_dataval.db_data;

	/* must be an i2 with valid precision */
	if (abs(type) != DB_INT_TYPE || len != 2
	    || *(i2 *)pdata < 1 || *(i2 *)pdata > DB_MAX_DECPREC)
	{
	   (VOID) psf_error(E_PS0C82_BAD_PRECISION, 0L, PSF_USERERR,
		    &err_code, err_blk, 0);
	   return (E_DB_ERROR);
	}

	type  = arg3->pst_sym.pst_dataval.db_datatype;
	len   = arg3->pst_sym.pst_dataval.db_length - ((type < 0) ? 1 : 0);
	sdata = arg3->pst_sym.pst_dataval.db_data;

	/* must be an i2 with valid scale */
	if (   abs(type) != DB_INT_TYPE || len != 2
	    || *(i2 *)sdata < 0 || *(i2 *)sdata > *(i2 *)pdata)
	{
	    (VOID) psf_error(E_PS0C83_BAD_SCALE, 0L, PSF_USERERR,
		    &err_code, err_blk, 1, sizeof(i2), pdata);
	    return (E_DB_ERROR);
	}

	/*
	** combine prec and scale into the node representing the second arg
	*/
	*(i2 *)pdata = DB_PS_ENCODE_MACRO(*(i2 *)pdata, *(i2 *)sdata);
    }
    else if (op_id == ADI_SUBSTRING_OP || op_id == ADI_TABLEINFO_OP)
    {
	i2	opnum = 0;
	/* operand 2 and 3 need to be numeric */
    	if (abs(arg2->pst_sym.pst_dataval.db_datatype) != DB_INT_TYPE)
           opnum = 2;
    	else if (abs(arg3->pst_sym.pst_dataval.db_datatype) != DB_INT_TYPE)
           opnum = 3;
	if (opnum)
	{
	    (VOID) psf_error(E_PS0C91_MUSTBE_NUMERIC, 0L, PSF_USERERR,
		    &err_code, err_blk, 
			(i4) sizeof("SUBSTRING")-1, "SUBSTRING",
			sizeof(i2), opnum);
	    return (E_DB_ERROR);
	}
    }

    /* Allow other 3 parameter functions, including UDTs */
    /* Only decimal() may accept 3 parameters */
    /*    (VOID) psf_error(E_PS0C84_TERNARY_FUNC, 0L, PSF_USERERR, */
    /*	&err_code, err_blk, 0);   */

    return(E_DB_OK);
}

/*
** Name: psl_arg_room - Check for room in func_args for arg pointer
**
** Description:
**
**	Function arg expressions are collected in a stack, $Yfunc_args.
**	The max size of that stack is PSS_YYMAXDEPTH * ADI_MAX_OPERANDS,
**	which might be pretty big especially if someone has increased
**	ADI_MAX_OPERANDS.  Therefore, the parser YY-vars area has room
**	for a stack that will work with most rational queries, and if
**	it runs out, we allocate the big area.  (It would certainly be
**	possible to allocate a medium sized area and work up, but it
**	hardly seems worth the effort.)
**
**	This routine is called before stacking an expression node
**	pointer.  It checks that there is enough room in the stack for N
**	more pointers, and if there isn't, the stack is expanded.
**
** Inputs:
**	cb			PSS_SESBLK * Parser session block
**	psq_cb			PSQ_CB * Query parse control block
**	yyvarsp			Pointer to parser state variables
**	n			Number of args to make room for
**
** Outputs:
**	Returns E_DB_OK or error status
**	Can reallocate $Yfunc_args pointer
**
** History:
**	10-Apr-2006 (kschendel)
**	    Written.
*/

static DB_STATUS
psl_arg_room(PSS_SESBLK *cb, PSQ_CB *psq_cb, PSS_YYVARS *yyvarsp, i4 n)
{

    i4 err_code;
    i4 i;
    i4 newmax;
    i4 psize;
    PST_QNODE **newargs;

    /* arg_ix is used in ix++ mode, it's OK until > max_args */
    if (yyvarsp->arg_ix + n <= yyvarsp->max_args)
	return (E_DB_OK);

    /* Need to make it bigger */

    newmax = PSS_YYMAXDEPTH * ADI_MAX_OPERANDS;
    if (yyvarsp->max_args == newmax)
    {
	i4 lineno = 1;
	(void) psf_error(2800L, 0, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, sizeof(lineno), &lineno);
	return (E_DB_ERROR);
    }

    psize = sizeof(PST_QNODE *) * newmax;
    if (cb->pss_funarg_stream == NULL)
    {
	ULM_RCB ulm;

	/* Open us up a PSF stream for funarg stacking */
	ulm.ulm_facility = DB_PSF_ID;
	ulm.ulm_poolid = Psf_srvblk->psf_poolid;
	ulm.ulm_blocksize = 0;
	ulm.ulm_memleft = &cb->pss_memleft;
	ulm.ulm_streamid_p = &cb->pss_funarg_stream;
	ulm.ulm_psize = psize;
	ulm.ulm_flags = ULM_PRIVATE_STREAM | ULM_OPEN_AND_PALLOC;
	if (ulm_openstream(&ulm) != E_DB_OK)
	{
	    if (ulm.ulm_error.err_code == E_UL0005_NOMEM)
	    {
		(VOID) psf_error(E_PS0F02_MEMORY_FULL, 0L, PSF_CALLERR, 
			&err_code, &psq_cb->psq_error, 0);
	    }
	    else
	    {
		(VOID) psf_error(E_PS0A02_BADALLOC, ulm.ulm_error.err_code,
		    PSF_INTERR, &err_code, &psq_cb->psq_error, 0);
	    }
	    return (E_DB_ERROR);
	}
	newargs = (PST_QNODE **) ulm.ulm_pptr;
    }
    else
    {
	/* Stream is open, ask for more */
	if (psf_umalloc(cb, cb->pss_funarg_stream, psize,
		(PTR *) &newargs, &psq_cb->psq_error) != E_DB_OK)
	    return (E_DB_ERROR);
    }
    /* Copy over existing pointers and clear the remainder */
    MEcopy(yyvarsp->func_args, sizeof(PST_QNODE *) * yyvarsp->max_args,
		newargs);
    MEfill(sizeof(PST_QNODE *) * newmax - sizeof(PST_QNODE *) * yyvarsp->max_args,
	0,
	&newargs[yyvarsp->max_args]);
    yyvarsp->func_args = newargs;
    yyvarsp->max_args = newmax;

    return (E_DB_OK);

} /* psl_arg_room */

/*
** Name: psl_nary_func - Generate tree node for N-ary func(arg,...)
**
** Description:
**
**	This routine is called after parsing a zero-or-more argument
**	function call.  It creates the proper tree node and returns
**	it to the caller.
**
**	The function args are in the yyvarsp->func_args[] array.  After
**	building the function call node, we unstack the function arg
**	indexes in case it was a nested function call.
**
**	The proper tree node for a function call depends on what the
**	function call is, and how many operands it has.  If the
**	function is a set function, we call psl_set_function to handle
**	it.  For normal scalar functions, we create a COP (no args),
**	UOP (unary), BOP (binary), or MOP (n-ary) tree node.  There's
**	one special case, which is the DECIMAL function;  it looks like
**	a ternary function in its general case DECIMAL(expr,p,s) but
**	the p,s part gets squished into a combo precision/scale.  So,
**	DECIMAL generates a BOP even in its 3-operand form.
**
** Inputs:
**	cb		PSS_SESBLK * parser session CB
**	psq_cb		PSQ_CB * query parse control block
**	yyvarsp		PSS_YYVARS * parser state variables
**	func		ADI_OPINFO * function operator info
**	result_ptr	PST_QNODE ** an output
**
** Outputs:
**	result_ptr	Pointer to generated xOP tree node returned here
**	Returns E_DB_OK or error status
**
** History:
**	8-Apr-2006 (kschendel)
**	    Extract from massive nonreswd-func production, generalize to
**	    N-ary functions.  (original parse was hardcoded up to 4 args!)
**	8-may-06 (dougi)
**	    Init pst_right for non-decimal UOPs.
*/

static DB_STATUS
psl_nary_func(PSS_SESBLK *cb, PSQ_CB *psq_cb,
	PSS_YYVARS *yyvarsp, ADI_OPINFO *func, PST_QNODE **result_ptr)

{
    DB_STATUS	status;
    i4		base = yyvarsp->arg_base;  /* For convenience */
    i4		i;
    i4		numargs;
    i4		pst_flags;		/* PSS_NORES or zero */
    i4		pst_type;		/* func node type */
    PST_OP_NODE	opnode;
    PST_QNODE	*dec_node;		/* CONST node for DECIMAL() func */

    dec_node = NULL;
    *result_ptr = NULL;
    numargs = yyvarsp->arg_ix - yyvarsp->arg_base;
    if (func->adi_optype == ADI_AGG_FUNC)
    {
	/* Unary or binary aggregate function, w/o distinct. */
	status = psl_set_function(cb, psq_cb, yyvarsp,
			(char *)&func->adi_opname, PST_NDISTINCT,
			FALSE,
			yyvarsp->func_args[base], yyvarsp->func_args[base+1],
			result_ptr);
	if (status != E_DB_OK)
	    return (status);
	/* Pop off arg base stack */
	if (numargs > 0)
	    MEfill(sizeof(PST_QNODE *) * numargs, 0,
			&yyvarsp->func_args[yyvarsp->arg_base]);
	yyvarsp->arg_ix = yyvarsp->arg_base;
	yyvarsp->arg_base = yyvarsp->arg_stack[--yyvarsp->arg_stack_ix];
	return (E_DB_OK);
    }
    /*
    ** delay arg type resolution if processing target list or a CHECK
    ** constraint specified as a part of CREATE TABLE statement until
    ** we have type info on attributes that may be involved in
    ** expressions passed to the function
    */
    if (numargs > 0 && yyvarsp->in_target_clause
	|| (   cb->pss_stmt_flags & PSS_PARSING_CHECK_CONS
	    && ( ( psq_cb->psq_mode == PSQ_CREATE) || 
		 ( psq_cb->psq_mode == PSQ_ATBL_ADD_COLUMN) ) ) )
    {
	pst_flags = PSS_NORES;
    }
    else
    {
	/* Not delaying type resolution, do extra type checking based on
	** number of function args.
	*/
	pst_flags = 0;
	status = E_DB_OK;
	if (numargs == 1)
	    status = psl_1ary_func_extra_proc(cb, func->adi_opid,
			yyvarsp->func_args[base], &dec_node,
			&psq_cb->psq_error);
	else if (numargs == 2)
	    status = psl_2ary_func_extra_proc(cb, func->adi_opid,
			yyvarsp->func_args[base], yyvarsp->func_args[base+1],
			&psq_cb->psq_error);
	else if (numargs == 3)
	    status = psl_3ary_func_extra_proc(func->adi_opid,
			yyvarsp->func_args[base+1], yyvarsp->func_args[base+2],
			&psq_cb->psq_error);

	if (status != E_DB_OK)
	    return (status);
    }

    /*
    ** Figure out which sort of node we're creating, based on the
    ** number of operands.  1 = UOP, 2 = BOP, 4 or more = MOP.
    ** 3 is screwy because if it's DECIMAL(a,b,c), we combine args
    ** 2 and 3 (prec/scale) and generate a BOP;  otherwise for 3
    ** we generate a MOP.
    */
    switch (numargs)
    {
    case 0:
	pst_type = PST_COP;
	yyvarsp->func_args[base] = (PST_QNODE *) NULL;
	yyvarsp->func_args[base+1] = (PST_QNODE *) NULL;
	break;

    case 1:
	pst_type = PST_UOP;
	if (dec_node != NULL)
	{
	    pst_type = PST_BOP;
	    yyvarsp->func_args[base+1] = dec_node;
	}
	else yyvarsp->func_args[base+1] = (PST_QNODE *) NULL;
	break;

    case 2:
	pst_type = PST_BOP;
	break;

    case 3:
	/* Decimal screwyness here -- DECIMAL(exp, p, s) ends up being a
	** BOP, because p and s have to be constant and we squish them into
	** one prec/scale value.  If we aren't resolving types yet, put
	** p and s into a temp CONST node, later call to 3ary_func_extra
	** will type-check things and remove the CONST.
	*/
	if (func->adi_opid == ADI_DEC_OP)
	{
	    if (pst_flags == PSS_NORES)
	    {
		PST_QNODE *dummy;

		status = psf_malloc(cb, &cb->pss_ostream, sizeof(PST_QNODE),
		    (PTR *) &dummy, &psq_cb->psq_error);
		if (status != E_DB_OK)
		    return (status);

		dummy->pst_sym.pst_type = PST_CONST;
		dummy->pst_left = yyvarsp->func_args[base+1];
		dummy->pst_right = yyvarsp->func_args[base+2];
		yyvarsp->func_args[base+1] = dummy;
	    }
	    pst_type = PST_BOP;
	    break;
	}
	/* else fall thru into MOP situation */
    default:
	/* For N-ary functions, we form a chain of PST_OPERAND nodes
	** linked thru pst_left, starting with the 2nd arg.  We'll
	** ultimately create a PST_MOP pointing to the first arg and to
	** the operand chain.
	*/
	{
	    PST_QNODE *first_op_node;
	    PST_QNODE *op_node;
	    PST_QNODE *prev_node;

	    for (i = 1; i < numargs; ++i)
	    {
		status = psl_mfunc_param(psq_cb, cb,
				yyvarsp->func_args[base+i], &op_node);
		if (status != E_DB_OK)
		    return (status);
		if (i == 1)
		    first_op_node = op_node;
		else
		    prev_node->pst_left = op_node;
		prev_node = op_node;
	    }
	    /* Nothing is ever easy.  For whatever reason, all the "real"
	    ** arg expr's have to be on right links.  So, we have to put
	    ** the PST_OPERAND chain just created on the left of the MOP.
	    ** Which means that we have to hook the chain where arg[0]
	    ** normally goes, putting the real arg[0] on the right of
	    ** the MOP, in the normal arg1 position.  Faugh!
	    */
	    yyvarsp->func_args[base+1] = yyvarsp->func_args[base];
	    yyvarsp->func_args[base] = first_op_node;
	    pst_type = PST_MOP;
	}
    } /* switch */

    opnode.pst_opno = func->adi_opid;
    opnode.pst_opmeta = PST_NOMETA;
    opnode.pst_isescape = PST_DOESNT_APPLY;
    status = pst_node(cb, &cb->pss_ostream,
		yyvarsp->func_args[base], yyvarsp->func_args[base+1],
		pst_type,
		(char *) &opnode, sizeof(opnode),
		DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
		result_ptr, &psq_cb->psq_error,
		pst_flags);
    if (status != E_DB_OK)
	return (status);

    if ((*result_ptr)->pst_sym.pst_type != PST_CONST
      && BTtest(yyvarsp->qual_depth, yyvarsp->qual_type))
    {
	/*
	** If we are processing a join_search condition, set the joinid
	** field appropriately.  It has been initialized to PST_NOJOIN in
	** pst_node().
	*/
	(*result_ptr)->pst_sym.pst_value.pst_s_op.pst_joinid =
		yyvarsp->pss_join_info.pss_join[yyvarsp->pss_join_info.depth].join_id;
    }
    if ( (cb->pss_distrib & DB_3_DDB_SESS) && numargs <= 1)
    {
	/* Dbmsinfo() & some constant funcs are evaluated to constants */
	status = psl_proc_func(cb, func->adi_opid, yyvarsp->func_args[base],
		result_ptr, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
    }
    /* Pop off arg base stack */
    if (numargs > 0)
	MEfill(sizeof(PST_QNODE *) * numargs, 0,
			&yyvarsp->func_args[yyvarsp->arg_base]);
    yyvarsp->arg_ix = yyvarsp->arg_base;
    yyvarsp->arg_base = yyvarsp->arg_stack[--yyvarsp->arg_stack_ix];

    return (E_DB_OK);

} /* psl_nary_func */

/*
** Name:    psl_must_be_string - verify that the specified value is of
**				 "character string" datatype
**
** Description:
**	This function will be called to verify that a value specified using a
**	language variable is of "character string" datatype.
**
** Input:
**	sess_cb		    PSF session CB
**	    pss_adfcb	    ADF cb
**	in_val		    DB_DATA_VALUE whose type needs validating
**	    db_datatype	    data type to validate
**
** Output:
**	err_blk		    filled in if the datatype a char string datatype
**
** Returns:
**	E_DB_{OK,ERROR}
**	
** Side effects:
**	none
**
** History:
**	26-may-93 (andre)
**	    written
*/
DB_STATUS
psl_must_be_string(
	PSS_SESBLK	*sess_cb,
	DB_DATA_VALUE	*in_val,
	DB_ERROR	*err_blk)
{
    DB_DT_ID	    in_type = abs(in_val->db_datatype);
    
    switch (in_type)
    {
	case DB_CHR_TYPE:
	case DB_TXT_TYPE:
	case DB_CHA_TYPE:
	case DB_VCH_TYPE:
	case DB_LTXT_TYPE:
	{
	    return(E_DB_OK);
	}
	
	default:
	{
	    /* bad datatype - report an error */
	    ADI_DT_NAME     type_name;
	    i4	    err_code;

	    STmove("<none>", ' ', sizeof (ADI_DT_NAME),
		(char *) &type_name);

	    (VOID) adi_tyname((ADF_CB *) sess_cb->pss_adfcb, in_type,
		&type_name);

	    (void) psf_error(2904L, 0L, PSF_USERERR, &err_code, err_blk, 1,
		psf_trmwhite(sizeof(ADI_DT_NAME), (char *) &type_name),
		&type_name);

	    return(E_DB_ERROR);
	}
    }
}

/*
** Name: psl_bld_col_spec_grant_template - build template for column specific
**					   GRANT statement
**
** Description:
**	This function will build a template for column-specific GRANT template
**	using bits of information found in psy_cb and text put together by the 
**	caller
**
** Input:
**	txt_chain		text chain used to build a template
**	priv_str		NULL-terminated string describing privilege
**	cols_excluded		TRUE if the privilege is being granted on a 
**				table except for some columns; FALSE otherwise
**	colq			list of column descriptions
**
** Output:
**	err_blk			filled in if an error occurs
**
** Side-effects:
**	memory will be allocated
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
** 	17-aug-93 (andre)
**	    written   
*/
static DB_STATUS
psl_bld_col_spec_grant_template(
	PTR		txt_chain,
	char		*priv_str,
	bool		cols_excluded,
	PSF_QUEUE	*colq,
	DB_ERROR	*err_blk)
{
    char	*str;
    i4		str_len;
    DB_STATUS	status;
    PTR		piece;
    PSY_COL	*psy_col;
    bool	needcomma;

    status = psq_tadd(txt_chain, (u_char *) (ERx("grant ")),
	sizeof(ERx("grant ")) - 1, &piece, err_blk);
    if (DB_FAILURE_MACRO(status))
	return(status);
    
    status = psq_tadd(txt_chain, (u_char *) priv_str,
	STlength(priv_str), &piece, err_blk);
    if (DB_FAILURE_MACRO(status))
	return(status);
    
    if (cols_excluded)
    {
	str = ERx(" excluding (");
	str_len = sizeof(ERx(" excluding (")) - 1;
    }
    else
    {
	str = ERx(" (");
	str_len = sizeof(ERx(" (")) - 1;
    }

    status = psq_tadd(txt_chain, (u_char *) str, str_len, &piece, err_blk);
    if (DB_FAILURE_MACRO(status))
	return(status);

    for (psy_col = (PSY_COL *) colq->q_next, needcomma = FALSE;
	 psy_col != (PSY_COL *) colq;
	 psy_col = (PSY_COL *) psy_col->queue.q_next
	)
    {
	u_char		*col_name;
	i4		col_nm_len;
	u_char		delim_col_name[DB_MAX_DELIMID];

	if (needcomma)
	{
	    status = psq_tadd(txt_chain, (u_char *) ERx(", "),
		sizeof(ERx(", ")) - 1, &piece, err_blk);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}
	else
	{
	    needcomma = TRUE;
	}

	/*
	** if the user specified column name using a delimited 
	** identifier, we need to invoke psl_reg_id_2_delim_id() to translate 
	** column name back into a delimited identifier; otherwise we 
	** just append it as is
	*/
	col_name = (u_char *) &psy_col->psy_colnm;
	col_nm_len = psf_trmwhite(sizeof(psy_col->psy_colnm),
	    (char *) col_name);

	if (~psy_col->psy_col_flags & PSY_REGID_COLSPEC)
	{
	    status = psl_norm_id_2_delim_id(&col_name, &col_nm_len, 
		delim_col_name, err_blk);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}

	status = psq_tadd(txt_chain, col_name, col_nm_len, &piece, err_blk);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }

    status = psq_tadd(txt_chain, (u_char *) ERx(")"),
	sizeof(ERx(")")) - 1, &piece, err_blk);

    return (status);
}

/*
** Name: psl_norm_id_2_delim_id - convert normalized identifier to a delimited 
**				  identifier
**
** Description:
**	Given address of a normalized identifier, this function will invoke
**	cui_idunorm() to unnormalize it and return pointer to and length of 
**	the resulting delimited identifier
**
** Input:
**	ident		address of a pointer to a normalized identifier
**	ident_len	length of normalized identifier
**	delim_id_buf	buffer to be used for the delimited identifier
**
** Output:
**	ident		address of a pointer to a delimited identifier
**			contained inside delim_id_buf
**	ident_len	length of delimited identifier contained inside 
**			delim_id_buf
**	err_blk		filled in if an error is encountered
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**	17-aug-93 (andre)
**	    written
*/
DB_STATUS
psl_norm_id_2_delim_id(
		u_char		**ident,
		i4		*ident_len,
		u_char		*delim_id_buf,
		DB_ERROR	*err_blk)
{
    u_i4	delim_id_len = DB_MAX_DELIMID;
    u_i4       chars_read = (u_i4) *ident_len;
    DB_STATUS	status;

    status = cui_idunorm(*ident, &chars_read, delim_id_buf, &delim_id_len, 
	(u_i4) (CUI_ID_DLM | CUI_ID_STRIP), err_blk);
    if (DB_FAILURE_MACRO(status))
    {
	i4		err_code;

	(VOID) psf_error(err_blk->err_code, 0L, 
			 PSF_INTERR, &err_code, err_blk, 2,
			 (i4)(sizeof(ERx("Normalized identifier")) - 1),
			 (PTR) (ERx("Normalized identifier")),
			 (i4) chars_read, (PTR) *ident);
	return(status);
    }

    *ident = delim_id_buf;
    *ident_len = (i4) delim_id_len;
	
    return(E_DB_OK);
}  /* end psl_norm_id_2_delim_id */

/*
** Name: psl_remove_single_quotes - remove single-quoted identifiers from
** 				    a text chain (i.e. from query text);
**				    replace them with a delimited identifier
**
** Description:
**	Removes single-quotes from an identifier, replacing them with
**	double-quotes. 
**	
**	Given the address of a string constant returned from the scanner,
**	this function finds the piece of the text chain containing the string
**	constant (in this case it's actually a single-quoted identifier),
**	and replaces that piece with the delimited identifier version of the
**	string.
**
**	(At some point in the future, we may want to change this to strip the
**	single quotes and only replace them with delimiters if the identifier
**	NEEDS to be delimited.)
**	
**	The expected use of this function is for removing single-quotes from
**	identifiers in query text stored in the catalogs for statements like
**	CREATE PROCEDURE and CREATE VIEW.  In 6.5, we no longer want any
**	single-quoted identifiers stored in the query text catalog, because we
**	are deprecating single-quoted identifiers for most statements and will
**	remove support for them in 6.6 (if possible).
**
** Input:
**	text_chain	pointer to the head of the text chain
**	identifier	pointer to SCONST identifier returned from scanner
**
** Output:
**	text_chain	modified to contain a delimited identifier for
**			<identifier> instead of a single-quoted identifier
**	err_blk		filled in if an error is encountered
**
** Returns:
**	E_DB_{OK,ERROR}
**
** Side effects:
**	none
**
** History:
**	27-oct-93 (rblumer)
**	    written
*/
static DB_STATUS
psl_remove_single_quotes(
			  char	*text_chain,
			  char	*identifier,	/* normalized identifier from
						** scanner */
			  DB_ERROR *err_blk)
{
    DB_STATUS	status;
    u_char	delim_id[DB_MAX_DELIMID];
    i4		id_len;
    PTR		newpiece, *oldpieceptr;
    
#ifdef BYTE_ALIGN
    PTR             align_ptr;
#else
#undef   align_ptr
#define  align_ptr  (*oldpieceptr)
#endif

    /* The pointer to the piece of the text chain holding the single-quoted
    ** identifier is stored after the string constant by the scanner.
    ** 
    ** Since the quoted identifier is returned as an SCONST (string constant),
    ** it is stored in a DB_TEXT_STRING & we need to add DB_CNTSIZE to its
    ** length in order to find the piece ptr.
    ** (Note that <identifier> no longer points to a DB_TEXT_STRING, since
    **  sconvert() has been run on it; <identifier> points to the beginning
    **  of a null-terminated string that is in the same memory space as the
    **  original DB_TEXT_STRING.  Which is why STlength + DB_CNT_SIZE works!)
    */
    oldpieceptr = (PTR *) (identifier + STlength(identifier) + DB_CNTSIZE);

#ifdef BYTE_ALIGN
    MECOPY_CONST_MACRO((PTR)oldpieceptr, sizeof(PTR),
		       (PTR)&align_ptr);
#endif

    /* convert identifier to delimited identifier
    ** (identifier pointer gets overwritten, but not the identifier itself)
    */
    id_len = STlength(identifier);

    status = psl_norm_id_2_delim_id((u_char **) &identifier, &id_len, 
				    delim_id, err_blk);
    if (DB_FAILURE_MACRO(status))
	    return(status);

    /* Add a space first, to separate delimited id from previous keyword
    ** (since align_ptr may point to a name with preceding blanks, and
    **  <identifier> has no preceding blanks).
    */
    status = psq_tinsert(text_chain, (u_char *) ERx(" "), sizeof(ERx(" ")) - 1,
			 &newpiece, align_ptr, err_blk);
    if (DB_FAILURE_MACRO(status))
	return (status);

    /* replace single-quoted id with delimited id name
     */
    status = psq_tsubs(text_chain, align_ptr, (u_char *) identifier, id_len,
		       &newpiece, err_blk);
    return (status);

} /* end psl_replace_single_quotes */

/*
** Name: psl_prepend_schemaname - add the owner/schema name to query text 
** 				  in order to qualify an object reference
**
** Description:
**	Adds the qualifier 'schema.' to a tablename, in order to have a
**	fully-qualified table reference of form 'schema.tablename' in the query
**	text.  This is necessary in order to allow VIEWS and PROCEDURES to be
**	recreated with the same tables, even if tables with the same name are
**	added to the schema later.  (Note: the 'table' above could also be a
**	view or a synonym.)
**
**	The schema name is always converted to a delimited identifier before
**	being added to the text, since we don't know if the identifier really
**	needs to be delimited or not.  Since the username is already
**	case-translated when we get it, and DELIM_ID_CASE has to be either be
**	mixed (untranslated) or the same as REG_ID_CASE, this will never cause
**	case-translation problems when recreating the procedure.
**	
**	Given the address of a string constant returned from the scanner,
**	this function finds the piece of the text chain containing the string
**	constant and inserts 'schema.' before that piece of the chain.
**
**	(At some point in the future, we may want to change this to strip the
**	single quotes and only replace them with delimiters if the identifier
**	NEEDS to be delimited.)
**	
** Input:
**	text_chain	pointer to the head of the text chain
**	obj_name	pointer to orig_obj_name returned from scanner
**	schema_name	pointer to schema/owner name to be added
**
** Output:
**	text_chain	modified to contain a delimited identifier for
**			<identifier> instead of a single-quoted identifier
**	err_blk		filled in if an error is encountered
**
** Returns:
**	E_DB_{OK,ERROR}
**
** Side effects:
**	none
**
** History:
**	29-oct-93 (rblumer)
**	    written
*/
static DB_STATUS
psl_prepend_schemaname(
		     char	*text_chain,
		     char	*obj_name,
		     u_char	*schema_name,
		     DB_ERROR	*err_blk)
{
    DB_STATUS	status;
    u_char	delim_id[DB_MAX_DELIMID];
    i4		schema_len;
    PTR		newpiece, *oldpieceptr;
    
#ifdef BYTE_ALIGN
    PTR             align_ptr;
#else
#undef   align_ptr
#define  align_ptr  (*oldpieceptr)
#endif

    /* The pointer to the piece of the text chain holding the 
    ** identifier is stored after the string by the scanner.
    ** Note that we have to account for the null terminator.
    */
    oldpieceptr = (PTR *) (obj_name + STlength(obj_name) + 1);

#ifdef BYTE_ALIGN
    MECOPY_CONST_MACRO((PTR)oldpieceptr, sizeof(PTR),
		       (PTR)&align_ptr);
#endif

    /* convert schema name to a delimited identifier
    ** (schema_name pointer gets overwritten)
    */
    schema_len = psf_trmwhite(DB_MAXNAME, (char *) schema_name);

    status = psl_norm_id_2_delim_id((u_char **) &schema_name, &schema_len, 
				    delim_id, err_blk);
    if (DB_FAILURE_MACRO(status))
	    return(status);

    /* Add a space first,
    ** to separate delimited id from previous keyword
    */
    status = psq_tinsert(text_chain, (u_char *) ERx(" "), sizeof(ERx(" ")) - 1,
			 &newpiece, align_ptr, err_blk);
    if (DB_FAILURE_MACRO(status))
	return (status);

    /* Add delimited schema/owner name
     */
    status = psq_tinsert(text_chain, schema_name, schema_len,
			 &newpiece, align_ptr, err_blk);
    if (DB_FAILURE_MACRO(status))
	return (status);

    /* Add a PERIOD */
    status = psq_tinsert(text_chain, (u_char *) ERx("."), sizeof(ERx(".")) - 1,
			 &newpiece, align_ptr, err_blk);
    return (status);

} /* end psl_prepend_schemaname */

/*
** Name: psl_seqop_search: - check a parse tree fragment for presence of 
**				sequence operators.
**
** Description:
**	Descends a parse tree fragment searching for PST_SEQOP nodes. This
**	is done to disallow queries with sequence operators in invalid 
**	contexts (such as case expressions and aggregate functions).
**
** Input:
**	nodep		pointer to parse tree fragment being searched
**
** Output:
**
** Returns:
**	TRUE	- sequence operator was found
**	FALSE	- sequence operator was not found
**
** Side effects:
**	none
**
** History:
**	9-apr-02 (inkdo01) 
**	    Written for sequence support.
*/
static bool
psl_seqop_search(
	PST_QNODE	*nodep)

{
    /* This function trivially decends a parse tree fragment looking for 
    ** PST_SEQOP nodes. */

    if (nodep == (PST_QNODE *) NULL)
	return(FALSE);		/* check for no expression at all */

    switch (nodep->pst_sym.pst_type) {
      case PST_SEQOP:
	return(TRUE);		/* got one - return TRUE */

      default:
	/* For all the rest, just keep descending. */
	if (nodep->pst_left && psl_seqop_search(nodep->pst_left))
	    return(TRUE);	/* found one somewhere on left */
	if (nodep->pst_right && psl_seqop_search(nodep->pst_right))
	    return(TRUE);	/* found one somewhere on right */

	else return(FALSE);	/* nuttin' dere */
    }

}

/*
** Name: psl_validate_collation_name - verify a collation name specified 
**	in a column definition (or later, in a order by, group by).
**
** Description:
**	Loops over a list of known collation names searching for specified 
**	value. Later it will have to search iicollation catalog.
**
** Input:
**	collname	pointer to collation name token value
**	collID		pointer to collID value to return to caller
**
** Output:
**
** Returns:
**	TRUE	- collation name is valid
**	FALSE	- collation name is not valid
**
** Side effects:
**	none
**
** History:
**	13-dec-04 (inkdo01)
**	    Written for column level collation support.
*/
static bool
psl_validate_collation_name(
	char		*collname,
	i4		*collID)

{
    char	cname[DB_MAXNAME];
    char	*letter;
    i4		i;

    /* Copy collation name to local memory and turn it to lower case. */
    STcopy(collname, cname);
    for (letter = &cname[0]; *letter != EOS; CMnext(letter))
	CMtolower(letter, letter);

    /* Loop over valid collation name array looking for match. */
    *collID = -1;		/* init */
    for (i = 0; i < VALID_COLLATION_COUNT; i++)
	if (STcompare(&cname[0], collname_array[i]) == 0)
	    break;

    if (i < VALID_COLLATION_COUNT)
	*collID = i+1;

    return((*collID >= 0) ? TRUE : FALSE);
}

/*
** Name: psl_validate_collation_mix - verify that binary operation 
**	doesn't involve incompatible collations
**
** Description:
**	non-explicit collation and explicit collation are ok, as are
**	Explicitly declared unicode and unicode_case_insensitive. But 
**	the rest are verboten.
**
** Input:
**	collID1		operand1 collation ID
**	collID2		operand2 collation ID
**
** Output:
**
** Returns:
**	TRUE	- operation is valid
**	FALSE	- operation is NOT valid
**
** Side effects:
**	none
**
** History:
**	30-dec-04 (inkdo01)
**	    Written for column level collation support.
*/
static bool
psl_validate_collation_mix(
	i2	collID1,
	i2	collID2)

{

    /* Not much to it - just check for mixed non-default collations. */

    if (collID1 > 0 && collID2 > 0 && collID1 != collID2 && 
	!((collID1 == DB_UNICODE_COLL ||
	collID1 == DB_UNICODE_CASEINSENSITIVE_COLL) && 
	(collID2 == DB_UNICODE_COLL || collID2 == DB_UNICODE_CASEINSENSITIVE_COLL)))
	return(FALSE);

    return(TRUE);
}

/*
** Name: psl_collation_check - verify that collation ID is appropriate.
**
** Description:
**	Checks that data type is string and that collation ID is valid
**	for the type.
**
** Input:
**	cb
**	dv		ptr to DB_DATA_VALUE to validate
**	collID		collation ID to validate
**
** Output:
**
** Returns:
**
** Side effects:
**	none
**
** History:
**	1-feb-06 (dougi)
**	    Written to allow cast functions with collation ID.
*/
static DB_STATUS
psl_collation_check(
	PSQ_CB		*psq_cb,
	PSS_SESBLK	*cb,
	DB_DATA_VALUE	*dv,
	i2		collID)
{
    i4		err_code;
    DB_DT_ID	dtype = dv->db_datatype;

    /* Do collation checks - first assure that collation is
    ** applicable for data type, then assure that column level
    ** collation is supported for defined collation. */
    if (!(((dtype == DB_NCHR_TYPE || dtype == DB_NVCHR_TYPE) &&
	    collID <= 2) || (collID > 2 &&
	    (dtype == DB_CHA_TYPE || dtype == DB_CHR_TYPE ||
	     dtype == DB_VCH_TYPE || dtype == DB_TXT_TYPE))))
    {
	i2	tcode;

	tcode = (collID <= 2) ? 0 : 1;
	(VOID) psf_error(6426L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		STlength(collname_array[collID-1]),
		collname_array[collID-1],
		STlength(type_array[tcode]), type_array[tcode]);
	return (E_DB_ERROR);
    }

    if (collID > 3)
    {
	(VOID) psf_error(6425L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		STlength(collname_array[collID-1]),
		collname_array[collID-1]);
	return (E_DB_ERROR);
    }

    return(E_DB_OK);
}


/*
** Name: psl_push_yyvars - allocate fresh YYVARS and push previous.
**
** Description:
**	When subselect is encountered in FROM clause (and possibly in 
**	other non-WHERE clause contexts), allocate fresh YYVARS, push old
**	one and effectively recurse the YACC locals.
**
** Input:
**	psq_cb		ptr to parser control block
**	cb		ptr to PSF session control block
**	yyvpp		ptr to ptr to YACC locals
**
** Output:
**	yyvpp		ptr to ptr to fresh copy of YACC locals
**
** Returns:
**	status		status of function
**
** Side effects:
**	none
**
** History:
**	24-jan-06 (dougi)
**	    Written for subselect in FROM clause support.
*/
static DB_STATUS
psl_push_yyvars(
	PSQ_CB		*psq_cb,
	PSS_SESBLK	*cb,
	PSS_YYVARS	**yyvpp)

{
    DB_STATUS	status = E_DB_OK;

    /* Just include yyvarsinit.h to initialize local instance of 
    ** PSS_YYVARS, then allocate fresh copy and copy it over. */

#define YYVARS	PSS_YYVARS	/* stupid YACC! */
#include <yyvarsinit.h>

    /* Local yyvars has been initialized. Save parent into it, allocate
    ** fresh one, then copy local into allocated storage. */

    yyvars.prev_yyvarsp = *yyvpp;
    yyvars.join_id = yyvars.prev_yyvarsp->join_id; /* join_id persists */

    /* Open memory stream for allocating query tree, if not already
    ** open
    */
    if (!cb->pss_ostream.psf_mstream.qso_handle &&
	(status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
	&psq_cb->psq_error)) != E_DB_OK)
    {
        return (status);    /* non-zero return means error */
    }

    status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PSS_YYVARS),
				yyvpp, &psq_cb->psq_error);
    if (DB_FAILURE_MACRO(status))
    {
	*yyvpp = yyvars.prev_yyvarsp;
	return(status);
    }

    /* Now copy it over. */
    MEcopy((char *)&yyvars, sizeof(PSS_YYVARS), (char *)*yyvpp);
    QUinit((QUEUE *)&(*yyvpp)->dcol_list);
    return(E_DB_OK);

}


/*
** Name: psl_groupingsets_fromcr - generate PST_GSET from cube/rollup
**
** Description:
**	There can only be one CUBE/ROLLUP optimally processed in a single
**	GROUPING SETS. If a GROUP BY has more than one, the subsequent ones
**	must be expanded into their corresponding GROUPING SETS.
**
** Input:
**	cb		ptr to PSF session control block
**	psq_cb		ptr to parser control block
**	crtype		indicator of whether this is CUBE or ROLLUP
**	listp		ptr to chain of entries in CUBE/ROLLUP
**	newnodep	ptr to ptr to PST_GSET structure to be returned
**
** Output:
**	newnodep	ptr to ptr to PST_GSET returned by expansion
**
** Returns:
**	status		status of function
**
** Side effects:
**	none
**
** History:
**	5-apr-06 (dougi)
**	    Written for GROUP BY enhancements.
*/
static DB_STATUS
psl_groupingsets_fromcr(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	i4		crtype,
	PST_QNODE	*listp,
	PST_QNODE	**newnodep)

{
    PST_QNODE	*nodep, *prevgcl;
    PSS_DUPRB	dup_rb;
    i4		i, j, k;
    DB_STATUS	status;


    /* Create PST_GSET node and fill it in with expanded ROLLUP or 
    ** CUBE (different algorithm is used for each). */

    /* Init. the pst_treedup() parameter. */
    dup_rb.pss_op_mask	= 0;
    dup_rb.pss_num_joins = PST_NOJOIN;
    dup_rb.pss_tree_info = (i4 *) NULL;
    dup_rb.pss_mstream = &cb->pss_ostream;
    dup_rb.pss_1ptr	= NULL;
    dup_rb.pss_err_blk	= &psq_cb->psq_error;

    /* CUBE and ROLLUP both have empty grouping set. */
    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			(PST_QNODE *) NULL, PST_GCL, (PTR) NULL, 0, 
			DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
			&prevgcl, &psq_cb->psq_error, 0);
    if (DB_FAILURE_MACRO(status))
	return(status);

    /* Allocate the PST_GSET and start by attaching the empty GCL. */
    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			prevgcl, PST_GSET, (PTR) NULL, 0, 
			DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
			newnodep, &psq_cb->psq_error, 0);
    if (DB_FAILURE_MACRO(status))
	return(status);

    for (i = 0, nodep = listp; 
		nodep && nodep->pst_sym.pst_type != PST_TREE; 
		i++, nodep = nodep->pst_left);	/* count list entries */

    if (crtype == PST_GROUP_ROLLUP)
    {
	/* For ROLLUP, just take 1st 1, 2, 3, ... entries in listp and
	** make successive PST_GCLs from them. */
	for (j = 1; j <= i; j++)
	{
	    /* Allocate PST_GCL to contain next set of entries. */
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			(PST_QNODE *) NULL, PST_GCL, (PTR) NULL, 0, 
			DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
			&prevgcl->pst_left, &psq_cb->psq_error, 0);
	    if (DB_FAILURE_MACRO(status))
		return(status);

	    prevgcl = prevgcl->pst_left;
	    if (j == i)
	    {
		/* For last entry, stick in whole list of entries. */
		prevgcl->pst_right = listp;
		return(E_DB_OK);	/* and we're done */
	    }

	    /* Position nodep at nth entry in ROLLUP list in preparation
	    ** for copy. */
	    for (k = 0, nodep = listp; k < j; k++, nodep = nodep->pst_left);
	    dup_rb.pss_tree = nodep;
	    dup_rb.pss_dup = &prevgcl->pst_right;

	    status = pst_treedup(cb, &dup_rb);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}
	return(E_DB_OK);
    }

    /* Now do CUBE expansion. This is trickier. We compute 2**i-1 (the
    ** number of grouping sets that a CUBE expands to). Then loop from 
    ** 1 to the value - each loop corresponds to a grouping and the grouping
    ** contains the list entries whose positions correspond to the set 
    ** bits in the loop control variable. E.g. the value of 5 corresponds
    ** to the grouping set with the 1st and 3rd entries of the cube list. */


}


/*
** Name: psl_groupingsets_normalize - check GROUP BY for grouping sets and
**	flatten them
**
** Description:
**	If a GROUP BY has multiple elements and at least one is a 
**	GROUPING SETS subclause, the gb must be transformed into a chain
**	of grouping sets that are the polynomial product of the 
**	original entries.
**	E.g. GROUP BY a, b, GROUPING SETS (c, d) becomes:
**	GROUP BY GROUPING SETS ((a, b, c), (a, b, d))
**
** Input:
**	cb		ptr to PSF session control block
**	psq_cb		ptr to parser control block
**	rootp		ptr to ptr to root node of GROUP BY list
**
** Output:
**	rootpp		ptr to ptr to updated GROUP BY list
**
** Returns:
**	status		status of function
**
** Side effects:
**	none
**
** History:
**	31-mar-06 (dougi)
**	    Written for GROUP BY enhancements.
*/
static DB_STATUS
psl_groupingsets_normalize(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PST_QNODE	**rootp)

{
    DB_STATUS	status = E_DB_OK;
    PST_QNODE	*nodep, *prevp, *np1, *np2, *newgs;
    i4		i;

    bool	gotone, alldone = FALSE, notfirst = FALSE;


    /* Start by looking for PST_GSETs in the BY list. If none, there's
    ** nothing else to do but set the pst_rsno values. If there is
    ** one, and at least one other BY list entry, allocate an outer
    ** PST_GSET to anchor whole BY list and loop 'til the expansions
    ** are done. */

    for (nodep = *rootp, gotone = FALSE, i = 0; 
		nodep && nodep->pst_sym.pst_type != PST_TREE &&
				(!gotone || i <= 1);
		i++, nodep = nodep->pst_left)
     if (nodep->pst_sym.pst_type == PST_GSET)
	gotone = TRUE;

    if (i > 1 && gotone)
    {
	/* We need to expand. First allocate a PST_GSET to anchor 
	** the new list of PST_GSETs. */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			*rootp, PST_GSET, (PTR) NULL, 0, 
			DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
			rootp, &psq_cb->psq_error, 0);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/* Next, loop over evolving BY list until there are no more
	** expansions to do. */
	do {
	    status = psl_groupingsets_expand(cb, psq_cb, rootp, &alldone);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	} while(!alldone);

	/* Then loop over all of them, looking for PST_GCLs to collapse. */
	for (nodep = *rootp; nodep; nodep = nodep->pst_left)
	 for (np1 = nodep->pst_right, prevp = NULL; np1;
			prevp = np1, np1 = np1->pst_left)
	  if (np1->pst_sym.pst_type == PST_GCL && np1->pst_right)
	  {
	    /* Got a PST_GCL. Drop the PST_GCL node and absorb the rest. */
	    if (prevp == (PST_QNODE *) NULL)
		nodep->pst_right = np1->pst_right;
	    else prevp->pst_left = np1->pst_right;

	    for (np2 = np1->pst_right; np2->pst_left; np2 = np2->pst_left);
					/* skip to end of GCL chain */
	    np2->pst_left = np1->pst_left;
	    np1 = np2;			/* reset for for-loop */
	  }

    }
    else if (gotone)
    {
	/* GROUP BY has one entry - a GROUPING SETS clause. Each 
	** entry in the list now requires a PST_GSET. */
	for (nodep = (*rootp)->pst_right, prevp = *rootp; 
		nodep && nodep->pst_sym.pst_type != PST_TREE;
		prevp = newgs, np1 = nodep, nodep = nodep->pst_left, 
				np1->pst_left = (PST_QNODE *) NULL)
	{
	    /* Allocate a PST_GSET for each entry and unstring them.
	    ** Notice that the first entry is left attached to the 
	    ** original PST_GSET. */
	    if (notfirst)
	    {
		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			nodep, PST_GSET, (PTR) NULL, 0, 
			DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
			&newgs, &psq_cb->psq_error, 0);
		if (DB_FAILURE_MACRO(status))
		    return(status);

		prevp->pst_left = newgs;
	    }
	    else newgs = *rootp;

	    notfirst = TRUE;

	    if (nodep->pst_sym.pst_type == PST_GCL &&
		nodep->pst_right != (PST_QNODE *) NULL)
	    {
		/* flatten non-empty GCLs into containing GSET. */
		newgs->pst_right = nodep->pst_right;
	    }
	}
    }
	

    /* Now, pass over the <group by> to assign ascending resdom nos
    ** and attach PST_TREE nodes where necessary. */
    for (nodep = *rootp; nodep; nodep = nodep->pst_left)
    {
	i4		rsdmno = 0;

	/* If there's a bunch of PST_GSETs, each must be tidied separately.
	** Otherwise, just tidy the whole list at once. */
	status = psl_groupingsets_tidy(cb, psq_cb, 
	    (nodep->pst_sym.pst_type == PST_GSET) ? nodep->pst_right : nodep, 
	    &rsdmno);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	if (nodep->pst_sym.pst_type != PST_GSET)
	    break;
    }

    return(E_DB_OK);
}


/*
** Name: psl_groupingsets_expand - replicates chunks of the GROUP BY to
**	expand the contained GROUPING SETS.
**
** Description:
**	If a GROUP BY has multiple elements and at least one is a 
**	GROUPING SETS subclause, the gb must be transformed into a chain
**	of grouping sets that are the polynomial product of the 
**	original entries.
**	E.g. GROUP BY a, b, GROUPING SETS (c, d) becomes:
**	GROUP BY GROUPING SETS ((a, b, c), (a, b, d))
**
** Input:
**	cb		ptr to PSF session control block
**	psq_cb		ptr to parser control block
**	rootpp		ptr to ptr to root node of GROUP BY list
**	alldonep	ptr to bool returning indication of completion
**			of expansion process
**
** Output:
**	rootpp		ptr to ptr to updated GROUP BY list
**
** Returns:
**	status		status of function
**
** Side effects:
**	none
**
** History:
**	31-mar-06 (dougi)
**	    Written for GROUP BY enhancements.
*/
static DB_STATUS
psl_groupingsets_expand(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PST_QNODE	**rootp,
	bool		*alldonep) 

{
    DB_STATUS	status = E_DB_OK;
    PST_QNODE	*np1, *np2, *np3, *newgs, *prevgs, *prev2, *xroot;
    PST_QNODE	*nodep, *outerp, *pouterp;
    PSS_DUPRB	dup_rb;
    i4		i, j;


    /* Init. the pst_treedup() parameter. */
    dup_rb.pss_op_mask	= 0;
    dup_rb.pss_num_joins = PST_NOJOIN;
    dup_rb.pss_tree_info = (i4 *) NULL;
    dup_rb.pss_mstream = &cb->pss_ostream;
    dup_rb.pss_1ptr	= NULL;
    dup_rb.pss_err_blk	= &psq_cb->psq_error;

    /* Look for the first BY list element with an embedded PST_GSET. */

    for (outerp = *rootp, pouterp = NULL; outerp; 
			pouterp = outerp, outerp = outerp->pst_left)
    {
	/* Search this BY list entry for an embedded PST_GSET. */
	for (nodep = outerp->pst_right, *alldonep = TRUE; nodep;
						nodep = nodep->pst_left)
	 if (nodep && nodep->pst_sym.pst_type == PST_GSET)
	 {
	    *alldonep = FALSE;		/* exit loop */
	    break;
	 }

	if (nodep == (PST_QNODE *) NULL ||
				nodep->pst_sym.pst_type != PST_GSET)
	    continue;			/* skip to next BY list entry */

	/* Found a PST_GSET to expand. Loop over embedded GSET, copying
	** whole BY list entry for each element. */
	for (np1 = nodep->pst_right, i = 0, xroot = NULL;
			np1 && np1->pst_sym.pst_type != PST_TREE;
			i++, np1 = np1->pst_left)
	{
	    /* Allocate new PST_GSET to spice into BY list. */
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			(PST_QNODE *) NULL, PST_GSET, (PTR) NULL, 0, 
			DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
			&newgs, &psq_cb->psq_error, 0);
	    if (DB_FAILURE_MACRO(status))
		return(status);

	    if (xroot == (PST_QNODE *) NULL)
		xroot = newgs;
	    else prevgs->pst_left = newgs;
	    prevgs = newgs;

	    dup_rb.pss_tree = outerp->pst_right;
	    dup_rb.pss_dup = &newgs->pst_right;
	    status = pst_treedup(cb, &dup_rb);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	    
	    /* Now locate the GSET to expand in the copied tree. */
	    for (np2 = newgs->pst_right, prev2 = NULL; np2;
			prev2 = np2, np2 = np2->pst_left)
	     if (np2->pst_sym.pst_type == PST_GSET)
		break;		/* found the GSET to remove */

	    /* Now locate the ith entry in the embedded GSET. That's 
	    ** the one that will replace the whole GSET in the new 
	    ** expanded GSET. */
	    for (j = 0, np3 = np2->pst_right; j < i && np3; 
					j++, np3 = np3->pst_left);

	    if (np3 == (PST_QNODE *) NULL)
		return(E_DB_SEVERE);	/* this better not happen! */

	    /* Splice around the old GSET. */
	    if (prev2 == (PST_QNODE *) NULL)
		newgs->pst_right = np3;
	    else prev2->pst_left = np3;
	    np3->pst_left = np2->pst_left;
	}	/* end of GSET expansion */

	if (pouterp == NULL)
	    *rootp = xroot;
	else pouterp->pst_left = xroot;

	newgs->pst_left = outerp->pst_left;	/* hook in rest of 
						** GROUP BY elements */

	return(E_DB_OK);
    }

}


/*
** Name: psl_groupingsets_tidy - set pst_rsno values and terminate
**	any NULL-terminated chains
**
** Description:
**	Recursively descend the GROUP BY list and assign the resdom nos
**	on the way back out.
**
** Input:
**	cb		ptr to PSF session control block
**	psq_cb		ptr to parser control block
**	nodep		ptr to GROUP BY list to be tidied
**	rsdmnop		ptr to current value of pst_rsno
**
** Output:
**
** Returns:
**	status		status of function
**
** Side effects:
**	none
**
** History:
**	4-apr-06 (dougi)
**	    Written for GROUP BY enhancements.
*/
static DB_STATUS
psl_groupingsets_tidy(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	PST_QNODE	*nodep,
	i4		*rsdmnop)

{
    DB_STATUS	status;
    i4		crcount = 0;


    /* If this is a PST_GBCR, tidy its insides. */
    if (nodep->pst_sym.pst_type == PST_GBCR)
    {
	status = psl_groupingsets_tidy(cb, psq_cb, nodep->pst_right, &crcount);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }

    /* If this is the last node in a chain and isn't properly terminated,
    ** add a PST_TREE node. */
    if (nodep->pst_left == (PST_QNODE *) NULL)
    {
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
			(PST_QNODE *) NULL, PST_TREE, (PTR) NULL, 0, 
			DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
			&nodep->pst_left, &psq_cb->psq_error, 0);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }

    /* If the next node isn't a PST_TREE, recurse on it. */
    if (nodep->pst_left->pst_sym.pst_type != PST_TREE)
    {
	status = psl_groupingsets_tidy(cb, psq_cb, nodep->pst_left, rsdmnop);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }

    /* Finally - check for RESDOM and update its pst_rsno. */
    if (nodep->pst_sym.pst_type == PST_RESDOM)
	nodep->pst_sym.pst_value.pst_s_rsdm.pst_rsno = ++(*rsdmnop);

    return(E_DB_OK);

}

/*
** Name: psl_ansi_strtodt - semantic action for handling ANSI date/time
**			    literals.
**
** Description:
**	This functions implements the semantic action for constant functions
**	CURRENT_USER, USER, SESSION_USER, SYSTEM_USER, and INITIAL_USER.
**	First we call ADF to get the right function instance, then we build a
**	query tree node for the function
**	
**	NOTE: call will contain either a non-null newnode or a non-null dataval.
**	If the former, it will build a CONST node, otherwise it will just
**	fill in dataval.
**
** Input:
**	cb		ptr to PSF session control block
**	ansitype 	datatype of the literal 
**	intflds		range of fields in interval
**	instr		input character string
**	secfrac		fractions of seconds (in interval literal)
**			
** Output:
**	*newnode	will point at a newly allocated query tree node
**	dataval		will contain coerced date/time value
**
** Returns:
**	E_DB_{OK,ERROR}
**
** History:
**	30-aug-06 (gupsh01)
**	    Created.
**	12-jan-2007 (dougi)
**	    Augmented support of intervals.
**	15-mar-2007 (dougi)
**	    Added support for fractions of secs in interval literals.
**	12-oct-2007 (dougi)
**	    Add logic to optionally only build and return the DB_DATA_VALUE.
*/
DB_STATUS
psl_ansi_strtodt(
        PSS_SESBLK      *cb,
        PSQ_CB          *psq_cb,
	DB_DT_ID	ansitype,
	i4		intflds,
        DB_TEXT_STRING	*instr,
        PST_QNODE       **newnode,
	DB_DATA_VALUE	*dataval,
	i2		secfrac)
{
	DB_STATUS		status = E_DB_OK;
	PST_CNST_NODE		cconst;
	i4			constSize;
	i2			stringlen;
	i2			precision;
	DB_DATA_VALUE		indv;
	DB_DATA_VALUE		outdv;
	DB_DATA_VALUE		*outp;
	i4			composite;
	AD_ADATE		adate;
	AD_TIME			atime;
	AD_TIMESTAMP		atimestamp;
	AD_INTYM 		aintym;
	AD_INTDS		aintds;
	i4		        err_code;
	ADF_CB 			*adf_cb = cb->pss_adfcb;
	ADF_ERROR		adf_errcb = adf_cb->adf_errcb;
	PTR			savedp;
	i2			poff, plen, aoff, alen;
	bool			prepend = FALSE, append = FALSE;


	if (dataval)
	    outp = dataval;
	else outp = &outdv;

	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_SQL;
	cconst.pst_origtxt = (char *) NULL;

	composite = ((DB_TEXT_STRING *)instr)->db_t_count;
	precision = DB_P_DECODE_MACRO(composite);
	stringlen    = DB_S_DECODE_MACRO(composite);
	instr->db_t_count = stringlen;	/* just store string length */

        indv.db_data = (char *)instr;
        indv.db_length = stringlen + DB_CNTSIZE;
        indv.db_datatype = DB_VCH_TYPE;
        indv.db_prec = 0;
        indv.db_collID = 0;

	/* If this is an interval literal, check for incomplete value
	** that requires 0 valued fields to be prepended and/or
	** appended. */
	if (ansitype == DB_INYM_TYPE && (intflds/8 == INT_MONTH ||
			intflds%8 == INT_YEAR))
	{
	    if (intflds/8 == INT_MONTH)
	    {
		/* MONTH only - prepend "0-" for year. */
		prepend = TRUE;
		poff = 0;
		plen = 2;
	    }
	    else
	    {
		/* YEAR only - append "-0" for month. */
		append = TRUE;
		aoff = 1;
		alen = 2;
	    }
	}
	else if (ansitype == DB_INDS_TYPE && (intflds/8 != INT_DAY ||
			intflds%8 != INT_SECOND))
	{
	    /* Switch on 2nd and 1st field to determine prepend/append
	    ** parameters. */
	    prepend = TRUE;
	    poff = 3;			/* prepend always starts here */
	    switch (intflds/8) {
	      case INT_DAY:
		prepend = FALSE;	/* nothing to prepend */
		break;
	      case INT_HOUR:
		plen = 2;
		break;
	      case INT_MINUTE:
		plen = 4;
		break;
	      case INT_SECOND:
		plen = 6;
		break;
	    }

	    append = TRUE;
	    switch (intflds%8) {
	      case INT_DAY:
		aoff = 4;
		alen = 6;
		break;
	      case INT_HOUR:
		aoff = 6;
		alen = 4;
		break;
	      case INT_MINUTE:
		aoff = 8;
		alen = 2;
		break;
	      case INT_SECOND:
		append = FALSE;		/* nothing to append */
		break;
	    }
	}

	/* Perform prepend/append operations into work field & copy
	** updated string back. */
	if (prepend || append)
	{
	    char	intwork[50];
	    i2		ilen;

	    /* Copy prepend string. */
	    if (prepend)
	    {
		MEcopy(&interval_filler[poff], plen, &intwork[0]);
		ilen = plen;
	    }
	    else ilen = 0;

	    /* Copy actual literal value. */
	    MEcopy(&instr->db_t_text[0], stringlen, &intwork[ilen]);
	    ilen += stringlen;

	    /* Copy append string. */
	    if (append)
	    {
		MEcopy(&interval_filler[aoff], alen, &intwork[ilen]);
		ilen += alen;
	    }

	    /* Put resulting string back in symbol table. */
	    MEcopy(&intwork[0], ilen, &instr->db_t_text[0]);
	    instr->db_t_count = stringlen = ilen;
	    indv.db_length = ilen + DB_CNTSIZE;
	}

	if (dataval)
	    savedp = outp->db_data;

	switch (ansitype)
	{
	  case DB_ADTE_TYPE:
	    outp->db_data = (char *)&adate;
	    outp->db_length = ADF_ADATE_LEN;
	    break;

	  case DB_TMWO_TYPE:
	  case DB_TMW_TYPE:
	  case DB_TME_TYPE:
	    outp->db_data = (char *)&atime;
	    outp->db_length = ADF_TIME_LEN;
	    break;

	  case DB_TSWO_TYPE:
	  case DB_TSW_TYPE:
	  case DB_TSTMP_TYPE:
	    outp->db_data = (char *)&atimestamp;
	    outp->db_length = ADF_TSTMP_LEN;
	    break;

	  case DB_INYM_TYPE:
	    outp->db_data = (char *)&aintym;
	    outp->db_length = ADF_INTYM_LEN;
	    break;

	  case DB_INDS_TYPE:
	    outp->db_data = (char *)&aintds;
	    outp->db_length = ADF_INTDS_LEN;
	    /* Default second precision is 6. */
	    if (intflds/8 == INT_SECOND || intflds%8 == INT_SECOND)
		precision = secfrac;
	    break;

	  default:
	    /* ERROR */
	    break;
       }

	if (dataval)
	    outp->db_data = savedp;
        outp->db_prec = precision;
        outp->db_datatype = ansitype;
        outp->db_collID = 0;

        status = adu_21ansi_strtodt (cb->pss_adfcb,
                                        &indv, outp);
        if (DB_FAILURE_MACRO(status))
        {
	    (VOID) psf_error(2937L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof (cb->pss_lineno), &cb->pss_lineno,
                instr->db_t_count, instr->db_t_text);

	      if (cb->pss_adfcb || 
		  cb->pss_adfcb->adf_errcb.ad_errclass == ADF_USER_ERROR)
                  psf_adf_error(&adf_errcb, &psq_cb->psq_error, cb);

	    return (E_DB_ERROR);
        }

	if (newnode)
	{
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		(PST_QNODE *) NULL, PST_CONST, (char *) &cconst, sizeof(cconst),
		ansitype, (i2) precision, outp->db_length, 
		(DB_ANYTYPE *)outp->db_data , newnode, &psq_cb->psq_error, 
		(i4) 0);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }
	}

	return (E_DB_OK);
}
